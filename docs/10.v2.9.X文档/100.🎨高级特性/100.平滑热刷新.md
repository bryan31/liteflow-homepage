---
title: 🍖平滑热刷新
date: 2022-07-03 11:04:48
permalink: /pages/v2.9.X/204d71/
---

LiteFlow支持了优雅平滑热刷新的特性。

即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。

在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。

LiteFlow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。

但是对于自定义配置源来说，LiteFlow提供了主动刷新和被动刷新2个接口，根据需要自行选择。

## 基于规则文件-主动刷新

你可以在spring容器中拿到`FlowExecutor`对象后，调用以下接口：

```java
flowExecutor.reloadRule();
```

这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。

## 基于规则文件-被动刷新

所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。

如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：

```java
FlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_EL_XML, newContent);
```

其中第一个参数是指文件格式什么，支持xml/json/yml，这里注意下，在EL规则表达式下，都是`TYPE_EL_XXX`的形式，不带EL的那是旧的形式，请不要用错！

第二个参数指的是推送过来的最新配置文本数据

## 基于动态代码构建-刷新

如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。

其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。