(window.webpackJsonp=window.webpackJsonp||[]).push([[358],{821:function(t,a,s){"use strict";s.r(a);var e=s(8),l=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("从v2.11.4正式版中开始新增了一个liteflow.fast-load的配置参数：")]),t._v(" "),a("div",{staticClass:"language-properties extra-class"},[a("pre",{pre:!0,attrs:{class:"language-properties"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("liteflow.fast-load")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("false")]),t._v("\n")])])]),a("p",[t._v("如果把这个设为"),a("code",[t._v("true")]),t._v("，则在拥有超大量的规则的时候，加载性能能提高4倍。")]),t._v(" "),a("p",[t._v("这里超大量规则指的是5000条规则以上。如果几百个规则，还是推荐用默认模式。")]),t._v(" "),a("p",[t._v("我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。")]),t._v(" "),a("p",[t._v("当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。")])])}),[],!1,null,null,null);a.default=l.exports}}]);