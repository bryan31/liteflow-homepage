(window.webpackJsonp=window.webpackJsonp||[]).push([[835],{1298:function(t,s,a){"use strict";a.r(s);var e=a(8),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("p",[t._v("距离上一次发版差不多有快4个月了。这几个月来断断续续的迭代终于带来了全新的2.15.0版本。这个版本一共带来了4个特性，7个增强，7个修复。总共18个issue的更新。")]),t._v(" "),s("p",[t._v("如果要问为什么从2.13.2直接就到2.15.0了。那其实也没啥特别的原因，可能是因为风水问题吧。")]),t._v(" "),s("p",[t._v("言归正传，如果你正在使用2.13.X，应该在99%的场景下是能无缝兼容的。具体那1%是哪个场景，下面会讲。")]),t._v(" "),s("h2",{attrs:{id:"平滑支持jdk8-jdk25的所有版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#平滑支持jdk8-jdk25的所有版本"}},[t._v("#")]),t._v(" 平滑支持JDK8~JDK25的所有版本")]),t._v(" "),s("p",[t._v("之前LiteFlow支持了JDK8~JDK17，但是在JDK9以上版本中，是需要额外加入jvm参数的。究其原因就是LF的底层用了一些对sun包下的反射调用，而sun包本身却又是强封装类型的。所以必须要参数来解除这一限制。也许有的社区同学没加参数也能运行起来，那是因为没用到相关的特性。")]),t._v(" "),s("p",[t._v("这次我们替换了一些底层方法的调用实现方式，使得现在在任意版本中使用LiteFlow，都无需再加任何jvm参数了")]),t._v(" "),s("h2",{attrs:{id:"全面支持jdk21以及以上版本的虚拟线程特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全面支持jdk21以及以上版本的虚拟线程特性"}},[t._v("#")]),t._v(" 全面支持JDK21以及以上版本的虚拟线程特性")]),t._v(" "),s("p",[t._v("虚拟线程是JDK21中最重要，最大的特性。虚拟线程的调度开销仅仅为平台线程的千分之一，对于高IO的应用来说，虚拟线程可以提升非常多的性能。社区里之前有非常多的小伙伴在询问LF是否支持JDK21，是否支持虚拟线程。现在，全部都已经实现了。")]),t._v(" "),s("p",[t._v("当LF运行在JDK21及以上时，LF中的所有异步线程均会自动的切换到虚拟线程。如果是JDK21以下版本时，那就是普通的平台线程。")]),t._v(" "),s("p",[t._v("并且，不管你是何种版本的JDK，引入的依赖都是同一套，不区分对应的JDK版本。")]),t._v(" "),s("h2",{attrs:{id:"支持直接执行el规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#支持直接执行el规则"}},[t._v("#")]),t._v(" 支持直接执行EL规则")]),t._v(" "),s("p",[t._v("对于执行一些简单的规则，有很多小伙伴反馈去xml里定义一个chain太过于繁琐，而用动态构建，每次都去构建，又太耗性能，而且用完还是自己清理chain。")]),t._v(" "),s("p",[t._v("所以这次，LF推出一个直接执行EL规则的能力。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LiteflowResponse")]),t._v(" response "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" flowExecutor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("execute2RespWithEL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"THEN(a, b, c)"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" requestData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CustomContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("你现在可以直接执行一个规则EL，不用去创建chain了。而且你不用担心每次都去编译构建会耗性能，在新的体系里，如果每个请求都执行相同的EL，只会在第一次时构建1次。")]),t._v(" "),s("h2",{attrs:{id:"活跃规则保活策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#活跃规则保活策略"}},[t._v("#")]),t._v(" 活跃规则保活策略")]),t._v(" "),s("p",[t._v("这个特性对系统中有大量规则的场景非常有用，这里的大量规则是指有上万条规则。能有效避免堆内存的持续扩大。")]),t._v(" "),s("p",[t._v("这个策略会在过多的规则下只维持前N条最活跃的规则缓存，而不活跃的规则会被暂时的从系统中卸载掉。被卸载掉的规则，再次被调用时的第一次会重新编译加入活跃的队列。")]),t._v(" "),s("p",[t._v("整个策略使用者无感，默认这个策略的开关在框架中是关闭的，这个策略的打开方式为：")]),t._v(" "),s("div",{staticClass:"language-properties extra-class"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 是否开启保活策略")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("liteflow.chain-cache.enabled")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("true")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 保持活跃chain的数目，默认为10000")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("liteflow.chain-cache.capacity")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("10000")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 模式一定得为PARSE_ONE_ON_FIRST_EXEC")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token key attr-name"}},[t._v("liteflow.parse-mode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[t._v("PARSE_ONE_ON_FIRST_EXEC")]),t._v("\n")])])]),s("h2",{attrs:{id:"隐式子流程的改版"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隐式子流程的改版"}},[t._v("#")]),t._v(" 隐式子流程的改版")]),t._v(" "),s("p",[t._v("隐式子流程这个特性，在LF中是一个非常糟糕的设计。")]),t._v(" "),s("p",[t._v("为了兼容隐式子流程特性，原先的很多特性都在为隐式子流程做妥协。这造就了一些硬代码判断，每次看到这些糟糕的代码时都如鲠在喉。所以我们一度想把这个功能给移除掉，反正作为替代方案，使用者完全可以在组件内另外调起一条流程来实现。")]),t._v(" "),s("p",[t._v("事实上我们也这么做了。但是在移除掉这个特性之后，发现可能使用到隐式子流程的人会非常抓狂，因为毕竟要改一些代码才能用替代方案。所以后面我们专门对隐式子流程做了改版，在保留原先调用方式的基础上，我们更换了底层实现方式。")]),t._v(" "),s("p",[t._v("可能使用到隐式子流程的人，只需要在取请求参数的地方改一下方法名应该就可以了。原先是getSubRequestData，现在统一变成了getDataRequest。")]),t._v(" "),s("h2",{attrs:{id:"完整更新列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#完整更新列表"}},[t._v("#")]),t._v(" 完整更新列表")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("特性 #ICUMKV 全面支持jdk21，以及支持jdk21中的虚拟线程\n\nhttps://gitee.com/dromara/liteFlow/issues/ICUMKV\n\n特性 #IBQCWB Liteflow的执行器FlowExecutor支持执行EL表达式，而不需要传入chainId\n\nhttps://gitee.com/dromara/liteFlow/issues/IBQCWB\n\n特性 #IAY66T 建立一种机制保证在过多的规则下只维持前N条最活跃的规则缓存\n\nhttps://gitee.com/dromara/liteFlow/issues/IAY66T\n\n特性 #ICM6TX WHEN 并行编排增加关键字实现完成任务达到百分比阈值时方可放行\n\nhttps://gitee.com/dromara/liteFlow/issues/ICM6TX\n\n增强 #ICO3IK 在switch节点中，希望能拿到target的列表信息\n\nhttps://gitee.com/dromara/liteFlow/issues/ICO3IK\n\n增强 #ICUEG9 JDK支持度更加平滑\n\nhttps://gitee.com/dromara/liteFlow/issues/ICUEG9\n\n增强 #ICANTH 隐式子流程改版\n\nhttps://gitee.com/dromara/liteFlow/issues/ICANTH\n\n增强 #IC9GTV 脚本ScriptValidator新增返回ValidationResp的API\n\nhttps://gitee.com/dromara/liteFlow/issues/IC9GTV\n\n增强 #ICGGAW redis数据源支持集群模式\n\nhttps://gitee.com/dromara/liteFlow/issues/ICGGAW\n\n增强 #ICR1PL AND关键字的逻辑和语意明确点\n\nhttps://gitee.com/dromara/liteFlow/issues/ICR1PL\n\n增强 #ICU7Z4 升级liteflow的一些依赖\n\nhttps://gitee.com/dromara/liteFlow/issues/ICU7Z4\n\n修复 #ICPDU7 Slot的conditionStack在多线程并发时无法保证Condition的弹栈压栈顺序\n\nhttps://gitee.com/dromara/liteFlow/issues/ICPDU7\n\n修复 #ICO23A Spring设置BeanFactory的cacheBeanMetadata属性为false时，Liteflow项目无法注册声明式组件，后续解析EL失败，项目无法启动\n\nhttps://gitee.com/dromara/liteFlow/issues/ICO23A\n\n修复 #ICJGIK PARSE_ONE_ON_FIRST_EXEC 模式下 Node 对象执行 Java 脚本 最终 instance.isEnd() 判断空指针问题\n\nhttps://gitee.com/dromara/liteFlow/issues/ICJGIK\n\n修复 #IC9ZZ8 reids poll模式代码问题\n\nhttps://gitee.com/dromara/liteFlow/issues/IC9ZZ8\n\n修复 #IC8UPJ 规则EL校验在liteflow.parse-mode=PARSE_ONE_ON_FIRST_EXEC时失效\n\nhttps://gitee.com/dromara/liteFlow/issues/IC8UPJ\n\n修复 #IC71HA 在线程1的执行过程中线程2去remove chain导致的线程1无法平滑继续执行的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/IC71HA\n\n修复 #IC2F4F 模糊文件路径的监听，添加新的规则文件没有自动加载\n\nhttps://gitee.com/dromara/liteFlow/issues/IC2F4F\n")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);