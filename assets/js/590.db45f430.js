(window.webpackJsonp=window.webpackJsonp||[]).push([[590],{1052:function(s,t,a){"use strict";a.r(t);var e=a(8),n=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"v2-10-5介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v2-10-5介绍"}},[s._v("#")]),s._v(" v2.10.5介绍")]),s._v(" "),t("p",[s._v("v2.10.5版本主要就是对日志从底层进行架构改造。增加了支持传入自定义的请求ID。")]),s._v(" "),t("p",[s._v("以及修复了一些循环表达式中的Bug。")]),s._v(" "),t("h2",{attrs:{id:"日志改造"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#日志改造"}},[s._v("#")]),s._v(" 日志改造")]),s._v(" "),t("p",[s._v("我们对日志进行了大幅度的改造，支持了自定义的RequestId传入，这个特性可以很方便的和你自己系统的traceId进行集成。")]),s._v(" "),t("p",[s._v("你可以调用如下方法来传入一个已有的requestId：")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LiteflowResponse")]),s._v(" response "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" flowExecutor"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("execute2RespWithRid")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"chain1"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" arg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"T001234"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("YourContext")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("那么，这个链路中所有的框架日志都会带有[T001234]这个传入的ID前缀了。")]),s._v(" "),t("p",[s._v("另外新版本的LiteFlow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求ID前缀。")]),s._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LFLog")]),s._v(" logger "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("LFLoggerManager")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("getLogger")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FlowExecutor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),t("p",[s._v("其中"),t("code",[s._v("LFLog")]),s._v("这个类是继承自slf4j的"),t("code",[s._v("Logger")]),s._v("类的，所以它的使用方式和"),t("code",[s._v("Logger")]),s._v("是完全一致的。")]),s._v(" "),t("p",[s._v("你只需要把定义换一下就ok了。")]),s._v(" "),t("p",[s._v("如果在一个链路中相同请求的日志都拥有同一个请求ID，那么对于定位问题来说，会很方便。推荐大家使用此特性。")]),s._v(" "),t("h2",{attrs:{id:"循环场景中的一些bug的修复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#循环场景中的一些bug的修复"}},[s._v("#")]),s._v(" 循环场景中的一些bug的修复")]),s._v(" "),t("p",[s._v("看来大家对循环特性使用的还是比较多的。在使用的过程中，社区内也给出了很多反馈意见。")]),s._v(" "),t("p",[s._v("可能是之前对循环定义的测试用例有些少了，所以对于一些场景没覆盖到。这次修复了社区内提供的2个Bug。")]),s._v(" "),t("p",[s._v("同时也补全了测试用例。")])])}),[],!1,null,null,null);t.default=n.exports}}]);