(window.webpackJsonp=window.webpackJsonp||[]).push([[725],{1186:function(v,_,e){"use strict";e.r(_);var t=e(8),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"v2-10-2介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v2-10-2介绍"}},[v._v("#")]),v._v(" v2.10.2介绍")]),v._v(" "),_("p",[v._v("我们为每个迭代版本都定了一个版本特性。")]),v._v(" "),_("p",[v._v("LiteFlow 2.10.2的版本特性就是"),_("code",[v._v("与或非")]),v._v("表达式。")]),v._v(" "),_("p",[v._v("除此之外，我们还增强了一些内容，修复了社区提出的bug。一共5个issue，作为此次小版本迭代的组成部分。")]),v._v(" "),_("h2",{attrs:{id:"与或非表达式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与或非表达式"}},[v._v("#")]),v._v(" 与或非表达式")]),v._v(" "),_("p",[v._v("社区里一直有人反应，条件编排能否在EL上写表达式，例如"),_("code",[v._v("a==5 && b>0")]),v._v("这种。")]),v._v(" "),_("p",[v._v("其实编排EL语法一切的操作对象都是"),_("code",[v._v("组件")]),v._v("，所以EL编排语法不能像逻辑代码一样来写很多逻辑过程。")]),v._v(" "),_("p",[v._v("我一直建议逻辑过程，通过java代码或者脚本组件来完成。而脚本组件是可以热更新热替换的。更加灵活。")]),v._v(" "),_("p",[v._v("但是在实际应用中，的确有人需要在条件编排里判断多个条件，而每个条件又是互相独立的组件。那么按照以前的写法，你只能把多个条件的逻辑塞到一个组件里，返回统一的true或者false。")]),v._v(" "),_("p",[v._v("这次我们新增了组件编排层面的与或非表达式，就是"),_("code",[v._v("AND")]),v._v("，"),_("code",[v._v("OR")]),v._v("，"),_("code",[v._v("NOT")]),v._v("表达式。")]),v._v(" "),_("p",[v._v("用法为方法模式："),_("code",[v._v("AND(a, b, c)")]),v._v("。")]),v._v(" "),_("p",[v._v("可能有些社区里的同学会问，为什么不设计成"),_("code",[v._v("a && b && c")]),v._v("呢，或者是"),_("code",[v._v("a AND b AND c")]),v._v("呢。")]),v._v(" "),_("p",[v._v("我来解释一下，首先这种用法模式和之前的语法呼应，都是方法模式，其次操作符的模式就有点像逻辑了，而这里突出的是编排。再者操作符的模式的几个关键字都被底层占用了。")]),v._v(" "),_("p",[v._v("综上所述，所以延续了之前的EL表述方式。")]),v._v(" "),_("p",[v._v("具体文档在官网"),_("code",[v._v("EL规则语法")]),v._v("大章的"),_("code",[v._v("与或非表达式")]),v._v("小章中。")]),v._v(" "),_("h2",{attrs:{id:"脚本新增了一些元数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#脚本新增了一些元数据"}},[v._v("#")]),v._v(" 脚本新增了一些元数据")]),v._v(" "),_("p",[v._v("脚本中现在也可以拿到循环下标了，在元数据里加入了"),_("code",[v._v("loopIndex")]),v._v("和"),_("code",[v._v("loopObject")]),v._v("2个属性。")]),v._v(" "),_("p",[v._v("可以通过"),_("code",[v._v("_meta.loopIndex")]),v._v("和"),_("code",[v._v("_meta.loopObject")]),v._v("来获取到。")]),v._v(" "),_("p",[v._v("所有的脚本元数据可以参照官网的"),_("code",[v._v("脚本组件")]),v._v("大章中的"),_("code",[v._v("与Java进行交互")]),v._v("小章节。")]),v._v(" "),_("h2",{attrs:{id:"选择表达式的增强和一些bug的修复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#选择表达式的增强和一些bug的修复"}},[v._v("#")]),v._v(" 选择表达式的增强和一些bug的修复")]),v._v(" "),_("p",[v._v("现在在选择编排语法上，之前"),_("code",[v._v("tag")]),v._v("属性只能添加到组件上，现在对任何的表达式后面都可以添加"),_("code",[v._v("tag")]),v._v("属性了。")]),v._v(" "),_("p",[v._v("在选择节点的返回上，更加灵活了。")]),v._v(" "),_("p",[v._v("具体见官网的"),_("code",[v._v("常规组件")]),v._v("大章中的"),_("code",[v._v("选择组件")]),v._v("小章节。")]),v._v(" "),_("p",[v._v("此次我们还另外修复了2个bug。")])])}),[],!1,null,null,null);_.default=a.exports}}]);