(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,l,r=e[0],s=e[1],c=e[2],p=0,m=[];p<r.length;p++)l=r[p],Object.prototype.hasOwnProperty.call(o,l)&&o[l]&&m.push(o[l][0]),o[l]=0;for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(n[a]=s[a]);for(d&&d(e);m.length;)m.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,r=1;r<t.length;r++){var s=t[r];0!==o[s]&&(a=!1)}a&&(i.splice(e--,1),n=l(l.s=t[0]))}return n}var a={},o={1:0},i=[];function l(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,l),t.l=!0,t.exports}l.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=o[n]=[e,a]}));e.push(t[2]=a);var i,r=document.createElement("script");r.charset="utf-8",r.timeout=120,l.nc&&r.setAttribute("nonce",l.nc),r.src=function(n){return l.p+"assets/js/"+({}[n]||n)+"."+{2:"291da1d7",3:"38cf7f6a",4:"4e7f8bac",5:"1b0fb98d",6:"eae2c4d7",7:"9bdb39ef",8:"64a026dc",9:"9c55ba2b",10:"b952c098",11:"43d7d423",12:"a334259b",13:"8af504a5",14:"d951a3d2",15:"5eb76524",16:"7d1a0adc",17:"017322fa",18:"81c530d0",19:"7d16b195",20:"2b6e2ce0",21:"dc045d77",22:"73271a2d",23:"703cdf59",24:"2556a4bc",25:"d16f0c12",26:"69279ba8",27:"61f07b14",28:"3a5e105e",29:"d38af115",30:"cb30dcf4",31:"87953fc1",32:"1e91d403",33:"127f61ec",34:"f2137f6e",35:"63af3eb8",36:"9d4020c0",37:"9f2088fb",38:"1f16ff12",39:"b0abec46",40:"4fe2bf8a",41:"675aed6c",42:"a8398246",43:"aa42e75a",44:"924fd1bb",45:"c7ea3925",46:"d6675352",47:"b7f19d0e",48:"6d2a96ed",49:"bc09a2a3",50:"b78e0efc",51:"88c6bd40",52:"023e05f0",53:"65064119",54:"d0ee9498",55:"2f534ce8",56:"cd13b33b",57:"933c6ad7",58:"7eab488f",59:"5b551fcf",60:"81671405",61:"e1214d54",62:"156f915f",63:"79680c11",64:"3ad7e5fd",65:"ee6f53cc",66:"b8ab0792",67:"d0a1f34f",68:"0edfb8f7",69:"6ea4f098",70:"9477bd6d",71:"3ce77af2",72:"09ec8412",73:"ff5d4fb4",74:"2b4b1dda",75:"ae9a5d6c",76:"e8777865",77:"178d4993",78:"2fb9ff77",79:"b1c6cac4",80:"6a8f0c08",81:"c1877114",82:"8da8a2cf",83:"04632cc9",84:"05cd3859",85:"07de1a37",86:"1e9e897c",87:"ff46470a",88:"eeda5488",89:"a9fc348c",90:"21374516",91:"388d63af",92:"f51ba87c",93:"fb64cc37",94:"d24c51c9",95:"1655963c",96:"feca34f6",97:"2fe78f87",98:"509bcde1",99:"57d359db",100:"86d707eb",101:"a2f563bf",102:"719caade",103:"d8041f0e",104:"8f8e5c5b",105:"fa24068a",106:"0d776a04",107:"94825257",108:"7c1d337a",109:"45bdfd45",110:"fd54c0c4",111:"ea8a87ba",112:"2908ec5b",113:"ce2a49c9",114:"12880c8d",115:"06543d5e",116:"b07d3cc7",117:"67ace6b1",118:"a07aa9d6",119:"000acd28",120:"51d52547",121:"96690d84",122:"c2efbf63",123:"a005aac1",124:"8b6bd3fe",125:"052baae3",126:"207fd49e",127:"dd8f3184",128:"ce89ad14",129:"d9dbe5cc",130:"d80ec24f",131:"5beaf621",132:"029d1acb",133:"d8143492",134:"e1569fa0",135:"dd483684",136:"cb9f68c2",137:"8b7fa891",138:"99f3200d",139:"ec3aba17",140:"4d460e70",141:"1f7937dd",142:"53b709de",143:"e74d8231",144:"e8ea10a8",145:"db92b469",146:"f7b98cf4",147:"6516e796",148:"a1ba6768",149:"41c9a92e",150:"74246060",151:"6dc9feea",152:"27a54777",153:"6576f226",154:"66e1435d",155:"f0588f34",156:"1b7d6009",157:"7ee9062e",158:"d212edd8",159:"1f8f3f50",160:"69442153",161:"d108cdaf",162:"efc9290d",163:"bb745219",164:"a92f4c8b",165:"01df2729",166:"caa25f33",167:"427ccf1c",168:"961fcb3a",169:"27669ee2",170:"a1a0cff5",171:"553c5d8d",172:"318ba9a6",173:"39104a53",174:"fff344b6",175:"8dd2baee",176:"0b93cb81",177:"85d3a916",178:"199d1781",179:"8530d74e",180:"46e32385",181:"38cb336c",182:"4ea805f4",183:"4d179250",184:"27deb396",185:"4a5632b5",186:"01e892e0",187:"886726a3",188:"21d25b72",189:"e32f1455",190:"8bbf25e1",191:"954658d6",192:"853b9583",193:"79cdd775",194:"e4bd31e8",195:"107aae0d",196:"bc033187",197:"624d15f8",198:"878b8ddd",199:"3089b947",200:"9c14a94c",201:"4a786eee",202:"7104c672",203:"7289ac06",204:"228ffb34",205:"25138607",206:"2933885f",207:"3a8807ce",208:"7802c867",209:"e896d687",210:"a4d5a329",211:"f0eb5d94",212:"3e48b6d3",213:"b49da81f",214:"16dac519",215:"5d23a434",216:"0fce10d2",217:"75fa5160",218:"a30ff2f4",219:"8eb42d10",220:"e5ea0cbd",221:"73d223be",222:"6277a47a",223:"4d2a28ee",224:"9739b41f",225:"526782af",226:"e4dc74d4",227:"4574239e",228:"dd2949a0",229:"a311dd3f",230:"00c2bb8f",231:"f4767fd9",232:"7a6983bb",233:"d6f6dafd",234:"e00cd2b0",235:"87904cf9",236:"480d8665",237:"8cbc2a37",238:"d8810af5",239:"e1f1c291",240:"33b590f7",241:"6551a58e",242:"809efb82",243:"9e7ab02c",244:"8a96c48e",245:"639e4130",246:"3876e014",247:"5206d962",248:"afd31154",249:"b2d6f85c",250:"9ae893d7",251:"fea6b2e0",252:"b6545c83",253:"0e888f3e",254:"3db003ae",255:"67023fd3",256:"827a58a3",257:"cbd03241",258:"c68eb273",259:"0b29d2dd",260:"9abeb33d",261:"f2f56a99",262:"03e6859b",263:"8cb761a2",264:"e0edb312",265:"820f0262",266:"522bee2c",267:"46bc6b6a",268:"63211ea1",269:"6d543c8a",270:"13726002",271:"ded62697",272:"83a41085",273:"0e701165",274:"3d2afc08",275:"844a07ab",276:"c9f88b6c",277:"62bfc051",278:"47eac754",279:"77c73ca2",280:"e8296fc6",281:"c9ad29e9",282:"19ca6526",283:"ec53ec76",284:"774042e3",285:"87999f30",286:"6ea21ccb",287:"c760b493",288:"a63057dd",289:"f39d0b72",290:"8f17208e",291:"883da40b",292:"91d31529",293:"66e7f012",294:"9db01985",295:"a5940f15",296:"57a650c1",297:"2e3dc2ac",298:"bec21e7e",299:"43be3cde",300:"22bcfca8",301:"0be086d6",302:"66d75826",303:"db1a3b90",304:"5156ca26",305:"9e8f5e48",306:"a02d3ce5",307:"ae7587e0",308:"07b05be1",309:"cf517d74",310:"53154fce",311:"ffc103ad",312:"91bc144a",313:"7054e53c",314:"b6ed4fdd",315:"f21cd915",316:"af60b203",317:"e046c7ec",318:"d18ebd03",319:"635ef972",320:"7557b287",321:"530c3558",322:"8ad2a920",323:"03244e4b",324:"b74aa2c3",325:"17b5e9d0",326:"9392f0e5",327:"830ce76d",328:"73d9e23d",329:"05254c27",330:"1eae9581",331:"fe9932cb",332:"7c062980",333:"8fb2a255",334:"6fd41333",335:"f3b4d97d",336:"7eff58e5",337:"a479e362",338:"d43bfc34",339:"94ce5f95",340:"5b7c7a03",341:"02951003",342:"f70aa7cb",343:"80468e66",344:"cf98eb73",345:"868dd6f3",346:"ed0b84e1",347:"8abdd1e1",348:"27c54578",349:"c33ef08e",350:"c7425e5e",351:"597f255e",352:"5d8d1f00",353:"46105d22",354:"7641aa67",355:"172ebb67",356:"09e2af81",357:"ebeb0451",358:"6f55a926",359:"73efa233",360:"f00d7bfc",361:"114d65d7",362:"e394b71c",363:"a9455b96",364:"d42d8348",365:"4241889b",366:"821e7fda",367:"10c9e7cc",368:"dc54a3f1",369:"d36ca154",370:"26516786",371:"e7f3f037",372:"a3a3d301",373:"6bece969",374:"952c4a92",375:"5a47e006",376:"30eb1139",377:"f2757084",378:"d9c6dc84",379:"28df077e",380:"7e4f9585",381:"d5fffb3e",382:"3218489f",383:"7d6c45ff",384:"64ac64a3",385:"ccf16bbc",386:"41ea4c49",387:"8b7f4990",388:"437e622a",389:"6d9ac2d5",390:"97ab2983",391:"19571f2e",392:"134b4739",393:"12240d59",394:"9a3ea423",395:"d0386fa1",396:"237eb077",397:"dbf4fa22",398:"0913ce34",399:"e3cf6c01",400:"03bfa16a",401:"52c8694a",402:"b8a37c9f",403:"c591d97b",404:"cffb87cd",405:"2c461dc4",406:"5dd4cac7",407:"da4fdd37",408:"9af6c41b",409:"257ca58b",410:"1dad423a",411:"63bd341a",412:"ebad97f3",413:"fbde0e41",414:"63cc3c00",415:"12f5e2cf",416:"a2ea82c3",417:"e9f7df1d",418:"cdc2ae5c",419:"49bb0f8e",420:"89e4a627",421:"d1b7729e",422:"c958bf15",423:"d8029f8e",424:"cfe2f4a1",425:"d08b15b9",426:"8ff536ff",427:"741b8fdf",428:"684486cf",429:"8f60782b",430:"09052094",431:"aa144d64",432:"5a343e20",433:"a40a4eb8",434:"33ff1816",435:"89f092e4",436:"6e2e6240",437:"d27a6678",438:"0f9e897c",439:"b07f3175",440:"d745e584",441:"4d6e1ff4",442:"393b6868",443:"caa6205c",444:"9c5b18b2",445:"0dc0700f",446:"f0521404",447:"b2875997",448:"84ee732d",449:"cd8b7fea",450:"efa6a7a8",451:"d946c368",452:"eedda6ec",453:"5985559c",454:"5665397e",455:"4cc56b42",456:"e32d21ea",457:"3dcb01a5",458:"409d8275",459:"e681fe65",460:"16f83732",461:"0e213fa4",462:"2201663a",463:"140021a6",464:"b5047b8a",465:"08768ea5",466:"0a45430f",467:"952c002a",468:"4286046d",469:"6b535954",470:"0ab0c7ce",471:"20c7012f",472:"bc8e1405",473:"618cb40f",474:"230c024b",475:"92d08d52",476:"077cfca3",477:"da758183",478:"112aea6c",479:"51604744",480:"ee967943",481:"f3340e87",482:"50c68661",483:"2e3e58b5",484:"7989e866",485:"7b2616f1",486:"14b5e8e8",487:"5ca75817",488:"e22380bf",489:"ee92cfb0",490:"8f0a2984",491:"e19c5d2b",492:"f8b55492",493:"aaf56cd9",494:"b605561d",495:"5c09d9fe",496:"d5cb1950",497:"179f96da",498:"47106cdd",499:"6eb4553f",500:"2a2359fb",501:"a2c596db",502:"3be499a6",503:"55caa462",504:"01a4f4ab",505:"4e780761",506:"2ebee320",507:"5192207c",508:"6edf831b",509:"9f3beaa8",510:"0b54a095",511:"daf5b77a",512:"23ba5b4e",513:"999e09f3",514:"2ff9112e",515:"d2aadbca",516:"77b29496",517:"fca4fa24",518:"0f03565f",519:"a88f51f5",520:"d3859c46",521:"4b9493bd",522:"34e853b8",523:"8e934c4f",524:"0f522691",525:"5da1b4a4",526:"01f6ff33",527:"3d161af6",528:"0aae1201",529:"bcc605b2",530:"1af9a5cc",531:"42d85cd1",532:"d82d3e1c",533:"cd21af96",534:"9edd7c0b",535:"a774f89b",536:"c8a70db6",537:"7b7c7c4c",538:"921e9126",539:"5312ee35",540:"0f96ae66",541:"60c021a3",542:"69640fe7",543:"01ff4dcc",544:"c27958d1",545:"6e853109",546:"0a8854cd",547:"ca173cf7",548:"9f31c990",549:"75716b37",550:"09b447dc",551:"8f477e0d",552:"c5444d83",553:"e509da0e",554:"9f1bab2a",555:"1483ac40",556:"19cb33b0",557:"bce5eeb0",558:"e1e8a3da",559:"936d3307",560:"abc8b79a",561:"7a5a023b",562:"7f2f1357",563:"7d962fe3",564:"b7bd7783",565:"8bf7c4ae",566:"bf0b413e",567:"9fb4ce93",568:"b40ead04",569:"c6f7042a",570:"9f1cfc56",571:"6cf8c56e",572:"0c82b52c",573:"7ca1c20a",574:"08c3e447",575:"71a10bba",576:"47353660",577:"a0b3cf8a",578:"27447265",579:"08fd8d3e",580:"6115dd22",581:"e876c130",582:"ddbfaa33",583:"34bf1440",584:"8c2a1cb3",585:"187ac334",586:"37d0bfca",587:"3186ccfd",588:"9668c56c",589:"6d552394",590:"db45f430",591:"441bda18",592:"b098fb05",593:"6534b9b1",594:"ca46c0d1",595:"b51dfffe",596:"6f737317",597:"d31927fa",598:"18006478",599:"9086371e",600:"db687cee",601:"3ef63b50",602:"69059ef8",603:"8405c124",604:"5c190a0b",605:"567475b9",606:"cd62ea36",607:"54216123",608:"d3fc0f5d",609:"de38ba1f",610:"e53aaaaa",611:"6b47b167",612:"9b2411de",613:"7382a97a",614:"768e5cda",615:"3da941d0"}[n]+".js"}(n);var s=new Error;i=function(e){r.onerror=r.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",s.name="ChunkLoadError",s.type=a,s.request=i,t[1](s)}o[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:r})}),12e4);r.onerror=r.onload=i,document.head.appendChild(r)}return Promise.all(e)},l.m=n,l.c=a,l.d=function(n,e,t){l.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},l.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},l.t=function(n,e){if(1&e&&(n=l(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(l.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)l.d(t,a,function(e){return n[e]}.bind(null,a));return t},l.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return l.d(e,"a",e),e},l.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},l.p="/",l.oe=function(n){throw console.error(n),n};var r=window.webpackJsonp=window.webpackJsonp||[],s=r.push.bind(r);r.push=e,r=r.slice();for(var c=0;c<r.length;c++)e(r[c]);var d=s;i.push([103,0]),t()}([function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({});function o(n){return null==n}function i(n){return null!=n}function l(n){return!0===n}function r(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function s(n){return null!==n&&"object"==typeof n}var c=Object.prototype.toString;function d(n){return"[object Object]"===c.call(n)}function p(n){return"[object RegExp]"===c.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function u(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===c?JSON.stringify(n,null,2):String(n)}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),a=n.split(","),o=0;o<a.length;o++)t[a[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var g=v("key,ref,slot,slot-scope,is");function b(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var w=Object.prototype.hasOwnProperty;function E(n,e){return w.call(n,e)}function x(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var y=/-(\w)/g,A=x((function(n){return n.replace(y,(function(n,e){return e?e.toUpperCase():""}))})),C=x((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),B=/\B([A-Z])/g,F=x((function(n){return n.replace(B,"-$1").toLowerCase()}));var L=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function X(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function T(n,e){for(var t in e)n[t]=e[t];return n}function I(n){for(var e={},t=0;t<n.length;t++)n[t]&&T(e,n[t]);return e}function S(n,e,t){}var k=function(n,e,t){return!1},N=function(n){return n};function z(n,e){if(n===e)return!0;var t=s(n),a=s(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var o=Array.isArray(n),i=Array.isArray(e);if(o&&i)return n.length===e.length&&n.every((function(n,t){return z(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||i)return!1;var l=Object.keys(n),r=Object.keys(e);return l.length===r.length&&l.every((function(t){return z(n[t],e[t])}))}catch(n){return!1}}function j(n,e){for(var t=0;t<n.length;t++)if(z(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var P=["component","directive","filter"],_=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],O={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:k,isReservedAttr:k,isUnknownElement:k,getTagNamespace:S,parsePlatformTagName:N,mustUseProp:k,async:!0,_lifecycleHooks:_},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function R(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var U=new RegExp("[^"+H.source+".$_\\d]");var q,M="__proto__"in{},W="undefined"!=typeof window,Z="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,J=Z&&WXEnvironment.platform.toLowerCase(),K=W&&window.navigator.userAgent.toLowerCase(),$=K&&/msie|trident/.test(K),Q=K&&K.indexOf("msie 9.0")>0,G=K&&K.indexOf("edge/")>0,Y=(K&&K.indexOf("android"),K&&/iphone|ipad|ipod|ios/.test(K)||"ios"===J),V=(K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K),K&&K.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(W)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var an=function(){return void 0===q&&(q=!W&&!Z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),q},on=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var rn,sn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);rn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var cn=S,dn=0,pn=function(){this.id=dn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){b(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function un(n){mn.push(n),pn.target=n}function hn(){mn.pop(),pn.target=mn[mn.length-1]}var fn=function(n,e,t,a,o,i,l,r){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=o,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=l,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=r,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(fn.prototype,vn);var gn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function bn(n){return new fn(void 0,void 0,void 0,String(n))}function wn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var En=Array.prototype,xn=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];R(xn,n,(function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];var o,i=e.apply(this,t),l=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&l.observeArray(o),l.dep.notify(),i}))}));var yn=Object.getOwnPropertyNames(xn),An=!0;function Cn(n){An=n}var Bn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,R(n,"__ob__",this),Array.isArray(n)?(M?function(n,e){n.__proto__=e}(n,xn):function(n,e,t){for(var a=0,o=t.length;a<o;a++){var i=t[a];R(n,i,e[i])}}(n,xn,yn),this.observeArray(n)):this.walk(n)};function Fn(n,e){var t;if(s(n)&&!(n instanceof fn))return E(n,"__ob__")&&n.__ob__ instanceof Bn?t=n.__ob__:An&&!an()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Bn(n)),e&&t&&t.vmCount++,t}function Ln(n,e,t,a,o){var i=new pn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var r=l&&l.get,s=l&&l.set;r&&!s||2!==arguments.length||(t=n[e]);var c=!o&&Fn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=r?r.call(n):t;return pn.target&&(i.depend(),c&&(c.dep.depend(),Array.isArray(e)&&In(e))),e},set:function(e){var a=r?r.call(n):t;e===a||e!=e&&a!=a||r&&!s||(s?s.call(n,e):t=e,c=!o&&Fn(e),i.notify())}})}}function Xn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var a=n.__ob__;return n._isVue||a&&a.vmCount?t:a?(Ln(a.value,e,t),a.dep.notify(),t):(n[e]=t,t)}function Tn(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||E(n,e)&&(delete n[e],t&&t.dep.notify())}}function In(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&In(e)}Bn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Ln(n,e[t])},Bn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Fn(n[e])};var Sn=O.optionMergeStrategies;function kn(n,e){if(!e)return n;for(var t,a,o,i=sn?Reflect.ownKeys(e):Object.keys(e),l=0;l<i.length;l++)"__ob__"!==(t=i[l])&&(a=n[t],o=e[t],E(n,t)?a!==o&&d(a)&&d(o)&&kn(a,o):Xn(n,t,o));return n}function Nn(n,e,t){return t?function(){var a="function"==typeof e?e.call(t,t):e,o="function"==typeof n?n.call(t,t):n;return a?kn(a,o):o}:e?n?function(){return kn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function zn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function jn(n,e,t,a){var o=Object.create(n||null);return e?T(o,e):o}Sn.data=function(n,e,t){return t?Nn(n,e,t):e&&"function"!=typeof e?n:Nn(n,e)},_.forEach((function(n){Sn[n]=zn})),P.forEach((function(n){Sn[n+"s"]=jn})),Sn.watch=function(n,e,t,a){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in T(o,n),e){var l=o[i],r=e[i];l&&!Array.isArray(l)&&(l=[l]),o[i]=l?l.concat(r):Array.isArray(r)?r:[r]}return o},Sn.props=Sn.methods=Sn.inject=Sn.computed=function(n,e,t,a){if(!n)return e;var o=Object.create(null);return T(o,n),e&&T(o,e),o},Sn.provide=Nn;var Dn=function(n,e){return void 0===e?n:e};function Pn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var a,o,i={};if(Array.isArray(t))for(a=t.length;a--;)"string"==typeof(o=t[a])&&(i[A(o)]={type:null});else if(d(t))for(var l in t)o=t[l],i[A(l)]=d(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(Array.isArray(t))for(var o=0;o<t.length;o++)a[t[o]]={from:t[o]};else if(d(t))for(var i in t){var l=t[i];a[i]=d(l)?T({from:i},l):{from:l}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];"function"==typeof a&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Pn(n,e.extends,t)),e.mixins))for(var a=0,o=e.mixins.length;a<o;a++)n=Pn(n,e.mixins[a],t);var i,l={};for(i in n)r(i);for(i in e)E(n,i)||r(i);function r(a){var o=Sn[a]||Dn;l[a]=o(n[a],e[a],t,a)}return l}function _n(n,e,t,a){if("string"==typeof t){var o=n[e];if(E(o,t))return o[t];var i=A(t);if(E(o,i))return o[i];var l=C(i);return E(o,l)?o[l]:o[t]||o[i]||o[l]}}function On(n,e,t,a){var o=e[n],i=!E(t,n),l=t[n],r=qn(Boolean,o.type);if(r>-1)if(i&&!E(o,"default"))l=!1;else if(""===l||l===F(n)){var s=qn(String,o.type);(s<0||r<s)&&(l=!0)}if(void 0===l){l=function(n,e,t){if(!E(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof a&&"Function"!==Rn(e.type)?a.call(n):a}(a,o,n);var c=An;Cn(!0),Fn(l),Cn(c)}return l}var Hn=/^\s*function (\w+)/;function Rn(n){var e=n&&n.toString().match(Hn);return e?e[1]:""}function Un(n,e){return Rn(n)===Rn(e)}function qn(n,e){if(!Array.isArray(e))return Un(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Un(e[t],n))return t;return-1}function Mn(n,e,t){un();try{if(e)for(var a=e;a=a.$parent;){var o=a.$options.errorCaptured;if(o)for(var i=0;i<o.length;i++)try{if(!1===o[i].call(a,n,e,t))return}catch(n){Zn(n,a,"errorCaptured hook")}}Zn(n,e,t)}finally{hn()}}function Wn(n,e,t,a,o){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&u(i)&&!i._handled&&(i.catch((function(n){return Mn(n,a,o+" (Promise/async)")})),i._handled=!0)}catch(n){Mn(n,a,o)}return i}function Zn(n,e,t){if(O.errorHandler)try{return O.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Jn(e,null,"config.errorHandler")}Jn(n,e,t)}function Jn(n,e,t){if(!W&&!Z||"undefined"==typeof console)throw n;console.error(n)}var Kn,$n=!1,Qn=[],Gn=!1;function Yn(){Gn=!1;var n=Qn.slice(0);Qn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Vn=Promise.resolve();Kn=function(){Vn.then(Yn),Y&&setTimeout(S)},$n=!0}else if($||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Kn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Yn)}:function(){setTimeout(Yn,0)};else{var ne=1,ee=new MutationObserver(Yn),te=document.createTextNode(String(ne));ee.observe(te,{characterData:!0}),Kn=function(){ne=(ne+1)%2,te.data=String(ne)},$n=!0}function ae(n,e){var t;if(Qn.push((function(){if(n)try{n.call(e)}catch(n){Mn(n,e,"nextTick")}else t&&t(e)})),Gn||(Gn=!0,Kn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var oe=new rn;function ie(n){!function n(e,t){var a,o,i=Array.isArray(e);if(!i&&!s(e)||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var l=e.__ob__.dep.id;if(t.has(l))return;t.add(l)}if(i)for(a=e.length;a--;)n(e[a],t);else for(o=Object.keys(e),a=o.length;a--;)n(e[o[a]],t)}(n,oe),oe.clear()}var le=x((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function re(n,e){function t(){var n=arguments,a=t.fns;if(!Array.isArray(a))return Wn(a,null,arguments,e,"v-on handler");for(var o=a.slice(),i=0;i<o.length;i++)Wn(o[i],null,n,e,"v-on handler")}return t.fns=n,t}function se(n,e,t,a,i,r){var s,c,d,p;for(s in n)c=n[s],d=e[s],p=le(s),o(c)||(o(d)?(o(c.fns)&&(c=n[s]=re(c,r)),l(p.once)&&(c=n[s]=i(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)o(n[s])&&a((p=le(s)).name,e[s],p.capture)}function ce(n,e,t){var a;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function s(){t.apply(this,arguments),b(a.fns,s)}o(r)?a=re([s]):i(r.fns)&&l(r.merged)?(a=r).fns.push(s):a=re([r,s]),a.merged=!0,n[e]=a}function de(n,e,t,a,o){if(i(e)){if(E(e,t))return n[t]=e[t],o||delete e[t],!0;if(E(e,a))return n[t]=e[a],o||delete e[a],!0}return!1}function pe(n){return r(n)?[bn(n)]:Array.isArray(n)?function n(e,t){var a,s,c,d,p=[];for(a=0;a<e.length;a++)o(s=e[a])||"boolean"==typeof s||(c=p.length-1,d=p[c],Array.isArray(s)?s.length>0&&(me((s=n(s,(t||"")+"_"+a))[0])&&me(d)&&(p[c]=bn(d.text+s[0].text),s.shift()),p.push.apply(p,s)):r(s)?me(d)?p[c]=bn(d.text+s):""!==s&&p.push(bn(s)):me(s)&&me(d)?p[c]=bn(d.text+s.text):(l(e._isVList)&&i(s.tag)&&o(s.key)&&i(t)&&(s.key="__vlist"+t+"_"+a+"__"),p.push(s)));return p}(n):void 0}function me(n){return i(n)&&i(n.text)&&!1===n.isComment}function ue(n,e){if(n){for(var t=Object.create(null),a=sn?Reflect.ownKeys(n):Object.keys(n),o=0;o<a.length;o++){var i=a[o];if("__ob__"!==i){for(var l=n[i].from,r=e;r;){if(r._provided&&E(r._provided,l)){t[i]=r._provided[l];break}r=r.$parent}if(!r)if("default"in n[i]){var s=n[i].default;t[i]="function"==typeof s?s.call(e):s}else 0}}return t}}function he(n,e){if(!n||!n.length)return{};for(var t={},a=0,o=n.length;a<o;a++){var i=n[a],l=i.data;if(l&&l.attrs&&l.attrs.slot&&delete l.attrs.slot,i.context!==e&&i.fnContext!==e||!l||null==l.slot)(t.default||(t.default=[])).push(i);else{var r=l.slot,s=t[r]||(t[r]=[]);"template"===i.tag?s.push.apply(s,i.children||[]):s.push(i)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function ge(n,e,t){var o,i=Object.keys(e).length>0,l=n?!!n.$stable:!i,r=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(l&&t&&t!==a&&r===t.$key&&!i&&!t.$hasNormal)return t;for(var s in o={},n)n[s]&&"$"!==s[0]&&(o[s]=be(e,s,n[s]))}else o={};for(var c in e)c in o||(o[c]=we(e,c));return n&&Object.isExtensible(n)&&(n._normalized=o),R(o,"$stable",l),R(o,"$key",r),R(o,"$hasNormal",i),o}function be(n,e,t){var a=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ve(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:a,enumerable:!0,configurable:!0}),a}function we(n,e){return function(){return n[e]}}function Ee(n,e){var t,a,o,l,r;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),a=0,o=n.length;a<o;a++)t[a]=e(n[a],a);else if("number"==typeof n)for(t=new Array(n),a=0;a<n;a++)t[a]=e(a+1,a);else if(s(n))if(sn&&n[Symbol.iterator]){t=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)t.push(e(d.value,t.length)),d=c.next()}else for(l=Object.keys(n),t=new Array(l.length),a=0,o=l.length;a<o;a++)r=l[a],t[a]=e(n[r],r,a);return i(t)||(t=[]),t._isVList=!0,t}function xe(n,e,t,a){var o,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=T(T({},a),t)),o=i(t)||("function"==typeof e?e():e)):o=this.$slots[n]||("function"==typeof e?e():e);var l=t&&t.slot;return l?this.$createElement("template",{slot:l},o):o}function ye(n){return _n(this.$options,"filters",n)||N}function Ae(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ce(n,e,t,a,o){var i=O.keyCodes[e]||t;return o&&a&&!O.keyCodes[e]?Ae(o,a):i?Ae(i,n):a?F(a)!==e:void 0===n}function Be(n,e,t,a,o){if(t)if(s(t)){var i;Array.isArray(t)&&(t=I(t));var l=function(l){if("class"===l||"style"===l||g(l))i=n;else{var r=n.attrs&&n.attrs.type;i=a||O.mustUseProp(e,r,l)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=A(l),c=F(l);s in i||c in i||(i[l]=t[l],o&&((n.on||(n.on={}))["update:"+l]=function(n){t[l]=n}))};for(var r in t)l(r)}else;return n}function Fe(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||Xe(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),a}function Le(n,e,t){return Xe(n,"__once__"+e+(t?"_"+t:""),!0),n}function Xe(n,e,t){if(Array.isArray(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&Te(n[a],e+"_"+a,t);else Te(n,e,t)}function Te(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ie(n,e){if(e)if(d(e)){var t=n.on=n.on?T({},n.on):{};for(var a in e){var o=t[a],i=e[a];t[a]=o?[].concat(o,i):i}}else;return n}function Se(n,e,t,a){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];Array.isArray(i)?Se(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return a&&(e.$key=a),e}function ke(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function Ne(n,e){return"string"==typeof n?e+n:n}function ze(n){n._o=Le,n._n=f,n._s=h,n._l=Ee,n._t=xe,n._q=z,n._i=j,n._m=Fe,n._f=ye,n._k=Ce,n._b=Be,n._v=bn,n._e=gn,n._u=Se,n._g=Ie,n._d=ke,n._p=Ne}function je(n,e,t,o,i){var r,s=this,c=i.options;E(o,"_uid")?(r=Object.create(o))._original=o:(r=o,o=o._original);var d=l(c._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||a,this.injections=ue(c.inject,o),this.slots=function(){return s.$slots||ge(n.scopedSlots,s.$slots=he(t,o)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ge(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,a){var i=Ue(r,n,e,t,a,p);return i&&!Array.isArray(i)&&(i.fnScopeId=c._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,a){return Ue(r,n,e,t,a,p)}}function De(n,e,t,a,o){var i=wn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function Pe(n,e){for(var t in e)n[A(t)]=e[t]}ze(je.prototype);var _e={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;_e.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;i(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ge)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,i){0;var l=o.data.scopedSlots,r=n.$scopedSlots,s=!!(l&&!l.$stable||r!==a&&!r.$stable||l&&n.$scopedSlots.$key!==l.$key||!l&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||s);n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o);if(n.$options._renderChildren=i,n.$attrs=o.data.attrs||a,n.$listeners=t||a,e&&n.$options.props){Cn(!1);for(var d=n._props,p=n.$options._propKeys||[],m=0;m<p.length;m++){var u=p[m],h=n.$options.props;d[u]=On(u,h,e,n)}Cn(!0),n.$options.propsData=e}t=t||a;var f=n.$options._parentListeners;n.$options._parentListeners=t,Qe(n,t,f),c&&(n.$slots=he(i,o.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,et(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,at.push(e)):nt(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ve(e)))return;if(!e._inactive){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);et(e,"deactivated")}}(e,!0):e.$destroy())}},Oe=Object.keys(_e);function He(n,e,t,r,c){if(!o(n)){var d=t.$options._base;if(s(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(o(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Me;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var a=n.owners=[t],r=!0,c=null,d=null;t.$on("hook:destroyed",(function(){return b(a,t)}));var p=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==c&&(clearTimeout(c),c=null),null!==d&&(clearTimeout(d),d=null))},m=D((function(t){n.resolved=We(t,e),r?a.length=0:p(!0)})),h=D((function(e){i(n.errorComp)&&(n.error=!0,p(!0))})),f=n(m,h);return s(f)&&(u(f)?o(n.resolved)&&f.then(m,h):u(f.component)&&(f.component.then(m,h),i(f.error)&&(n.errorComp=We(f.error,e)),i(f.loading)&&(n.loadingComp=We(f.loading,e),0===f.delay?n.loading=!0:c=setTimeout((function(){c=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,p(!1))}),f.delay||200)),i(f.timeout)&&(d=setTimeout((function(){d=null,o(n.resolved)&&h(null)}),f.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,a,o){var i=gn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:o},i}(p,e,t,r,c);e=e||{},At(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),l=o[a],r=e.model.callback;i(l)?(Array.isArray(l)?-1===l.indexOf(r):l!==r)&&(o[a]=[r].concat(l)):o[a]=r}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!o(a)){var l={},r=n.attrs,s=n.props;if(i(r)||i(s))for(var c in a){var d=F(c);de(l,s,c,d,!0)||de(l,r,c,d,!1)}return l}}(e,n);if(l(n.options.functional))return function(n,e,t,o,l){var r=n.options,s={},c=r.props;if(i(c))for(var d in c)s[d]=On(d,c,e||a);else i(t.attrs)&&Pe(s,t.attrs),i(t.props)&&Pe(s,t.props);var p=new je(t,s,l,o,n),m=r.render.call(null,p._c,p);if(m instanceof fn)return De(m,t,p.parent,r,p);if(Array.isArray(m)){for(var u=pe(m)||[],h=new Array(u.length),f=0;f<u.length;f++)h[f]=De(u[f],t,p.parent,r,p);return h}}(n,m,e,t,r);var h=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Oe.length;t++){var a=Oe[t],o=e[a],i=_e[a];o===i||o&&o._merged||(e[a]=o?Re(i,o):i)}}(e);var v=n.options.name||c;return new fn("vue-component-"+n.cid+(v?"-"+v:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:r},p)}}}function Re(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}function Ue(n,e,t,a,c,d){return(Array.isArray(t)||r(t))&&(c=a,a=t,t=void 0),l(d)&&(c=2),function(n,e,t,a,r){if(i(t)&&i(t.__ob__))return gn();i(t)&&i(t.is)&&(e=t.is);if(!e)return gn();0;Array.isArray(a)&&"function"==typeof a[0]&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===r?a=pe(a):1===r&&(a=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var c,d;if("string"==typeof e){var p;d=n.$vnode&&n.$vnode.ns||O.getTagNamespace(e),c=O.isReservedTag(e)?new fn(O.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!i(p=_n(n.$options,"components",e))?new fn(e,t,a,void 0,void 0,n):He(p,t,n,a,e)}else c=He(e,t,n,a);return Array.isArray(c)?c:i(c)?(i(d)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(i(e.children))for(var r=0,s=e.children.length;r<s;r++){var c=e.children[r];i(c.tag)&&(o(c.ns)||l(a)&&"svg"!==c.tag)&&n(c,t,a)}}(c,d),i(t)&&function(n){s(n.style)&&ie(n.style);s(n.class)&&ie(n.class)}(t),c):gn()}(n,e,t,a,c)}var qe,Me=null;function We(n,e){return(n.__esModule||sn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),s(n)?e.extend(n):n}function Ze(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||ve(t)))return t}}function Je(n,e){qe.$on(n,e)}function Ke(n,e){qe.$off(n,e)}function $e(n,e){var t=qe;return function a(){var o=e.apply(null,arguments);null!==o&&t.$off(n,a)}}function Qe(n,e,t){qe=n,se(e,t||{},Je,Ke,$e,n),qe=void 0}var Ge=null;function Ye(n){var e=Ge;return Ge=n,function(){Ge=e}}function Ve(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ve(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e){un();var t=n.$options[e],a=e+" hook";if(t)for(var o=0,i=t.length;o<i;o++)Wn(t[o],n,null,n,a);n._hasHookEvent&&n.$emit("hook:"+e),hn()}var tt=[],at=[],ot={},it=!1,lt=!1,rt=0;var st=0,ct=Date.now;if(W&&!$){var dt=window.performance;dt&&"function"==typeof dt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return dt.now()})}function pt(){var n,e;for(st=ct(),lt=!0,tt.sort((function(n,e){return n.id-e.id})),rt=0;rt<tt.length;rt++)(n=tt[rt]).before&&n.before(),e=n.id,ot[e]=null,n.run();var t=at.slice(),a=tt.slice();rt=tt.length=at.length=0,ot={},it=lt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a._watcher===t&&a._isMounted&&!a._isDestroyed&&et(a,"updated")}}(a),on&&O.devtools&&on.emit("flush")}var mt=0,ut=function(n,e,t,a,o){this.vm=n,o&&(n._watcher=this),n._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new rn,this.newDepIds=new rn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!U.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=S)),this.value=this.lazy?void 0:this.get()};ut.prototype.get=function(){var n;un(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Mn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ie(n),hn(),this.cleanupDeps()}return n},ut.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ut.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ut.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==ot[e]){if(ot[e]=!0,lt){for(var t=tt.length-1;t>rt&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);it||(it=!0,ae(pt))}}(this)},ut.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||s(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Wn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ut.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ut.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ut.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||b(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ht={enumerable:!0,configurable:!0,get:S,set:S};function ft(n,e,t){ht.get=function(){return this[e][t]},ht.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ht)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props={},o=n.$options._propKeys=[];n.$parent&&Cn(!1);var i=function(i){o.push(i);var l=On(i,e,t,n);Ln(a,i,l),i in n||ft(n,"_props",i)};for(var l in e)i(l);Cn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?S:L(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){un();try{return n.call(e,e)}catch(n){return Mn(n,e,"data()"),{}}finally{hn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var i=t[o];0,a&&E(a,i)||(l=void 0,36!==(l=(i+"").charCodeAt(0))&&95!==l&&ft(n,"_data",i))}var l;Fn(e,!0)}(n):Fn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=an();for(var o in e){var i=e[o],l="function"==typeof i?i:i.get;0,a||(t[o]=new ut(n,l||S,S,gt)),o in n||bt(n,o,i)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var a=e[t];if(Array.isArray(a))for(var o=0;o<a.length;o++)xt(n,t,a[o]);else xt(n,t,a)}}(n,e.watch)}var gt={lazy:!0};function bt(n,e,t){var a=!an();"function"==typeof t?(ht.get=a?wt(e):Et(t),ht.set=S):(ht.get=t.get?a&&!1!==t.cache?wt(e):Et(t.get):S,ht.set=t.set||S),Object.defineProperty(n,e,ht)}function wt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function Et(n){return function(){return n.call(this,this)}}function xt(n,e,t,a){return d(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var yt=0;function At(n){var e=n.options;if(n.super){var t=At(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var o in t)t[o]!==a[o]&&(e||(e={}),e[o]=t[o]);return e}(n);a&&T(n.extendOptions,a),(e=n.options=Pn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ct(n){this._init(n)}function Bt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,o=n._Ctor||(n._Ctor={});if(o[a])return o[a];var i=n.name||t.options.name;var l=function(n){this._init(n)};return(l.prototype=Object.create(t.prototype)).constructor=l,l.cid=e++,l.options=Pn(t.options,n),l.super=t,l.options.props&&function(n){var e=n.options.props;for(var t in e)ft(n.prototype,"_props",t)}(l),l.options.computed&&function(n){var e=n.options.computed;for(var t in e)bt(n.prototype,t,e[t])}(l),l.extend=t.extend,l.mixin=t.mixin,l.use=t.use,P.forEach((function(n){l[n]=t[n]})),i&&(l.options.components[i]=l),l.superOptions=t.options,l.extendOptions=n,l.sealedOptions=T({},l.options),o[a]=l,l}}function Ft(n){return n&&(n.Ctor.options.name||n.tag)}function Lt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Xt(n,e){var t=n.cache,a=n.keys,o=n._vnode;for(var i in t){var l=t[i];if(l){var r=l.name;r&&!e(r)&&Tt(t,i,a,o)}}}function Tt(n,e,t,a){var o=n[e];!o||a&&o.tag===a.tag||o.componentInstance.$destroy(),n[e]=null,b(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=yt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var o=a.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Pn(At(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=he(e._renderChildren,o),n.$scopedSlots=a,n._c=function(e,t,a,o){return Ue(n,e,t,a,o,!1)},n.$createElement=function(e,t,a,o){return Ue(n,e,t,a,o,!0)};var i=t&&t.data;Ln(n,"$attrs",i&&i.attrs||a,null,!0),Ln(n,"$listeners",e._parentListeners||a,null,!0)}(e),et(e,"beforeCreate"),function(n){var e=ue(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){Ln(n,t,e[t])})),Cn(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ct),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Xn,n.prototype.$delete=Tn,n.prototype.$watch=function(n,e,t){if(d(e))return xt(this,n,e,t);(t=t||{}).user=!0;var a=new ut(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'+a.expression+'"';un(),Wn(e,this,[a.value],this,o),hn()}return function(){a.teardown()}}}(Ct),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(Array.isArray(n))for(var o=0,i=n.length;o<i;o++)a.$on(n[o],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var a=0,o=n.length;a<o;a++)t.$off(n[a],e);return t}var i,l=t._events[n];if(!l)return t;if(!e)return t._events[n]=null,t;for(var r=l.length;r--;)if((i=l[r])===e||i.fn===e){l.splice(r,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?X(t):t;for(var a=X(arguments,1),o='event handler for "'+n+'"',i=0,l=t.length;i<l;i++)Wn(t[i],e,a,e,o)}return e}}(Ct),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,o=t._vnode,i=Ye(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||b(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ct),function(n){ze(n.prototype),n.prototype.$nextTick=function(n){return ae(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,o=t._parentVnode;o&&(e.$scopedSlots=ge(o.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=o;try{Me=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Mn(t,e,"render"),n=e._vnode}finally{Me=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof fn||(n=gn()),n.parent=o,n}}(Ct);var It=[String,RegExp,Array],St={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:It,exclude:It,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var o=t.tag,i=t.componentInstance,l=t.componentOptions;n[a]={name:Ft(l),tag:o,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Tt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Tt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Lt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Lt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ze(n),t=e&&e.componentOptions;if(t){var a=Ft(t),o=this.include,i=this.exclude;if(o&&(!a||!Lt(o,a))||i&&a&&Lt(i,a))return e;var l=this.cache,r=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;l[s]?(e.componentInstance=l[s].componentInstance,b(r,s),r.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return O}};Object.defineProperty(n,"config",e),n.util={warn:cn,extend:T,mergeOptions:Pn,defineReactive:Ln},n.set=Xn,n.delete=Tn,n.nextTick=ae,n.observable=function(n){return Fn(n),n},n.options=Object.create(null),P.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,T(n.options.components,St),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=X(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Pn(this.options,n),this}}(n),Bt(n),function(n){P.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ct),Object.defineProperty(Ct.prototype,"$isServer",{get:an}),Object.defineProperty(Ct.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ct,"FunctionalRenderContext",{value:je}),Ct.version="2.6.14";var kt=v("style,class"),Nt=v("input,textarea,option,select,progress"),zt=v("contenteditable,draggable,spellcheck"),jt=v("events,caret,typing,plaintext-only"),Dt=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Pt="http://www.w3.org/1999/xlink",_t=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ot=function(n){return _t(n)?n.slice(6,n.length):""},Ht=function(n){return null==n||!1===n};function Rt(n){for(var e=n.data,t=n,a=n;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=Ut(a.data,e));for(;i(t=t.parent);)t&&t.data&&(e=Ut(e,t.data));return function(n,e){if(i(n)||i(e))return qt(n,Mt(e));return""}(e.staticClass,e.class)}function Ut(n,e){return{staticClass:qt(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function qt(n,e){return n?e?n+" "+e:n:e||""}function Mt(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,o=n.length;a<o;a++)i(e=Mt(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):s(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Wt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Zt=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Jt=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Kt=function(n){return Zt(n)||Jt(n)};var $t=Object.create(null);var Qt=v("text,number,password,search,email,tel,url");var Gt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Wt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Yt={create:function(n,e){Vt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Vt(n,!0),Vt(e))},destroy:function(n){Vt(n,!0)}};function Vt(n,e){var t=n.data.ref;if(i(t)){var a=n.context,o=n.componentInstance||n.elm,l=a.$refs;e?Array.isArray(l[t])?b(l[t],o):l[t]===o&&(l[t]=void 0):n.data.refInFor?Array.isArray(l[t])?l[t].indexOf(o)<0&&l[t].push(o):l[t]=[o]:l[t]=o}}var na=new fn("",{},[]),ea=["create","activate","update","remove","destroy"];function ta(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=i(t=n.data)&&i(t=t.attrs)&&t.type,o=i(t=e.data)&&i(t=t.attrs)&&t.type;return a===o||Qt(a)&&Qt(o)}(n,e)||l(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function aa(n,e,t){var a,o,l={};for(a=e;a<=t;++a)i(o=n[a].key)&&(l[o]=a);return l}var oa={create:ia,update:ia,destroy:function(n){ia(n,na)}};function ia(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,o,i=n===na,l=e===na,r=ra(n.data.directives,n.context),s=ra(e.data.directives,e.context),c=[],d=[];for(t in s)a=r[t],o=s[t],a?(o.oldValue=a.value,o.oldArg=a.arg,ca(o,"update",e,n),o.def&&o.def.componentUpdated&&d.push(o)):(ca(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var p=function(){for(var t=0;t<c.length;t++)ca(c[t],"inserted",e,n)};i?ce(e,"insert",p):p()}d.length&&ce(e,"postpatch",(function(){for(var t=0;t<d.length;t++)ca(d[t],"componentUpdated",e,n)}));if(!i)for(t in r)s[t]||ca(r[t],"unbind",n,n,l)}(n,e)}var la=Object.create(null);function ra(n,e){var t,a,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++)(a=n[t]).modifiers||(a.modifiers=la),o[sa(a)]=a,a.def=_n(e.$options,"directives",a.name);return o}function sa(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ca(n,e,t,a,o){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,o)}catch(a){Mn(a,t.context,"directive "+n.name+" "+e+" hook")}}var da=[Yt,oa];function pa(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var a,l,r=e.elm,s=n.data.attrs||{},c=e.data.attrs||{};for(a in i(c.__ob__)&&(c=e.data.attrs=T({},c)),c)l=c[a],s[a]!==l&&ma(r,a,l,e.data.pre);for(a in($||G)&&c.value!==s.value&&ma(r,"value",c.value),s)o(c[a])&&(_t(a)?r.removeAttributeNS(Pt,Ot(a)):zt(a)||r.removeAttribute(a))}}function ma(n,e,t,a){a||n.tagName.indexOf("-")>-1?ua(n,e,t):Dt(e)?Ht(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):zt(e)?n.setAttribute(e,function(n,e){return Ht(e)||"false"===e?"false":"contenteditable"===n&&jt(e)?e:"true"}(e,t)):_t(e)?Ht(t)?n.removeAttributeNS(Pt,Ot(e)):n.setAttributeNS(Pt,e,t):ua(n,e,t)}function ua(n,e,t){if(Ht(t))n.removeAttribute(e);else{if($&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var ha={create:pa,update:pa};function fa(n,e){var t=e.elm,a=e.data,l=n.data;if(!(o(a.staticClass)&&o(a.class)&&(o(l)||o(l.staticClass)&&o(l.class)))){var r=Rt(e),s=t._transitionClasses;i(s)&&(r=qt(r,Mt(s))),r!==t._prevClass&&(t.setAttribute("class",r),t._prevClass=r)}}var va,ga={create:fa,update:fa};function ba(n,e,t){var a=va;return function o(){var i=e.apply(null,arguments);null!==i&&xa(n,o,t,a)}}var wa=$n&&!(V&&Number(V[1])<=53);function Ea(n,e,t,a){if(wa){var o=st,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}va.addEventListener(n,e,en?{capture:t,passive:a}:t)}function xa(n,e,t,a){(a||va).removeEventListener(n,e._wrapper||e,t)}function ya(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},a=n.data.on||{};va=e.elm,function(n){if(i(n.__r)){var e=$?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),se(t,a,Ea,xa,ba,e.context),va=void 0}}var Aa,Ca={create:ya,update:ya};function Ba(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,a,l=e.elm,r=n.data.domProps||{},s=e.data.domProps||{};for(t in i(s.__ob__)&&(s=e.data.domProps=T({},s)),r)t in s||(l[t]="");for(t in s){if(a=s[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===r[t])continue;1===l.childNodes.length&&l.removeChild(l.childNodes[0])}if("value"===t&&"PROGRESS"!==l.tagName){l._value=a;var c=o(a)?"":String(a);Fa(l,c)&&(l.value=c)}else if("innerHTML"===t&&Jt(l.tagName)&&o(l.innerHTML)){(Aa=Aa||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var d=Aa.firstChild;l.firstChild;)l.removeChild(l.firstChild);for(;d.firstChild;)l.appendChild(d.firstChild)}else if(a!==r[t])try{l[t]=a}catch(n){}}}}function Fa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(i(a)){if(a.number)return f(t)!==f(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var La={create:Ba,update:Ba},Xa=x((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ta(n){var e=Ia(n.style);return n.staticStyle?T(n.staticStyle,e):e}function Ia(n){return Array.isArray(n)?I(n):"string"==typeof n?Xa(n):n}var Sa,ka=/^--/,Na=/\s*!important$/,za=function(n,e,t){if(ka.test(e))n.style.setProperty(e,t);else if(Na.test(t))n.style.setProperty(F(e),t.replace(Na,""),"important");else{var a=Da(e);if(Array.isArray(t))for(var o=0,i=t.length;o<i;o++)n.style[a]=t[o];else n.style[a]=t}},ja=["Webkit","Moz","ms"],Da=x((function(n){if(Sa=Sa||document.createElement("div").style,"filter"!==(n=A(n))&&n in Sa)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ja.length;t++){var a=ja[t]+e;if(a in Sa)return a}}));function Pa(n,e){var t=e.data,a=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(a.staticStyle)&&o(a.style))){var l,r,s=e.elm,c=a.staticStyle,d=a.normalizedStyle||a.style||{},p=c||d,m=Ia(e.data.style)||{};e.data.normalizedStyle=i(m.__ob__)?T({},m):m;var u=function(n,e){var t,a={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Ta(o.data))&&T(a,t);(t=Ta(n.data))&&T(a,t);for(var i=n;i=i.parent;)i.data&&(t=Ta(i.data))&&T(a,t);return a}(e,!0);for(r in p)o(u[r])&&za(s,r,"");for(r in u)(l=u[r])!==p[r]&&za(s,r,null==l?"":l)}}var _a={create:Pa,update:Pa},Oa=/\s+/;function Ha(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Oa).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Ra(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Oa).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ua(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&T(e,qa(n.name||"v")),T(e,n),e}return"string"==typeof n?qa(n):void 0}}var qa=x((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Ma=W&&!Q,Wa="transition",Za="transitionend",Ja="animation",Ka="animationend";Ma&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Wa="WebkitTransition",Za="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ja="WebkitAnimation",Ka="webkitAnimationEnd"));var $a=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Qa(n){$a((function(){$a(n)}))}function Ga(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Ha(n,e))}function Ya(n,e){n._transitionClasses&&b(n._transitionClasses,e),Ra(n,e)}function Va(n,e,t){var a=eo(n,e),o=a.type,i=a.timeout,l=a.propCount;if(!o)return t();var r="transition"===o?Za:Ka,s=0,c=function(){n.removeEventListener(r,d),t()},d=function(e){e.target===n&&++s>=l&&c()};setTimeout((function(){s<l&&c()}),i+1),n.addEventListener(r,d)}var no=/\b(transform|all)(,|$)/;function eo(n,e){var t,a=window.getComputedStyle(n),o=(a[Wa+"Delay"]||"").split(", "),i=(a[Wa+"Duration"]||"").split(", "),l=to(o,i),r=(a[Ja+"Delay"]||"").split(", "),s=(a[Ja+"Duration"]||"").split(", "),c=to(r,s),d=0,p=0;return"transition"===e?l>0&&(t="transition",d=l,p=i.length):"animation"===e?c>0&&(t="animation",d=c,p=s.length):p=(t=(d=Math.max(l,c))>0?l>c?"transition":"animation":null)?"transition"===t?i.length:s.length:0,{type:t,timeout:d,propCount:p,hasTransform:"transition"===t&&no.test(a[Wa+"Property"])}}function to(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ao(e)+ao(n[t])})))}function ao(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function oo(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=Ua(n.data.transition);if(!o(a)&&!i(t._enterCb)&&1===t.nodeType){for(var l=a.css,r=a.type,c=a.enterClass,d=a.enterToClass,p=a.enterActiveClass,m=a.appearClass,u=a.appearToClass,h=a.appearActiveClass,v=a.beforeEnter,g=a.enter,b=a.afterEnter,w=a.enterCancelled,E=a.beforeAppear,x=a.appear,y=a.afterAppear,A=a.appearCancelled,C=a.duration,B=Ge,F=Ge.$vnode;F&&F.parent;)B=F.context,F=F.parent;var L=!B._isMounted||!n.isRootInsert;if(!L||x||""===x){var X=L&&m?m:c,T=L&&h?h:p,I=L&&u?u:d,S=L&&E||v,k=L&&"function"==typeof x?x:g,N=L&&y||b,z=L&&A||w,j=f(s(C)?C.enter:C);0;var P=!1!==l&&!Q,_=ro(k),O=t._enterCb=D((function(){P&&(Ya(t,I),Ya(t,T)),O.cancelled?(P&&Ya(t,X),z&&z(t)):N&&N(t),t._enterCb=null}));n.data.show||ce(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),k&&k(t,O)})),S&&S(t),P&&(Ga(t,X),Ga(t,T),Qa((function(){Ya(t,X),O.cancelled||(Ga(t,I),_||(lo(j)?setTimeout(O,j):Va(t,r,O)))}))),n.data.show&&(e&&e(),k&&k(t,O)),P||_||O()}}}function io(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=Ua(n.data.transition);if(o(a)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var l=a.css,r=a.type,c=a.leaveClass,d=a.leaveToClass,p=a.leaveActiveClass,m=a.beforeLeave,u=a.leave,h=a.afterLeave,v=a.leaveCancelled,g=a.delayLeave,b=a.duration,w=!1!==l&&!Q,E=ro(u),x=f(s(b)?b.leave:b);0;var y=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),w&&(Ya(t,d),Ya(t,p)),y.cancelled?(w&&Ya(t,c),v&&v(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(A):A()}function A(){y.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),m&&m(t),w&&(Ga(t,c),Ga(t,p),Qa((function(){Ya(t,c),y.cancelled||(Ga(t,d),E||(lo(x)?setTimeout(y,x):Va(t,r,y)))}))),u&&u(t,y),w||E||y())}}function lo(n){return"number"==typeof n&&!isNaN(n)}function ro(n){if(o(n))return!1;var e=n.fns;return i(e)?ro(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function so(n,e){!0!==e.data.show&&oo(e)}var co=function(n){var e,t,a={},s=n.modules,c=n.nodeOps;for(e=0;e<ea.length;++e)for(a[ea[e]]=[],t=0;t<s.length;++t)i(s[t][ea[e]])&&a[ea[e]].push(s[t][ea[e]]);function d(n){var e=c.parentNode(n);i(e)&&c.removeChild(e,n)}function p(n,e,t,o,r,s,d){if(i(n.elm)&&i(s)&&(n=s[d]=wn(n)),n.isRootInsert=!r,!function(n,e,t,o){var r=n.data;if(i(r)){var s=i(n.componentInstance)&&r.keepAlive;if(i(r=r.hook)&&i(r=r.init)&&r(n,!1),i(n.componentInstance))return m(n,e),u(t,n.elm,o),l(s)&&function(n,e,t,o){var l,r=n;for(;r.componentInstance;)if(r=r.componentInstance._vnode,i(l=r.data)&&i(l=l.transition)){for(l=0;l<a.activate.length;++l)a.activate[l](na,r);e.push(r);break}u(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var p=n.data,f=n.children,v=n.tag;i(v)?(n.elm=n.ns?c.createElementNS(n.ns,v):c.createElement(v,n),b(n),h(n,f,e),i(p)&&g(n,e),u(t,n.elm,o)):l(n.isComment)?(n.elm=c.createComment(n.text),u(t,n.elm,o)):(n.elm=c.createTextNode(n.text),u(t,n.elm,o))}}function m(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(g(n,e),b(n)):(Vt(n),e.push(n))}function u(n,e,t){i(n)&&(i(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else r(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var o=0;o<a.create.length;++o)a.create[o](na,n);i(e=n.data.hook)&&(i(e.create)&&e.create(na,n),i(e.insert)&&t.push(n))}function b(n){var e;if(i(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;i(e=Ge)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function w(n,e,t,a,o,i){for(;a<=o;++a)p(t[a],i,n,e,!1,t,a)}function E(n){var e,t,o=n.data;if(i(o))for(i(e=o.hook)&&i(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)E(n.children[t])}function x(n,e,t){for(;e<=t;++e){var a=n[e];i(a)&&(i(a.tag)?(y(a),E(a)):d(a.elm))}}function y(n,e){if(i(e)||i(n.data)){var t,o=a.remove.length+1;for(i(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,o),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&y(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else d(n.elm)}function A(n,e,t,a){for(var o=t;o<a;o++){var l=e[o];if(i(l)&&ta(n,l))return o}}function C(n,e,t,r,s,d){if(n!==e){i(e.elm)&&i(r)&&(e=r[s]=wn(e));var m=e.elm=n.elm;if(l(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?L(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var u,h=e.data;i(h)&&i(u=h.hook)&&i(u=u.prepatch)&&u(n,e);var v=n.children,g=e.children;if(i(h)&&f(e)){for(u=0;u<a.update.length;++u)a.update[u](n,e);i(u=h.hook)&&i(u=u.update)&&u(n,e)}o(e.text)?i(v)&&i(g)?v!==g&&function(n,e,t,a,l){var r,s,d,m=0,u=0,h=e.length-1,f=e[0],v=e[h],g=t.length-1,b=t[0],E=t[g],y=!l;for(0;m<=h&&u<=g;)o(f)?f=e[++m]:o(v)?v=e[--h]:ta(f,b)?(C(f,b,a,t,u),f=e[++m],b=t[++u]):ta(v,E)?(C(v,E,a,t,g),v=e[--h],E=t[--g]):ta(f,E)?(C(f,E,a,t,g),y&&c.insertBefore(n,f.elm,c.nextSibling(v.elm)),f=e[++m],E=t[--g]):ta(v,b)?(C(v,b,a,t,u),y&&c.insertBefore(n,v.elm,f.elm),v=e[--h],b=t[++u]):(o(r)&&(r=aa(e,m,h)),o(s=i(b.key)?r[b.key]:A(b,e,m,h))?p(b,a,n,f.elm,!1,t,u):ta(d=e[s],b)?(C(d,b,a,t,u),e[s]=void 0,y&&c.insertBefore(n,d.elm,f.elm)):p(b,a,n,f.elm,!1,t,u),b=t[++u]);m>h?w(n,o(t[g+1])?null:t[g+1].elm,t,u,g,a):u>g&&x(e,m,h)}(m,v,g,t,d):i(g)?(i(n.text)&&c.setTextContent(m,""),w(m,null,g,0,g.length-1,t)):i(v)?x(v,0,v.length-1):i(n.text)&&c.setTextContent(m,""):n.text!==e.text&&c.setTextContent(m,e.text),i(h)&&i(u=h.hook)&&i(u=u.postpatch)&&u(n,e)}}}function B(n,e,t){if(l(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var F=v("attrs,class,staticClass,staticStyle,key");function L(n,e,t,a){var o,r=e.tag,s=e.data,c=e.children;if(a=a||s&&s.pre,e.elm=n,l(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(s)&&(i(o=s.hook)&&i(o=o.init)&&o(e,!0),i(o=e.componentInstance)))return m(e,t),!0;if(i(r)){if(i(c))if(n.hasChildNodes())if(i(o=s)&&i(o=o.domProps)&&i(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var d=!0,p=n.firstChild,u=0;u<c.length;u++){if(!p||!L(p,c[u],t,a)){d=!1;break}p=p.nextSibling}if(!d||p)return!1}else h(e,c,t);if(i(s)){var f=!1;for(var v in s)if(!F(v)){f=!0,g(e,t);break}!f&&s.class&&ie(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!o(e)){var s,d=!1,m=[];if(o(n))d=!0,p(e,m);else{var u=i(n.nodeType);if(!u&&ta(n,e))C(n,e,m,null,null,r);else{if(u){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&L(n,e,m))return B(e,m,!0),n;s=n,n=new fn(c.tagName(s).toLowerCase(),{},[],void 0,s)}var h=n.elm,v=c.parentNode(h);if(p(e,m,h._leaveCb?null:v,c.nextSibling(h)),i(e.parent))for(var g=e.parent,b=f(e);g;){for(var w=0;w<a.destroy.length;++w)a.destroy[w](g);if(g.elm=e.elm,b){for(var y=0;y<a.create.length;++y)a.create[y](na,g);var A=g.data.hook.insert;if(A.merged)for(var F=1;F<A.fns.length;F++)A.fns[F]()}else Vt(g);g=g.parent}i(v)?x([n],0,0):i(n.tag)&&E(n)}}return B(e,m,d),e.elm}i(n)&&E(n)}}({nodeOps:Gt,modules:[ha,ga,Ca,La,_a,W?{create:so,activate:so,remove:function(n,e){!0!==n.data.show?io(n,e):e()}}:{}].concat(da)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bo(n,"input")}));var po={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?ce(t,"postpatch",(function(){po.componentUpdated(n,e,t)})):mo(n,e,t.context),n._vOptions=[].map.call(n.options,fo)):("textarea"===t.tag||Qt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",vo),n.addEventListener("compositionend",go),n.addEventListener("change",go),Q&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){mo(n,e,t.context);var a=n._vOptions,o=n._vOptions=[].map.call(n.options,fo);if(o.some((function(n,e){return!z(n,a[e])})))(n.multiple?e.value.some((function(n){return ho(n,o)})):e.value!==e.oldValue&&ho(e.value,o))&&bo(n,"change")}}};function mo(n,e,t){uo(n,e,t),($||G)&&setTimeout((function(){uo(n,e,t)}),0)}function uo(n,e,t){var a=e.value,o=n.multiple;if(!o||Array.isArray(a)){for(var i,l,r=0,s=n.options.length;r<s;r++)if(l=n.options[r],o)i=j(a,fo(l))>-1,l.selected!==i&&(l.selected=i);else if(z(fo(l),a))return void(n.selectedIndex!==r&&(n.selectedIndex=r));o||(n.selectedIndex=-1)}}function ho(n,e){return e.every((function(e){return!z(e,n)}))}function fo(n){return"_value"in n?n._value:n.value}function vo(n){n.target.composing=!0}function go(n){n.target.composing&&(n.target.composing=!1,bo(n.target,"input"))}function bo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function wo(n){return!n.componentInstance||n.data&&n.data.transition?n:wo(n.componentInstance._vnode)}var Eo={model:po,show:{bind:function(n,e,t){var a=e.value,o=(t=wo(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&o?(t.data.show=!0,oo(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=wo(t)).data&&t.data.transition?(t.data.show=!0,a?oo(t,(function(){n.style.display=n.__vOriginalDisplay})):io(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,o){o||(n.style.display=n.__vOriginalDisplay)}}},xo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function yo(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?yo(Ze(e.children)):n}function Ao(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var o=t._parentListeners;for(var i in o)e[A(i)]=o[i];return e}function Co(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Bo=function(n){return n.tag||ve(n)},Fo=function(n){return"show"===n.name},Lo={name:"transition",props:xo,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Bo)).length){0;var a=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var i=yo(o);if(!i)return o;if(this._leaving)return Co(n,o);var l="__transition-"+this._uid+"-";i.key=null==i.key?i.isComment?l+"comment":l+i.tag:r(i.key)?0===String(i.key).indexOf(l)?i.key:l+i.key:i.key;var s=(i.data||(i.data={})).transition=Ao(this),c=this._vnode,d=yo(c);if(i.data.directives&&i.data.directives.some(Fo)&&(i.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,d)&&!ve(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var p=d.data.transition=T({},s);if("out-in"===a)return this._leaving=!0,ce(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Co(n,o);if("in-out"===a){if(ve(i))return c;var m,u=function(){m()};ce(s,"afterEnter",u),ce(s,"enterCancelled",u),ce(p,"delayLeave",(function(n){m=n}))}}return o}}},Xo=T({tag:String,moveClass:String},xo);function To(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Io(n){n.data.newPos=n.elm.getBoundingClientRect()}function So(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,o=e.top-t.top;if(a||o){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate("+a+"px,"+o+"px)",i.transitionDuration="0s"}}delete Xo.mode;var ko={Transition:Lo,TransitionGroup:{props:Xo,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var o=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,o=this.$slots.default||[],i=this.children=[],l=Ao(this),r=0;r<o.length;r++){var s=o[r];if(s.tag)if(null!=s.key&&0!==String(s.key).indexOf("__vlist"))i.push(s),t[s.key]=s,(s.data||(s.data={})).transition=l;else;}if(a){for(var c=[],d=[],p=0;p<a.length;p++){var m=a[p];m.data.transition=l,m.data.pos=m.elm.getBoundingClientRect(),t[m.key]?c.push(m):d.push(m)}this.kept=n(e,null,c),this.removed=d}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(To),n.forEach(Io),n.forEach(So),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;Ga(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(Za,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(Za,n),t._moveCb=null,Ya(t,e))})}})))},methods:{hasMove:function(n,e){if(!Ma)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Ra(t,n)})),Ha(t,e),t.style.display="none",this.$el.appendChild(t);var a=eo(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};Ct.config.mustUseProp=function(n,e,t){return"value"===t&&Nt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ct.config.isReservedTag=Kt,Ct.config.isReservedAttr=kt,Ct.config.getTagNamespace=function(n){return Jt(n)?"svg":"math"===n?"math":void 0},Ct.config.isUnknownElement=function(n){if(!W)return!0;if(Kt(n))return!1;if(n=n.toLowerCase(),null!=$t[n])return $t[n];var e=document.createElement(n);return n.indexOf("-")>-1?$t[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:$t[n]=/HTMLUnknownElement/.test(e.toString())},T(Ct.options.directives,Eo),T(Ct.options.components,ko),Ct.prototype.__patch__=W?co:S,Ct.prototype.$mount=function(n,e){return function(n,e,t){var a;return n.$el=e,n.$options.render||(n.$options.render=gn),et(n,"beforeMount"),a=function(){n._update(n._render(),t)},new ut(n,a,S,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){O.devtools&&on&&on.emit("init",Ct)}),0),e.default=Ct},function(n,e,t){var a=t(56),o=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===o}:function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var a=t(29),o=Function.prototype,i=o.call,l=a&&o.bind.bind(i,i);n.exports=a?l:function(n){return function(){return i.apply(n,arguments)}}},function(n,e,t){var a=t(3);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(70),o="object"==typeof self&&self&&self.Object===Object&&self,i=a||o||Function("return this")();n.exports=i},function(n,e,t){"use strict";function a(n,e,t,a,o,i,l,r){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),l?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(l)},c._ssrRegister=s):o&&(s=r?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(4),o=t(32),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(o(n),e)}},function(n,e,t){var a=t(1),o=t(56),i=o.all;n.exports=o.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===i}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(162),o=t(165);n.exports=function(n,e){var t=o(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return l})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return m})),t.d(e,"l",(function(){return u})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return v})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return E}));t(14);const a=/#.*$/,o=/\.(md|html)$/,i=/\/$/,l=/^[a-z]+:/i;function r(n){return decodeURI(n).replace(a,"").replace(o,"")}function s(n){return l.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function p(n){if(s(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",o=r(n);return i.test(o)?n:o+".html"+t}function m(n,e){const t=n.hash,o=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(o&&t!==o)return!1;return r(n.path)===r(e)}function u(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const o=e.split("/");t&&o[o.length-1]||o.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?o.pop():"."!==e&&o.push(e)}""!==o[0]&&o.unshift("");return o.join("/")}(e,t));const a=r(e);for(let e=0;e<n.length;e++)if(r(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:o,themeConfig:i}=t,l=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||l.sidebar||i.sidebar))return f(n);const r=l.sidebar||i.sidebar;if(r){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,r);return"auto"===a?f(n):a?a.map(n=>function n(e,t,a,o=1){if("string"==typeof e)return u(t,e,a);if(Array.isArray(e))return Object.assign(u(t,e[0],a),{title:e[1]});{o>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(u(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,o+1)),collapsable:!1!==e.collapsable}}}(n,o,t)):[]}return[]}function f(n){const e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function v(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function w(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function E(n,e){return w(e)-w(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var a=t(28),o=t(32),i=t(33),l=t(128),r=t(130),s=t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)})),c=!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}();a({target:"Array",proto:!0,arity:1,forced:s||c},{push:function(n){var e=o(this),t=i(e),a=arguments.length;r(t+a);for(var s=0;s<a;s++)e[t]=arguments[s],t++;return l(e,t),t}})},function(n,e,t){var a=t(16),o=t(147),i=t(148),l=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":l&&l in Object(n)?o(n):i(n)}},function(n,e,t){var a=t(7).Symbol;n.exports=a},function(n,e,t){var a=t(5),o=t(65),i=t(99),l=t(27),r=t(55),s=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(l(n),e=r(e),l(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(l(n),e=r(e),l(t),o)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw s("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(4),o=a({}.toString),i=a("".slice);n.exports=function(n){return i(o(n),8,-1)}},function(n,e,t){var a=t(2),o=t(1),i=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(5),o=t(17),i=t(35);n.exports=a?function(n,e,t){return o.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(152),o=t(153),i=t(154),l=t(155),r=t(156);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=o,s.prototype.get=i,s.prototype.has=l,s.prototype.set=r,n.exports=s},function(n,e,t){var a=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(11)(Object,"create");n.exports=a},function(n,e,t){var a=t(174);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(45);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,a.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(a.barSelector),d=a.speed,p=a.easing;return s.offsetWidth,l((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),r(c,function(n,e,t){var o;return(o="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,o}(n,d,p)),1===n?(r(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){r(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var o,l=e.querySelector(a.barSelector),s=n?"-100":i(t.status||0),d=document.querySelector(a.parent);return r(l,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),a.showSpinner||(o=e.querySelector(a.spinnerSelector))&&m(o),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&m(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var l=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),r=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,o=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((a=n[o]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,o,i=arguments;if(2==i.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&a(n,t,o);else a(n,i[1],i[2])}}();function s(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),a=t+e;s(t,e)||(n.className=a.substring(1))}function d(n,e){var t,a=p(n);s(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function m(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=o)},function(n,e,t){var a=t(10),o=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(o(n)+" is not an object")}},function(n,e,t){var a=t(2),o=t(52).f,i=t(20),l=t(111),r=t(37),s=t(66),c=t(124);n.exports=function(n,e){var t,d,p,m,u,h=n.target,f=n.global,v=n.stat;if(t=f?a:v?a[h]||r(h,{}):(a[h]||{}).prototype)for(d in e){if(m=e[d],p=n.dontCallGetSet?(u=o(t,d))&&u.value:t[d],!c(f?d:h+(v?".":"#")+d,n.forced)&&void 0!==p){if(typeof m==typeof p)continue;s(m,p)}(n.sham||p&&p.sham)&&i(m,"sham",!0),l(t,d,m,n)}}},function(n,e,t){var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(47),o=t(53);n.exports=function(n){return a(o(n))}},function(n,e,t){var a=t(2),o=t(62),i=t(9),l=t(64),r=t(60),s=t(59),c=o("wks"),d=a.Symbol,p=d&&d.for,m=s?d:d&&d.withoutSetter||l;n.exports=function(n){if(!i(c,n)||!r&&"string"!=typeof c[n]){var e="Symbol."+n;r&&i(d,n)?c[n]=d[n]:c[n]=s&&p?p(e):m(e)}return c[n]}},function(n,e,t){var a=t(53),o=Object;n.exports=function(n){return o(a(n))}},function(n,e,t){var a=t(122);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(29),o=Function.prototype.call;n.exports=a?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(2),o=t(37),i=a["__core-js_shared__"]||o("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(2),o=Object.defineProperty;n.exports=function(n,e){try{o(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(146),o=t(13),i=Object.prototype,l=i.hasOwnProperty,r=i.propertyIsEnumerable,s=a(function(){return arguments}())?a:function(n){return o(n)&&l.call(n,"callee")&&!r.call(n,"callee")};n.exports=s},function(n,e,t){var a=t(11)(t(7),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(166),o=t(173),i=t(175),l=t(176),r=t(177);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=o,s.prototype.get=i,s.prototype.has=l,s.prototype.set=r,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(6),o=t(45),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,l=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(l.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(15),o=t(13);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(4),o=t(3),i=t(18),l=Object,r=a("".split);n.exports=o((function(){return!l("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?r(n,""):l(n)}:l},function(n,e,t){var a=t(1),o=t(109),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(o(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,i=/^0o[0-7]+$/i,l=parseInt,r="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=r||s||Function("return this")(),d=Object.prototype.toString,p=Math.max,m=Math.min,u=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var r=o.test(n);return r||i.test(n)?l(n.slice(2),r?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,o,i,l,r,s,c=0,d=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,i=o;return a=o=void 0,c=e,l=n.apply(i,t)}function w(n){return c=n,r=setTimeout(x,e),d?b(n):l}function E(n){var t=n-s;return void 0===s||t>=e||t<0||v&&n-c>=i}function x(){var n=u();if(E(n))return y(n);r=setTimeout(x,function(n){var t=e-(n-s);return v?m(t,i-(n-c)):t}(n))}function y(n){return r=void 0,g&&a?b(n):(a=o=void 0,l)}function A(){var n=u(),t=E(n);if(a=arguments,o=this,s=n,t){if(void 0===r)return w(s);if(v)return r=setTimeout(x,e),b(s)}return void 0===r&&(r=setTimeout(x,e)),l}return e=f(e)||0,h(t)&&(d=!!t.leading,i=(v="maxWait"in t)?p(f(t.maxWait)||0,e):i,g="trailing"in t?!!t.trailing:g),A.cancel=function(){void 0!==r&&clearTimeout(r),c=0,a=s=o=r=void 0},A.flush=function(){return void 0===r?l:y(u())},A}},function(n,e,t){var a=t(5),o=t(34),i=t(105),l=t(35),r=t(30),s=t(55),c=t(9),d=t(65),p=Object.getOwnPropertyDescriptor;e.f=a?p:function(n,e){if(n=r(n),e=s(e),d)try{return p(n,e)}catch(n){}if(c(n,e))return l(!o(i.f,n,e),n[e])}},function(n,e,t){var a=t(54),o=TypeError;n.exports=function(n){if(a(n))throw o("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(106),o=t(57);n.exports=function(n){var e=a(n,"string");return o(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(19),o=t(1),i=t(58),l=t(59),r=Object;n.exports=l?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return o(e)&&i(e.prototype,r(n))}},function(n,e,t){var a=t(4);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(60);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(61),o=t(3);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,o,i=t(2),l=t(107),r=i.process,s=i.Deno,c=r&&r.versions||s&&s.version,d=c&&c.v8;d&&(o=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!o&&l&&(!(a=l.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=l.match(/Chrome\/(\d+)/))&&(o=+a[1]),n.exports=o},function(n,e,t){var a=t(63),o=t(36);(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.26.1",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(4),o=0,i=Math.random(),l=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+l(++o+i,36)}},function(n,e,t){var a=t(5),o=t(3),i=t(98);n.exports=!a&&!o((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(9),o=t(117),i=t(52),l=t(17);n.exports=function(n,e,t){for(var r=o(e),s=l.f,c=i.f,d=0;d<r.length;d++){var p=r[d];a(n,p)||t&&a(t,p)||s(n,p,c(e,p))}}},function(n,e,t){var a=t(121);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(4),o=t(27),i=t(134);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return o(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,o=n.length;++t<a;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(21),o=t(157),i=t(158),l=t(159),r=t(160),s=t(161);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=i,c.prototype.get=l,c.prototype.has=r,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(15),o=t(40);n.exports=function(n){if(!o(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(178),o=t(13);n.exports=function n(e,t,i,l,r){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:a(e,t,i,l,n,r))}},function(n,e,t){var a=t(77),o=t(181),i=t(78);n.exports=function(n,e,t,l,r,s){var c=1&t,d=n.length,p=e.length;if(d!=p&&!(c&&p>d))return!1;var m=s.get(n),u=s.get(e);if(m&&u)return m==e&&u==n;var h=-1,f=!0,v=2&t?new a:void 0;for(s.set(n,e),s.set(e,n);++h<d;){var g=n[h],b=e[h];if(l)var w=c?l(b,g,h,e,n,s):l(g,b,h,n,e,s);if(void 0!==w){if(w)continue;f=!1;break}if(v){if(!o(e,(function(n,e){if(!i(v,e)&&(g===n||r(g,n,t,l,s)))return v.push(e)}))){f=!1;break}}else if(g!==b&&!r(g,b,t,l,s)){f=!1;break}}return s.delete(n),s.delete(e),f}},function(n,e,t){var a=t(41),o=t(179),i=t(180);function l(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}l.prototype.add=l.prototype.push=o,l.prototype.has=i,n.exports=l},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(191),o=t(197),i=t(83);n.exports=function(n){return i(n)?a(n):o(n)}},function(n,e,t){(function(n){var a=t(7),o=t(193),i=e&&!e.nodeType&&e,l=i&&"object"==typeof n&&n&&!n.nodeType&&n,r=l&&l.exports===i?a.Buffer:void 0,s=(r?r.isBuffer:void 0)||o;n.exports=s}).call(this,t(50)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(194),o=t(195),i=t(196),l=i&&i.isTypedArray,r=l?o(l):a;n.exports=r},function(n,e,t){var a=t(73),o=t(43);n.exports=function(n){return null!=n&&o(n.length)&&!a(n)}},function(n,e,t){var a=t(11)(t(7),"Set");n.exports=a},function(n,e,t){var a=t(40);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(88),o=t(25);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[o(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(6),o=t(44),i=t(208),l=t(211);n.exports=function(n,e){return a(n)?n:o(n,e)?[n]:i(l(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(144),o=t(149),i=t(220),l=t(228),r=t(237),s=t(102),c=i((function(n){var e=s(n);return r(e)&&(e=void 0),l(a(n,1,r,!0),o(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,o=a.exec(t);if(!o)return t;var i="",l=0,r=0;for(l=o.index;l<t.length;l++){switch(t.charCodeAt(l)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}r!==l&&(i+=t.substring(r,l)),r=l+1,i+=e}return r!==l?i+t.substring(r,l):i}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},o=(t(240),t(8)),i=Object(o.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},o=(t(241),t(8)),i=Object(o.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(2),o=t(10),i=a.document,l=o(i)&&o(i.createElement);n.exports=function(n){return l?i.createElement(n):{}}},function(n,e,t){var a=t(5),o=t(3);n.exports=a&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(62),o=t(64),i=a("keys");n.exports=function(n){return i[n]||(i[n]=o(n))}},function(n,e,t){var a=t(4),o=t(9),i=t(30),l=t(119).indexOf,r=t(49),s=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,d=[];for(t in a)!o(r,t)&&o(a,t)&&s(d,t);for(;e.length>c;)o(a,t=e[c++])&&(~l(d,t)||s(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(246)},function(n,e,t){"use strict";var a=t(28),o=t(125).left,i=t(126),l=t(61),r=t(127);a({target:"Array",proto:!0,forced:!i("reduce")||!r&&l>79&&l<83},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,i=o&&!a.call({1:2},1);e.f=i?function(n){var e=o(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(34),o=t(10),i=t(57),l=t(108),r=t(110),s=t(31),c=TypeError,d=s("toPrimitive");n.exports=function(n,e){if(!o(n)||i(n))return n;var t,s=l(n,d);if(s){if(void 0===e&&(e="default"),t=a(s,n,e),!o(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),r(n,e)}},function(n,e,t){var a=t(19);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(48),o=t(54);n.exports=function(n,e){var t=n[e];return o(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(34),o=t(1),i=t(10),l=TypeError;n.exports=function(n,e){var t,r;if("string"===e&&o(t=n.toString)&&!i(r=a(t,n)))return r;if(o(t=n.valueOf)&&!i(r=a(t,n)))return r;if("string"!==e&&o(t=n.toString)&&!i(r=a(t,n)))return r;throw l("Can't convert object to primitive value")}},function(n,e,t){var a=t(1),o=t(17),i=t(112),l=t(37);n.exports=function(n,e,t,r){r||(r={});var s=r.enumerable,c=void 0!==r.name?r.name:e;if(a(t)&&i(t,c,r),r.global)s?n[e]=t:l(e,t);else{try{r.unsafe?n[e]&&(s=!0):delete n[e]}catch(n){}s?n[e]=t:o.f(n,e,{value:t,enumerable:!1,configurable:!r.nonConfigurable,writable:!r.nonWritable})}return n}},function(n,e,t){var a=t(3),o=t(1),i=t(9),l=t(5),r=t(113).CONFIGURABLE,s=t(114),c=t(115),d=c.enforce,p=c.get,m=Object.defineProperty,u=l&&!a((function(){return 8!==m((function(){}),"length",{value:8}).length})),h=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||r&&n.name!==e)&&(l?m(n,"name",{value:e,configurable:!0}):n.name=e),u&&t&&i(t,"arity")&&n.length!==t.arity&&m(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?l&&m(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=d(n);return i(a,"source")||(a.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return o(this)&&p(this).source||s(this)}),"toString")},function(n,e,t){var a=t(5),o=t(9),i=Function.prototype,l=a&&Object.getOwnPropertyDescriptor,r=o(i,"name"),s=r&&"something"===function(){}.name,c=r&&(!a||a&&l(i,"name").configurable);n.exports={EXISTS:r,PROPER:s,CONFIGURABLE:c}},function(n,e,t){var a=t(4),o=t(1),i=t(36),l=a(Function.toString);o(i.inspectSource)||(i.inspectSource=function(n){return l(n)}),n.exports=i.inspectSource},function(n,e,t){var a,o,i,l=t(116),r=t(2),s=t(10),c=t(20),d=t(9),p=t(36),m=t(100),u=t(49),h=r.TypeError,f=r.WeakMap;if(l||p.state){var v=p.state||(p.state=new f);v.get=v.get,v.has=v.has,v.set=v.set,a=function(n,e){if(v.has(n))throw h("Object already initialized");return e.facade=n,v.set(n,e),e},o=function(n){return v.get(n)||{}},i=function(n){return v.has(n)}}else{var g=m("state");u[g]=!0,a=function(n,e){if(d(n,g))throw h("Object already initialized");return e.facade=n,c(n,g,e),e},o=function(n){return d(n,g)?n[g]:{}},i=function(n){return d(n,g)}}n.exports={set:a,get:o,has:i,enforce:function(n){return i(n)?o(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!s(e)||(t=o(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(2),o=t(1),i=a.WeakMap;n.exports=o(i)&&/native code/.test(String(i))},function(n,e,t){var a=t(19),o=t(4),i=t(118),l=t(123),r=t(27),s=o([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(r(n)),t=l.f;return t?s(e,t(n)):e}},function(n,e,t){var a=t(101),o=t(97).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,o)}},function(n,e,t){var a=t(30),o=t(120),i=t(33),l=function(n){return function(e,t,l){var r,s=a(e),c=i(s),d=o(l,c);if(n&&t!=t){for(;c>d;)if((r=s[d++])!=r)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:l(!0),indexOf:l(!1)}},function(n,e,t){var a=t(67),o=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?o(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(67),o=Math.min;n.exports=function(n){return n>0?o(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(3),o=t(1),i=/#|\.prototype\./,l=function(n,e){var t=s[r(n)];return t==d||t!=c&&(o(e)?a(e):!!e)},r=l.normalize=function(n){return String(n).replace(i,".").toLowerCase()},s=l.data={},c=l.NATIVE="N",d=l.POLYFILL="P";n.exports=l},function(n,e,t){var a=t(48),o=t(32),i=t(47),l=t(33),r=TypeError,s=function(n){return function(e,t,s,c){a(t);var d=o(e),p=i(d),m=l(d),u=n?m-1:0,h=n?-1:1;if(s<2)for(;;){if(u in p){c=p[u],u+=h;break}if(u+=h,n?u<0:m<=u)throw r("Reduce of empty array with no initial value")}for(;n?u>=0:m>u;u+=h)u in p&&(c=t(c,p[u],u,d));return c}};n.exports={left:s(!1),right:s(!0)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(18),o=t(2);n.exports="process"==a(o.process)},function(n,e,t){"use strict";var a=t(5),o=t(129),i=TypeError,l=Object.getOwnPropertyDescriptor,r=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=r?function(n,e){if(o(n)&&!l(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(18);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(28),o=t(2),i=t(132),l=t(133),r=o.WebAssembly,s=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=l(n,e,s),a({global:!0,constructor:!0,arity:1,forced:s},t)},d=function(n,e){if(r&&r[n]){var t={};t[n]=l("WebAssembly."+n,e,s),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:s},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var a=t(29),o=Function.prototype,i=o.apply,l=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?l.bind(i):function(){return l.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(19),o=t(9),i=t(20),l=t(58),r=t(68),s=t(66),c=t(135),d=t(136),p=t(137),m=t(141),u=t(142),h=t(143),f=t(5),v=t(63);n.exports=function(n,e,t,g){var b=g?2:1,w=n.split("."),E=w[w.length-1],x=a.apply(null,w);if(x){var y=x.prototype;if(!v&&o(y,"cause")&&delete y.cause,!t)return x;var A=a("Error"),C=e((function(n,e){var t=p(g?e:n,void 0),a=g?new x(n):new x;return void 0!==t&&i(a,"message",t),h&&i(a,"stack",u(a.stack,2)),this&&l(y,this)&&d(a,this,C),arguments.length>b&&m(a,arguments[b]),a}));if(C.prototype=y,"Error"!==E?r?r(C,A):s(C,A,{name:!0}):f&&"stackTraceLimit"in x&&(c(C,x,"stackTraceLimit"),c(C,x,"prepareStackTrace")),s(C,x),!v)try{y.name!==E&&i(y,"name",E),y.constructor=C}catch(n){}return C}}},function(n,e,t){var a=t(1),o=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+o(n)+" as a prototype")}},function(n,e,t){var a=t(17).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(1),o=t(10),i=t(68);n.exports=function(n,e,t){var l,r;return i&&a(l=e.constructor)&&l!==t&&o(r=l.prototype)&&r!==t.prototype&&i(n,r),n}},function(n,e,t){var a=t(138);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(139),o=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e,t){var a=t(140),o=t(1),i=t(18),l=t(31)("toStringTag"),r=Object,s="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=r(n),l))?t:s?i(e):"Object"==(a=i(e))&&o(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(31)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(10),o=t(20);n.exports=function(n,e){a(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){var a=t(4),o=Error,i=a("".replace),l=String(o("zxcasd").stack),r=/\n\s*at [^:]*:[^\n]*/,s=r.test(l);n.exports=function(n,e){if(s&&"string"==typeof n&&!o.prepareStackTrace)for(;e--;)n=i(n,r,"");return n}},function(n,e,t){var a=t(3),o=t(35);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(69),o=t(145);n.exports=function n(e,t,i,l,r){var s=-1,c=e.length;for(i||(i=o),r||(r=[]);++s<c;){var d=e[s];t>0&&i(d)?t>1?n(d,t-1,i,l,r):a(r,d):l||(r[r.length]=d)}return r}},function(n,e,t){var a=t(16),o=t(38),i=t(6),l=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||o(n)||!!(l&&n&&n[l])}},function(n,e,t){var a=t(15),o=t(13);n.exports=function(n){return o(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(16),o=Object.prototype,i=o.hasOwnProperty,l=o.toString,r=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,r),t=n[r];try{n[r]=void 0;var a=!0}catch(n){}var o=l.call(n);return a&&(e?n[r]=t:delete n[r]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(150),o=t(206),i=t(46),l=t(6),r=t(217);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?l(n)?o(n[0],n[1]):a(n):r(n)}},function(n,e,t){var a=t(151),o=t(205),i=t(86);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(71),o=t(75);n.exports=function(n,e,t,i){var l=t.length,r=l,s=!i;if(null==n)return!r;for(n=Object(n);l--;){var c=t[l];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++l<r;){var d=(c=t[l])[0],p=n[d],m=c[1];if(s&&c[2]){if(void 0===p&&!(d in n))return!1}else{var u=new a;if(i)var h=i(p,m,d,n,e,u);if(!(void 0===h?o(m,p,3,i,u):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(22),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(22);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=this.__data__,o=a(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var a=t(21);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(21),o=t(39),i=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var l=t.__data__;if(!o||l.length<199)return l.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(l)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(73),o=t(163),i=t(40),l=t(74),r=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,p=c.hasOwnProperty,m=RegExp("^"+d.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||o(n))&&(a(n)?m:r).test(l(n))}},function(n,e,t){var a,o=t(164),i=(a=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(7)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(167),o=t(21),i=t(39);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||o),string:new a}}},function(n,e,t){var a=t(168),o=t(169),i=t(170),l=t(171),r=t(172);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}s.prototype.clear=a,s.prototype.delete=o,s.prototype.get=i,s.prototype.has=l,s.prototype.set=r,n.exports=s},function(n,e,t){var a=t(23);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(23),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(23),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var a=t(23);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(24);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(24);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(24);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(24);n.exports=function(n,e){var t=a(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var a=t(71),o=t(76),i=t(182),l=t(185),r=t(201),s=t(6),c=t(80),d=t(82),p="[object Object]",m=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,u,h,f){var v=s(n),g=s(e),b=v?"[object Array]":r(n),w=g?"[object Array]":r(e),E=(b="[object Arguments]"==b?p:b)==p,x=(w="[object Arguments]"==w?p:w)==p,y=b==w;if(y&&c(n)){if(!c(e))return!1;v=!0,E=!1}if(y&&!E)return f||(f=new a),v||d(n)?o(n,e,t,u,h,f):i(n,e,b,t,u,h,f);if(!(1&t)){var A=E&&m.call(n,"__wrapped__"),C=x&&m.call(e,"__wrapped__");if(A||C){var B=A?n.value():n,F=C?e.value():e;return f||(f=new a),h(B,F,t,u,f)}}return!!y&&(f||(f=new a),l(n,e,t,u,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(16),o=t(183),i=t(72),l=t(76),r=t(184),s=t(42),c=a?a.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,p,m){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var u=r;case"[object Set]":var h=1&a;if(u||(u=s),n.size!=e.size&&!h)return!1;var f=m.get(n);if(f)return f==e;a|=2,m.set(n,e);var v=l(u(n),u(e),a,c,p,m);return m.delete(n),v;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var a=t(7).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(186),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,l,r){var s=1&t,c=a(n),d=c.length;if(d!=a(e).length&&!s)return!1;for(var p=d;p--;){var m=c[p];if(!(s?m in e:o.call(e,m)))return!1}var u=r.get(n),h=r.get(e);if(u&&h)return u==e&&h==n;var f=!0;r.set(n,e),r.set(e,n);for(var v=s;++p<d;){var g=n[m=c[p]],b=e[m];if(i)var w=s?i(b,g,m,e,n,r):i(g,b,m,n,e,r);if(!(void 0===w?g===b||l(g,b,t,i,r):w)){f=!1;break}v||(v="constructor"==m)}if(f&&!v){var E=n.constructor,x=e.constructor;E==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof E&&E instanceof E&&"function"==typeof x&&x instanceof x||(f=!1)}return r.delete(n),r.delete(e),f}},function(n,e,t){var a=t(187),o=t(188),i=t(79);n.exports=function(n){return a(n,i,o)}},function(n,e,t){var a=t(69),o=t(6);n.exports=function(n,e,t){var i=e(n);return o(n)?i:a(i,t(n))}},function(n,e,t){var a=t(189),o=t(190),i=Object.prototype.propertyIsEnumerable,l=Object.getOwnPropertySymbols,r=l?function(n){return null==n?[]:(n=Object(n),a(l(n),(function(e){return i.call(n,e)})))}:o;n.exports=r},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,o=0,i=[];++t<a;){var l=n[t];e(l,t,n)&&(i[o++]=l)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(192),o=t(38),i=t(6),l=t(80),r=t(81),s=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),d=!t&&o(n),p=!t&&!d&&l(n),m=!t&&!d&&!p&&s(n),u=t||d||p||m,h=u?a(n.length,String):[],f=h.length;for(var v in n)!e&&!c.call(n,v)||u&&("length"==v||p&&("offset"==v||"parent"==v)||m&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||r(v,f))||h.push(v);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(15),o=t(43),i=t(13),l={};l["[object Float32Array]"]=l["[object Float64Array]"]=l["[object Int8Array]"]=l["[object Int16Array]"]=l["[object Int32Array]"]=l["[object Uint8Array]"]=l["[object Uint8ClampedArray]"]=l["[object Uint16Array]"]=l["[object Uint32Array]"]=!0,l["[object Arguments]"]=l["[object Array]"]=l["[object ArrayBuffer]"]=l["[object Boolean]"]=l["[object DataView]"]=l["[object Date]"]=l["[object Error]"]=l["[object Function]"]=l["[object Map]"]=l["[object Number]"]=l["[object Object]"]=l["[object RegExp]"]=l["[object Set]"]=l["[object String]"]=l["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&o(n.length)&&!!l[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(70),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,l=i&&i.exports===o&&a.process,r=function(){try{var n=i&&i.require&&i.require("util").types;return n||l&&l.binding&&l.binding("util")}catch(n){}}();n.exports=r}).call(this,t(50)(n))},function(n,e,t){var a=t(198),o=t(199),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return o(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(200)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(202),o=t(39),i=t(203),l=t(84),r=t(204),s=t(15),c=t(74),d=c(a),p=c(o),m=c(i),u=c(l),h=c(r),f=s;(a&&"[object DataView]"!=f(new a(new ArrayBuffer(1)))||o&&"[object Map]"!=f(new o)||i&&"[object Promise]"!=f(i.resolve())||l&&"[object Set]"!=f(new l)||r&&"[object WeakMap]"!=f(new r))&&(f=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case d:return"[object DataView]";case p:return"[object Map]";case m:return"[object Promise]";case u:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var a=t(11)(t(7),"DataView");n.exports=a},function(n,e,t){var a=t(11)(t(7),"Promise");n.exports=a},function(n,e,t){var a=t(11)(t(7),"WeakMap");n.exports=a},function(n,e,t){var a=t(85),o=t(79);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var i=e[t],l=n[i];e[t]=[i,l,a(l)]}return e}},function(n,e,t){var a=t(75),o=t(207),i=t(214),l=t(44),r=t(85),s=t(86),c=t(25);n.exports=function(n,e){return l(n)&&r(e)?s(c(n),e):function(t){var l=o(t,n);return void 0===l&&l===e?i(t,n):a(e,l,3)}}},function(n,e,t){var a=t(87);n.exports=function(n,e,t){var o=null==n?void 0:a(n,e);return void 0===o?t:o}},function(n,e,t){var a=t(209),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,l=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,a,o){e.push(a?o.replace(i,"$1"):t||n)})),e}));n.exports=l},function(n,e,t){var a=t(210);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(41);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,o=e?e.apply(this,a):a[0],i=t.cache;if(i.has(o))return i.get(o);var l=n.apply(this,a);return t.cache=i.set(o,l)||i,l};return t.cache=new(o.Cache||a),t}o.Cache=a,n.exports=o},function(n,e,t){var a=t(212);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(16),o=t(213),i=t(6),l=t(45),r=a?a.prototype:void 0,s=r?r.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return o(e,n)+"";if(l(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,o=Array(a);++t<a;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var a=t(215),o=t(216);n.exports=function(n,e){return null!=n&&o(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(88),o=t(38),i=t(6),l=t(81),r=t(43),s=t(25);n.exports=function(n,e,t){for(var c=-1,d=(e=a(e,n)).length,p=!1;++c<d;){var m=s(e[c]);if(!(p=null!=n&&t(n,m)))break;n=n[m]}return p||++c!=d?p:!!(d=null==n?0:n.length)&&r(d)&&l(m,d)&&(i(n)||o(n))}},function(n,e,t){var a=t(218),o=t(219),i=t(44),l=t(25);n.exports=function(n){return i(n)?a(l(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(87);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(46),o=t(221),i=t(223);n.exports=function(n,e){return i(o(n,e,a),n+"")}},function(n,e,t){var a=t(222),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var i=arguments,l=-1,r=o(i.length-e,0),s=Array(r);++l<r;)s[l]=i[e+l];l=-1;for(var c=Array(e+1);++l<e;)c[l]=i[l];return c[e]=t(s),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(224),o=t(227)(a);n.exports=o},function(n,e,t){var a=t(225),o=t(226),i=t(46),l=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=l},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(11),o=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var o=t(),i=16-(o-a);if(a=o,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(77),o=t(229),i=t(234),l=t(78),r=t(235),s=t(42);n.exports=function(n,e,t){var c=-1,d=o,p=n.length,m=!0,u=[],h=u;if(t)m=!1,d=i;else if(p>=200){var f=e?null:r(n);if(f)return s(f);m=!1,d=l,h=new a}else h=e?[]:u;n:for(;++c<p;){var v=n[c],g=e?e(v):v;if(v=t||0!==v?v:0,m&&g==g){for(var b=h.length;b--;)if(h[b]===g)continue n;e&&h.push(g),u.push(v)}else d(h,g,t)||(h!==u&&h.push(g),u.push(v))}return u}},function(n,e,t){var a=t(230);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(231),o=t(232),i=t(233);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,o,t)}},function(n,e){n.exports=function(n,e,t,a){for(var o=n.length,i=t+(a?1:-1);a?i--:++i<o;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,o=n.length;++a<o;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,o=null==n?0:n.length;++a<o;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(84),o=t(236),i=t(42),l=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:o;n.exports=l},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(83),o=t(13);n.exports=function(n){return o(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);var a=t(0);
/*!
  * vue-router v3.6.5
  * (c) 2022 Evan You
  * @license MIT
  */function o(n,e){for(var t in e)n[t]=e[t];return n}var i=/[!'()*]/g,l=function(n){return"%"+n.charCodeAt(0).toString(16)},r=/%2C/g,s=function(n){return encodeURIComponent(n).replace(i,l).replace(r,",")};function c(n){try{return decodeURIComponent(n)}catch(n){0}return n}var d=function(n){return null==n||"object"==typeof n?n:String(n)};function p(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=c(t.shift()),o=t.length>0?c(t.join("=")):null;void 0===e[a]?e[a]=o:Array.isArray(e[a])?e[a].push(o):e[a]=[e[a],o]})),e):e}function m(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return s(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(s(e)):a.push(s(e)+"="+s(n)))})),a.join("&")}return s(e)+"="+s(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var u=/\/?$/;function h(n,e,t,a){var o=a&&a.options.stringifyQuery,i=e.query||{};try{i=f(i)}catch(n){}var l={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:b(e,o),matched:n?g(n):[]};return t&&(l.redirectedFrom=b(t,o)),Object.freeze(l)}function f(n){if(Array.isArray(n))return n.map(f);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=f(n[t]);return e}return n}var v=h(null,{path:"/"});function g(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function b(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||m)(a)+o}function w(n,e,t){return e===v?n===e:!!e&&(n.path&&e.path?n.path.replace(u,"")===e.path.replace(u,"")&&(t||n.hash===e.hash&&E(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&E(n.query,e.query)&&E(n.params,e.params))))}function E(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,o){var i=n[t];if(a[o]!==t)return!1;var l=e[t];return null==i||null==l?i===l:"object"==typeof i&&"object"==typeof l?E(i,l):String(i)===String(l)}))}function x(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var o=t.instances[a],i=t.enteredCbs[a];if(o&&i){delete t.enteredCbs[a];for(var l=0;l<i.length;l++)o._isBeingDestroyed||i[l](o)}}}}var y={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,i=e.parent,l=e.data;l.routerView=!0;for(var r=i.$createElement,s=t.name,c=i.$route,d=i._routerViewCache||(i._routerViewCache={}),p=0,m=!1;i&&i._routerRoot!==i;){var u=i.$vnode?i.$vnode.data:{};u.routerView&&p++,u.keepAlive&&i._directInactive&&i._inactive&&(m=!0),i=i.$parent}if(l.routerViewDepth=p,m){var h=d[s],f=h&&h.component;return f?(h.configProps&&A(f,l,h.route,h.configProps),r(f,l,a)):r()}var v=c.matched[p],g=v&&v.components[s];if(!v||!g)return d[s]=null,r();d[s]={component:g},l.registerRouteInstance=function(n,e){var t=v.instances[s];(e&&t!==n||!e&&t===n)&&(v.instances[s]=e)},(l.hook||(l.hook={})).prepatch=function(n,e){v.instances[s]=e.componentInstance},l.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==v.instances[s]&&(v.instances[s]=n.componentInstance),x(c)};var b=v.props&&v.props[s];return b&&(o(d[s],{route:c,configProps:b}),A(g,l,c,b)),r(g,l,a)}};function A(n,e,t,a){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(i){i=e.props=o({},i);var l=e.attrs=e.attrs||{};for(var r in i)n.props&&r in n.props||(l[r]=i[r],delete i[r])}}function C(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var i=n.replace(/^\//,"").split("/"),l=0;l<i.length;l++){var r=i[l];".."===r?o.pop():"."!==r&&o.push(r)}return""!==o[0]&&o.unshift(""),o.join("/")}function B(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var F=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},L=R,X=N,T=function(n,e){return j(N(n,e),e)},I=j,S=H,k=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function N(n,e){for(var t,a=[],o=0,i=0,l="",r=e&&e.delimiter||"/";null!=(t=k.exec(n));){var s=t[0],c=t[1],d=t.index;if(l+=n.slice(i,d),i=d+s.length,c)l+=c[1];else{var p=n[i],m=t[2],u=t[3],h=t[4],f=t[5],v=t[6],g=t[7];l&&(a.push(l),l="");var b=null!=m&&null!=p&&p!==m,w="+"===v||"*"===v,E="?"===v||"*"===v,x=t[2]||r,y=h||f;a.push({name:u||o++,prefix:m||"",delimiter:x,optional:E,repeat:w,partial:b,asterisk:!!g,pattern:y?P(y):g?".*":"[^"+D(x)+"]+?"})}}return i<n.length&&(l+=n.substr(i)),l&&a.push(l),a}function z(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function j(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",O(e)));return function(e,a){for(var o="",i=e||{},l=(a||{}).pretty?z:encodeURIComponent,r=0;r<n.length;r++){var s=n[r];if("string"!=typeof s){var c,d=i[s.name];if(null==d){if(s.optional){s.partial&&(o+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(F(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var p=0;p<d.length;p++){if(c=l(d[p]),!t[r].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===p?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):l(d),!t[r].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');o+=s.prefix+c}}else o+=s}return o}}function D(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function P(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function _(n,e){return n.keys=e,n}function O(n){return n&&n.sensitive?"":"i"}function H(n,e,t){F(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,o=!1!==t.end,i="",l=0;l<n.length;l++){var r=n[l];if("string"==typeof r)i+=D(r);else{var s=D(r.prefix),c="(?:"+r.pattern+")";e.push(r),r.repeat&&(c+="(?:"+s+c+")*"),i+=c=r.optional?r.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=D(t.delimiter||"/"),p=i.slice(-d.length)===d;return a||(i=(p?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=o?"$":a&&p?"":"(?="+d+"|$)",_(new RegExp("^"+i,O(t)),e)}function R(n,e,t){return F(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return _(n,e)}(n,e):F(n)?function(n,e,t){for(var a=[],o=0;o<n.length;o++)a.push(R(n[o],e,t).source);return _(new RegExp("(?:"+a.join("|")+")",O(t)),e)}(n,e,t):function(n,e,t){return H(N(n,t),e,t)}(n,e,t)}L.parse=X,L.compile=T,L.tokensToFunction=I,L.tokensToRegExp=S;var U=Object.create(null);function q(n,e,t){e=e||{};try{var a=U[n]||(U[n]=L.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function M(n,e,t,a){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var l=(i=o({},n)).params;return l&&"object"==typeof l&&(i.params=o({},l)),i}if(!i.path&&i.params&&e){(i=o({},i))._normalized=!0;var r=o(o({},e.params),i.params);if(e.name)i.name=e.name,i.params=r;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=q(s,r,e.path)}else 0;return i}var c=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(i.path||""),m=e&&e.path||"/",u=c.path?C(c.path,m,t||i.append):m,h=function(n,e,t){void 0===e&&(e={});var a,o=t||p;try{a=o(n||"")}catch(n){a={}}for(var i in e){var l=e[i];a[i]=Array.isArray(l)?l.map(d):d(l)}return a}(c.query,i.query,a&&a.options.parseQuery),f=i.hash||c.hash;return f&&"#"!==f.charAt(0)&&(f="#"+f),{_normalized:!0,path:u,query:h,hash:f}}var W,Z=function(){},J={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,i=t.resolve(this.to,a,this.append),l=i.location,r=i.route,s=i.href,c={},d=t.options.linkActiveClass,p=t.options.linkExactActiveClass,m=null==d?"router-link-active":d,f=null==p?"router-link-exact-active":p,v=null==this.activeClass?m:this.activeClass,g=null==this.exactActiveClass?f:this.exactActiveClass,b=r.redirectedFrom?h(null,M(r.redirectedFrom),null,t):r;c[g]=w(a,b,this.exactPath),c[v]=this.exact||this.exactPath?c[g]:function(n,e){return 0===n.path.replace(u,"/").indexOf(e.path.replace(u,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,b);var E=c[g]?this.ariaCurrentValue:null,x=function(n){K(n)&&(e.replace?t.replace(l,Z):t.push(l,Z))},y={click:K};Array.isArray(this.event)?this.event.forEach((function(n){y[n]=x})):y[this.event]=x;var A={class:c},C=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:r,navigate:x,isActive:c[v],isExactActive:c[g]});if(C){if(1===C.length)return C[0];if(C.length>1||!C.length)return 0===C.length?n():n("span",{},C)}if("a"===this.tag)A.on=y,A.attrs={href:s,"aria-current":E};else{var B=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(B){B.isStatic=!1;var F=B.data=o({},B.data);for(var L in F.on=F.on||{},F.on){var X=F.on[L];L in y&&(F.on[L]=Array.isArray(X)?X:[X])}for(var T in y)T in F.on?F.on[T].push(y[T]):F.on[T]=x;var I=B.data.attrs=o({},B.data.attrs);I.href=s,I["aria-current"]=E}else A.on=y}return n(this.tag,A,this.$slots.default)}};function K(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var $="undefined"!=typeof window;function Q(n,e,t,a,o){var i=e||[],l=t||Object.create(null),r=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,o,i,l){var r=o.path,s=o.name;0;var c=o.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return B(e.path+"/"+n)}(r,i,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var p={path:d,regex:G(d,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:s,parent:i,matchAs:l,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var i=l?B(l+"/"+o.path):void 0;n(e,t,a,o,p,i)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==o.alias)for(var m=Array.isArray(o.alias)?o.alias:[o.alias],u=0;u<m.length;++u){0;var h={path:m[u],children:o.children};n(e,t,a,h,i,p.path||"/")}s&&(a[s]||(a[s]=p))}(i,l,r,n,o)}));for(var s=0,c=i.length;s<c;s++)"*"===i[s]&&(i.push(i.splice(s,1)[0]),c--,s--);return{pathList:i,pathMap:l,nameMap:r}}function G(n,e){return L(n,[],e)}function Y(n,e){var t=Q(n),a=t.pathList,o=t.pathMap,i=t.nameMap;function l(n,t,l){var r=M(n,t,!1,e),c=r.name;if(c){var d=i[c];if(!d)return s(null,r);var p=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof r.params&&(r.params={}),t&&"object"==typeof t.params)for(var m in t.params)!(m in r.params)&&p.indexOf(m)>-1&&(r.params[m]=t.params[m]);return r.path=q(d.path,r.params),s(d,r,l)}if(r.path){r.params={};for(var u=0;u<a.length;u++){var h=a[u],f=o[h];if(V(f.regex,r.path,r.params))return s(f,r,l)}}return s(null,r)}function r(n,t){var a=n.redirect,o="function"==typeof a?a(h(n,t,null,e)):a;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return s(null,t);var r=o,c=r.name,d=r.path,p=t.query,m=t.hash,u=t.params;if(p=r.hasOwnProperty("query")?r.query:p,m=r.hasOwnProperty("hash")?r.hash:m,u=r.hasOwnProperty("params")?r.params:u,c){i[c];return l({_normalized:!0,name:c,query:p,hash:m,params:u},void 0,t)}if(d){var f=function(n,e){return C(n,e.parent?e.parent.path:"/",!0)}(d,n);return l({_normalized:!0,path:q(f,u),query:p,hash:m},void 0,t)}return s(null,t)}function s(n,t,a){return n&&n.redirect?r(n,a||t):n&&n.matchAs?function(n,e,t){var a=l({_normalized:!0,path:q(t,e.params)});if(a){var o=a.matched,i=o[o.length-1];return e.params=a.params,s(i,e)}return s(null,e)}(0,t,n.matchAs):h(n,t,a,e)}return{match:l,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Q([e||n],a,o,i,t),t&&t.alias.length&&Q(t.alias.map((function(n){return{path:n,children:[e]}})),a,o,i,t)},getRoutes:function(){return a.map((function(n){return o[n]}))},addRoutes:function(n){Q(n,a,o,i)}}}function V(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var o=1,i=a.length;o<i;++o){var l=n.keys[o-1];l&&(t[l.name||"pathMatch"]="string"==typeof a[o]?c(a[o]):a[o])}return!0}var nn=$&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function an(){return tn}function on(n){return tn=n}var ln=Object.create(null);function rn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=o({},window.history.state);return t.key=an(),window.history.replaceState(t,"",e),window.addEventListener("popstate",dn),function(){window.removeEventListener("popstate",dn)}}function sn(n,e,t,a){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var i=function(){var n=an();if(n)return ln[n]}(),l=o.call(n,e,t,a?i:null);l&&("function"==typeof l.then?l.then((function(n){fn(n,i)})).catch((function(n){0})):fn(l,i))}))}}function cn(){var n=an();n&&(ln[n]={x:window.pageXOffset,y:window.pageYOffset})}function dn(n){cn(),n.state&&n.state.key&&on(n.state.key)}function pn(n){return un(n.x)||un(n.y)}function mn(n){return{x:un(n.x)?n.x:window.pageXOffset,y:un(n.y)?n.y:window.pageYOffset}}function un(n){return"number"==typeof n}var hn=/^#\d/;function fn(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var o=hn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(o,i={x:un((t=i).x)?t.x:0,y:un(t.y)?t.y:0})}else pn(n)&&(e=mn(n))}else a&&pn(n)&&(e=mn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var vn,gn=$&&((-1===(vn=window.navigator.userAgent).indexOf("Android 2.")&&-1===vn.indexOf("Android 4.0")||-1===vn.indexOf("Mobile Safari")||-1!==vn.indexOf("Chrome")||-1!==vn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function bn(n,e){cn();var t=window.history;try{if(e){var a=o({},t.state);a.key=an(),t.replaceState(a,"",n)}else t.pushState({key:on(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function wn(n){bn(n,!0)}var En={redirected:2,aborted:4,cancelled:8,duplicated:16};function xn(n,e){return An(n,e,En.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Cn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yn(n,e){return An(n,e,En.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function An(n,e,t,a){var o=new Error(a);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var Cn=["params","query","hash"];function Bn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Fn(n,e){return Bn(n)&&n._isRouter&&(null==e||n.type===e)}function Ln(n,e,t){var a=function(o){o>=n.length?t():n[o]?e(n[o],(function(){a(o+1)})):a(o+1)};a(0)}function Xn(n){return function(e,t,a){var o=!1,i=0,l=null;Tn(n,(function(n,e,t,r){if("function"==typeof n&&void 0===n.cid){o=!0,i++;var s,c=kn((function(e){var o;((o=e).__esModule||Sn&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:W.extend(e),t.components[r]=e,--i<=0&&a()})),d=kn((function(n){var e="Failed to resolve async component "+r+": "+n;l||(l=Bn(n)?n:new Error(e),a(l))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var p=s.component;p&&"function"==typeof p.then&&p.then(c,d)}}})),o||a()}}function Tn(n,e){return In(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function In(n){return Array.prototype.concat.apply([],n)}var Sn="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function kn(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Nn=function(n,e){this.router=n,this.base=function(n){if(!n)if($){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=v,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function zn(n,e,t,a){var o=Tn(n,(function(n,a,o,i){var l=function(n,e){"function"!=typeof n&&(n=W.extend(n));return n.options[e]}(n,e);if(l)return Array.isArray(l)?l.map((function(n){return t(n,a,o,i)})):t(l,a,o,i)}));return In(a?o.reverse():o)}function jn(n,e){if(e)return function(){return n.apply(e,arguments)}}Nn.prototype.listen=function(n){this.cb=n},Nn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Nn.prototype.onError=function(n){this.errorCbs.push(n)},Nn.prototype.transitionTo=function(n,e,t){var a,o=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){o.updateRoute(a),e&&e(a),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(a,i)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!o.ready&&(Fn(n,En.redirected)&&i===v||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},Nn.prototype.confirmTransition=function(n,e,t){var a=this,o=this.current;this.pending=n;var i,l,r=function(n){!Fn(n)&&Bn(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=o.matched.length-1;if(w(n,o)&&s===c&&n.matched[s]===o.matched[c])return this.ensureURL(),n.hash&&sn(this.router,o,n,!1),r(((l=An(i=o,n,En.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",l));var d=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=d.updated,m=d.deactivated,u=d.activated,h=[].concat(function(n){return zn(n,"beforeRouteLeave",jn,!0)}(m),this.router.beforeHooks,function(n){return zn(n,"beforeRouteUpdate",jn)}(p),u.map((function(n){return n.beforeEnter})),Xn(u)),f=function(e,t){if(a.pending!==n)return r(yn(o,n));try{e(n,o,(function(e){!1===e?(a.ensureURL(!0),r(function(n,e){return An(n,e,En.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):Bn(e)?(a.ensureURL(!0),r(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(r(xn(o,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){r(n)}};Ln(h,f,(function(){Ln(function(n){return zn(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,o,i){return n(a,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(u).concat(a.router.resolveHooks),f,(function(){if(a.pending!==n)return r(yn(o,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){x(n)}))}))}))},Nn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Nn.prototype.setupListeners=function(){},Nn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=v,this.pending=null};var Dn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Pn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=gn&&t;a&&this.listeners.push(rn());var o=function(){var t=n.current,o=Pn(n.base);n.current===v&&o===n._startLocation||n.transitionTo(o,(function(n){a&&sn(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,o=this.current;this.transitionTo(n,(function(n){bn(B(a.base+n.fullPath)),sn(a.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,o=this.current;this.transitionTo(n,(function(n){wn(B(a.base+n.fullPath)),sn(a.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Pn(this.base)!==this.current.fullPath){var e=B(this.base+this.current.fullPath);n?bn(e):wn(e)}},e.prototype.getCurrentLocation=function(){return Pn(this.base)},e}(Nn);function Pn(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(B(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var _n=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Pn(n);if(!/^\/#/.test(e))return window.location.replace(B(n+"/#"+e)),!0}(this.base)||On()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=gn&&e;t&&this.listeners.push(rn());var a=function(){var e=n.current;On()&&n.transitionTo(Hn(),(function(a){t&&sn(n.router,a,e,!0),gn||qn(a.fullPath)}))},o=gn?"popstate":"hashchange";window.addEventListener(o,a),this.listeners.push((function(){window.removeEventListener(o,a)}))}},e.prototype.push=function(n,e,t){var a=this,o=this.current;this.transitionTo(n,(function(n){Un(n.fullPath),sn(a.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,o=this.current;this.transitionTo(n,(function(n){qn(n.fullPath),sn(a.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Hn()!==e&&(n?Un(e):qn(e))},e.prototype.getCurrentLocation=function(){return Hn()},e}(Nn);function On(){var n=Hn();return"/"===n.charAt(0)||(qn("/"+n),!1)}function Hn(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Rn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Un(n){gn?bn(Rn(n)):window.location.hash=n}function qn(n){gn?wn(Rn(n)):window.location.replace(Rn(n))}var Mn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){Fn(n,En.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Nn),Wn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Y(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!gn&&!1!==n.fallback,this.fallback&&(e="hash"),$||(e="abstract"),this.mode=e,e){case"history":this.history=new Dn(this,n.base);break;case"hash":this.history=new _n(this,n.base,this.fallback);break;case"abstract":this.history=new Mn(this,n.base);break;default:0}},Zn={currentRoute:{configurable:!0}};Wn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Zn.currentRoute.get=function(){return this.history&&this.history.current},Wn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Dn||t instanceof _n){var a=function(n){t.setupListeners(),function(n){var a=t.current,o=e.options.scrollBehavior;gn&&o&&"fullPath"in n&&sn(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Wn.prototype.beforeEach=function(n){return Kn(this.beforeHooks,n)},Wn.prototype.beforeResolve=function(n){return Kn(this.resolveHooks,n)},Wn.prototype.afterEach=function(n){return Kn(this.afterHooks,n)},Wn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Wn.prototype.onError=function(n){this.history.onError(n)},Wn.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Wn.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Wn.prototype.go=function(n){this.history.go(n)},Wn.prototype.back=function(){this.go(-1)},Wn.prototype.forward=function(){this.go(1)},Wn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Wn.prototype.resolve=function(n,e,t){var a=M(n,e=e||this.history.current,t,this),o=this.match(a,e),i=o.redirectedFrom||o.fullPath;return{location:a,route:o,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?B(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:o}},Wn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Wn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==v&&this.history.transitionTo(this.history.getCurrentLocation())},Wn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==v&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Wn.prototype,Zn);var Jn=Wn;function Kn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Wn.install=function n(e){if(!n.installed||W!==e){n.installed=!0,W=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",y),e.component("RouterLink",J);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},Wn.version="3.6.5",Wn.isNavigationFailure=Fn,Wn.NavigationFailureType=En,Wn.START_LOCATION=v,$&&window.Vue&&window.Vue.use(Wn);t(104);t(14),t(131);var $n={NotFound:()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,469)),Layout:()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,468))},Qn={"v-6396017e":()=>t.e(9).then(t.bind(null,471)),"v-784de8c4":()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,472)),"v-da1df29a":()=>t.e(12).then(t.bind(null,473)),"v-4119261a":()=>t.e(10).then(t.bind(null,474)),"v-74a4f0e5":()=>t.e(11).then(t.bind(null,475)),"v-10b2fb62":()=>t.e(14).then(t.bind(null,476)),"v-7d89a885":()=>t.e(13).then(t.bind(null,477)),"v-64008660":()=>t.e(16).then(t.bind(null,478)),"v-4fa2d74e":()=>t.e(18).then(t.bind(null,479)),"v-b316b3ca":()=>t.e(19).then(t.bind(null,480)),"v-f415f82a":()=>t.e(17).then(t.bind(null,481)),"v-816334e8":()=>t.e(15).then(t.bind(null,482)),"v-8c9751b4":()=>t.e(20).then(t.bind(null,483)),"v-73b71fee":()=>t.e(21).then(t.bind(null,484)),"v-06a73ca4":()=>t.e(23).then(t.bind(null,485)),"v-28ee3436":()=>t.e(22).then(t.bind(null,486)),"v-8b088f8e":()=>t.e(24).then(t.bind(null,487)),"v-abbd7ec8":()=>t.e(25).then(t.bind(null,488)),"v-1822b90e":()=>t.e(26).then(t.bind(null,489)),"v-4e84c0e3":()=>t.e(27).then(t.bind(null,490)),"v-af74883a":()=>t.e(29).then(t.bind(null,491)),"v-dd188c24":()=>t.e(30).then(t.bind(null,492)),"v-0dcffefe":()=>t.e(28).then(t.bind(null,493)),"v-1506da02":()=>t.e(32).then(t.bind(null,494)),"v-55b0e3c4":()=>t.e(31).then(t.bind(null,495)),"v-1dffa9d7":()=>t.e(33).then(t.bind(null,496)),"v-f4a518ac":()=>t.e(34).then(t.bind(null,497)),"v-a5710d10":()=>t.e(35).then(t.bind(null,498)),"v-8ba74128":()=>t.e(36).then(t.bind(null,499)),"v-7955259c":()=>t.e(37).then(t.bind(null,500)),"v-20415b54":()=>t.e(38).then(t.bind(null,501)),"v-e067da7e":()=>t.e(41).then(t.bind(null,502)),"v-9b96d50a":()=>t.e(39).then(t.bind(null,503)),"v-0ac95c8f":()=>t.e(40).then(t.bind(null,504)),"v-013aca90":()=>t.e(42).then(t.bind(null,505)),"v-38b0ef02":()=>t.e(43).then(t.bind(null,506)),"v-fb57a1fe":()=>t.e(44).then(t.bind(null,507)),"v-b6fbb606":()=>t.e(46).then(t.bind(null,508)),"v-644c1664":()=>t.e(47).then(t.bind(null,509)),"v-6a15ff77":()=>t.e(45).then(t.bind(null,510)),"v-060c75b8":()=>t.e(48).then(t.bind(null,511)),"v-75b7ef26":()=>t.e(49).then(t.bind(null,512)),"v-7dd444d7":()=>t.e(50).then(t.bind(null,513)),"v-6823ac97":()=>t.e(51).then(t.bind(null,514)),"v-6e0c9def":()=>t.e(52).then(t.bind(null,515)),"v-91b16664":()=>t.e(53).then(t.bind(null,516)),"v-679dde1e":()=>t.e(55).then(t.bind(null,517)),"v-1b8a9604":()=>t.e(56).then(t.bind(null,518)),"v-3856a03d":()=>t.e(54).then(t.bind(null,519)),"v-2af994e8":()=>t.e(57).then(t.bind(null,520)),"v-7c7541bf":()=>t.e(58).then(t.bind(null,521)),"v-7c35f060":()=>t.e(59).then(t.bind(null,522)),"v-10e549cd":()=>t.e(60).then(t.bind(null,523)),"v-2afc8f15":()=>t.e(62).then(t.bind(null,524)),"v-108d3743":()=>t.e(61).then(t.bind(null,525)),"v-8aa45958":()=>t.e(63).then(t.bind(null,526)),"v-51d49431":()=>t.e(64).then(t.bind(null,527)),"v-f6731782":()=>t.e(66).then(t.bind(null,528)),"v-eca5b5e8":()=>t.e(67).then(t.bind(null,529)),"v-184bd5cb":()=>t.e(65).then(t.bind(null,530)),"v-42def230":()=>t.e(68).then(t.bind(null,531)),"v-64d81acc":()=>t.e(69).then(t.bind(null,532)),"v-013d839a":()=>t.e(70).then(t.bind(null,533)),"v-09fb6ac2":()=>t.e(72).then(t.bind(null,534)),"v-4b84ca42":()=>t.e(73).then(t.bind(null,535)),"v-59a98c42":()=>t.e(71).then(t.bind(null,536)),"v-25df2f08":()=>t.e(74).then(t.bind(null,537)),"v-e98a58fc":()=>t.e(75).then(t.bind(null,538)),"v-5f974606":()=>t.e(76).then(t.bind(null,539)),"v-516cdc82":()=>t.e(78).then(t.bind(null,540)),"v-410b3c24":()=>t.e(77).then(t.bind(null,541)),"v-dfbe432c":()=>t.e(80).then(t.bind(null,542)),"v-a3cae70c":()=>t.e(79).then(t.bind(null,543)),"v-2e126258":()=>t.e(81).then(t.bind(null,544)),"v-2dc6750e":()=>t.e(82).then(t.bind(null,545)),"v-2972917a":()=>t.e(84).then(t.bind(null,546)),"v-a2e02dc6":()=>t.e(83).then(t.bind(null,547)),"v-c370ebdc":()=>t.e(85).then(t.bind(null,548)),"v-ac912cf0":()=>t.e(86).then(t.bind(null,549)),"v-5f9481d8":()=>t.e(87).then(t.bind(null,550)),"v-67644772":()=>t.e(88).then(t.bind(null,551)),"v-5c54cd7e":()=>t.e(90).then(t.bind(null,552)),"v-7347303e":()=>t.e(89).then(t.bind(null,553)),"v-432c3864":()=>t.e(91).then(t.bind(null,554)),"v-d76fa88e":()=>t.e(94).then(t.bind(null,555)),"v-31e646a2":()=>t.e(93).then(t.bind(null,556)),"v-0dc67eba":()=>t.e(92).then(t.bind(null,557)),"v-3c44b12e":()=>t.e(95).then(t.bind(null,558)),"v-9ef5bc66":()=>t.e(96).then(t.bind(null,559)),"v-dc09fe22":()=>t.e(98).then(t.bind(null,560)),"v-184ed96b":()=>t.e(99).then(t.bind(null,561)),"v-710f7ada":()=>t.e(100).then(t.bind(null,562)),"v-16f910af":()=>t.e(97).then(t.bind(null,563)),"v-11ba52b0":()=>t.e(101).then(t.bind(null,564)),"v-400c1155":()=>t.e(102).then(t.bind(null,565)),"v-dc55cd76":()=>t.e(103).then(t.bind(null,566)),"v-34701b02":()=>t.e(105).then(t.bind(null,567)),"v-3877a216":()=>t.e(104).then(t.bind(null,568)),"v-030d45c2":()=>t.e(106).then(t.bind(null,569)),"v-74a1d3c8":()=>t.e(107).then(t.bind(null,570)),"v-c5f9b436":()=>t.e(108).then(t.bind(null,571)),"v-3ae6687c":()=>t.e(109).then(t.bind(null,572)),"v-3c9903ea":()=>t.e(111).then(t.bind(null,573)),"v-795f1111":()=>t.e(110).then(t.bind(null,574)),"v-5f43eff4":()=>t.e(112).then(t.bind(null,575)),"v-551685fc":()=>t.e(113).then(t.bind(null,576)),"v-d6b6ac36":()=>t.e(116).then(t.bind(null,577)),"v-dad72f28":()=>t.e(114).then(t.bind(null,578)),"v-4445c84e":()=>t.e(115).then(t.bind(null,579)),"v-aa97e0f4":()=>t.e(117).then(t.bind(null,580)),"v-558d1a18":()=>t.e(119).then(t.bind(null,581)),"v-4a7ed459":()=>t.e(118).then(t.bind(null,582)),"v-21bc4e62":()=>t.e(121).then(t.bind(null,583)),"v-14193918":()=>t.e(120).then(t.bind(null,584)),"v-1232ba9a":()=>t.e(122).then(t.bind(null,585)),"v-523e15a6":()=>t.e(123).then(t.bind(null,586)),"v-3df23b4c":()=>t.e(126).then(t.bind(null,587)),"v-08a52da4":()=>t.e(125).then(t.bind(null,588)),"v-36b7bba2":()=>t.e(124).then(t.bind(null,589)),"v-412981e5":()=>t.e(127).then(t.bind(null,590)),"v-9ed471fa":()=>t.e(128).then(t.bind(null,591)),"v-3cd6d033":()=>t.e(131).then(t.bind(null,592)),"v-da72d61a":()=>t.e(130).then(t.bind(null,593)),"v-09959741":()=>t.e(129).then(t.bind(null,594)),"v-2a18f085":()=>t.e(132).then(t.bind(null,595)),"v-21ea24e2":()=>t.e(133).then(t.bind(null,596)),"v-da2d04e8":()=>t.e(134).then(t.bind(null,597)),"v-c118e040":()=>t.e(135).then(t.bind(null,598)),"v-e9d43e64":()=>t.e(137).then(t.bind(null,599)),"v-7d2fe52a":()=>t.e(136).then(t.bind(null,600)),"v-2b9660ca":()=>t.e(138).then(t.bind(null,601)),"v-0516feb4":()=>t.e(139).then(t.bind(null,602)),"v-09e49989":()=>t.e(140).then(t.bind(null,603)),"v-53af0494":()=>t.e(141).then(t.bind(null,604)),"v-ac32a9a4":()=>t.e(142).then(t.bind(null,605)),"v-575b8a1c":()=>t.e(144).then(t.bind(null,606)),"v-42670b79":()=>t.e(145).then(t.bind(null,607)),"v-67b601b9":()=>t.e(143).then(t.bind(null,608)),"v-0c9eca63":()=>t.e(146).then(t.bind(null,609)),"v-0a4f2a01":()=>t.e(147).then(t.bind(null,610)),"v-c418353a":()=>t.e(148).then(t.bind(null,611)),"v-23b79988":()=>t.e(149).then(t.bind(null,612)),"v-5d63701c":()=>t.e(150).then(t.bind(null,613)),"v-2c906cbe":()=>t.e(151).then(t.bind(null,614)),"v-2f5f0498":()=>t.e(153).then(t.bind(null,615)),"v-2edf2a5e":()=>t.e(154).then(t.bind(null,616)),"v-60631a33":()=>t.e(152).then(t.bind(null,617)),"v-34546ad2":()=>t.e(156).then(t.bind(null,618)),"v-44ace19e":()=>t.e(155).then(t.bind(null,619)),"v-728de3bf":()=>t.e(159).then(t.bind(null,620)),"v-d15e277e":()=>t.e(160).then(t.bind(null,621)),"v-170e5d3c":()=>t.e(157).then(t.bind(null,622)),"v-129c0d43":()=>t.e(158).then(t.bind(null,623)),"v-06e77438":()=>t.e(161).then(t.bind(null,624)),"v-11d57881":()=>t.e(163).then(t.bind(null,625)),"v-034193f0":()=>t.e(164).then(t.bind(null,626)),"v-1a462536":()=>t.e(162).then(t.bind(null,627)),"v-6b3ab58c":()=>t.e(166).then(t.bind(null,628)),"v-0cd16e12":()=>t.e(165).then(t.bind(null,629)),"v-03922cfd":()=>t.e(167).then(t.bind(null,630)),"v-4e239d24":()=>t.e(169).then(t.bind(null,631)),"v-95142338":()=>t.e(168).then(t.bind(null,632)),"v-164de06d":()=>t.e(170).then(t.bind(null,633)),"v-6203c652":()=>t.e(171).then(t.bind(null,634)),"v-5c3dc76f":()=>t.e(173).then(t.bind(null,635)),"v-8d64f6d2":()=>t.e(172).then(t.bind(null,636)),"v-6ce21664":()=>t.e(174).then(t.bind(null,637)),"v-21994c86":()=>t.e(175).then(t.bind(null,638)),"v-2df23e04":()=>t.e(177).then(t.bind(null,639)),"v-1e7a979e":()=>t.e(176).then(t.bind(null,640)),"v-3bad0d8c":()=>t.e(178).then(t.bind(null,641)),"v-78c1c150":()=>t.e(180).then(t.bind(null,642)),"v-64c1cc82":()=>t.e(179).then(t.bind(null,643)),"v-620f21cd":()=>t.e(181).then(t.bind(null,644)),"v-2391217a":()=>t.e(182).then(t.bind(null,645)),"v-78db2895":()=>t.e(183).then(t.bind(null,646)),"v-59824782":()=>t.e(185).then(t.bind(null,647)),"v-088c6cd4":()=>t.e(184).then(t.bind(null,648)),"v-67575d0c":()=>t.e(186).then(t.bind(null,649)),"v-878a8230":()=>t.e(187).then(t.bind(null,650)),"v-340ada9a":()=>t.e(188).then(t.bind(null,651)),"v-e23af09a":()=>t.e(189).then(t.bind(null,652)),"v-2b553a7c":()=>t.e(191).then(t.bind(null,653)),"v-d328377c":()=>t.e(190).then(t.bind(null,654)),"v-7a115242":()=>t.e(192).then(t.bind(null,655)),"v-bed8d4b8":()=>t.e(196).then(t.bind(null,656)),"v-625a0ef0":()=>t.e(193).then(t.bind(null,657)),"v-7005a8fc":()=>t.e(194).then(t.bind(null,658)),"v-cc8680f4":()=>t.e(195).then(t.bind(null,659)),"v-d457f70c":()=>t.e(197).then(t.bind(null,660)),"v-6e38866a":()=>t.e(198).then(t.bind(null,661)),"v-608c3a58":()=>t.e(199).then(t.bind(null,662)),"v-789e0ef9":()=>t.e(200).then(t.bind(null,663)),"v-7c5f3212":()=>t.e(201).then(t.bind(null,664)),"v-02709772":()=>t.e(204).then(t.bind(null,665)),"v-16638950":()=>t.e(203).then(t.bind(null,666)),"v-479d7cf0":()=>t.e(202).then(t.bind(null,667)),"v-5b00a83e":()=>t.e(205).then(t.bind(null,668)),"v-6ebc757e":()=>t.e(206).then(t.bind(null,669)),"v-6ac251e4":()=>t.e(207).then(t.bind(null,670)),"v-4790ead5":()=>t.e(210).then(t.bind(null,671)),"v-0c1bcada":()=>t.e(208).then(t.bind(null,672)),"v-e746dfb0":()=>t.e(209).then(t.bind(null,673)),"v-cd4c1a76":()=>t.e(211).then(t.bind(null,674)),"v-3ffc7b96":()=>t.e(212).then(t.bind(null,675)),"v-3bf4f482":()=>t.e(213).then(t.bind(null,676)),"v-7c26ad48":()=>t.e(215).then(t.bind(null,677)),"v-dae2e17c":()=>t.e(214).then(t.bind(null,678)),"v-2bdcb57c":()=>t.e(217).then(t.bind(null,679)),"v-fe382ade":()=>t.e(218).then(t.bind(null,680)),"v-2b032de5":()=>t.e(216).then(t.bind(null,681)),"v-dce50a5c":()=>t.e(221).then(t.bind(null,682)),"v-48593528":()=>t.e(219).then(t.bind(null,683)),"v-585191b8":()=>t.e(220).then(t.bind(null,684)),"v-cbcd7c28":()=>t.e(222).then(t.bind(null,685)),"v-4bcaa1ce":()=>t.e(223).then(t.bind(null,686)),"v-ea0f0df4":()=>t.e(225).then(t.bind(null,687)),"v-4bffc44e":()=>t.e(226).then(t.bind(null,688)),"v-c7acf936":()=>t.e(224).then(t.bind(null,689)),"v-f516a618":()=>t.e(228).then(t.bind(null,690)),"v-26634af4":()=>t.e(227).then(t.bind(null,691)),"v-9213f03c":()=>t.e(229).then(t.bind(null,692)),"v-311061b4":()=>t.e(231).then(t.bind(null,693)),"v-b12717cc":()=>t.e(230).then(t.bind(null,694)),"v-52828b4c":()=>t.e(234).then(t.bind(null,695)),"v-27ae08a2":()=>t.e(232).then(t.bind(null,696)),"v-ab917da4":()=>t.e(233).then(t.bind(null,697)),"v-198329e5":()=>t.e(235).then(t.bind(null,698)),"v-63e8ef03":()=>t.e(236).then(t.bind(null,699)),"v-44f62f41":()=>t.e(237).then(t.bind(null,700)),"v-3286cc9a":()=>t.e(239).then(t.bind(null,701)),"v-52af8ef6":()=>t.e(240).then(t.bind(null,702)),"v-4619bcf3":()=>t.e(238).then(t.bind(null,703)),"v-4a32cd40":()=>t.e(243).then(t.bind(null,704)),"v-6684958c":()=>t.e(242).then(t.bind(null,705)),"v-33214e62":()=>t.e(241).then(t.bind(null,706)),"v-4134aa26":()=>t.e(247).then(t.bind(null,707)),"v-f93a7194":()=>t.e(249).then(t.bind(null,708)),"v-2df4f91b":()=>t.e(246).then(t.bind(null,709)),"v-4da4c309":()=>t.e(248).then(t.bind(null,710)),"v-5720f4ae":()=>t.e(250).then(t.bind(null,711)),"v-72ee2b64":()=>t.e(245).then(t.bind(null,712)),"v-14f04b39":()=>t.e(251).then(t.bind(null,713)),"v-0495d39c":()=>t.e(252).then(t.bind(null,714)),"v-6a8e583a":()=>t.e(254).then(t.bind(null,715)),"v-0649d22a":()=>t.e(244).then(t.bind(null,716)),"v-1b865381":()=>t.e(255).then(t.bind(null,717)),"v-de41190e":()=>t.e(253).then(t.bind(null,718)),"v-998e39f0":()=>t.e(257).then(t.bind(null,719)),"v-d8bbe23a":()=>t.e(256).then(t.bind(null,720)),"v-66880172":()=>t.e(258).then(t.bind(null,721)),"v-07c11cbe":()=>t.e(259).then(t.bind(null,722)),"v-ee1a7b9a":()=>t.e(260).then(t.bind(null,723)),"v-28e1b734":()=>t.e(261).then(t.bind(null,724)),"v-028dfb44":()=>t.e(262).then(t.bind(null,725)),"v-c096ecc4":()=>t.e(263).then(t.bind(null,726)),"v-0e6c4db8":()=>t.e(266).then(t.bind(null,727)),"v-c254747e":()=>t.e(265).then(t.bind(null,728)),"v-020f2d3f":()=>t.e(264).then(t.bind(null,729)),"v-21cafeb6":()=>t.e(267).then(t.bind(null,730)),"v-bd527bfe":()=>t.e(268).then(t.bind(null,731)),"v-da7a4520":()=>t.e(269).then(t.bind(null,732)),"v-59e3eeba":()=>t.e(271).then(t.bind(null,733)),"v-edcedb12":()=>t.e(270).then(t.bind(null,734)),"v-62a234fd":()=>t.e(272).then(t.bind(null,735)),"v-c16515b8":()=>t.e(274).then(t.bind(null,736)),"v-069fc664":()=>t.e(273).then(t.bind(null,737)),"v-2027f4d7":()=>t.e(276).then(t.bind(null,738)),"v-6777b86d":()=>t.e(275).then(t.bind(null,739)),"v-0a775c97":()=>t.e(277).then(t.bind(null,740)),"v-4a6ef0ef":()=>t.e(278).then(t.bind(null,741)),"v-4812c664":()=>t.e(279).then(t.bind(null,742)),"v-55515dc4":()=>t.e(281).then(t.bind(null,743)),"v-4059e604":()=>t.e(282).then(t.bind(null,744)),"v-b3dfd986":()=>t.e(280).then(t.bind(null,745)),"v-e65234e8":()=>t.e(283).then(t.bind(null,746)),"v-1ec8f1bf":()=>t.e(284).then(t.bind(null,747)),"v-998e0c66":()=>t.e(286).then(t.bind(null,748)),"v-2f9e7ad0":()=>t.e(285).then(t.bind(null,749)),"v-728c7bd6":()=>t.e(288).then(t.bind(null,750)),"v-566b0654":()=>t.e(289).then(t.bind(null,751)),"v-21b7443f":()=>t.e(290).then(t.bind(null,752)),"v-683cb17a":()=>t.e(287).then(t.bind(null,753)),"v-4501950c":()=>t.e(291).then(t.bind(null,754)),"v-cafc7acc":()=>t.e(293).then(t.bind(null,755)),"v-cc361230":()=>t.e(292).then(t.bind(null,756)),"v-4c3a5f6c":()=>t.e(294).then(t.bind(null,757)),"v-53e924a7":()=>t.e(295).then(t.bind(null,758)),"v-3ea3508a":()=>t.e(296).then(t.bind(null,759)),"v-d9f3db50":()=>t.e(297).then(t.bind(null,760)),"v-081f5879":()=>t.e(299).then(t.bind(null,761)),"v-70ba750c":()=>t.e(298).then(t.bind(null,762)),"v-5a76da12":()=>t.e(300).then(t.bind(null,763)),"v-ebf01650":()=>t.e(302).then(t.bind(null,764)),"v-31418c47":()=>t.e(303).then(t.bind(null,765)),"v-7c2126fd":()=>t.e(304).then(t.bind(null,766)),"v-0eab1988":()=>t.e(301).then(t.bind(null,767)),"v-2c6bf293":()=>t.e(305).then(t.bind(null,768)),"v-219649a8":()=>t.e(306).then(t.bind(null,769)),"v-be426776":()=>t.e(308).then(t.bind(null,770)),"v-01f634c7":()=>t.e(307).then(t.bind(null,771)),"v-4379ce02":()=>t.e(310).then(t.bind(null,772)),"v-47815516":()=>t.e(309).then(t.bind(null,773)),"v-220fd8c2":()=>t.e(311).then(t.bind(null,774)),"v-8df99436":()=>t.e(312).then(t.bind(null,775)),"v-1cd3027c":()=>t.e(313).then(t.bind(null,776)),"v-ef2e77de":()=>t.e(314).then(t.bind(null,777)),"v-1f8d82d2":()=>t.e(315).then(t.bind(null,778)),"v-534f7b4e":()=>t.e(316).then(t.bind(null,779)),"v-6b3ce286":()=>t.e(318).then(t.bind(null,780)),"v-69816759":()=>t.e(319).then(t.bind(null,781)),"v-778d22f4":()=>t.e(320).then(t.bind(null,782)),"v-b8a34636":()=>t.e(317).then(t.bind(null,783)),"v-3ca62d9a":()=>t.e(322).then(t.bind(null,784)),"v-4c2fc162":()=>t.e(321).then(t.bind(null,785)),"v-7cb188a6":()=>t.e(323).then(t.bind(null,786)),"v-58c1192e":()=>t.e(325).then(t.bind(null,787)),"v-18a455a2":()=>t.e(324).then(t.bind(null,788)),"v-173c1703":()=>t.e(328).then(t.bind(null,789)),"v-1c465c36":()=>t.e(327).then(t.bind(null,790)),"v-6712db4c":()=>t.e(326).then(t.bind(null,791)),"v-1ca17a9a":()=>t.e(330).then(t.bind(null,792)),"v-7f5f767c":()=>t.e(331).then(t.bind(null,793)),"v-2d84a4c2":()=>t.e(332).then(t.bind(null,794)),"v-efb3dfca":()=>t.e(329).then(t.bind(null,795)),"v-22ef70cc":()=>t.e(334).then(t.bind(null,796)),"v-078be602":()=>t.e(333).then(t.bind(null,797)),"v-14b837d0":()=>t.e(336).then(t.bind(null,798)),"v-402e1f5b":()=>t.e(335).then(t.bind(null,799)),"v-27124f30":()=>t.e(338).then(t.bind(null,800)),"v-050f5b36":()=>t.e(337).then(t.bind(null,801)),"v-2e12cd9d":()=>t.e(340).then(t.bind(null,802)),"v-6685dc6a":()=>t.e(341).then(t.bind(null,803)),"v-43114340":()=>t.e(339).then(t.bind(null,804)),"v-23aeb7c2":()=>t.e(344).then(t.bind(null,805)),"v-e76eefa2":()=>t.e(342).then(t.bind(null,806)),"v-2eb8bbff":()=>t.e(343).then(t.bind(null,807)),"v-09f8dec5":()=>t.e(345).then(t.bind(null,808)),"v-a93c3458":()=>t.e(346).then(t.bind(null,809)),"v-36e19ec4":()=>t.e(347).then(t.bind(null,810)),"v-795964ca":()=>t.e(348).then(t.bind(null,811)),"v-21f0ea1a":()=>t.e(349).then(t.bind(null,812)),"v-c777c758":()=>t.e(351).then(t.bind(null,813)),"v-524263f0":()=>t.e(352).then(t.bind(null,814)),"v-6def73d0":()=>t.e(350).then(t.bind(null,815)),"v-554071f5":()=>t.e(353).then(t.bind(null,816)),"v-3950d9a7":()=>t.e(354).then(t.bind(null,817)),"v-440b5bb0":()=>t.e(355).then(t.bind(null,818)),"v-1b6941c6":()=>t.e(357).then(t.bind(null,819)),"v-4cfdd4d2":()=>t.e(356).then(t.bind(null,820)),"v-0edc713a":()=>t.e(358).then(t.bind(null,821)),"v-67317150":()=>t.e(360).then(t.bind(null,822)),"v-21f94fdd":()=>t.e(361).then(t.bind(null,823)),"v-354ec439":()=>t.e(359).then(t.bind(null,824)),"v-56d7f860":()=>t.e(363).then(t.bind(null,825)),"v-680d383a":()=>t.e(364).then(t.bind(null,826)),"v-53b4cc2a":()=>t.e(362).then(t.bind(null,827)),"v-9475cda2":()=>t.e(366).then(t.bind(null,828)),"v-6f0f39a6":()=>t.e(365).then(t.bind(null,829)),"v-91354242":()=>t.e(367).then(t.bind(null,830)),"v-8642e540":()=>t.e(369).then(t.bind(null,831)),"v-7731e1d0":()=>t.e(368).then(t.bind(null,832)),"v-2142b61a":()=>t.e(370).then(t.bind(null,833)),"v-a9fc73ae":()=>t.e(371).then(t.bind(null,834)),"v-b6f05fdc":()=>t.e(372).then(t.bind(null,835)),"v-170cb6af":()=>t.e(373).then(t.bind(null,836)),"v-3fc46a1b":()=>t.e(374).then(t.bind(null,837)),"v-5d4d5890":()=>t.e(376).then(t.bind(null,838)),"v-41af40b2":()=>t.e(375).then(t.bind(null,839)),"v-4eb00f52":()=>t.e(377).then(t.bind(null,840)),"v-3fa50058":()=>t.e(378).then(t.bind(null,841)),"v-04e73544":()=>t.e(381).then(t.bind(null,842)),"v-13087c82":()=>t.e(379).then(t.bind(null,843)),"v-a6e7c306":()=>t.e(382).then(t.bind(null,844)),"v-169395d6":()=>t.e(380).then(t.bind(null,845)),"v-098d1892":()=>t.e(383).then(t.bind(null,846)),"v-d7fb7712":()=>t.e(385).then(t.bind(null,847)),"v-5846da0c":()=>t.e(386).then(t.bind(null,848)),"v-25e08f44":()=>t.e(384).then(t.bind(null,849)),"v-025b9304":()=>t.e(387).then(t.bind(null,850)),"v-ffa44e3a":()=>t.e(389).then(t.bind(null,851)),"v-69f60b1c":()=>t.e(388).then(t.bind(null,852)),"v-10f0512d":()=>t.e(390).then(t.bind(null,853)),"v-75fc0eca":()=>t.e(392).then(t.bind(null,854)),"v-21e11e33":()=>t.e(391).then(t.bind(null,855)),"v-18ac2dc6":()=>t.e(395).then(t.bind(null,856)),"v-1c718c24":()=>t.e(394).then(t.bind(null,857)),"v-40e52047":()=>t.e(393).then(t.bind(null,858)),"v-46a8dc7a":()=>t.e(396).then(t.bind(null,859)),"v-0cadd811":()=>t.e(397).then(t.bind(null,860)),"v-253500a4":()=>t.e(398).then(t.bind(null,861)),"v-7b67b75f":()=>t.e(399).then(t.bind(null,862)),"v-7526d598":()=>t.e(400).then(t.bind(null,863)),"v-df4a91a0":()=>t.e(401).then(t.bind(null,864)),"v-4b48812e":()=>t.e(402).then(t.bind(null,865)),"v-4d862e92":()=>t.e(403).then(t.bind(null,866)),"v-3b3b3795":()=>t.e(404).then(t.bind(null,867)),"v-4027c910":()=>t.e(405).then(t.bind(null,868)),"v-73a75c4c":()=>t.e(406).then(t.bind(null,869)),"v-7a595d3c":()=>t.e(407).then(t.bind(null,870)),"v-29f3fb6c":()=>t.e(408).then(t.bind(null,871)),"v-0d8f95bb":()=>t.e(409).then(t.bind(null,872)),"v-3aec6ce4":()=>t.e(410).then(t.bind(null,873)),"v-21afc496":()=>t.e(411).then(t.bind(null,874)),"v-65d1f9ad":()=>t.e(412).then(t.bind(null,875)),"v-c10bbfe2":()=>t.e(413).then(t.bind(null,876)),"v-55f81e62":()=>t.e(414).then(t.bind(null,877)),"v-3dc1ade7":()=>t.e(415).then(t.bind(null,878)),"v-4c728b76":()=>t.e(416).then(t.bind(null,879)),"v-4e3584bf":()=>t.e(418).then(t.bind(null,880)),"v-7f801c82":()=>t.e(417).then(t.bind(null,881)),"v-74eae88c":()=>t.e(419).then(t.bind(null,882)),"v-476157ca":()=>t.e(420).then(t.bind(null,883)),"v-dc75ce50":()=>t.e(421).then(t.bind(null,884)),"v-ccccf1b6":()=>t.e(422).then(t.bind(null,885)),"v-6fb5ca28":()=>t.e(423).then(t.bind(null,886)),"v-61b65020":()=>t.e(424).then(t.bind(null,887)),"v-9d5c8146":()=>t.e(425).then(t.bind(null,888)),"v-0433e063":()=>t.e(427).then(t.bind(null,889)),"v-2c7663ac":()=>t.e(426).then(t.bind(null,890)),"v-30dcc1bf":()=>t.e(428).then(t.bind(null,891)),"v-07cee6df":()=>t.e(429).then(t.bind(null,892)),"v-2086a185":()=>t.e(430).then(t.bind(null,893)),"v-70666594":()=>t.e(431).then(t.bind(null,894)),"v-62b15ff8":()=>t.e(432).then(t.bind(null,895)),"v-c273b4aa":()=>t.e(433).then(t.bind(null,896)),"v-9f99f032":()=>t.e(435).then(t.bind(null,897)),"v-3eb52555":()=>t.e(434).then(t.bind(null,898)),"v-54dc8068":()=>t.e(436).then(t.bind(null,899)),"v-755d6911":()=>t.e(438).then(t.bind(null,900)),"v-783ff9dc":()=>t.e(437).then(t.bind(null,901)),"v-23c101de":()=>t.e(439).then(t.bind(null,902)),"v-b6bf8cf8":()=>t.e(440).then(t.bind(null,903)),"v-c7f4ccd2":()=>t.e(441).then(t.bind(null,904)),"v-cef6ce3e":()=>t.e(442).then(t.bind(null,905)),"v-4135901f":()=>t.e(443).then(t.bind(null,906)),"v-4e374058":()=>t.e(444).then(t.bind(null,907)),"v-1d622864":()=>t.e(446).then(t.bind(null,908)),"v-7b0dfbdd":()=>t.e(447).then(t.bind(null,909)),"v-7d329ecf":()=>t.e(449).then(t.bind(null,910)),"v-2e580152":()=>t.e(448).then(t.bind(null,911)),"v-47a4ff94":()=>t.e(445).then(t.bind(null,912)),"v-6425d832":()=>t.e(450).then(t.bind(null,913)),"v-7fc3f010":()=>t.e(451).then(t.bind(null,914)),"v-5093508b":()=>t.e(452).then(t.bind(null,915)),"v-5076b136":()=>t.e(454).then(t.bind(null,916)),"v-1d9bb488":()=>t.e(453).then(t.bind(null,917)),"v-5713db61":()=>t.e(457).then(t.bind(null,918)),"v-2a88920a":()=>t.e(455).then(t.bind(null,919)),"v-cabfb2d2":()=>t.e(456).then(t.bind(null,920)),"v-ece90370":()=>t.e(458).then(t.bind(null,921)),"v-14a2d8cc":()=>t.e(459).then(t.bind(null,922)),"v-3be426db":()=>t.e(461).then(t.bind(null,923)),"v-3c536be7":()=>t.e(460).then(t.bind(null,924)),"v-68a9682e":()=>t.e(462).then(t.bind(null,925)),"v-0bad5c3a":()=>t.e(464).then(t.bind(null,926)),"v-11410945":()=>t.e(465).then(t.bind(null,927)),"v-e0e347f4":()=>t.e(463).then(t.bind(null,928)),"v-1b6c34c2":()=>t.e(467).then(t.bind(null,929)),"v-c7d1a238":()=>t.e(466).then(t.bind(null,930)),"v-6c007330":()=>t.e(468).then(t.bind(null,931)),"v-513deda9":()=>t.e(470).then(t.bind(null,932)),"v-073ce570":()=>t.e(469).then(t.bind(null,933)),"v-4d06295c":()=>t.e(471).then(t.bind(null,934)),"v-5df2031a":()=>t.e(474).then(t.bind(null,935)),"v-003fb755":()=>t.e(472).then(t.bind(null,936)),"v-fa6898ec":()=>t.e(476).then(t.bind(null,937)),"v-1033fec4":()=>t.e(473).then(t.bind(null,938)),"v-f71c780a":()=>t.e(477).then(t.bind(null,939)),"v-121f0e7c":()=>t.e(475).then(t.bind(null,940)),"v-df54096c":()=>t.e(478).then(t.bind(null,941)),"v-7537d280":()=>t.e(481).then(t.bind(null,942)),"v-d0b41b10":()=>t.e(482).then(t.bind(null,943)),"v-6e38463e":()=>t.e(479).then(t.bind(null,944)),"v-28e6e97a":()=>t.e(480).then(t.bind(null,945)),"v-b6cb569e":()=>t.e(484).then(t.bind(null,946)),"v-dd9b6e5c":()=>t.e(487).then(t.bind(null,947)),"v-392abc59":()=>t.e(483).then(t.bind(null,948)),"v-3a9e92c8":()=>t.e(485).then(t.bind(null,949)),"v-16d7e605":()=>t.e(486).then(t.bind(null,950)),"v-04a8ea25":()=>t.e(489).then(t.bind(null,951)),"v-b5fc8b30":()=>t.e(488).then(t.bind(null,952)),"v-7f0c511c":()=>t.e(490).then(t.bind(null,953)),"v-64da3635":()=>t.e(491).then(t.bind(null,954)),"v-5e9bd66a":()=>t.e(493).then(t.bind(null,955)),"v-62977c2d":()=>t.e(492).then(t.bind(null,956)),"v-3144e437":()=>t.e(494).then(t.bind(null,957)),"v-44799627":()=>t.e(495).then(t.bind(null,958)),"v-1ef5f67a":()=>t.e(498).then(t.bind(null,959)),"v-3e2ff606":()=>t.e(496).then(t.bind(null,960)),"v-3d3e29c6":()=>t.e(497).then(t.bind(null,961)),"v-70cdd20a":()=>t.e(502).then(t.bind(null,962)),"v-966ef4de":()=>t.e(501).then(t.bind(null,963)),"v-268cceea":()=>t.e(500).then(t.bind(null,964)),"v-b353778c":()=>t.e(499).then(t.bind(null,965)),"v-a37aca76":()=>t.e(505).then(t.bind(null,966)),"v-bff5a9be":()=>t.e(507).then(t.bind(null,967)),"v-549e4cb6":()=>t.e(503).then(t.bind(null,968)),"v-81fe0ba2":()=>t.e(504).then(t.bind(null,969)),"v-eaf4644a":()=>t.e(506).then(t.bind(null,970)),"v-59a5790e":()=>t.e(509).then(t.bind(null,971)),"v-3164109e":()=>t.e(508).then(t.bind(null,972)),"v-22de3825":()=>t.e(510).then(t.bind(null,973)),"v-706f6f58":()=>t.e(512).then(t.bind(null,974)),"v-14aed509":()=>t.e(511).then(t.bind(null,975)),"v-ddcfc118":()=>t.e(513).then(t.bind(null,976)),"v-3b6e0af2":()=>t.e(517).then(t.bind(null,977)),"v-67ee27c8":()=>t.e(514).then(t.bind(null,978)),"v-57a40646":()=>t.e(515).then(t.bind(null,979)),"v-235f254c":()=>t.e(516).then(t.bind(null,980)),"v-cdd68b34":()=>t.e(518).then(t.bind(null,981)),"v-54b99ca9":()=>t.e(520).then(t.bind(null,982)),"v-696430cb":()=>t.e(522).then(t.bind(null,983)),"v-c5da7924":()=>t.e(519).then(t.bind(null,984)),"v-16b5c4e2":()=>t.e(523).then(t.bind(null,985)),"v-52983ae0":()=>t.e(521).then(t.bind(null,986)),"v-4a680961":()=>t.e(526).then(t.bind(null,987)),"v-15448875":()=>t.e(525).then(t.bind(null,988)),"v-5729ccfc":()=>t.e(524).then(t.bind(null,989)),"v-c063c074":()=>t.e(527).then(t.bind(null,990)),"v-8f248be2":()=>t.e(528).then(t.bind(null,991)),"v-5f412447":()=>t.e(530).then(t.bind(null,992)),"v-a44aed54":()=>t.e(529).then(t.bind(null,993)),"v-72e418fb":()=>t.e(531).then(t.bind(null,994)),"v-436fb586":()=>t.e(532).then(t.bind(null,995)),"v-415eb07f":()=>t.e(533).then(t.bind(null,996)),"v-0d1d299e":()=>t.e(535).then(t.bind(null,997)),"v-64a7d354":()=>t.e(536).then(t.bind(null,998)),"v-79399e30":()=>t.e(534).then(t.bind(null,999)),"v-461d0c53":()=>t.e(537).then(t.bind(null,1e3)),"v-12d6b6e0":()=>t.e(538).then(t.bind(null,1001)),"v-667a2bb6":()=>t.e(539).then(t.bind(null,1002)),"v-e1cf439a":()=>t.e(540).then(t.bind(null,1003)),"v-71a27340":()=>t.e(541).then(t.bind(null,1004)),"v-cd30b37a":()=>t.e(542).then(t.bind(null,1005)),"v-7dae1c3b":()=>t.e(543).then(t.bind(null,1006)),"v-16c02276":()=>t.e(545).then(t.bind(null,1007)),"v-707b5938":()=>t.e(544).then(t.bind(null,1008)),"v-67f50c3a":()=>t.e(546).then(t.bind(null,1009)),"v-677bc6ea":()=>t.e(547).then(t.bind(null,1010)),"v-78a45fb6":()=>t.e(550).then(t.bind(null,1011)),"v-3ab104de":()=>t.e(548).then(t.bind(null,1012)),"v-ed90420a":()=>t.e(549).then(t.bind(null,1013)),"v-c780dd76":()=>t.e(552).then(t.bind(null,1014)),"v-7e9380af":()=>t.e(551).then(t.bind(null,1015)),"v-44e111c4":()=>t.e(554).then(t.bind(null,1016)),"v-3e17b9be":()=>t.e(553).then(t.bind(null,1017)),"v-c23e6ee8":()=>t.e(555).then(t.bind(null,1018)),"v-ed31df58":()=>t.e(557).then(t.bind(null,1019)),"v-5364c5ee":()=>t.e(556).then(t.bind(null,1020)),"v-55eb1e48":()=>t.e(559).then(t.bind(null,1021)),"v-ceda0374":()=>t.e(560).then(t.bind(null,1022)),"v-52b6e774":()=>t.e(558).then(t.bind(null,1023)),"v-05e65a1c":()=>t.e(561).then(t.bind(null,1024)),"v-493e29ee":()=>t.e(562).then(t.bind(null,1025)),"v-2b02f8cb":()=>t.e(565).then(t.bind(null,1026)),"v-42b69329":()=>t.e(563).then(t.bind(null,1027)),"v-04b2bb62":()=>t.e(566).then(t.bind(null,1028)),"v-18c894fc":()=>t.e(567).then(t.bind(null,1029)),"v-cf5aaae0":()=>t.e(564).then(t.bind(null,1030)),"v-5b6866c4":()=>t.e(569).then(t.bind(null,1031)),"v-f3b66e04":()=>t.e(568).then(t.bind(null,1032)),"v-1f6947c6":()=>t.e(570).then(t.bind(null,1033)),"v-83585ee2":()=>t.e(571).then(t.bind(null,1034)),"v-1ba304f4":()=>t.e(575).then(t.bind(null,1035)),"v-20dfec47":()=>t.e(573).then(t.bind(null,1036)),"v-24597525":()=>t.e(578).then(t.bind(null,1037)),"v-2d75b156":()=>t.e(572).then(t.bind(null,1038)),"v-b0e29e0a":()=>t.e(574).then(t.bind(null,1039)),"v-d3947202":()=>t.e(576).then(t.bind(null,1040)),"v-0d95a0b6":()=>t.e(579).then(t.bind(null,1041)),"v-f495d4f6":()=>t.e(577).then(t.bind(null,1042)),"v-719004fe":()=>t.e(580).then(t.bind(null,1043)),"v-1c3744ee":()=>t.e(582).then(t.bind(null,1044)),"v-46e3a4f6":()=>t.e(581).then(t.bind(null,1045)),"v-1c90bd91":()=>t.e(584).then(t.bind(null,1046)),"v-073a8d8d":()=>t.e(583).then(t.bind(null,1047)),"v-99f89dde":()=>t.e(586).then(t.bind(null,1048)),"v-c4a4fde6":()=>t.e(585).then(t.bind(null,1049)),"v-6f4c3dd6":()=>t.e(587).then(t.bind(null,1050)),"v-a3bac3ca":()=>t.e(588).then(t.bind(null,1051)),"v-4a5cd6c1":()=>t.e(590).then(t.bind(null,1052)),"v-e34b70da":()=>t.e(589).then(t.bind(null,1053)),"v-009820c9":()=>t.e(591).then(t.bind(null,1054)),"v-a3023f2a":()=>t.e(594).then(t.bind(null,1055)),"v-2b4480d1":()=>t.e(593).then(t.bind(null,1056)),"v-15ee50cd":()=>t.e(592).then(t.bind(null,1057)),"v-56ca45aa":()=>t.e(595).then(t.bind(null,1058)),"v-0a924c2a":()=>t.e(596).then(t.bind(null,1059)),"v-20d2d6ab":()=>t.e(597).then(t.bind(null,1060)),"v-46eed36b":()=>t.e(598).then(t.bind(null,1061)),"v-27cad9cb":()=>t.e(599).then(t.bind(null,1062)),"v-1f450a8b":()=>t.e(600).then(t.bind(null,1063)),"v-1daaa968":()=>t.e(603).then(t.bind(null,1064)),"v-636d5f18":()=>t.e(601).then(t.bind(null,1065)),"v-0b1d72b6":()=>t.e(604).then(t.bind(null,1066)),"v-49473fe3":()=>t.e(605).then(t.bind(null,1067)),"v-59ace5bb":()=>t.e(606).then(t.bind(null,1068)),"v-df9b805c":()=>t.e(602).then(t.bind(null,1069)),"v-4c31868e":()=>t.e(607).then(t.bind(null,1070)),"v-5a2193b7":()=>t.e(609).then(t.bind(null,1071)),"v-66788692":()=>t.e(610).then(t.bind(null,1072)),"v-0276baae":()=>t.e(611).then(t.bind(null,1073)),"v-7ddee6a8":()=>t.e(612).then(t.bind(null,1074)),"v-fe3c68fe":()=>t.e(608).then(t.bind(null,1075)),"v-53f8d4bb":()=>t.e(613).then(t.bind(null,1076)),"v-b83e32ac":()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,1077)),"v-2619eb8a":()=>t.e(614).then(t.bind(null,1078)),"v-a9f0e71a":()=>t.e(615).then(t.bind(null,1079))};function Gn(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Yn=/-(\w)/g,Vn=Gn(n=>n.replace(Yn,(n,e)=>e?e.toUpperCase():"")),ne=/\B([A-Z])/g,ee=Gn(n=>n.replace(ne,"-$1").toLowerCase()),te=Gn(n=>n.charAt(0).toUpperCase()+n.slice(1));function ae(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(te(Vn(e))):n(te(e))||n(ee(e))}const oe=Object.assign({},$n,Qn),ie=n=>oe[n],le=n=>Qn[n],re=n=>$n[n],se=n=>a.default.component(n);function ce(n){return ae(le,n)}function de(n){return ae(re,n)}function pe(n){return ae(ie,n)}function me(n){return ae(se,n)}function ue(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!me(n)&&pe(n)){const e=await pe(n)();a.default.component(n,e.default)}}))}function he(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var fe=t(93),ve=t.n(fe),ge=t(94),be=t.n(ge),we={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${be()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=xe(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ye(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ve()([{name:"description",content:this.$description}],n,this.siteMeta,Ae)},updateCanonicalLink(){Ee(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",xe(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ye(null,this.currentMetaTags),Ee()}};function Ee(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function xe(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ye(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Ae(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Ce=t(51),Be={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Ce)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],l=e[n+1],r=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!l||t<l.parentElement.offsetTop-10),s=decodeURIComponent(this.$route.hash);if(r&&s!==decodeURIComponent(i.hash)){const t=i;if(o===a)for(let t=n+1;t<e.length;t++)if(s===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Fe=t(26),Le=t.n(Fe),Xe={mounted(){Le.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||a.default.component(n.name)||Le.a.start(),t()}),this.$router.afterEach(()=>{Le.a.done(),this.isSidebarOpen=!1})}};t(238),t(239);class Te{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Ie={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Te).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&a.firstChild?a.insertBefore(o,a.firstChild):a.appendChild(o),o.styleSheet?o.styleSheet.cssText=n:o.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Se={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ke={},Ne=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},ze=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Se[n]},je=function n(e,t,a){var o=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))o[n]=t[n];else{var e=n.replace("data","");o.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;o.appendChild(n(t,a,i))})),o},De=function(n,e,t){var a,o=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==o.length||t?o:o[0]},Pe=function(n,e){var t,a,o=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),l=n.match(/<script>([\s\S]+)<\/script>/),r={css:o&&o[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:l&&l[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};r.htmlTpl=Ne(r.html),r.jsTpl=(t=r.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),r.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),o=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](o);return i.template=e,i}(r.js,r.html);var s=ze("vue");return r.jsLib.unshift(s),r},_e=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),l={css:a&&a[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return l.htmlTpl=l.html,l.jsTpl=l.js,l.script=(t=l.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),l},Oe=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function He(){var n=De(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=De(n,"vuepress-plugin-demo-block__code"),t=De(n,"vuepress-plugin-demo-block__display"),a=De(n,"vuepress-plugin-demo-block__footer"),o=De(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),l=decodeURIComponent(n.dataset.config),r=decodeURIComponent(n.dataset.type);l=l?JSON.parse(l):{};var s=e.querySelector("div").clientHeight,c="react"===r?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),o=new Function("return ".concat(a))(),i={js:o,css:o.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Oe(n),htmlTpl:Ne("")},l=ze("react"),r=ze("reactDOM");return i.jsLib.unshift(l,r),i}(i,l):"vanilla"===r?_e(i,l):Pe(i,l),d=je("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",Re.bind(null,d,s,e,a)),ze("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,o=n.jsLib,i=n.cssLib,l=o.concat(i).concat(ze("cssLib")).concat(ze("jsLib")).join(",");return je("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:l}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),ze("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,o=n.jsLib,i=n.cssLib,l=JSON.stringify({css:e,html:t,js:a,js_external:o.concat(ze("jsLib")).join(";"),css_external:i.concat(ze("cssLib")).join(";"),layout:ze("codepenLayout"),js_pre_processor:ze("codepenJsProcessor"),editors:ze("codepenEditors")});return je("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:l}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==l.horizontal?l.horizontal:ze("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!ke[n]){var e=je("style",{innerHTML:n});document.body.appendChild(e),ke[n]=!0}}(c.css),"react"===r)ReactDOM.render(React.createElement(c.js),o);else if("vue"===r){var m=(new(Vue.extend(c.script))).$mount();o.appendChild(m.$el)}else"vanilla"===r&&(o.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){He()}),300)}function Re(n,e,t,a){var o="1"!==n.dataset.isExpand;t.style.height=o?"".concat(e,"px"):0,o?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=o?"1":"0"}var Ue={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},He()},updated:function(){He()}},qe="auto",Me="zoom-in",We="zoom-out",Ze="grab",Je="move";function Ke(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o={passive:!1};a?n.addEventListener(e,t,o):n.removeEventListener(e,t,o)}function $e(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Qe(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ge(n,e,t){!function(n){var e=Ye,t=Ve;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var o=n.transform;delete n.transform,n[t]=o}}(e);var a=n.style,o={};for(var i in e)t&&(o[i]=a[i]||""),a[i]=e[i];return o}var Ye="transition",Ve="transform",nt="transform",et="transitionend";var tt=function(){},at={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:tt,onClose:tt,onGrab:tt,onMove:tt,onRelease:tt,onBeforeOpen:tt,onBeforeClose:tt,onBeforeGrab:tt,onBeforeRelease:tt,onImageLoading:tt,onImageLoaded:tt},ot={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),lt(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,o=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(o)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(it(n)&&!lt(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){it(n)&&!lt(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function it(n){return 0===n.button}function lt(n){return n.metaKey||n.ctrlKey}var rt={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ge(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ke(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ge(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},st="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ct=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),dt=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},pt={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Qe(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,o=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ze:We,transition:nt+"\n        "+a+"s\n        "+o,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ge(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ge(this.el,{transform:"none"})},grab:function(n,e,t){var a=mt(),o=a.x-n,i=a.y-e;Ge(this.el,{cursor:Je,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=mt(),o=a.x-n,i=a.y-e;Ge(this.el,{transition:nt,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ge(this.el,this.styleClose)},restoreOpenStyle:function(){Ge(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=mt(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,o=a.customSize,i=a.scaleBase;if(!o&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(o&&"object"===(void 0===o?"undefined":st(o)))return{x:o.width/this.rect.width,y:o.height/this.rect.height};var l=this.rect.width/2,r=this.rect.height/2,s=mt(),c={x:s.x-l,y:s.y-r},d=c.x/l,p=c.y/r,m=i+Math.min(d,p);if(o&&"string"==typeof o){var u=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(o)*u/(100*this.rect.width),v=parseFloat(o)*h/(100*this.rect.height);if(m>f||m>v)return{x:f,y:v}}return{x:m,y:m}}};function mt(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function ut(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Ke(n,a,e[a],t)}))}var ht=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(pt),this.overlay=Object.create(rt),this.handler=Object.create(ot),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=dt({},at,e),this.overlay.init(this),this.handler.init(this)}return ct(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Me,Ke(n,"click",this.handler.click),this.options.preloadImage&&$e(Qe(n)));return this}},{key:"config",value:function(n){return n?(dt(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var o=this.target.srcOriginal;null!=o&&(this.options.onImageLoading(a),$e(o,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ke(document,"scroll",this.handler.scroll),Ke(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ke(window,"resize",this.handler.resizeWindow);var i=function n(){Ke(a,et,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&ut(document,e.handler,!0),t(a)};return Ke(a,et,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=qe,this.overlay.fadeOut(),this.target.zoomOut(),Ke(document,"scroll",this.handler.scroll,!1),Ke(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ke(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Ke(t,et,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&ut(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ke(t,et,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var o=this.target.el;this.options.onBeforeGrab(o),this.released=!1,this.target.grab(n,e,t);var i=function n(){Ke(o,et,n,!1),a(o)};return Ke(o,et,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Je,this.target.move(n,e,t);var o=this.target.el,i=function n(){Ke(o,et,n,!1),a(o)};return Ke(o,et,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=qe,this.target.restoreOpenStyle();var a=function a(){Ke(t,et,a,!1),n.lock=!1,n.released=!0,e(t)};return Ke(t,et,a),this}}}]),n}();const ft=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),vt=Number("500");class gt{constructor(){this.instance=new ht(ft)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=vt){setTimeout(()=>this.update(n),e)}}var bt=[we,Be,Xe,Ie,Ue,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new gt,this.$vuepress.zooming.updateDelay()}}],wt={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return he("layout",n),a.default.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Et=t(8),xt=Object(Et.a)(wt,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(xt,"mixins",bt);const yt=[{name:"v-6396017e",path:"/pages/5816c5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6396017e").then(t)}},{path:"/pages/5816c5/index.html",redirect:"/pages/5816c5/"},{path:"/07.v2.12.X文档/010.LiteFlow简介.html",redirect:"/pages/5816c5/"},{name:"v-784de8c4",path:"/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-784de8c4").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-da1df29a",path:"/pages/7cf080/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-da1df29a").then(t)}},{path:"/pages/7cf080/index.html",redirect:"/pages/7cf080/"},{path:"/07.v2.12.X文档/021.🧁环境支持/010.JDK支持度.html",redirect:"/pages/7cf080/"},{name:"v-4119261a",path:"/pages/724bc3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4119261a").then(t)}},{path:"/pages/724bc3/index.html",redirect:"/pages/724bc3/"},{path:"/07.v2.12.X文档/020.项目特性.html",redirect:"/pages/724bc3/"},{name:"v-74a4f0e5",path:"/pages/c1a488/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-74a4f0e5").then(t)}},{path:"/pages/c1a488/index.html",redirect:"/pages/c1a488/"},{path:"/07.v2.12.X文档/021.🧁环境支持/005.环境支持说明.html",redirect:"/pages/c1a488/"},{name:"v-10b2fb62",path:"/pages/2d12db/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-10b2fb62").then(t)}},{path:"/pages/2d12db/index.html",redirect:"/pages/2d12db/"},{path:"/07.v2.12.X文档/021.🧁环境支持/030.Spring的支持度.html",redirect:"/pages/2d12db/"},{name:"v-7d89a885",path:"/pages/891e0f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7d89a885").then(t)}},{path:"/pages/891e0f/index.html",redirect:"/pages/891e0f/"},{path:"/07.v2.12.X文档/021.🧁环境支持/020.Springboot支持度.html",redirect:"/pages/891e0f/"},{name:"v-64008660",path:"/pages/df6982/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-64008660").then(t)}},{path:"/pages/df6982/index.html",redirect:"/pages/df6982/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.html",redirect:"/pages/df6982/"},{name:"v-4fa2d74e",path:"/pages/9f4489/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4fa2d74e").then(t)}},{path:"/pages/9f4489/index.html",redirect:"/pages/9f4489/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.html",redirect:"/pages/9f4489/"},{name:"v-b316b3ca",path:"/pages/0a4573/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b316b3ca").then(t)}},{path:"/pages/0a4573/index.html",redirect:"/pages/0a4573/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.html",redirect:"/pages/0a4573/"},{name:"v-f415f82a",path:"/pages/82ef41/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f415f82a").then(t)}},{path:"/pages/82ef41/index.html",redirect:"/pages/82ef41/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.html",redirect:"/pages/82ef41/"},{name:"v-816334e8",path:"/pages/631fa1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-816334e8").then(t)}},{path:"/pages/631fa1/index.html",redirect:"/pages/631fa1/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/005.说明.html",redirect:"/pages/631fa1/"},{name:"v-8c9751b4",path:"/pages/495f21/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8c9751b4").then(t)}},{path:"/pages/495f21/index.html",redirect:"/pages/495f21/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.html",redirect:"/pages/495f21/"},{name:"v-73b71fee",path:"/pages/0e0fb5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-73b71fee").then(t)}},{path:"/pages/0e0fb5/index.html",redirect:"/pages/0e0fb5/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.html",redirect:"/pages/0e0fb5/"},{name:"v-06a73ca4",path:"/pages/8760c4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-06a73ca4").then(t)}},{path:"/pages/8760c4/index.html",redirect:"/pages/8760c4/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.html",redirect:"/pages/8760c4/"},{name:"v-28ee3436",path:"/pages/522432/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-28ee3436").then(t)}},{path:"/pages/522432/index.html",redirect:"/pages/522432/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.html",redirect:"/pages/522432/"},{name:"v-8b088f8e",path:"/pages/249d17/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8b088f8e").then(t)}},{path:"/pages/249d17/index.html",redirect:"/pages/249d17/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.html",redirect:"/pages/249d17/"},{name:"v-abbd7ec8",path:"/pages/151524/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-abbd7ec8").then(t)}},{path:"/pages/151524/index.html",redirect:"/pages/151524/"},{path:"/07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.html",redirect:"/pages/151524/"},{name:"v-1822b90e",path:"/pages/b70ec8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1822b90e").then(t)}},{path:"/pages/b70ec8/index.html",redirect:"/pages/b70ec8/"},{path:"/07.v2.12.X文档/040.🍢配置项/010.说明.html",redirect:"/pages/b70ec8/"},{name:"v-4e84c0e3",path:"/pages/4594ec/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4e84c0e3").then(t)}},{path:"/pages/4594ec/index.html",redirect:"/pages/4594ec/"},{path:"/07.v2.12.X文档/040.🍢配置项/020.Springboot下的配置项.html",redirect:"/pages/4594ec/"},{name:"v-af74883a",path:"/pages/b5065a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-af74883a").then(t)}},{path:"/pages/b5065a/index.html",redirect:"/pages/b5065a/"},{path:"/07.v2.12.X文档/040.🍢配置项/040.其他场景代码设置配置项.html",redirect:"/pages/b5065a/"},{name:"v-dd188c24",path:"/pages/6fa87e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dd188c24").then(t)}},{path:"/pages/6fa87e/index.html",redirect:"/pages/6fa87e/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/010.规则文件格式.html",redirect:"/pages/6fa87e/"},{name:"v-0dcffefe",path:"/pages/33833a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0dcffefe").then(t)}},{path:"/pages/33833a/index.html",redirect:"/pages/33833a/"},{path:"/07.v2.12.X文档/040.🍢配置项/030.Spring下的配置项.html",redirect:"/pages/33833a/"},{name:"v-1506da02",path:"/pages/ffc345/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1506da02").then(t)}},{path:"/pages/ffc345/index.html",redirect:"/pages/ffc345/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/030.ZK规则文件配置源.html",redirect:"/pages/ffc345/"},{name:"v-55b0e3c4",path:"/pages/51ddd5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-55b0e3c4").then(t)}},{path:"/pages/51ddd5/index.html",redirect:"/pages/51ddd5/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/020.本地规则文件配置.html",redirect:"/pages/51ddd5/"},{name:"v-1dffa9d7",path:"/pages/236b4f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1dffa9d7").then(t)}},{path:"/pages/236b4f/index.html",redirect:"/pages/236b4f/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/040.SQL数据库配置源.html",redirect:"/pages/236b4f/"},{name:"v-f4a518ac",path:"/pages/09b776/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f4a518ac").then(t)}},{path:"/pages/09b776/index.html",redirect:"/pages/09b776/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/050.Nacos配置源.html",redirect:"/pages/09b776/"},{name:"v-a5710d10",path:"/pages/4bfac2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a5710d10").then(t)}},{path:"/pages/4bfac2/index.html",redirect:"/pages/4bfac2/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/060.Etcd配置源.html",redirect:"/pages/4bfac2/"},{name:"v-8ba74128",path:"/pages/bea809/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8ba74128").then(t)}},{path:"/pages/bea809/index.html",redirect:"/pages/bea809/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/065.Apollo配置源.html",redirect:"/pages/bea809/"},{name:"v-7955259c",path:"/pages/38dcf8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7955259c").then(t)}},{path:"/pages/38dcf8/index.html",redirect:"/pages/38dcf8/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/066.📑Redis配置源/010.配置说明.html",redirect:"/pages/38dcf8/"},{name:"v-20415b54",path:"/pages/186747/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-20415b54").then(t)}},{path:"/pages/186747/index.html",redirect:"/pages/186747/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/066.📑Redis配置源/020.轮询模式配置.html",redirect:"/pages/186747/"},{name:"v-e067da7e",path:"/pages/8486fb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e067da7e").then(t)}},{path:"/pages/8486fb/index.html",redirect:"/pages/8486fb/"},{path:"/07.v2.12.X文档/055.🔗常规组件/010.普通组件.html",redirect:"/pages/8486fb/"},{name:"v-9b96d50a",path:"/pages/3f553f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-9b96d50a").then(t)}},{path:"/pages/3f553f/index.html",redirect:"/pages/3f553f/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/066.📑Redis配置源/030.订阅模式配置.html",redirect:"/pages/3f553f/"},{name:"v-0ac95c8f",path:"/pages/25f2c0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0ac95c8f").then(t)}},{path:"/pages/25f2c0/index.html",redirect:"/pages/25f2c0/"},{path:"/07.v2.12.X文档/050.🗂规则以及配置源/070.自定义配置源.html",redirect:"/pages/25f2c0/"},{name:"v-013aca90",path:"/pages/c0f5d7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-013aca90").then(t)}},{path:"/pages/c0f5d7/index.html",redirect:"/pages/c0f5d7/"},{path:"/07.v2.12.X文档/055.🔗常规组件/020.选择组件.html",redirect:"/pages/c0f5d7/"},{name:"v-38b0ef02",path:"/pages/cb0b59/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-38b0ef02").then(t)}},{path:"/pages/cb0b59/index.html",redirect:"/pages/cb0b59/"},{path:"/07.v2.12.X文档/055.🔗常规组件/030.布尔组件.html",redirect:"/pages/cb0b59/"},{name:"v-fb57a1fe",path:"/pages/5f971f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-fb57a1fe").then(t)}},{path:"/pages/5f971f/index.html",redirect:"/pages/5f971f/"},{path:"/07.v2.12.X文档/055.🔗常规组件/040.次数循环组件.html",redirect:"/pages/5f971f/"},{name:"v-b6fbb606",path:"/pages/16eca9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b6fbb606").then(t)}},{path:"/pages/16eca9/index.html",redirect:"/pages/16eca9/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/010.说明.html",redirect:"/pages/16eca9/"},{name:"v-644c1664",path:"/pages/a590ee/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-644c1664").then(t)}},{path:"/pages/a590ee/index.html",redirect:"/pages/a590ee/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/020.串行编排.html",redirect:"/pages/a590ee/"},{name:"v-6a15ff77",path:"/pages/64262b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6a15ff77").then(t)}},{path:"/pages/64262b/index.html",redirect:"/pages/64262b/"},{path:"/07.v2.12.X文档/055.🔗常规组件/055.迭代循环组件.html",redirect:"/pages/64262b/"},{name:"v-060c75b8",path:"/pages/b3446a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-060c75b8").then(t)}},{path:"/pages/b3446a/index.html",redirect:"/pages/b3446a/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/030.并行编排.html",redirect:"/pages/b3446a/"},{name:"v-75b7ef26",path:"/pages/d90483/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-75b7ef26").then(t)}},{path:"/pages/d90483/index.html",redirect:"/pages/d90483/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/040.选择编排.html",redirect:"/pages/d90483/"},{name:"v-7dd444d7",path:"/pages/e76999/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7dd444d7").then(t)}},{path:"/pages/e76999/index.html",redirect:"/pages/e76999/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/045.条件编排.html",redirect:"/pages/e76999/"},{name:"v-6823ac97",path:"/pages/fbf715/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6823ac97").then(t)}},{path:"/pages/fbf715/index.html",redirect:"/pages/fbf715/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/046.循环编排.html",redirect:"/pages/fbf715/"},{name:"v-6e0c9def",path:"/pages/f53b51/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6e0c9def").then(t)}},{path:"/pages/f53b51/index.html",redirect:"/pages/f53b51/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/047.捕获异常表达式.html",redirect:"/pages/f53b51/"},{name:"v-91b16664",path:"/pages/a8b344/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-91b16664").then(t)}},{path:"/pages/a8b344/index.html",redirect:"/pages/a8b344/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/048.与或非表达式.html",redirect:"/pages/a8b344/"},{name:"v-679dde1e",path:"/pages/71ff49/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-679dde1e").then(t)}},{path:"/pages/71ff49/index.html",redirect:"/pages/71ff49/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/060.使用子变量.html",redirect:"/pages/71ff49/"},{name:"v-1b8a9604",path:"/pages/5156b3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1b8a9604").then(t)}},{path:"/pages/5156b3/index.html",redirect:"/pages/5156b3/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/070.复杂编排例子.html",redirect:"/pages/5156b3/"},{name:"v-3856a03d",path:"/pages/dc5df7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3856a03d").then(t)}},{path:"/pages/dc5df7/index.html",redirect:"/pages/dc5df7/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/050.使用子流程.html",redirect:"/pages/dc5df7/"},{name:"v-2af994e8",path:"/pages/af44a6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2af994e8").then(t)}},{path:"/pages/af44a6/index.html",redirect:"/pages/af44a6/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/080.关于分号.html",redirect:"/pages/af44a6/"},{name:"v-7c7541bf",path:"/pages/f3dc09/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7c7541bf").then(t)}},{path:"/pages/f3dc09/index.html",redirect:"/pages/f3dc09/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/090.关于注释.html",redirect:"/pages/f3dc09/"},{name:"v-7c35f060",path:"/pages/2df3d9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7c35f060").then(t)}},{path:"/pages/2df3d9/index.html",redirect:"/pages/2df3d9/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/100.组件名包装.html",redirect:"/pages/2df3d9/"},{name:"v-10e549cd",path:"/pages/395fd0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-10e549cd").then(t)}},{path:"/pages/395fd0/index.html",redirect:"/pages/395fd0/"},{path:"/07.v2.12.X文档/060.🧩EL规则的写法/110.验证规则.html",redirect:"/pages/395fd0/"},{name:"v-2afc8f15",path:"/pages/501abf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2afc8f15").then(t)}},{path:"/pages/501abf/index.html",redirect:"/pages/501abf/"},{path:"/07.v2.12.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.html",redirect:"/pages/501abf/"},{name:"v-108d3743",path:"/pages/74b4bf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-108d3743").then(t)}},{path:"/pages/74b4bf/index.html",redirect:"/pages/74b4bf/"},{path:"/07.v2.12.X文档/070.🌮数据上下文/010.说明.html",redirect:"/pages/74b4bf/"},{name:"v-8aa45958",path:"/pages/f05ed6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8aa45958").then(t)}},{path:"/pages/f05ed6/index.html",redirect:"/pages/f05ed6/"},{path:"/07.v2.12.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.html",redirect:"/pages/f05ed6/"},{name:"v-51d49431",path:"/pages/e71ced/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-51d49431").then(t)}},{path:"/pages/e71ced/index.html",redirect:"/pages/e71ced/"},{path:"/07.v2.12.X文档/070.🌮数据上下文/040.给上下文设置别名.html",redirect:"/pages/e71ced/"},{name:"v-f6731782",path:"/pages/90b2a5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f6731782").then(t)}},{path:"/pages/90b2a5/index.html",redirect:"/pages/90b2a5/"},{path:"/07.v2.12.X文档/080.🛩执行器/010.说明.html",redirect:"/pages/90b2a5/"},{name:"v-eca5b5e8",path:"/pages/20072e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-eca5b5e8").then(t)}},{path:"/pages/20072e/index.html",redirect:"/pages/20072e/"},{path:"/07.v2.12.X文档/080.🛩执行器/020.执行方法.html",redirect:"/pages/20072e/"},{name:"v-184bd5cb",path:"/pages/8777f8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-184bd5cb").then(t)}},{path:"/pages/8777f8/index.html",redirect:"/pages/8777f8/"},{path:"/07.v2.12.X文档/070.🌮数据上下文/050.上下文参数注入.html",redirect:"/pages/8777f8/"},{name:"v-42def230",path:"/pages/563b67/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-42def230").then(t)}},{path:"/pages/563b67/index.html",redirect:"/pages/563b67/"},{path:"/07.v2.12.X文档/080.🛩执行器/030.流程入参.html",redirect:"/pages/563b67/"},{name:"v-64d81acc",path:"/pages/9f653d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-64d81acc").then(t)}},{path:"/pages/9f653d/index.html",redirect:"/pages/9f653d/"},{path:"/07.v2.12.X文档/080.🛩执行器/040.LiteflowResponse对象.html",redirect:"/pages/9f653d/"},{name:"v-013d839a",path:"/pages/38c781/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-013d839a").then(t)}},{path:"/pages/38c781/index.html",redirect:"/pages/38c781/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/005.脚本语言介绍.html",redirect:"/pages/38c781/"},{name:"v-09fb6ac2",path:"/pages/07f433/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-09fb6ac2").then(t)}},{path:"/pages/07f433/index.html",redirect:"/pages/07f433/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/020.Javascript脚本引擎.html",redirect:"/pages/07f433/"},{name:"v-4b84ca42",path:"/pages/2b8afb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4b84ca42").then(t)}},{path:"/pages/2b8afb/index.html",redirect:"/pages/2b8afb/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/030.Java脚本引擎.html",redirect:"/pages/2b8afb/"},{name:"v-59a98c42",path:"/pages/36877b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-59a98c42").then(t)}},{path:"/pages/36877b/index.html",redirect:"/pages/36877b/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/010.Groovy脚本引擎.html",redirect:"/pages/36877b/"},{name:"v-25df2f08",path:"/pages/19db6d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-25df2f08").then(t)}},{path:"/pages/19db6d/index.html",redirect:"/pages/19db6d/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/040.QLExpress脚本引擎.html",redirect:"/pages/19db6d/"},{name:"v-e98a58fc",path:"/pages/114982/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e98a58fc").then(t)}},{path:"/pages/114982/index.html",redirect:"/pages/114982/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/050.Python脚本引擎.html",redirect:"/pages/114982/"},{name:"v-5f974606",path:"/pages/5f0cc7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5f974606").then(t)}},{path:"/pages/5f0cc7/index.html",redirect:"/pages/5f0cc7/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/060.Lua脚本引擎.html",redirect:"/pages/5f0cc7/"},{name:"v-516cdc82",path:"/pages/7c44ca/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-516cdc82").then(t)}},{path:"/pages/7c44ca/index.html",redirect:"/pages/7c44ca/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/080.Kotlin脚本引擎.html",redirect:"/pages/7c44ca/"},{name:"v-410b3c24",path:"/pages/bad4b0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-410b3c24").then(t)}},{path:"/pages/bad4b0/index.html",redirect:"/pages/bad4b0/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/070.Aviator脚本引擎.html",redirect:"/pages/bad4b0/"},{name:"v-dfbe432c",path:"/pages/acba2c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dfbe432c").then(t)}},{path:"/pages/acba2c/index.html",redirect:"/pages/acba2c/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/020.多脚本语言混合共存.html",redirect:"/pages/acba2c/"},{name:"v-a3cae70c",path:"/pages/d861c8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a3cae70c").then(t)}},{path:"/pages/d861c8/index.html",redirect:"/pages/d861c8/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/015.脚本与Java进行交互.html",redirect:"/pages/d861c8/"},{name:"v-2e126258",path:"/pages/f7acfd/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2e126258").then(t)}},{path:"/pages/f7acfd/index.html",redirect:"/pages/f7acfd/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/030.文件脚本的定义.html",redirect:"/pages/f7acfd/"},{name:"v-2dc6750e",path:"/pages/cbcb14/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2dc6750e").then(t)}},{path:"/pages/cbcb14/index.html",redirect:"/pages/cbcb14/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/050.动态刷新脚本.html",redirect:"/pages/cbcb14/"},{name:"v-2972917a",path:"/pages/28ad17/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2972917a").then(t)}},{path:"/pages/28ad17/index.html",redirect:"/pages/28ad17/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/070.卸载脚本.html",redirect:"/pages/28ad17/"},{name:"v-a2e02dc6",path:"/pages/a5f7d9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a2e02dc6").then(t)}},{path:"/pages/a5f7d9/index.html",redirect:"/pages/a5f7d9/"},{path:"/07.v2.12.X文档/085.🍋脚本组件/060.验证脚本.html",redirect:"/pages/a5f7d9/"},{name:"v-c370ebdc",path:"/pages/46f0fa/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c370ebdc").then(t)}},{path:"/pages/46f0fa/index.html",redirect:"/pages/46f0fa/"},{path:"/07.v2.12.X文档/086.🍇声明式组件/010.什么叫声明式组件.html",redirect:"/pages/46f0fa/"},{name:"v-ac912cf0",path:"/pages/18f548/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ac912cf0").then(t)}},{path:"/pages/18f548/index.html",redirect:"/pages/18f548/"},{path:"/07.v2.12.X文档/086.🍇声明式组件/020.类级别式声明.html",redirect:"/pages/18f548/"},{name:"v-5f9481d8",path:"/pages/797830/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5f9481d8").then(t)}},{path:"/pages/797830/index.html",redirect:"/pages/797830/"},{path:"/07.v2.12.X文档/086.🍇声明式组件/030.方法级别式声明.html",redirect:"/pages/797830/"},{name:"v-67644772",path:"/pages/9aa85a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-67644772").then(t)}},{path:"/pages/9aa85a/index.html",redirect:"/pages/9aa85a/"},{path:"/07.v2.12.X文档/090.🎲用代码动态构造规则/010.说明.html",redirect:"/pages/9aa85a/"},{name:"v-5c54cd7e",path:"/pages/a3cb4b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5c54cd7e").then(t)}},{path:"/pages/a3cb4b/index.html",redirect:"/pages/a3cb4b/"},{path:"/07.v2.12.X文档/090.🎲用代码动态构造规则/030.构造EL.html",redirect:"/pages/a3cb4b/"},{name:"v-7347303e",path:"/pages/5bbee3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7347303e").then(t)}},{path:"/pages/5bbee3/index.html",redirect:"/pages/5bbee3/"},{path:"/07.v2.12.X文档/090.🎲用代码动态构造规则/020.构造Node.html",redirect:"/pages/5bbee3/"},{name:"v-432c3864",path:"/pages/cd0445/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-432c3864").then(t)}},{path:"/pages/cd0445/index.html",redirect:"/pages/cd0445/"},{path:"/07.v2.12.X文档/090.🎲用代码动态构造规则/040.构造Chain.html",redirect:"/pages/cd0445/"},{name:"v-d76fa88e",path:"/pages/891f36/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d76fa88e").then(t)}},{path:"/pages/891f36/index.html",redirect:"/pages/891f36/"},{path:"/07.v2.12.X文档/095.🍼元数据管理/030.启动不检查规则.html",redirect:"/pages/891f36/"},{name:"v-31e646a2",path:"/pages/204d71/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-31e646a2").then(t)}},{path:"/pages/204d71/index.html",redirect:"/pages/204d71/"},{path:"/07.v2.12.X文档/095.🍼元数据管理/020.平滑热刷新.html",redirect:"/pages/204d71/"},{name:"v-0dc67eba",path:"/pages/7cb165/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0dc67eba").then(t)}},{path:"/pages/7cb165/index.html",redirect:"/pages/7cb165/"},{path:"/07.v2.12.X文档/095.🍼元数据管理/010.概念以及介绍.html",redirect:"/pages/7cb165/"},{name:"v-3c44b12e",path:"/pages/b0bb54/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3c44b12e").then(t)}},{path:"/pages/b0bb54/index.html",redirect:"/pages/b0bb54/"},{path:"/07.v2.12.X文档/095.🍼元数据管理/040.查看指定规则下的所有组件.html",redirect:"/pages/b0bb54/"},{name:"v-9ef5bc66",path:"/pages/ec1ac4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-9ef5bc66").then(t)}},{path:"/pages/ec1ac4/index.html",redirect:"/pages/ec1ac4/"},{path:"/07.v2.12.X文档/097.🧮决策路由/010.概念以及介绍.html",redirect:"/pages/ec1ac4/"},{name:"v-dc09fe22",path:"/pages/ef098d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dc09fe22").then(t)}},{path:"/pages/ef098d/index.html",redirect:"/pages/ef098d/"},{path:"/07.v2.12.X文档/098.😸生命周期/010.启动时生命周期.html",redirect:"/pages/ef098d/"},{name:"v-184ed96b",path:"/pages/f6ae9e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-184ed96b").then(t)}},{path:"/pages/f6ae9e/index.html",redirect:"/pages/f6ae9e/"},{path:"/07.v2.12.X文档/098.😸生命周期/020.执行时生命周期.html",redirect:"/pages/f6ae9e/"},{name:"v-710f7ada",path:"/pages/9f93be/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-710f7ada").then(t)}},{path:"/pages/9f93be/index.html",redirect:"/pages/9f93be/"},{path:"/07.v2.12.X文档/100.🎨高级特性/030.前置和后置组件.html",redirect:"/pages/9f93be/"},{name:"v-16f910af",path:"/pages/b7ed78/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-16f910af").then(t)}},{path:"/pages/b7ed78/index.html",redirect:"/pages/b7ed78/"},{path:"/07.v2.12.X文档/097.🧮决策路由/020.决策路由用法.html",redirect:"/pages/b7ed78/"},{name:"v-11ba52b0",path:"/pages/f8aa79/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-11ba52b0").then(t)}},{path:"/pages/f8aa79/index.html",redirect:"/pages/f8aa79/"},{path:"/07.v2.12.X文档/100.🎨高级特性/031.本地规则文件监听.html",redirect:"/pages/f8aa79/"},{name:"v-400c1155",path:"/pages/79289a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-400c1155").then(t)}},{path:"/pages/79289a/index.html",redirect:"/pages/79289a/"},{path:"/07.v2.12.X文档/100.🎨高级特性/035.组件降级.html",redirect:"/pages/79289a/"},{name:"v-dc55cd76",path:"/pages/6e4d15/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dc55cd76").then(t)}},{path:"/pages/6e4d15/index.html",redirect:"/pages/6e4d15/"},{path:"/07.v2.12.X文档/100.🎨高级特性/036.组件参数.html",redirect:"/pages/6e4d15/"},{name:"v-34701b02",path:"/pages/0f788f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-34701b02").then(t)}},{path:"/pages/0f788f/index.html",redirect:"/pages/0f788f/"},{path:"/07.v2.12.X文档/100.🎨高级特性/050.组件标签.html",redirect:"/pages/0f788f/"},{name:"v-3877a216",path:"/pages/92ef89/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3877a216").then(t)}},{path:"/pages/92ef89/index.html",redirect:"/pages/92ef89/"},{path:"/07.v2.12.X文档/100.🎨高级特性/040.组件别名.html",redirect:"/pages/92ef89/"},{name:"v-030d45c2",path:"/pages/3ee755/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-030d45c2").then(t)}},{path:"/pages/3ee755/index.html",redirect:"/pages/3ee755/"},{path:"/07.v2.12.X文档/100.🎨高级特性/060.组件事件回调.html",redirect:"/pages/3ee755/"},{name:"v-74a1d3c8",path:"/pages/y172l7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-74a1d3c8").then(t)}},{path:"/pages/y172l7/index.html",redirect:"/pages/y172l7/"},{path:"/07.v2.12.X文档/100.🎨高级特性/061.组件回滚.html",redirect:"/pages/y172l7/"},{name:"v-c5f9b436",path:"/pages/80e873/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c5f9b436").then(t)}},{path:"/pages/80e873/index.html",redirect:"/pages/80e873/"},{path:"/07.v2.12.X文档/100.🎨高级特性/070.隐式子流程.html",redirect:"/pages/80e873/"},{name:"v-3ae6687c",path:"/pages/fbb938/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3ae6687c").then(t)}},{path:"/pages/fbb938/index.html",redirect:"/pages/fbb938/"},{path:"/07.v2.12.X文档/100.🎨高级特性/080.私有投递.html",redirect:"/pages/fbb938/"},{name:"v-3c9903ea",path:"/pages/b44233/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3c9903ea").then(t)}},{path:"/pages/b44233/index.html",redirect:"/pages/b44233/"},{path:"/07.v2.12.X文档/100.🎨高级特性/091.EL中的重试.html",redirect:"/pages/b44233/"},{name:"v-795f1111",path:"/pages/7e9da1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-795f1111").then(t)}},{path:"/pages/7e9da1/index.html",redirect:"/pages/7e9da1/"},{path:"/07.v2.12.X文档/100.🎨高级特性/090.组件重试.html",redirect:"/pages/7e9da1/"},{name:"v-5f43eff4",path:"/pages/35cc4a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5f43eff4").then(t)}},{path:"/pages/35cc4a/index.html",redirect:"/pages/35cc4a/"},{path:"/07.v2.12.X文档/100.🎨高级特性/095.异步循环模式.html",redirect:"/pages/35cc4a/"},{name:"v-551685fc",path:"/pages/fd5984/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-551685fc").then(t)}},{path:"/pages/fd5984/index.html",redirect:"/pages/fd5984/"},{path:"/07.v2.12.X文档/100.🎨高级特性/097.超时控制.html",redirect:"/pages/fd5984/"},{name:"v-d6b6ac36",path:"/pages/e5ed0d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d6b6ac36").then(t)}},{path:"/pages/e5ed0d/index.html",redirect:"/pages/e5ed0d/"},{path:"/07.v2.12.X文档/100.🎨高级特性/120.步骤信息.html",redirect:"/pages/e5ed0d/"},{name:"v-dad72f28",path:"/pages/524c43/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dad72f28").then(t)}},{path:"/pages/524c43/index.html",redirect:"/pages/524c43/"},{path:"/07.v2.12.X文档/100.🎨高级特性/105.链路继承.html",redirect:"/pages/524c43/"},{name:"v-4445c84e",path:"/pages/2373f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4445c84e").then(t)}},{path:"/pages/2373f5/index.html",redirect:"/pages/2373f5/"},{path:"/07.v2.12.X文档/100.🎨高级特性/110.组件切面.html",redirect:"/pages/2373f5/"},{name:"v-aa97e0f4",path:"/pages/dc9bfe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-aa97e0f4").then(t)}},{path:"/pages/dc9bfe/index.html",redirect:"/pages/dc9bfe/"},{path:"/07.v2.12.X文档/100.🎨高级特性/125.异常.html",redirect:"/pages/dc9bfe/"},{name:"v-558d1a18",path:"/pages/47e8f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-558d1a18").then(t)}},{path:"/pages/47e8f5/index.html",redirect:"/pages/47e8f5/"},{path:"/07.v2.12.X文档/100.🎨高级特性/140.自定义请求Id.html",redirect:"/pages/47e8f5/"},{name:"v-4a7ed459",path:"/pages/4d614c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4a7ed459").then(t)}},{path:"/pages/4d614c/index.html",redirect:"/pages/4d614c/"},{path:"/07.v2.12.X文档/100.🎨高级特性/130.打印信息详解.html",redirect:"/pages/4d614c/"},{name:"v-21bc4e62",path:"/pages/a7e02e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21bc4e62").then(t)}},{path:"/pages/a7e02e/index.html",redirect:"/pages/a7e02e/"},{path:"/07.v2.12.X文档/100.🎨高级特性/150.不同格式规则加载.html",redirect:"/pages/a7e02e/"},{name:"v-14193918",path:"/pages/5fe959/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-14193918").then(t)}},{path:"/pages/5fe959/index.html",redirect:"/pages/5fe959/"},{path:"/07.v2.12.X文档/100.🎨高级特性/145.快速解析模式.html",redirect:"/pages/5fe959/"},{name:"v-1232ba9a",path:"/pages/7280ea/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1232ba9a").then(t)}},{path:"/pages/7280ea/index.html",redirect:"/pages/7280ea/"},{path:"/07.v2.12.X文档/100.🎨高级特性/160.异步线程池自定义.html",redirect:"/pages/7280ea/"},{name:"v-523e15a6",path:"/pages/46bbed/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-523e15a6").then(t)}},{path:"/pages/46bbed/index.html",redirect:"/pages/46bbed/"},{path:"/07.v2.12.X文档/100.🎨高级特性/170.自定义组件执行器.html",redirect:"/pages/46bbed/"},{name:"v-3df23b4c",path:"/pages/81cdce/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3df23b4c").then(t)}},{path:"/pages/81cdce/index.html",redirect:"/pages/81cdce/"},{path:"/07.v2.12.X文档/110.⛱测试用例以及示例/010.测试用例.html",redirect:"/pages/81cdce/"},{name:"v-08a52da4",path:"/pages/0066ae/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-08a52da4").then(t)}},{path:"/pages/0066ae/index.html",redirect:"/pages/0066ae/"},{path:"/07.v2.12.X文档/100.🎨高级特性/190.XML的DTD.html",redirect:"/pages/0066ae/"},{name:"v-36b7bba2",path:"/pages/e59f3a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-36b7bba2").then(t)}},{path:"/pages/e59f3a/index.html",redirect:"/pages/e59f3a/"},{path:"/07.v2.12.X文档/100.🎨高级特性/180.简单监控.html",redirect:"/pages/e59f3a/"},{name:"v-412981e5",path:"/pages/0a8188/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-412981e5").then(t)}},{path:"/pages/0a8188/index.html",redirect:"/pages/0a8188/"},{path:"/07.v2.12.X文档/110.⛱测试用例以及示例/020.DEMO案例.html",redirect:"/pages/0a8188/"},{name:"v-9ed471fa",path:"/pages/9bf839/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-9ed471fa").then(t)}},{path:"/pages/9bf839/index.html",redirect:"/pages/9bf839/"},{path:"/07.v2.12.X文档/120.性能表现.html",redirect:"/pages/9bf839/"},{name:"v-3cd6d033",path:"/pages/v2.11.X/7cf080/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3cd6d033").then(t)}},{path:"/pages/v2.11.X/7cf080/index.html",redirect:"/pages/v2.11.X/7cf080/"},{path:"/08.v2.11.X文档/021.🧁环境支持/010.JDK支持度.html",redirect:"/pages/v2.11.X/7cf080/"},{name:"v-da72d61a",path:"/pages/v2.11.X/724bc3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-da72d61a").then(t)}},{path:"/pages/v2.11.X/724bc3/index.html",redirect:"/pages/v2.11.X/724bc3/"},{path:"/08.v2.11.X文档/020.项目特性.html",redirect:"/pages/v2.11.X/724bc3/"},{name:"v-09959741",path:"/pages/v2.11.X/5816c5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-09959741").then(t)}},{path:"/pages/v2.11.X/5816c5/index.html",redirect:"/pages/v2.11.X/5816c5/"},{path:"/08.v2.11.X文档/010.LiteFlow简介.html",redirect:"/pages/v2.11.X/5816c5/"},{name:"v-2a18f085",path:"/pages/v2.11.X/891e0f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2a18f085").then(t)}},{path:"/pages/v2.11.X/891e0f/index.html",redirect:"/pages/v2.11.X/891e0f/"},{path:"/08.v2.11.X文档/021.🧁环境支持/020.Springboot支持度.html",redirect:"/pages/v2.11.X/891e0f/"},{name:"v-21ea24e2",path:"/pages/v2.11.X/2d12db/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21ea24e2").then(t)}},{path:"/pages/v2.11.X/2d12db/index.html",redirect:"/pages/v2.11.X/2d12db/"},{path:"/08.v2.11.X文档/021.🧁环境支持/030.Spring的支持度.html",redirect:"/pages/v2.11.X/2d12db/"},{name:"v-da2d04e8",path:"/pages/v2.11.X/631fa1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-da2d04e8").then(t)}},{path:"/pages/v2.11.X/631fa1/index.html",redirect:"/pages/v2.11.X/631fa1/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/005.说明.html",redirect:"/pages/v2.11.X/631fa1/"},{name:"v-c118e040",path:"/pages/v2.11.X/df6982/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c118e040").then(t)}},{path:"/pages/v2.11.X/df6982/index.html",redirect:"/pages/v2.11.X/df6982/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.html",redirect:"/pages/v2.11.X/df6982/"},{name:"v-e9d43e64",path:"/pages/v2.11.X/9f4489/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e9d43e64").then(t)}},{path:"/pages/v2.11.X/9f4489/index.html",redirect:"/pages/v2.11.X/9f4489/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.html",redirect:"/pages/v2.11.X/9f4489/"},{name:"v-7d2fe52a",path:"/pages/v2.11.X/82ef41/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7d2fe52a").then(t)}},{path:"/pages/v2.11.X/82ef41/index.html",redirect:"/pages/v2.11.X/82ef41/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.html",redirect:"/pages/v2.11.X/82ef41/"},{name:"v-2b9660ca",path:"/pages/v2.11.X/0a4573/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2b9660ca").then(t)}},{path:"/pages/v2.11.X/0a4573/index.html",redirect:"/pages/v2.11.X/0a4573/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.html",redirect:"/pages/v2.11.X/0a4573/"},{name:"v-0516feb4",path:"/pages/v2.11.X/495f21/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0516feb4").then(t)}},{path:"/pages/v2.11.X/495f21/index.html",redirect:"/pages/v2.11.X/495f21/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.html",redirect:"/pages/v2.11.X/495f21/"},{name:"v-09e49989",path:"/pages/v2.11.X/0e0fb5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-09e49989").then(t)}},{path:"/pages/v2.11.X/0e0fb5/index.html",redirect:"/pages/v2.11.X/0e0fb5/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.html",redirect:"/pages/v2.11.X/0e0fb5/"},{name:"v-53af0494",path:"/pages/v2.11.X/522432/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-53af0494").then(t)}},{path:"/pages/v2.11.X/522432/index.html",redirect:"/pages/v2.11.X/522432/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.html",redirect:"/pages/v2.11.X/522432/"},{name:"v-ac32a9a4",path:"/pages/v2.11.X/8760c4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ac32a9a4").then(t)}},{path:"/pages/v2.11.X/8760c4/index.html",redirect:"/pages/v2.11.X/8760c4/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.html",redirect:"/pages/v2.11.X/8760c4/"},{name:"v-575b8a1c",path:"/pages/v2.11.X/151524/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-575b8a1c").then(t)}},{path:"/pages/v2.11.X/151524/index.html",redirect:"/pages/v2.11.X/151524/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.html",redirect:"/pages/v2.11.X/151524/"},{name:"v-42670b79",path:"/pages/v2.11.X/b70ec8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-42670b79").then(t)}},{path:"/pages/v2.11.X/b70ec8/index.html",redirect:"/pages/v2.11.X/b70ec8/"},{path:"/08.v2.11.X文档/040.🍢配置项/010.说明.html",redirect:"/pages/v2.11.X/b70ec8/"},{name:"v-67b601b9",path:"/pages/v2.11.X/249d17/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-67b601b9").then(t)}},{path:"/pages/v2.11.X/249d17/index.html",redirect:"/pages/v2.11.X/249d17/"},{path:"/08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.html",redirect:"/pages/v2.11.X/249d17/"},{name:"v-0c9eca63",path:"/pages/v2.11.X/4594ec/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0c9eca63").then(t)}},{path:"/pages/v2.11.X/4594ec/index.html",redirect:"/pages/v2.11.X/4594ec/"},{path:"/08.v2.11.X文档/040.🍢配置项/020.Springboot下的配置项.html",redirect:"/pages/v2.11.X/4594ec/"},{name:"v-0a4f2a01",path:"/pages/v2.11.X/33833a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0a4f2a01").then(t)}},{path:"/pages/v2.11.X/33833a/index.html",redirect:"/pages/v2.11.X/33833a/"},{path:"/08.v2.11.X文档/040.🍢配置项/030.Spring下的配置项.html",redirect:"/pages/v2.11.X/33833a/"},{name:"v-c418353a",path:"/pages/v2.11.X/b5065a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c418353a").then(t)}},{path:"/pages/v2.11.X/b5065a/index.html",redirect:"/pages/v2.11.X/b5065a/"},{path:"/08.v2.11.X文档/040.🍢配置项/040.其他场景代码设置配置项.html",redirect:"/pages/v2.11.X/b5065a/"},{name:"v-23b79988",path:"/pages/v2.11.X/6fa87e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-23b79988").then(t)}},{path:"/pages/v2.11.X/6fa87e/index.html",redirect:"/pages/v2.11.X/6fa87e/"},{path:"/08.v2.11.X文档/050.🗂规则文件/010.规则文件格式.html",redirect:"/pages/v2.11.X/6fa87e/"},{name:"v-5d63701c",path:"/pages/v2.11.X/51ddd5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5d63701c").then(t)}},{path:"/pages/v2.11.X/51ddd5/index.html",redirect:"/pages/v2.11.X/51ddd5/"},{path:"/08.v2.11.X文档/050.🗂规则文件/020.本地规则文件配置.html",redirect:"/pages/v2.11.X/51ddd5/"},{name:"v-2c906cbe",path:"/pages/v2.11.X/ffc345/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2c906cbe").then(t)}},{path:"/pages/v2.11.X/ffc345/index.html",redirect:"/pages/v2.11.X/ffc345/"},{path:"/08.v2.11.X文档/050.🗂规则文件/030.ZK规则文件配置源.html",redirect:"/pages/v2.11.X/ffc345/"},{name:"v-2f5f0498",path:"/pages/v2.11.X/09b776/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2f5f0498").then(t)}},{path:"/pages/v2.11.X/09b776/index.html",redirect:"/pages/v2.11.X/09b776/"},{path:"/08.v2.11.X文档/050.🗂规则文件/050.Nacos配置源.html",redirect:"/pages/v2.11.X/09b776/"},{name:"v-2edf2a5e",path:"/pages/v2.11.X/4bfac2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2edf2a5e").then(t)}},{path:"/pages/v2.11.X/4bfac2/index.html",redirect:"/pages/v2.11.X/4bfac2/"},{path:"/08.v2.11.X文档/050.🗂规则文件/060.Etcd配置源.html",redirect:"/pages/v2.11.X/4bfac2/"},{name:"v-60631a33",path:"/pages/v2.11.X/236b4f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-60631a33").then(t)}},{path:"/pages/v2.11.X/236b4f/index.html",redirect:"/pages/v2.11.X/236b4f/"},{path:"/08.v2.11.X文档/050.🗂规则文件/040.SQL数据库配置源.html",redirect:"/pages/v2.11.X/236b4f/"},{name:"v-34546ad2",path:"/pages/v2.11.X/38dcf8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-34546ad2").then(t)}},{path:"/pages/v2.11.X/38dcf8/index.html",redirect:"/pages/v2.11.X/38dcf8/"},{path:"/08.v2.11.X文档/050.🗂规则文件/066.📑Redis配置源/010.配置说明.html",redirect:"/pages/v2.11.X/38dcf8/"},{name:"v-44ace19e",path:"/pages/v2.11.X/bea809/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-44ace19e").then(t)}},{path:"/pages/v2.11.X/bea809/index.html",redirect:"/pages/v2.11.X/bea809/"},{path:"/08.v2.11.X文档/050.🗂规则文件/065.Apollo配置源.html",redirect:"/pages/v2.11.X/bea809/"},{name:"v-728de3bf",path:"/pages/v2.11.X/25f2c0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-728de3bf").then(t)}},{path:"/pages/v2.11.X/25f2c0/index.html",redirect:"/pages/v2.11.X/25f2c0/"},{path:"/08.v2.11.X文档/050.🗂规则文件/070.自定义配置源.html",redirect:"/pages/v2.11.X/25f2c0/"},{name:"v-d15e277e",path:"/pages/v2.11.X/8486fb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d15e277e").then(t)}},{path:"/pages/v2.11.X/8486fb/index.html",redirect:"/pages/v2.11.X/8486fb/"},{path:"/08.v2.11.X文档/055.🔗常规组件/010.普通组件.html",redirect:"/pages/v2.11.X/8486fb/"},{name:"v-170e5d3c",path:"/pages/v2.11.X/186747/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-170e5d3c").then(t)}},{path:"/pages/v2.11.X/186747/index.html",redirect:"/pages/v2.11.X/186747/"},{path:"/08.v2.11.X文档/050.🗂规则文件/066.📑Redis配置源/020.轮询模式配置.html",redirect:"/pages/v2.11.X/186747/"},{name:"v-129c0d43",path:"/pages/v2.11.X/3f553f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-129c0d43").then(t)}},{path:"/pages/v2.11.X/3f553f/index.html",redirect:"/pages/v2.11.X/3f553f/"},{path:"/08.v2.11.X文档/050.🗂规则文件/066.📑Redis配置源/030.订阅模式配置.html",redirect:"/pages/v2.11.X/3f553f/"},{name:"v-06e77438",path:"/pages/v2.11.X/c0f5d7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-06e77438").then(t)}},{path:"/pages/v2.11.X/c0f5d7/index.html",redirect:"/pages/v2.11.X/c0f5d7/"},{path:"/08.v2.11.X文档/055.🔗常规组件/020.选择组件.html",redirect:"/pages/v2.11.X/c0f5d7/"},{name:"v-11d57881",path:"/pages/v2.11.X/5f971f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-11d57881").then(t)}},{path:"/pages/v2.11.X/5f971f/index.html",redirect:"/pages/v2.11.X/5f971f/"},{path:"/08.v2.11.X文档/055.🔗常规组件/040.次数循环组件.html",redirect:"/pages/v2.11.X/5f971f/"},{name:"v-034193f0",path:"/pages/v2.11.X/e6995e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-034193f0").then(t)}},{path:"/pages/v2.11.X/e6995e/index.html",redirect:"/pages/v2.11.X/e6995e/"},{path:"/08.v2.11.X文档/055.🔗常规组件/050.条件循环组件.html",redirect:"/pages/v2.11.X/e6995e/"},{name:"v-1a462536",path:"/pages/v2.11.X/cb0b59/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1a462536").then(t)}},{path:"/pages/v2.11.X/cb0b59/index.html",redirect:"/pages/v2.11.X/cb0b59/"},{path:"/08.v2.11.X文档/055.🔗常规组件/030.条件组件.html",redirect:"/pages/v2.11.X/cb0b59/"},{name:"v-6b3ab58c",path:"/pages/v2.11.X/c078cd/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6b3ab58c").then(t)}},{path:"/pages/v2.11.X/c078cd/index.html",redirect:"/pages/v2.11.X/c078cd/"},{path:"/08.v2.11.X文档/055.🔗常规组件/060.退出循环组件.html",redirect:"/pages/v2.11.X/c078cd/"},{name:"v-0cd16e12",path:"/pages/v2.11.X/64262b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0cd16e12").then(t)}},{path:"/pages/v2.11.X/64262b/index.html",redirect:"/pages/v2.11.X/64262b/"},{path:"/08.v2.11.X文档/055.🔗常规组件/055.迭代循环组件.html",redirect:"/pages/v2.11.X/64262b/"},{name:"v-03922cfd",path:"/pages/v2.11.X/16eca9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-03922cfd").then(t)}},{path:"/pages/v2.11.X/16eca9/index.html",redirect:"/pages/v2.11.X/16eca9/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/010.说明.html",redirect:"/pages/v2.11.X/16eca9/"},{name:"v-4e239d24",path:"/pages/v2.11.X/b3446a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4e239d24").then(t)}},{path:"/pages/v2.11.X/b3446a/index.html",redirect:"/pages/v2.11.X/b3446a/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/030.并行编排.html",redirect:"/pages/v2.11.X/b3446a/"},{name:"v-95142338",path:"/pages/v2.11.X/a590ee/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-95142338").then(t)}},{path:"/pages/v2.11.X/a590ee/index.html",redirect:"/pages/v2.11.X/a590ee/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/020.串行编排.html",redirect:"/pages/v2.11.X/a590ee/"},{name:"v-164de06d",path:"/pages/v2.11.X/d90483/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-164de06d").then(t)}},{path:"/pages/v2.11.X/d90483/index.html",redirect:"/pages/v2.11.X/d90483/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/040.选择编排.html",redirect:"/pages/v2.11.X/d90483/"},{name:"v-6203c652",path:"/pages/v2.11.X/e76999/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6203c652").then(t)}},{path:"/pages/v2.11.X/e76999/index.html",redirect:"/pages/v2.11.X/e76999/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/045.条件编排.html",redirect:"/pages/v2.11.X/e76999/"},{name:"v-5c3dc76f",path:"/pages/v2.11.X/f53b51/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5c3dc76f").then(t)}},{path:"/pages/v2.11.X/f53b51/index.html",redirect:"/pages/v2.11.X/f53b51/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/047.捕获异常表达式.html",redirect:"/pages/v2.11.X/f53b51/"},{name:"v-8d64f6d2",path:"/pages/v2.11.X/fbf715/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8d64f6d2").then(t)}},{path:"/pages/v2.11.X/fbf715/index.html",redirect:"/pages/v2.11.X/fbf715/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/046.循环编排.html",redirect:"/pages/v2.11.X/fbf715/"},{name:"v-6ce21664",path:"/pages/v2.11.X/a8b344/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6ce21664").then(t)}},{path:"/pages/v2.11.X/a8b344/index.html",redirect:"/pages/v2.11.X/a8b344/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/048.与或非表达式.html",redirect:"/pages/v2.11.X/a8b344/"},{name:"v-21994c86",path:"/pages/v2.11.X/dc5df7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21994c86").then(t)}},{path:"/pages/v2.11.X/dc5df7/index.html",redirect:"/pages/v2.11.X/dc5df7/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/050.使用子流程.html",redirect:"/pages/v2.11.X/dc5df7/"},{name:"v-2df23e04",path:"/pages/v2.11.X/5156b3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2df23e04").then(t)}},{path:"/pages/v2.11.X/5156b3/index.html",redirect:"/pages/v2.11.X/5156b3/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/070.复杂编排例子.html",redirect:"/pages/v2.11.X/5156b3/"},{name:"v-1e7a979e",path:"/pages/v2.11.X/71ff49/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1e7a979e").then(t)}},{path:"/pages/v2.11.X/71ff49/index.html",redirect:"/pages/v2.11.X/71ff49/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/060.使用子变量.html",redirect:"/pages/v2.11.X/71ff49/"},{name:"v-3bad0d8c",path:"/pages/v2.11.X/af44a6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3bad0d8c").then(t)}},{path:"/pages/v2.11.X/af44a6/index.html",redirect:"/pages/v2.11.X/af44a6/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/080.关于分号.html",redirect:"/pages/v2.11.X/af44a6/"},{name:"v-78c1c150",path:"/pages/v2.11.X/2df3d9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-78c1c150").then(t)}},{path:"/pages/v2.11.X/2df3d9/index.html",redirect:"/pages/v2.11.X/2df3d9/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/100.组件名包装.html",redirect:"/pages/v2.11.X/2df3d9/"},{name:"v-64c1cc82",path:"/pages/v2.11.X/f3dc09/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-64c1cc82").then(t)}},{path:"/pages/v2.11.X/f3dc09/index.html",redirect:"/pages/v2.11.X/f3dc09/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/090.关于注释.html",redirect:"/pages/v2.11.X/f3dc09/"},{name:"v-620f21cd",path:"/pages/v2.11.X/395fd0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-620f21cd").then(t)}},{path:"/pages/v2.11.X/395fd0/index.html",redirect:"/pages/v2.11.X/395fd0/"},{path:"/08.v2.11.X文档/060.🧩EL规则的写法/110.验证规则.html",redirect:"/pages/v2.11.X/395fd0/"},{name:"v-2391217a",path:"/pages/v2.11.X/74b4bf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2391217a").then(t)}},{path:"/pages/v2.11.X/74b4bf/index.html",redirect:"/pages/v2.11.X/74b4bf/"},{path:"/08.v2.11.X文档/070.🌮数据上下文/010.说明.html",redirect:"/pages/v2.11.X/74b4bf/"},{name:"v-78db2895",path:"/pages/v2.11.X/501abf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-78db2895").then(t)}},{path:"/pages/v2.11.X/501abf/index.html",redirect:"/pages/v2.11.X/501abf/"},{path:"/08.v2.11.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.html",redirect:"/pages/v2.11.X/501abf/"},{name:"v-59824782",path:"/pages/v2.11.X/90b2a5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-59824782").then(t)}},{path:"/pages/v2.11.X/90b2a5/index.html",redirect:"/pages/v2.11.X/90b2a5/"},{path:"/08.v2.11.X文档/080.🛩执行器/010.说明.html",redirect:"/pages/v2.11.X/90b2a5/"},{name:"v-088c6cd4",path:"/pages/v2.11.X/f05ed6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-088c6cd4").then(t)}},{path:"/pages/v2.11.X/f05ed6/index.html",redirect:"/pages/v2.11.X/f05ed6/"},{path:"/08.v2.11.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.html",redirect:"/pages/v2.11.X/f05ed6/"},{name:"v-67575d0c",path:"/pages/v2.11.X/20072e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-67575d0c").then(t)}},{path:"/pages/v2.11.X/20072e/index.html",redirect:"/pages/v2.11.X/20072e/"},{path:"/08.v2.11.X文档/080.🛩执行器/020.执行方法.html",redirect:"/pages/v2.11.X/20072e/"},{name:"v-878a8230",path:"/pages/v2.11.X/563b67/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-878a8230").then(t)}},{path:"/pages/v2.11.X/563b67/index.html",redirect:"/pages/v2.11.X/563b67/"},{path:"/08.v2.11.X文档/080.🛩执行器/030.流程入参.html",redirect:"/pages/v2.11.X/563b67/"},{name:"v-340ada9a",path:"/pages/v2.11.X/9f653d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-340ada9a").then(t)}},{path:"/pages/v2.11.X/9f653d/index.html",redirect:"/pages/v2.11.X/9f653d/"},{path:"/08.v2.11.X文档/080.🛩执行器/040.LiteflowResponse对象.html",redirect:"/pages/v2.11.X/9f653d/"},{name:"v-e23af09a",path:"/pages/v2.11.X/38c781/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e23af09a").then(t)}},{path:"/pages/v2.11.X/38c781/index.html",redirect:"/pages/v2.11.X/38c781/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/005.脚本语言介绍.html",redirect:"/pages/v2.11.X/38c781/"},{name:"v-2b553a7c",path:"/pages/v2.11.X/07f433/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2b553a7c").then(t)}},{path:"/pages/v2.11.X/07f433/index.html",redirect:"/pages/v2.11.X/07f433/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/020.Javascript脚本引擎.html",redirect:"/pages/v2.11.X/07f433/"},{name:"v-d328377c",path:"/pages/v2.11.X/36877b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d328377c").then(t)}},{path:"/pages/v2.11.X/36877b/index.html",redirect:"/pages/v2.11.X/36877b/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/010.Groovy脚本引擎.html",redirect:"/pages/v2.11.X/36877b/"},{name:"v-7a115242",path:"/pages/v2.11.X/2b8afb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7a115242").then(t)}},{path:"/pages/v2.11.X/2b8afb/index.html",redirect:"/pages/v2.11.X/2b8afb/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/030.Java脚本引擎.html",redirect:"/pages/v2.11.X/2b8afb/"},{name:"v-bed8d4b8",path:"/pages/v2.11.X/bad4b0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-bed8d4b8").then(t)}},{path:"/pages/v2.11.X/bad4b0/index.html",redirect:"/pages/v2.11.X/bad4b0/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/070.Aviator脚本引擎.html",redirect:"/pages/v2.11.X/bad4b0/"},{name:"v-625a0ef0",path:"/pages/v2.11.X/19db6d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-625a0ef0").then(t)}},{path:"/pages/v2.11.X/19db6d/index.html",redirect:"/pages/v2.11.X/19db6d/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/040.QLExpress脚本引擎.html",redirect:"/pages/v2.11.X/19db6d/"},{name:"v-7005a8fc",path:"/pages/v2.11.X/114982/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7005a8fc").then(t)}},{path:"/pages/v2.11.X/114982/index.html",redirect:"/pages/v2.11.X/114982/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/050.Python脚本引擎.html",redirect:"/pages/v2.11.X/114982/"},{name:"v-cc8680f4",path:"/pages/v2.11.X/5f0cc7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cc8680f4").then(t)}},{path:"/pages/v2.11.X/5f0cc7/index.html",redirect:"/pages/v2.11.X/5f0cc7/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/060.Lua脚本引擎.html",redirect:"/pages/v2.11.X/5f0cc7/"},{name:"v-d457f70c",path:"/pages/v2.11.X/d861c8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d457f70c").then(t)}},{path:"/pages/v2.11.X/d861c8/index.html",redirect:"/pages/v2.11.X/d861c8/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/015.脚本与Java进行交互.html",redirect:"/pages/v2.11.X/d861c8/"},{name:"v-6e38866a",path:"/pages/v2.11.X/acba2c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6e38866a").then(t)}},{path:"/pages/v2.11.X/acba2c/index.html",redirect:"/pages/v2.11.X/acba2c/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/020.多脚本语言混合共存.html",redirect:"/pages/v2.11.X/acba2c/"},{name:"v-608c3a58",path:"/pages/v2.11.X/f7acfd/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-608c3a58").then(t)}},{path:"/pages/v2.11.X/f7acfd/index.html",redirect:"/pages/v2.11.X/f7acfd/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/030.文件脚本的定义.html",redirect:"/pages/v2.11.X/f7acfd/"},{name:"v-789e0ef9",path:"/pages/v2.11.X/cbcb14/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-789e0ef9").then(t)}},{path:"/pages/v2.11.X/cbcb14/index.html",redirect:"/pages/v2.11.X/cbcb14/"},{path:"/08.v2.11.X文档/085.🍋脚本组件/050.动态刷新脚本.html",redirect:"/pages/v2.11.X/cbcb14/"},{name:"v-7c5f3212",path:"/pages/v2.11.X/46f0fa/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7c5f3212").then(t)}},{path:"/pages/v2.11.X/46f0fa/index.html",redirect:"/pages/v2.11.X/46f0fa/"},{path:"/08.v2.11.X文档/086.🍇声明式组件/010.什么叫声明式组件.html",redirect:"/pages/v2.11.X/46f0fa/"},{name:"v-02709772",path:"/pages/v2.11.X/9aa85a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-02709772").then(t)}},{path:"/pages/v2.11.X/9aa85a/index.html",redirect:"/pages/v2.11.X/9aa85a/"},{path:"/08.v2.11.X文档/090.🎲用代码动态构造规则/010.说明.html",redirect:"/pages/v2.11.X/9aa85a/"},{name:"v-16638950",path:"/pages/v2.11.X/797830/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-16638950").then(t)}},{path:"/pages/v2.11.X/797830/index.html",redirect:"/pages/v2.11.X/797830/"},{path:"/08.v2.11.X文档/086.🍇声明式组件/030.方法级别式声明.html",redirect:"/pages/v2.11.X/797830/"},{name:"v-479d7cf0",path:"/pages/v2.11.X/18f548/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-479d7cf0").then(t)}},{path:"/pages/v2.11.X/18f548/index.html",redirect:"/pages/v2.11.X/18f548/"},{path:"/08.v2.11.X文档/086.🍇声明式组件/020.类级别式声明.html",redirect:"/pages/v2.11.X/18f548/"},{name:"v-5b00a83e",path:"/pages/v2.11.X/5bbee3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5b00a83e").then(t)}},{path:"/pages/v2.11.X/5bbee3/index.html",redirect:"/pages/v2.11.X/5bbee3/"},{path:"/08.v2.11.X文档/090.🎲用代码动态构造规则/020.构造Node.html",redirect:"/pages/v2.11.X/5bbee3/"},{name:"v-6ebc757e",path:"/pages/v2.11.X/a3cb4b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6ebc757e").then(t)}},{path:"/pages/v2.11.X/a3cb4b/index.html",redirect:"/pages/v2.11.X/a3cb4b/"},{path:"/08.v2.11.X文档/090.🎲用代码动态构造规则/030.构造EL.html",redirect:"/pages/v2.11.X/a3cb4b/"},{name:"v-6ac251e4",path:"/pages/v2.11.X/cd0445/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6ac251e4").then(t)}},{path:"/pages/v2.11.X/cd0445/index.html",redirect:"/pages/v2.11.X/cd0445/"},{path:"/08.v2.11.X文档/090.🎲用代码动态构造规则/040.构造Chain.html",redirect:"/pages/v2.11.X/cd0445/"},{name:"v-4790ead5",path:"/pages/v2.11.X/79289a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4790ead5").then(t)}},{path:"/pages/v2.11.X/79289a/index.html",redirect:"/pages/v2.11.X/79289a/"},{path:"/08.v2.11.X文档/100.🎨高级特性/035.组件降级.html",redirect:"/pages/v2.11.X/79289a/"},{name:"v-0c1bcada",path:"/pages/v2.11.X/9f93be/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0c1bcada").then(t)}},{path:"/pages/v2.11.X/9f93be/index.html",redirect:"/pages/v2.11.X/9f93be/"},{path:"/08.v2.11.X文档/100.🎨高级特性/030.前置和后置组件.html",redirect:"/pages/v2.11.X/9f93be/"},{name:"v-e746dfb0",path:"/pages/v2.11.X/f8aa79/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e746dfb0").then(t)}},{path:"/pages/v2.11.X/f8aa79/index.html",redirect:"/pages/v2.11.X/f8aa79/"},{path:"/08.v2.11.X文档/100.🎨高级特性/031.本地规则文件监听.html",redirect:"/pages/v2.11.X/f8aa79/"},{name:"v-cd4c1a76",path:"/pages/v2.11.X/6e4d15/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cd4c1a76").then(t)}},{path:"/pages/v2.11.X/6e4d15/index.html",redirect:"/pages/v2.11.X/6e4d15/"},{path:"/08.v2.11.X文档/100.🎨高级特性/036.组件参数.html",redirect:"/pages/v2.11.X/6e4d15/"},{name:"v-3ffc7b96",path:"/pages/v2.11.X/92ef89/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3ffc7b96").then(t)}},{path:"/pages/v2.11.X/92ef89/index.html",redirect:"/pages/v2.11.X/92ef89/"},{path:"/08.v2.11.X文档/100.🎨高级特性/040.组件别名.html",redirect:"/pages/v2.11.X/92ef89/"},{name:"v-3bf4f482",path:"/pages/v2.11.X/0f788f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3bf4f482").then(t)}},{path:"/pages/v2.11.X/0f788f/index.html",redirect:"/pages/v2.11.X/0f788f/"},{path:"/08.v2.11.X文档/100.🎨高级特性/050.组件标签.html",redirect:"/pages/v2.11.X/0f788f/"},{name:"v-7c26ad48",path:"/pages/v2.11.X/y172l7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7c26ad48").then(t)}},{path:"/pages/v2.11.X/y172l7/index.html",redirect:"/pages/v2.11.X/y172l7/"},{path:"/08.v2.11.X文档/100.🎨高级特性/061.组件回滚.html",redirect:"/pages/v2.11.X/y172l7/"},{name:"v-dae2e17c",path:"/pages/v2.11.X/3ee755/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dae2e17c").then(t)}},{path:"/pages/v2.11.X/3ee755/index.html",redirect:"/pages/v2.11.X/3ee755/"},{path:"/08.v2.11.X文档/100.🎨高级特性/060.组件事件回调.html",redirect:"/pages/v2.11.X/3ee755/"},{name:"v-2bdcb57c",path:"/pages/v2.11.X/fbb938/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2bdcb57c").then(t)}},{path:"/pages/v2.11.X/fbb938/index.html",redirect:"/pages/v2.11.X/fbb938/"},{path:"/08.v2.11.X文档/100.🎨高级特性/080.私有投递.html",redirect:"/pages/v2.11.X/fbb938/"},{name:"v-fe382ade",path:"/pages/v2.11.X/7e9da1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-fe382ade").then(t)}},{path:"/pages/v2.11.X/7e9da1/index.html",redirect:"/pages/v2.11.X/7e9da1/"},{path:"/08.v2.11.X文档/100.🎨高级特性/090.组件重试.html",redirect:"/pages/v2.11.X/7e9da1/"},{name:"v-2b032de5",path:"/pages/v2.11.X/80e873/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2b032de5").then(t)}},{path:"/pages/v2.11.X/80e873/index.html",redirect:"/pages/v2.11.X/80e873/"},{path:"/08.v2.11.X文档/100.🎨高级特性/070.隐式子流程.html",redirect:"/pages/v2.11.X/80e873/"},{name:"v-dce50a5c",path:"/pages/v2.11.X/204d71/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dce50a5c").then(t)}},{path:"/pages/v2.11.X/204d71/index.html",redirect:"/pages/v2.11.X/204d71/"},{path:"/08.v2.11.X文档/100.🎨高级特性/100.平滑热刷新.html",redirect:"/pages/v2.11.X/204d71/"},{name:"v-48593528",path:"/pages/v2.11.X/35cc4a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-48593528").then(t)}},{path:"/pages/v2.11.X/35cc4a/index.html",redirect:"/pages/v2.11.X/35cc4a/"},{path:"/08.v2.11.X文档/100.🎨高级特性/091.异步循环模式.html",redirect:"/pages/v2.11.X/35cc4a/"},{name:"v-585191b8",path:"/pages/v2.11.X/fd5984/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-585191b8").then(t)}},{path:"/pages/v2.11.X/fd5984/index.html",redirect:"/pages/v2.11.X/fd5984/"},{path:"/08.v2.11.X文档/100.🎨高级特性/092.超时控制.html",redirect:"/pages/v2.11.X/fd5984/"},{name:"v-cbcd7c28",path:"/pages/v2.11.X/524c43/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cbcd7c28").then(t)}},{path:"/pages/v2.11.X/524c43/index.html",redirect:"/pages/v2.11.X/524c43/"},{path:"/08.v2.11.X文档/100.🎨高级特性/105.链路继承.html",redirect:"/pages/v2.11.X/524c43/"},{name:"v-4bcaa1ce",path:"/pages/v2.11.X/2373f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4bcaa1ce").then(t)}},{path:"/pages/v2.11.X/2373f5/index.html",redirect:"/pages/v2.11.X/2373f5/"},{path:"/08.v2.11.X文档/100.🎨高级特性/110.组件切面.html",redirect:"/pages/v2.11.X/2373f5/"},{name:"v-ea0f0df4",path:"/pages/v2.11.X/dc9bfe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ea0f0df4").then(t)}},{path:"/pages/v2.11.X/dc9bfe/index.html",redirect:"/pages/v2.11.X/dc9bfe/"},{path:"/08.v2.11.X文档/100.🎨高级特性/125.异常.html",redirect:"/pages/v2.11.X/dc9bfe/"},{name:"v-4bffc44e",path:"/pages/v2.11.X/4d614c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4bffc44e").then(t)}},{path:"/pages/v2.11.X/4d614c/index.html",redirect:"/pages/v2.11.X/4d614c/"},{path:"/08.v2.11.X文档/100.🎨高级特性/130.打印信息详解.html",redirect:"/pages/v2.11.X/4d614c/"},{name:"v-c7acf936",path:"/pages/v2.11.X/e5ed0d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c7acf936").then(t)}},{path:"/pages/v2.11.X/e5ed0d/index.html",redirect:"/pages/v2.11.X/e5ed0d/"},{path:"/08.v2.11.X文档/100.🎨高级特性/120.步骤信息.html",redirect:"/pages/v2.11.X/e5ed0d/"},{name:"v-f516a618",path:"/pages/v2.11.X/5fe959/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f516a618").then(t)}},{path:"/pages/v2.11.X/5fe959/index.html",redirect:"/pages/v2.11.X/5fe959/"},{path:"/08.v2.11.X文档/100.🎨高级特性/145.快速解析模式.html",redirect:"/pages/v2.11.X/5fe959/"},{name:"v-26634af4",path:"/pages/v2.11.X/47e8f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-26634af4").then(t)}},{path:"/pages/v2.11.X/47e8f5/index.html",redirect:"/pages/v2.11.X/47e8f5/"},{path:"/08.v2.11.X文档/100.🎨高级特性/140.自定义请求Id.html",redirect:"/pages/v2.11.X/47e8f5/"},{name:"v-9213f03c",path:"/pages/v2.11.X/a7e02e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-9213f03c").then(t)}},{path:"/pages/v2.11.X/a7e02e/index.html",redirect:"/pages/v2.11.X/a7e02e/"},{path:"/08.v2.11.X文档/100.🎨高级特性/150.不同格式规则加载.html",redirect:"/pages/v2.11.X/a7e02e/"},{name:"v-311061b4",path:"/pages/v2.11.X/46bbed/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-311061b4").then(t)}},{path:"/pages/v2.11.X/46bbed/index.html",redirect:"/pages/v2.11.X/46bbed/"},{path:"/08.v2.11.X文档/100.🎨高级特性/170.自定义组件执行器.html",redirect:"/pages/v2.11.X/46bbed/"},{name:"v-b12717cc",path:"/pages/v2.11.X/7280ea/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b12717cc").then(t)}},{path:"/pages/v2.11.X/7280ea/index.html",redirect:"/pages/v2.11.X/7280ea/"},{path:"/08.v2.11.X文档/100.🎨高级特性/160.异步线程池自定义.html",redirect:"/pages/v2.11.X/7280ea/"},{name:"v-52828b4c",path:"/pages/v2.11.X/81cdce/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-52828b4c").then(t)}},{path:"/pages/v2.11.X/81cdce/index.html",redirect:"/pages/v2.11.X/81cdce/"},{path:"/08.v2.11.X文档/110.⛱测试用例以及示例/010.测试用例.html",redirect:"/pages/v2.11.X/81cdce/"},{name:"v-27ae08a2",path:"/pages/v2.11.X/e59f3a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-27ae08a2").then(t)}},{path:"/pages/v2.11.X/e59f3a/index.html",redirect:"/pages/v2.11.X/e59f3a/"},{path:"/08.v2.11.X文档/100.🎨高级特性/180.简单监控.html",redirect:"/pages/v2.11.X/e59f3a/"},{name:"v-ab917da4",path:"/pages/v2.11.X/0066ae/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ab917da4").then(t)}},{path:"/pages/v2.11.X/0066ae/index.html",redirect:"/pages/v2.11.X/0066ae/"},{path:"/08.v2.11.X文档/100.🎨高级特性/190.XML的DTD.html",redirect:"/pages/v2.11.X/0066ae/"},{name:"v-198329e5",path:"/pages/v2.11.X/0a8188/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-198329e5").then(t)}},{path:"/pages/v2.11.X/0a8188/index.html",redirect:"/pages/v2.11.X/0a8188/"},{path:"/08.v2.11.X文档/110.⛱测试用例以及示例/020.DEMO案例.html",redirect:"/pages/v2.11.X/0a8188/"},{name:"v-63e8ef03",path:"/pages/v2.11.X/9bf839/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-63e8ef03").then(t)}},{path:"/pages/v2.11.X/9bf839/index.html",redirect:"/pages/v2.11.X/9bf839/"},{path:"/08.v2.11.X文档/120.性能表现.html",redirect:"/pages/v2.11.X/9bf839/"},{name:"v-44f62f41",path:"/pages/v2.10.X/5816c5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-44f62f41").then(t)}},{path:"/pages/v2.10.X/5816c5/index.html",redirect:"/pages/v2.10.X/5816c5/"},{path:"/09.v2.10.X文档/010.LiteFlow简介.html",redirect:"/pages/v2.10.X/5816c5/"},{name:"v-3286cc9a",path:"/pages/v2.10.X/7cf080/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3286cc9a").then(t)}},{path:"/pages/v2.10.X/7cf080/index.html",redirect:"/pages/v2.10.X/7cf080/"},{path:"/09.v2.10.X文档/021.🧁环境支持/010.JDK支持度.html",redirect:"/pages/v2.10.X/7cf080/"},{name:"v-52af8ef6",path:"/pages/v2.10.X/891e0f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-52af8ef6").then(t)}},{path:"/pages/v2.10.X/891e0f/index.html",redirect:"/pages/v2.10.X/891e0f/"},{path:"/09.v2.10.X文档/021.🧁环境支持/020.Springboot支持度.html",redirect:"/pages/v2.10.X/891e0f/"},{name:"v-4619bcf3",path:"/pages/v2.10.X/724bc3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4619bcf3").then(t)}},{path:"/pages/v2.10.X/724bc3/index.html",redirect:"/pages/v2.10.X/724bc3/"},{path:"/09.v2.10.X文档/020.项目特性.html",redirect:"/pages/v2.10.X/724bc3/"},{name:"v-4a32cd40",path:"/pages/v2.10.X/df6982/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4a32cd40").then(t)}},{path:"/pages/v2.10.X/df6982/index.html",redirect:"/pages/v2.10.X/df6982/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.html",redirect:"/pages/v2.10.X/df6982/"},{name:"v-6684958c",path:"/pages/v2.10.X/631fa1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6684958c").then(t)}},{path:"/pages/v2.10.X/631fa1/index.html",redirect:"/pages/v2.10.X/631fa1/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/005.说明.html",redirect:"/pages/v2.10.X/631fa1/"},{name:"v-33214e62",path:"/pages/v2.10.X/2d12db/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-33214e62").then(t)}},{path:"/pages/v2.10.X/2d12db/index.html",redirect:"/pages/v2.10.X/2d12db/"},{path:"/09.v2.10.X文档/021.🧁环境支持/030.Spring的支持度.html",redirect:"/pages/v2.10.X/2d12db/"},{name:"v-4134aa26",path:"/pages/v2.10.X/495f21/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4134aa26").then(t)}},{path:"/pages/v2.10.X/495f21/index.html",redirect:"/pages/v2.10.X/495f21/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.html",redirect:"/pages/v2.10.X/495f21/"},{name:"v-f93a7194",path:"/pages/v2.10.X/522432/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f93a7194").then(t)}},{path:"/pages/v2.10.X/522432/index.html",redirect:"/pages/v2.10.X/522432/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.html",redirect:"/pages/v2.10.X/522432/"},{name:"v-2df4f91b",path:"/pages/v2.10.X/0a4573/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2df4f91b").then(t)}},{path:"/pages/v2.10.X/0a4573/index.html",redirect:"/pages/v2.10.X/0a4573/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.html",redirect:"/pages/v2.10.X/0a4573/"},{name:"v-4da4c309",path:"/pages/v2.10.X/0e0fb5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4da4c309").then(t)}},{path:"/pages/v2.10.X/0e0fb5/index.html",redirect:"/pages/v2.10.X/0e0fb5/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.html",redirect:"/pages/v2.10.X/0e0fb5/"},{name:"v-5720f4ae",path:"/pages/v2.10.X/8760c4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5720f4ae").then(t)}},{path:"/pages/v2.10.X/8760c4/index.html",redirect:"/pages/v2.10.X/8760c4/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.html",redirect:"/pages/v2.10.X/8760c4/"},{name:"v-72ee2b64",path:"/pages/v2.10.X/9f4489/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-72ee2b64").then(t)}},{path:"/pages/v2.10.X/9f4489/index.html",redirect:"/pages/v2.10.X/9f4489/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.html",redirect:"/pages/v2.10.X/9f4489/"},{name:"v-14f04b39",path:"/pages/v2.10.X/249d17/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-14f04b39").then(t)}},{path:"/pages/v2.10.X/249d17/index.html",redirect:"/pages/v2.10.X/249d17/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.html",redirect:"/pages/v2.10.X/249d17/"},{name:"v-0495d39c",path:"/pages/v2.10.X/151524/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0495d39c").then(t)}},{path:"/pages/v2.10.X/151524/index.html",redirect:"/pages/v2.10.X/151524/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.html",redirect:"/pages/v2.10.X/151524/"},{name:"v-6a8e583a",path:"/pages/v2.10.X/4594ec/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6a8e583a").then(t)}},{path:"/pages/v2.10.X/4594ec/index.html",redirect:"/pages/v2.10.X/4594ec/"},{path:"/09.v2.10.X文档/040.🍢配置项/020.Springboot下的配置项.html",redirect:"/pages/v2.10.X/4594ec/"},{name:"v-0649d22a",path:"/pages/v2.10.X/82ef41/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0649d22a").then(t)}},{path:"/pages/v2.10.X/82ef41/index.html",redirect:"/pages/v2.10.X/82ef41/"},{path:"/09.v2.10.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.html",redirect:"/pages/v2.10.X/82ef41/"},{name:"v-1b865381",path:"/pages/v2.10.X/33833a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1b865381").then(t)}},{path:"/pages/v2.10.X/33833a/index.html",redirect:"/pages/v2.10.X/33833a/"},{path:"/09.v2.10.X文档/040.🍢配置项/030.Spring下的配置项.html",redirect:"/pages/v2.10.X/33833a/"},{name:"v-de41190e",path:"/pages/v2.10.X/b70ec8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-de41190e").then(t)}},{path:"/pages/v2.10.X/b70ec8/index.html",redirect:"/pages/v2.10.X/b70ec8/"},{path:"/09.v2.10.X文档/040.🍢配置项/010.说明.html",redirect:"/pages/v2.10.X/b70ec8/"},{name:"v-998e39f0",path:"/pages/v2.10.X/6fa87e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-998e39f0").then(t)}},{path:"/pages/v2.10.X/6fa87e/index.html",redirect:"/pages/v2.10.X/6fa87e/"},{path:"/09.v2.10.X文档/050.🗂规则文件/010.规则文件格式.html",redirect:"/pages/v2.10.X/6fa87e/"},{name:"v-d8bbe23a",path:"/pages/v2.10.X/b5065a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d8bbe23a").then(t)}},{path:"/pages/v2.10.X/b5065a/index.html",redirect:"/pages/v2.10.X/b5065a/"},{path:"/09.v2.10.X文档/040.🍢配置项/040.其他场景代码设置配置项.html",redirect:"/pages/v2.10.X/b5065a/"},{name:"v-66880172",path:"/pages/v2.10.X/51ddd5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-66880172").then(t)}},{path:"/pages/v2.10.X/51ddd5/index.html",redirect:"/pages/v2.10.X/51ddd5/"},{path:"/09.v2.10.X文档/050.🗂规则文件/020.本地规则文件配置.html",redirect:"/pages/v2.10.X/51ddd5/"},{name:"v-07c11cbe",path:"/pages/v2.10.X/ffc345/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-07c11cbe").then(t)}},{path:"/pages/v2.10.X/ffc345/index.html",redirect:"/pages/v2.10.X/ffc345/"},{path:"/09.v2.10.X文档/050.🗂规则文件/030.ZK规则文件配置源.html",redirect:"/pages/v2.10.X/ffc345/"},{name:"v-ee1a7b9a",path:"/pages/v2.10.X/236b4f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ee1a7b9a").then(t)}},{path:"/pages/v2.10.X/236b4f/index.html",redirect:"/pages/v2.10.X/236b4f/"},{path:"/09.v2.10.X文档/050.🗂规则文件/040.SQL数据库配置源.html",redirect:"/pages/v2.10.X/236b4f/"},{name:"v-28e1b734",path:"/pages/v2.10.X/09b776/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-28e1b734").then(t)}},{path:"/pages/v2.10.X/09b776/index.html",redirect:"/pages/v2.10.X/09b776/"},{path:"/09.v2.10.X文档/050.🗂规则文件/050.Nacos配置源.html",redirect:"/pages/v2.10.X/09b776/"},{name:"v-028dfb44",path:"/pages/v2.10.X/4bfac2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-028dfb44").then(t)}},{path:"/pages/v2.10.X/4bfac2/index.html",redirect:"/pages/v2.10.X/4bfac2/"},{path:"/09.v2.10.X文档/050.🗂规则文件/060.Etcd配置源.html",redirect:"/pages/v2.10.X/4bfac2/"},{name:"v-c096ecc4",path:"/pages/v2.10.X/bea809/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c096ecc4").then(t)}},{path:"/pages/v2.10.X/bea809/index.html",redirect:"/pages/v2.10.X/bea809/"},{path:"/09.v2.10.X文档/050.🗂规则文件/065.Apollo配置源.html",redirect:"/pages/v2.10.X/bea809/"},{name:"v-0e6c4db8",path:"/pages/v2.10.X/c0f5d7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0e6c4db8").then(t)}},{path:"/pages/v2.10.X/c0f5d7/index.html",redirect:"/pages/v2.10.X/c0f5d7/"},{path:"/09.v2.10.X文档/055.🔗常规组件/020.选择组件.html",redirect:"/pages/v2.10.X/c0f5d7/"},{name:"v-c254747e",path:"/pages/v2.10.X/8486fb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c254747e").then(t)}},{path:"/pages/v2.10.X/8486fb/index.html",redirect:"/pages/v2.10.X/8486fb/"},{path:"/09.v2.10.X文档/055.🔗常规组件/010.普通组件.html",redirect:"/pages/v2.10.X/8486fb/"},{name:"v-020f2d3f",path:"/pages/v2.10.X/25f2c0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-020f2d3f").then(t)}},{path:"/pages/v2.10.X/25f2c0/index.html",redirect:"/pages/v2.10.X/25f2c0/"},{path:"/09.v2.10.X文档/050.🗂规则文件/070.自定义配置源.html",redirect:"/pages/v2.10.X/25f2c0/"},{name:"v-21cafeb6",path:"/pages/v2.10.X/cb0b59/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21cafeb6").then(t)}},{path:"/pages/v2.10.X/cb0b59/index.html",redirect:"/pages/v2.10.X/cb0b59/"},{path:"/09.v2.10.X文档/055.🔗常规组件/030.条件组件.html",redirect:"/pages/v2.10.X/cb0b59/"},{name:"v-bd527bfe",path:"/pages/v2.10.X/5f971f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-bd527bfe").then(t)}},{path:"/pages/v2.10.X/5f971f/index.html",redirect:"/pages/v2.10.X/5f971f/"},{path:"/09.v2.10.X文档/055.🔗常规组件/040.次数循环组件.html",redirect:"/pages/v2.10.X/5f971f/"},{name:"v-da7a4520",path:"/pages/v2.10.X/e6995e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-da7a4520").then(t)}},{path:"/pages/v2.10.X/e6995e/index.html",redirect:"/pages/v2.10.X/e6995e/"},{path:"/09.v2.10.X文档/055.🔗常规组件/050.条件循环组件.html",redirect:"/pages/v2.10.X/e6995e/"},{name:"v-59e3eeba",path:"/pages/v2.10.X/c078cd/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-59e3eeba").then(t)}},{path:"/pages/v2.10.X/c078cd/index.html",redirect:"/pages/v2.10.X/c078cd/"},{path:"/09.v2.10.X文档/055.🔗常规组件/060.退出循环组件.html",redirect:"/pages/v2.10.X/c078cd/"},{name:"v-edcedb12",path:"/pages/v2.10.X/64262b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-edcedb12").then(t)}},{path:"/pages/v2.10.X/64262b/index.html",redirect:"/pages/v2.10.X/64262b/"},{path:"/09.v2.10.X文档/055.🔗常规组件/055.迭代循环组件.html",redirect:"/pages/v2.10.X/64262b/"},{name:"v-62a234fd",path:"/pages/v2.10.X/16eca9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-62a234fd").then(t)}},{path:"/pages/v2.10.X/16eca9/index.html",redirect:"/pages/v2.10.X/16eca9/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/010.说明.html",redirect:"/pages/v2.10.X/16eca9/"},{name:"v-c16515b8",path:"/pages/v2.10.X/b3446a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c16515b8").then(t)}},{path:"/pages/v2.10.X/b3446a/index.html",redirect:"/pages/v2.10.X/b3446a/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/030.并行编排.html",redirect:"/pages/v2.10.X/b3446a/"},{name:"v-069fc664",path:"/pages/v2.10.X/a590ee/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-069fc664").then(t)}},{path:"/pages/v2.10.X/a590ee/index.html",redirect:"/pages/v2.10.X/a590ee/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/020.串行编排.html",redirect:"/pages/v2.10.X/a590ee/"},{name:"v-2027f4d7",path:"/pages/v2.10.X/e76999/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2027f4d7").then(t)}},{path:"/pages/v2.10.X/e76999/index.html",redirect:"/pages/v2.10.X/e76999/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/045.条件编排.html",redirect:"/pages/v2.10.X/e76999/"},{name:"v-6777b86d",path:"/pages/v2.10.X/d90483/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6777b86d").then(t)}},{path:"/pages/v2.10.X/d90483/index.html",redirect:"/pages/v2.10.X/d90483/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/040.选择编排.html",redirect:"/pages/v2.10.X/d90483/"},{name:"v-0a775c97",path:"/pages/v2.10.X/fbf715/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0a775c97").then(t)}},{path:"/pages/v2.10.X/fbf715/index.html",redirect:"/pages/v2.10.X/fbf715/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/046.循环编排.html",redirect:"/pages/v2.10.X/fbf715/"},{name:"v-4a6ef0ef",path:"/pages/v2.10.X/f53b51/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4a6ef0ef").then(t)}},{path:"/pages/v2.10.X/f53b51/index.html",redirect:"/pages/v2.10.X/f53b51/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/047.捕获异常表达式.html",redirect:"/pages/v2.10.X/f53b51/"},{name:"v-4812c664",path:"/pages/v2.10.X/a8b344/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4812c664").then(t)}},{path:"/pages/v2.10.X/a8b344/index.html",redirect:"/pages/v2.10.X/a8b344/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/048.与或非表达式.html",redirect:"/pages/v2.10.X/a8b344/"},{name:"v-55515dc4",path:"/pages/v2.10.X/71ff49/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-55515dc4").then(t)}},{path:"/pages/v2.10.X/71ff49/index.html",redirect:"/pages/v2.10.X/71ff49/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/060.使用子变量.html",redirect:"/pages/v2.10.X/71ff49/"},{name:"v-4059e604",path:"/pages/v2.10.X/5156b3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4059e604").then(t)}},{path:"/pages/v2.10.X/5156b3/index.html",redirect:"/pages/v2.10.X/5156b3/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/070.复杂编排例子.html",redirect:"/pages/v2.10.X/5156b3/"},{name:"v-b3dfd986",path:"/pages/v2.10.X/dc5df7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b3dfd986").then(t)}},{path:"/pages/v2.10.X/dc5df7/index.html",redirect:"/pages/v2.10.X/dc5df7/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/050.使用子流程.html",redirect:"/pages/v2.10.X/dc5df7/"},{name:"v-e65234e8",path:"/pages/v2.10.X/af44a6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e65234e8").then(t)}},{path:"/pages/v2.10.X/af44a6/index.html",redirect:"/pages/v2.10.X/af44a6/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/080.关于分号.html",redirect:"/pages/v2.10.X/af44a6/"},{name:"v-1ec8f1bf",path:"/pages/v2.10.X/f3dc09/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1ec8f1bf").then(t)}},{path:"/pages/v2.10.X/f3dc09/index.html",redirect:"/pages/v2.10.X/f3dc09/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/090.关于注释.html",redirect:"/pages/v2.10.X/f3dc09/"},{name:"v-998e0c66",path:"/pages/v2.10.X/395fd0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-998e0c66").then(t)}},{path:"/pages/v2.10.X/395fd0/index.html",redirect:"/pages/v2.10.X/395fd0/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/110.验证规则.html",redirect:"/pages/v2.10.X/395fd0/"},{name:"v-2f9e7ad0",path:"/pages/v2.10.X/2df3d9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2f9e7ad0").then(t)}},{path:"/pages/v2.10.X/2df3d9/index.html",redirect:"/pages/v2.10.X/2df3d9/"},{path:"/09.v2.10.X文档/060.🧩EL规则的写法/100.组件名包装.html",redirect:"/pages/v2.10.X/2df3d9/"},{name:"v-728c7bd6",path:"/pages/v2.10.X/501abf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-728c7bd6").then(t)}},{path:"/pages/v2.10.X/501abf/index.html",redirect:"/pages/v2.10.X/501abf/"},{path:"/09.v2.10.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.html",redirect:"/pages/v2.10.X/501abf/"},{name:"v-566b0654",path:"/pages/v2.10.X/f05ed6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-566b0654").then(t)}},{path:"/pages/v2.10.X/f05ed6/index.html",redirect:"/pages/v2.10.X/f05ed6/"},{path:"/09.v2.10.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.html",redirect:"/pages/v2.10.X/f05ed6/"},{name:"v-21b7443f",path:"/pages/v2.10.X/90b2a5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21b7443f").then(t)}},{path:"/pages/v2.10.X/90b2a5/index.html",redirect:"/pages/v2.10.X/90b2a5/"},{path:"/09.v2.10.X文档/080.🛩执行器/010.说明.html",redirect:"/pages/v2.10.X/90b2a5/"},{name:"v-683cb17a",path:"/pages/v2.10.X/74b4bf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-683cb17a").then(t)}},{path:"/pages/v2.10.X/74b4bf/index.html",redirect:"/pages/v2.10.X/74b4bf/"},{path:"/09.v2.10.X文档/070.🌮数据上下文/010.说明.html",redirect:"/pages/v2.10.X/74b4bf/"},{name:"v-4501950c",path:"/pages/v2.10.X/20072e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4501950c").then(t)}},{path:"/pages/v2.10.X/20072e/index.html",redirect:"/pages/v2.10.X/20072e/"},{path:"/09.v2.10.X文档/080.🛩执行器/020.执行方法.html",redirect:"/pages/v2.10.X/20072e/"},{name:"v-cafc7acc",path:"/pages/v2.10.X/9f653d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cafc7acc").then(t)}},{path:"/pages/v2.10.X/9f653d/index.html",redirect:"/pages/v2.10.X/9f653d/"},{path:"/09.v2.10.X文档/080.🛩执行器/040.LiteflowResponse对象.html",redirect:"/pages/v2.10.X/9f653d/"},{name:"v-cc361230",path:"/pages/v2.10.X/563b67/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cc361230").then(t)}},{path:"/pages/v2.10.X/563b67/index.html",redirect:"/pages/v2.10.X/563b67/"},{path:"/09.v2.10.X文档/080.🛩执行器/030.流程入参.html",redirect:"/pages/v2.10.X/563b67/"},{name:"v-4c3a5f6c",path:"/pages/v2.10.X/bd70f7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4c3a5f6c").then(t)}},{path:"/pages/v2.10.X/bd70f7/index.html",redirect:"/pages/v2.10.X/bd70f7/"},{path:"/09.v2.10.X文档/085.🍋脚本组件/010.选择脚本语言.html",redirect:"/pages/v2.10.X/bd70f7/"},{name:"v-53e924a7",path:"/pages/v2.10.X/81d53c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-53e924a7").then(t)}},{path:"/pages/v2.10.X/81d53c/index.html",redirect:"/pages/v2.10.X/81d53c/"},{path:"/09.v2.10.X文档/085.🍋脚本组件/020.定义脚本组件.html",redirect:"/pages/v2.10.X/81d53c/"},{name:"v-3ea3508a",path:"/pages/v2.10.X/acba2c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3ea3508a").then(t)}},{path:"/pages/v2.10.X/acba2c/index.html",redirect:"/pages/v2.10.X/acba2c/"},{path:"/09.v2.10.X文档/085.🍋脚本组件/025.多脚本语言混合共存.html",redirect:"/pages/v2.10.X/acba2c/"},{name:"v-d9f3db50",path:"/pages/v2.10.X/f7acfd/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d9f3db50").then(t)}},{path:"/pages/v2.10.X/f7acfd/index.html",redirect:"/pages/v2.10.X/f7acfd/"},{path:"/09.v2.10.X文档/085.🍋脚本组件/030.文件脚本的定义.html",redirect:"/pages/v2.10.X/f7acfd/"},{name:"v-081f5879",path:"/pages/v2.10.X/cbcb14/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-081f5879").then(t)}},{path:"/pages/v2.10.X/cbcb14/index.html",redirect:"/pages/v2.10.X/cbcb14/"},{path:"/09.v2.10.X文档/085.🍋脚本组件/050.动态刷新脚本.html",redirect:"/pages/v2.10.X/cbcb14/"},{name:"v-70ba750c",path:"/pages/v2.10.X/d861c8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-70ba750c").then(t)}},{path:"/pages/v2.10.X/d861c8/index.html",redirect:"/pages/v2.10.X/d861c8/"},{path:"/09.v2.10.X文档/085.🍋脚本组件/040.脚本与Java进行交互.html",redirect:"/pages/v2.10.X/d861c8/"},{name:"v-5a76da12",path:"/pages/v2.10.X/46f0fa/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5a76da12").then(t)}},{path:"/pages/v2.10.X/46f0fa/index.html",redirect:"/pages/v2.10.X/46f0fa/"},{path:"/09.v2.10.X文档/086.🍇声明式组件/010.什么叫声明式组件.html",redirect:"/pages/v2.10.X/46f0fa/"},{name:"v-ebf01650",path:"/pages/v2.10.X/797830/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ebf01650").then(t)}},{path:"/pages/v2.10.X/797830/index.html",redirect:"/pages/v2.10.X/797830/"},{path:"/09.v2.10.X文档/086.🍇声明式组件/030.方法级别式声明.html",redirect:"/pages/v2.10.X/797830/"},{name:"v-31418c47",path:"/pages/v2.10.X/9aa85a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-31418c47").then(t)}},{path:"/pages/v2.10.X/9aa85a/index.html",redirect:"/pages/v2.10.X/9aa85a/"},{path:"/09.v2.10.X文档/090.🎲用代码动态构造规则/010.说明.html",redirect:"/pages/v2.10.X/9aa85a/"},{name:"v-7c2126fd",path:"/pages/v2.10.X/6bc8fe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7c2126fd").then(t)}},{path:"/pages/v2.10.X/6bc8fe/index.html",redirect:"/pages/v2.10.X/6bc8fe/"},{path:"/09.v2.10.X文档/090.🎲用代码动态构造规则/020.如何构造.html",redirect:"/pages/v2.10.X/6bc8fe/"},{name:"v-0eab1988",path:"/pages/v2.10.X/18f548/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0eab1988").then(t)}},{path:"/pages/v2.10.X/18f548/index.html",redirect:"/pages/v2.10.X/18f548/"},{path:"/09.v2.10.X文档/086.🍇声明式组件/020.类级别式声明.html",redirect:"/pages/v2.10.X/18f548/"},{name:"v-2c6bf293",path:"/pages/v2.10.X/9f93be/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2c6bf293").then(t)}},{path:"/pages/v2.10.X/9f93be/index.html",redirect:"/pages/v2.10.X/9f93be/"},{path:"/09.v2.10.X文档/100.🎨高级特性/030.前置和后置组件.html",redirect:"/pages/v2.10.X/9f93be/"},{name:"v-219649a8",path:"/pages/v2.10.X/f8aa79/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-219649a8").then(t)}},{path:"/pages/v2.10.X/f8aa79/index.html",redirect:"/pages/v2.10.X/f8aa79/"},{path:"/09.v2.10.X文档/100.🎨高级特性/031.本地规则文件监听.html",redirect:"/pages/v2.10.X/f8aa79/"},{name:"v-be426776",path:"/pages/v2.10.X/6e4d15/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-be426776").then(t)}},{path:"/pages/v2.10.X/6e4d15/index.html",redirect:"/pages/v2.10.X/6e4d15/"},{path:"/09.v2.10.X文档/100.🎨高级特性/036.组件参数.html",redirect:"/pages/v2.10.X/6e4d15/"},{name:"v-01f634c7",path:"/pages/v2.10.X/79289a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-01f634c7").then(t)}},{path:"/pages/v2.10.X/79289a/index.html",redirect:"/pages/v2.10.X/79289a/"},{path:"/09.v2.10.X文档/100.🎨高级特性/035.替补组件.html",redirect:"/pages/v2.10.X/79289a/"},{name:"v-4379ce02",path:"/pages/v2.10.X/0f788f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4379ce02").then(t)}},{path:"/pages/v2.10.X/0f788f/index.html",redirect:"/pages/v2.10.X/0f788f/"},{path:"/09.v2.10.X文档/100.🎨高级特性/050.组件标签.html",redirect:"/pages/v2.10.X/0f788f/"},{name:"v-47815516",path:"/pages/v2.10.X/92ef89/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-47815516").then(t)}},{path:"/pages/v2.10.X/92ef89/index.html",redirect:"/pages/v2.10.X/92ef89/"},{path:"/09.v2.10.X文档/100.🎨高级特性/040.组件别名.html",redirect:"/pages/v2.10.X/92ef89/"},{name:"v-220fd8c2",path:"/pages/v2.10.X/3ee755/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-220fd8c2").then(t)}},{path:"/pages/v2.10.X/3ee755/index.html",redirect:"/pages/v2.10.X/3ee755/"},{path:"/09.v2.10.X文档/100.🎨高级特性/060.组件事件回调.html",redirect:"/pages/v2.10.X/3ee755/"},{name:"v-8df99436",path:"/pages/v2.10.X/80e873/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8df99436").then(t)}},{path:"/pages/v2.10.X/80e873/index.html",redirect:"/pages/v2.10.X/80e873/"},{path:"/09.v2.10.X文档/100.🎨高级特性/070.隐式子流程.html",redirect:"/pages/v2.10.X/80e873/"},{name:"v-1cd3027c",path:"/pages/v2.10.X/fbb938/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1cd3027c").then(t)}},{path:"/pages/v2.10.X/fbb938/index.html",redirect:"/pages/v2.10.X/fbb938/"},{path:"/09.v2.10.X文档/100.🎨高级特性/080.私有投递.html",redirect:"/pages/v2.10.X/fbb938/"},{name:"v-ef2e77de",path:"/pages/v2.10.X/7e9da1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ef2e77de").then(t)}},{path:"/pages/v2.10.X/7e9da1/index.html",redirect:"/pages/v2.10.X/7e9da1/"},{path:"/09.v2.10.X文档/100.🎨高级特性/090.组件重试.html",redirect:"/pages/v2.10.X/7e9da1/"},{name:"v-1f8d82d2",path:"/pages/v2.10.X/204d71/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1f8d82d2").then(t)}},{path:"/pages/v2.10.X/204d71/index.html",redirect:"/pages/v2.10.X/204d71/"},{path:"/09.v2.10.X文档/100.🎨高级特性/100.平滑热刷新.html",redirect:"/pages/v2.10.X/204d71/"},{name:"v-534f7b4e",path:"/pages/v2.10.X/2373f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-534f7b4e").then(t)}},{path:"/pages/v2.10.X/2373f5/index.html",redirect:"/pages/v2.10.X/2373f5/"},{path:"/09.v2.10.X文档/100.🎨高级特性/110.组件切面.html",redirect:"/pages/v2.10.X/2373f5/"},{name:"v-6b3ce286",path:"/pages/v2.10.X/dc9bfe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6b3ce286").then(t)}},{path:"/pages/v2.10.X/dc9bfe/index.html",redirect:"/pages/v2.10.X/dc9bfe/"},{path:"/09.v2.10.X文档/100.🎨高级特性/125.异常.html",redirect:"/pages/v2.10.X/dc9bfe/"},{name:"v-69816759",path:"/pages/v2.10.X/4d614c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-69816759").then(t)}},{path:"/pages/v2.10.X/4d614c/index.html",redirect:"/pages/v2.10.X/4d614c/"},{path:"/09.v2.10.X文档/100.🎨高级特性/130.打印信息详解.html",redirect:"/pages/v2.10.X/4d614c/"},{name:"v-778d22f4",path:"/pages/v2.10.X/47e8f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-778d22f4").then(t)}},{path:"/pages/v2.10.X/47e8f5/index.html",redirect:"/pages/v2.10.X/47e8f5/"},{path:"/09.v2.10.X文档/100.🎨高级特性/140.自定义请求Id.html",redirect:"/pages/v2.10.X/47e8f5/"},{name:"v-b8a34636",path:"/pages/v2.10.X/e5ed0d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b8a34636").then(t)}},{path:"/pages/v2.10.X/e5ed0d/index.html",redirect:"/pages/v2.10.X/e5ed0d/"},{path:"/09.v2.10.X文档/100.🎨高级特性/120.步骤信息.html",redirect:"/pages/v2.10.X/e5ed0d/"},{name:"v-3ca62d9a",path:"/pages/v2.10.X/7280ea/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3ca62d9a").then(t)}},{path:"/pages/v2.10.X/7280ea/index.html",redirect:"/pages/v2.10.X/7280ea/"},{path:"/09.v2.10.X文档/100.🎨高级特性/160.异步线程池自定义.html",redirect:"/pages/v2.10.X/7280ea/"},{name:"v-4c2fc162",path:"/pages/v2.10.X/a7e02e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4c2fc162").then(t)}},{path:"/pages/v2.10.X/a7e02e/index.html",redirect:"/pages/v2.10.X/a7e02e/"},{path:"/09.v2.10.X文档/100.🎨高级特性/150.不同格式规则加载.html",redirect:"/pages/v2.10.X/a7e02e/"},{name:"v-7cb188a6",path:"/pages/v2.10.X/46bbed/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7cb188a6").then(t)}},{path:"/pages/v2.10.X/46bbed/index.html",redirect:"/pages/v2.10.X/46bbed/"},{path:"/09.v2.10.X文档/100.🎨高级特性/170.自定义组件执行器.html",redirect:"/pages/v2.10.X/46bbed/"},{name:"v-58c1192e",path:"/pages/v2.10.X/0066ae/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-58c1192e").then(t)}},{path:"/pages/v2.10.X/0066ae/index.html",redirect:"/pages/v2.10.X/0066ae/"},{path:"/09.v2.10.X文档/100.🎨高级特性/190.XML的DTD.html",redirect:"/pages/v2.10.X/0066ae/"},{name:"v-18a455a2",path:"/pages/v2.10.X/e59f3a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-18a455a2").then(t)}},{path:"/pages/v2.10.X/e59f3a/index.html",redirect:"/pages/v2.10.X/e59f3a/"},{path:"/09.v2.10.X文档/100.🎨高级特性/180.简单监控.html",redirect:"/pages/v2.10.X/e59f3a/"},{name:"v-173c1703",path:"/pages/v2.10.X/9bf839/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-173c1703").then(t)}},{path:"/pages/v2.10.X/9bf839/index.html",redirect:"/pages/v2.10.X/9bf839/"},{path:"/09.v2.10.X文档/120.性能表现.html",redirect:"/pages/v2.10.X/9bf839/"},{name:"v-1c465c36",path:"/pages/v2.10.X/0a8188/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1c465c36").then(t)}},{path:"/pages/v2.10.X/0a8188/index.html",redirect:"/pages/v2.10.X/0a8188/"},{path:"/09.v2.10.X文档/110.⛱测试用例以及示例/020.DEMO案例.html",redirect:"/pages/v2.10.X/0a8188/"},{name:"v-6712db4c",path:"/pages/v2.10.X/81cdce/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6712db4c").then(t)}},{path:"/pages/v2.10.X/81cdce/index.html",redirect:"/pages/v2.10.X/81cdce/"},{path:"/09.v2.10.X文档/110.⛱测试用例以及示例/010.测试用例.html",redirect:"/pages/v2.10.X/81cdce/"},{name:"v-1ca17a9a",path:"/pages/v2.9.X/724bc3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1ca17a9a").then(t)}},{path:"/pages/v2.9.X/724bc3/index.html",redirect:"/pages/v2.9.X/724bc3/"},{path:"/10.v2.9.X文档/020.项目特性.html",redirect:"/pages/v2.9.X/724bc3/"},{name:"v-7f5f767c",path:"/pages/v2.9.X/631fa1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7f5f767c").then(t)}},{path:"/pages/v2.9.X/631fa1/index.html",redirect:"/pages/v2.9.X/631fa1/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/005.说明.html",redirect:"/pages/v2.9.X/631fa1/"},{name:"v-2d84a4c2",path:"/pages/v2.9.X/df6982/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2d84a4c2").then(t)}},{path:"/pages/v2.9.X/df6982/index.html",redirect:"/pages/v2.9.X/df6982/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.html",redirect:"/pages/v2.9.X/df6982/"},{name:"v-efb3dfca",path:"/pages/v2.9.X/5816c5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-efb3dfca").then(t)}},{path:"/pages/v2.9.X/5816c5/index.html",redirect:"/pages/v2.9.X/5816c5/"},{path:"/10.v2.9.X文档/010.LiteFlow简介.html",redirect:"/pages/v2.9.X/5816c5/"},{name:"v-22ef70cc",path:"/pages/v2.9.X/9f4489/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-22ef70cc").then(t)}},{path:"/pages/v2.9.X/9f4489/index.html",redirect:"/pages/v2.9.X/9f4489/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.html",redirect:"/pages/v2.9.X/9f4489/"},{name:"v-078be602",path:"/pages/v2.9.X/82ef41/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-078be602").then(t)}},{path:"/pages/v2.9.X/82ef41/index.html",redirect:"/pages/v2.9.X/82ef41/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.html",redirect:"/pages/v2.9.X/82ef41/"},{name:"v-14b837d0",path:"/pages/v2.9.X/495f21/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-14b837d0").then(t)}},{path:"/pages/v2.9.X/495f21/index.html",redirect:"/pages/v2.9.X/495f21/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.html",redirect:"/pages/v2.9.X/495f21/"},{name:"v-402e1f5b",path:"/pages/v2.9.X/0a4573/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-402e1f5b").then(t)}},{path:"/pages/v2.9.X/0a4573/index.html",redirect:"/pages/v2.9.X/0a4573/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.html",redirect:"/pages/v2.9.X/0a4573/"},{name:"v-27124f30",path:"/pages/v2.9.X/522432/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-27124f30").then(t)}},{path:"/pages/v2.9.X/522432/index.html",redirect:"/pages/v2.9.X/522432/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.html",redirect:"/pages/v2.9.X/522432/"},{name:"v-050f5b36",path:"/pages/v2.9.X/0e0fb5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-050f5b36").then(t)}},{path:"/pages/v2.9.X/0e0fb5/index.html",redirect:"/pages/v2.9.X/0e0fb5/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.html",redirect:"/pages/v2.9.X/0e0fb5/"},{name:"v-2e12cd9d",path:"/pages/v2.9.X/249d17/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2e12cd9d").then(t)}},{path:"/pages/v2.9.X/249d17/index.html",redirect:"/pages/v2.9.X/249d17/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.html",redirect:"/pages/v2.9.X/249d17/"},{name:"v-6685dc6a",path:"/pages/v2.9.X/151524/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6685dc6a").then(t)}},{path:"/pages/v2.9.X/151524/index.html",redirect:"/pages/v2.9.X/151524/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.html",redirect:"/pages/v2.9.X/151524/"},{name:"v-43114340",path:"/pages/v2.9.X/8760c4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-43114340").then(t)}},{path:"/pages/v2.9.X/8760c4/index.html",redirect:"/pages/v2.9.X/8760c4/"},{path:"/10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.html",redirect:"/pages/v2.9.X/8760c4/"},{name:"v-23aeb7c2",path:"/pages/v2.9.X/33833a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-23aeb7c2").then(t)}},{path:"/pages/v2.9.X/33833a/index.html",redirect:"/pages/v2.9.X/33833a/"},{path:"/10.v2.9.X文档/040.🍢配置项/030.Spring下的配置项.html",redirect:"/pages/v2.9.X/33833a/"},{name:"v-e76eefa2",path:"/pages/v2.9.X/b70ec8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e76eefa2").then(t)}},{path:"/pages/v2.9.X/b70ec8/index.html",redirect:"/pages/v2.9.X/b70ec8/"},{path:"/10.v2.9.X文档/040.🍢配置项/010.说明.html",redirect:"/pages/v2.9.X/b70ec8/"},{name:"v-2eb8bbff",path:"/pages/v2.9.X/4594ec/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2eb8bbff").then(t)}},{path:"/pages/v2.9.X/4594ec/index.html",redirect:"/pages/v2.9.X/4594ec/"},{path:"/10.v2.9.X文档/040.🍢配置项/020.Springboot下的配置项.html",redirect:"/pages/v2.9.X/4594ec/"},{name:"v-09f8dec5",path:"/pages/v2.9.X/b5065a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-09f8dec5").then(t)}},{path:"/pages/v2.9.X/b5065a/index.html",redirect:"/pages/v2.9.X/b5065a/"},{path:"/10.v2.9.X文档/040.🍢配置项/040.其他场景代码设置配置项.html",redirect:"/pages/v2.9.X/b5065a/"},{name:"v-a93c3458",path:"/pages/v2.9.X/6fa87e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a93c3458").then(t)}},{path:"/pages/v2.9.X/6fa87e/index.html",redirect:"/pages/v2.9.X/6fa87e/"},{path:"/10.v2.9.X文档/050.🗂规则文件/010.规则文件格式.html",redirect:"/pages/v2.9.X/6fa87e/"},{name:"v-36e19ec4",path:"/pages/v2.9.X/51ddd5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-36e19ec4").then(t)}},{path:"/pages/v2.9.X/51ddd5/index.html",redirect:"/pages/v2.9.X/51ddd5/"},{path:"/10.v2.9.X文档/050.🗂规则文件/020.本地规则文件配置.html",redirect:"/pages/v2.9.X/51ddd5/"},{name:"v-795964ca",path:"/pages/v2.9.X/ffc345/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-795964ca").then(t)}},{path:"/pages/v2.9.X/ffc345/index.html",redirect:"/pages/v2.9.X/ffc345/"},{path:"/10.v2.9.X文档/050.🗂规则文件/030.ZK规则文件配置源.html",redirect:"/pages/v2.9.X/ffc345/"},{name:"v-21f0ea1a",path:"/pages/v2.9.X/236b4f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21f0ea1a").then(t)}},{path:"/pages/v2.9.X/236b4f/index.html",redirect:"/pages/v2.9.X/236b4f/"},{path:"/10.v2.9.X文档/050.🗂规则文件/040.SQL数据库配置源.html",redirect:"/pages/v2.9.X/236b4f/"},{name:"v-c777c758",path:"/pages/v2.9.X/4bfac2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c777c758").then(t)}},{path:"/pages/v2.9.X/4bfac2/index.html",redirect:"/pages/v2.9.X/4bfac2/"},{path:"/10.v2.9.X文档/050.🗂规则文件/060.Etcd配置源.html",redirect:"/pages/v2.9.X/4bfac2/"},{name:"v-524263f0",path:"/pages/v2.9.X/bea809/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-524263f0").then(t)}},{path:"/pages/v2.9.X/bea809/index.html",redirect:"/pages/v2.9.X/bea809/"},{path:"/10.v2.9.X文档/050.🗂规则文件/065.Apollo配置源.html",redirect:"/pages/v2.9.X/bea809/"},{name:"v-6def73d0",path:"/pages/v2.9.X/09b776/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6def73d0").then(t)}},{path:"/pages/v2.9.X/09b776/index.html",redirect:"/pages/v2.9.X/09b776/"},{path:"/10.v2.9.X文档/050.🗂规则文件/050.Nacos配置源.html",redirect:"/pages/v2.9.X/09b776/"},{name:"v-554071f5",path:"/pages/v2.9.X/25f2c0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-554071f5").then(t)}},{path:"/pages/v2.9.X/25f2c0/index.html",redirect:"/pages/v2.9.X/25f2c0/"},{path:"/10.v2.9.X文档/050.🗂规则文件/070.自定义配置源.html",redirect:"/pages/v2.9.X/25f2c0/"},{name:"v-3950d9a7",path:"/pages/v2.9.X/8486fb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3950d9a7").then(t)}},{path:"/pages/v2.9.X/8486fb/index.html",redirect:"/pages/v2.9.X/8486fb/"},{path:"/10.v2.9.X文档/055.🔗常规组件/010.普通组件.html",redirect:"/pages/v2.9.X/8486fb/"},{name:"v-440b5bb0",path:"/pages/v2.9.X/c0f5d7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-440b5bb0").then(t)}},{path:"/pages/v2.9.X/c0f5d7/index.html",redirect:"/pages/v2.9.X/c0f5d7/"},{path:"/10.v2.9.X文档/055.🔗常规组件/020.选择组件.html",redirect:"/pages/v2.9.X/c0f5d7/"},{name:"v-1b6941c6",path:"/pages/v2.9.X/5f971f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1b6941c6").then(t)}},{path:"/pages/v2.9.X/5f971f/index.html",redirect:"/pages/v2.9.X/5f971f/"},{path:"/10.v2.9.X文档/055.🔗常规组件/040.次数循环组件.html",redirect:"/pages/v2.9.X/5f971f/"},{name:"v-4cfdd4d2",path:"/pages/v2.9.X/cb0b59/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4cfdd4d2").then(t)}},{path:"/pages/v2.9.X/cb0b59/index.html",redirect:"/pages/v2.9.X/cb0b59/"},{path:"/10.v2.9.X文档/055.🔗常规组件/030.条件组件.html",redirect:"/pages/v2.9.X/cb0b59/"},{name:"v-0edc713a",path:"/pages/v2.9.X/e6995e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0edc713a").then(t)}},{path:"/pages/v2.9.X/e6995e/index.html",redirect:"/pages/v2.9.X/e6995e/"},{path:"/10.v2.9.X文档/055.🔗常规组件/050.条件循环组件.html",redirect:"/pages/v2.9.X/e6995e/"},{name:"v-67317150",path:"/pages/v2.9.X/c078cd/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-67317150").then(t)}},{path:"/pages/v2.9.X/c078cd/index.html",redirect:"/pages/v2.9.X/c078cd/"},{path:"/10.v2.9.X文档/055.🔗常规组件/060.退出循环组件.html",redirect:"/pages/v2.9.X/c078cd/"},{name:"v-21f94fdd",path:"/pages/v2.9.X/16eca9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21f94fdd").then(t)}},{path:"/pages/v2.9.X/16eca9/index.html",redirect:"/pages/v2.9.X/16eca9/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/010.说明.html",redirect:"/pages/v2.9.X/16eca9/"},{name:"v-354ec439",path:"/pages/v2.9.X/64262b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-354ec439").then(t)}},{path:"/pages/v2.9.X/64262b/index.html",redirect:"/pages/v2.9.X/64262b/"},{path:"/10.v2.9.X文档/055.🔗常规组件/055.迭代循环组件.html",redirect:"/pages/v2.9.X/64262b/"},{name:"v-56d7f860",path:"/pages/v2.9.X/b3446a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-56d7f860").then(t)}},{path:"/pages/v2.9.X/b3446a/index.html",redirect:"/pages/v2.9.X/b3446a/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/030.并行编排.html",redirect:"/pages/v2.9.X/b3446a/"},{name:"v-680d383a",path:"/pages/v2.9.X/d90483/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-680d383a").then(t)}},{path:"/pages/v2.9.X/d90483/index.html",redirect:"/pages/v2.9.X/d90483/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/040.选择编排.html",redirect:"/pages/v2.9.X/d90483/"},{name:"v-53b4cc2a",path:"/pages/v2.9.X/a590ee/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-53b4cc2a").then(t)}},{path:"/pages/v2.9.X/a590ee/index.html",redirect:"/pages/v2.9.X/a590ee/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/020.串行编排.html",redirect:"/pages/v2.9.X/a590ee/"},{name:"v-9475cda2",path:"/pages/v2.9.X/fbf715/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-9475cda2").then(t)}},{path:"/pages/v2.9.X/fbf715/index.html",redirect:"/pages/v2.9.X/fbf715/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/046.循环编排.html",redirect:"/pages/v2.9.X/fbf715/"},{name:"v-6f0f39a6",path:"/pages/v2.9.X/e76999/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6f0f39a6").then(t)}},{path:"/pages/v2.9.X/e76999/index.html",redirect:"/pages/v2.9.X/e76999/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/045.条件编排.html",redirect:"/pages/v2.9.X/e76999/"},{name:"v-91354242",path:"/pages/v2.9.X/dc5df7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-91354242").then(t)}},{path:"/pages/v2.9.X/dc5df7/index.html",redirect:"/pages/v2.9.X/dc5df7/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/050.使用子流程.html",redirect:"/pages/v2.9.X/dc5df7/"},{name:"v-8642e540",path:"/pages/v2.9.X/5156b3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8642e540").then(t)}},{path:"/pages/v2.9.X/5156b3/index.html",redirect:"/pages/v2.9.X/5156b3/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/070.复杂编排例子.html",redirect:"/pages/v2.9.X/5156b3/"},{name:"v-7731e1d0",path:"/pages/v2.9.X/71ff49/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7731e1d0").then(t)}},{path:"/pages/v2.9.X/71ff49/index.html",redirect:"/pages/v2.9.X/71ff49/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/060.使用子变量.html",redirect:"/pages/v2.9.X/71ff49/"},{name:"v-2142b61a",path:"/pages/v2.9.X/af44a6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2142b61a").then(t)}},{path:"/pages/v2.9.X/af44a6/index.html",redirect:"/pages/v2.9.X/af44a6/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/080.关于分号.html",redirect:"/pages/v2.9.X/af44a6/"},{name:"v-a9fc73ae",path:"/pages/v2.9.X/f3dc09/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a9fc73ae").then(t)}},{path:"/pages/v2.9.X/f3dc09/index.html",redirect:"/pages/v2.9.X/f3dc09/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/090.关于注释.html",redirect:"/pages/v2.9.X/f3dc09/"},{name:"v-b6f05fdc",path:"/pages/v2.9.X/2df3d9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b6f05fdc").then(t)}},{path:"/pages/v2.9.X/2df3d9/index.html",redirect:"/pages/v2.9.X/2df3d9/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/100.组件名包装.html",redirect:"/pages/v2.9.X/2df3d9/"},{name:"v-170cb6af",path:"/pages/v2.9.X/395fd0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-170cb6af").then(t)}},{path:"/pages/v2.9.X/395fd0/index.html",redirect:"/pages/v2.9.X/395fd0/"},{path:"/10.v2.9.X文档/060.🧩EL规则的写法/110.验证规则.html",redirect:"/pages/v2.9.X/395fd0/"},{name:"v-3fc46a1b",path:"/pages/v2.9.X/74b4bf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3fc46a1b").then(t)}},{path:"/pages/v2.9.X/74b4bf/index.html",redirect:"/pages/v2.9.X/74b4bf/"},{path:"/10.v2.9.X文档/070.🌮数据上下文/010.说明.html",redirect:"/pages/v2.9.X/74b4bf/"},{name:"v-5d4d5890",path:"/pages/v2.9.X/f05ed6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5d4d5890").then(t)}},{path:"/pages/v2.9.X/f05ed6/index.html",redirect:"/pages/v2.9.X/f05ed6/"},{path:"/10.v2.9.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.html",redirect:"/pages/v2.9.X/f05ed6/"},{name:"v-41af40b2",path:"/pages/v2.9.X/501abf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-41af40b2").then(t)}},{path:"/pages/v2.9.X/501abf/index.html",redirect:"/pages/v2.9.X/501abf/"},{path:"/10.v2.9.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.html",redirect:"/pages/v2.9.X/501abf/"},{name:"v-4eb00f52",path:"/pages/v2.9.X/90b2a5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4eb00f52").then(t)}},{path:"/pages/v2.9.X/90b2a5/index.html",redirect:"/pages/v2.9.X/90b2a5/"},{path:"/10.v2.9.X文档/080.🛩执行器/010.说明.html",redirect:"/pages/v2.9.X/90b2a5/"},{name:"v-3fa50058",path:"/pages/v2.9.X/20072e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3fa50058").then(t)}},{path:"/pages/v2.9.X/20072e/index.html",redirect:"/pages/v2.9.X/20072e/"},{path:"/10.v2.9.X文档/080.🛩执行器/020.执行方法.html",redirect:"/pages/v2.9.X/20072e/"},{name:"v-04e73544",path:"/pages/v2.9.X/bd70f7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-04e73544").then(t)}},{path:"/pages/v2.9.X/bd70f7/index.html",redirect:"/pages/v2.9.X/bd70f7/"},{path:"/10.v2.9.X文档/085.🍋脚本组件/010.选择脚本语言.html",redirect:"/pages/v2.9.X/bd70f7/"},{name:"v-13087c82",path:"/pages/v2.9.X/563b67/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-13087c82").then(t)}},{path:"/pages/v2.9.X/563b67/index.html",redirect:"/pages/v2.9.X/563b67/"},{path:"/10.v2.9.X文档/080.🛩执行器/030.流程入参.html",redirect:"/pages/v2.9.X/563b67/"},{name:"v-a6e7c306",path:"/pages/v2.9.X/81d53c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a6e7c306").then(t)}},{path:"/pages/v2.9.X/81d53c/index.html",redirect:"/pages/v2.9.X/81d53c/"},{path:"/10.v2.9.X文档/085.🍋脚本组件/020.定义脚本组件.html",redirect:"/pages/v2.9.X/81d53c/"},{name:"v-169395d6",path:"/pages/v2.9.X/9f653d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-169395d6").then(t)}},{path:"/pages/v2.9.X/9f653d/index.html",redirect:"/pages/v2.9.X/9f653d/"},{path:"/10.v2.9.X文档/080.🛩执行器/040.LiteflowResponse对象.html",redirect:"/pages/v2.9.X/9f653d/"},{name:"v-098d1892",path:"/pages/v2.9.X/f7acfd/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-098d1892").then(t)}},{path:"/pages/v2.9.X/f7acfd/index.html",redirect:"/pages/v2.9.X/f7acfd/"},{path:"/10.v2.9.X文档/085.🍋脚本组件/030.文件脚本的定义.html",redirect:"/pages/v2.9.X/f7acfd/"},{name:"v-d7fb7712",path:"/pages/v2.9.X/cbcb14/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d7fb7712").then(t)}},{path:"/pages/v2.9.X/cbcb14/index.html",redirect:"/pages/v2.9.X/cbcb14/"},{path:"/10.v2.9.X文档/085.🍋脚本组件/050.动态刷新脚本.html",redirect:"/pages/v2.9.X/cbcb14/"},{name:"v-5846da0c",path:"/pages/v2.9.X/46f0fa/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5846da0c").then(t)}},{path:"/pages/v2.9.X/46f0fa/index.html",redirect:"/pages/v2.9.X/46f0fa/"},{path:"/10.v2.9.X文档/086.🍇声明式组件/010.什么叫声明式组件.html",redirect:"/pages/v2.9.X/46f0fa/"},{name:"v-25e08f44",path:"/pages/v2.9.X/d861c8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-25e08f44").then(t)}},{path:"/pages/v2.9.X/d861c8/index.html",redirect:"/pages/v2.9.X/d861c8/"},{path:"/10.v2.9.X文档/085.🍋脚本组件/040.与Java进行交互.html",redirect:"/pages/v2.9.X/d861c8/"},{name:"v-025b9304",path:"/pages/v2.9.X/18f548/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-025b9304").then(t)}},{path:"/pages/v2.9.X/18f548/index.html",redirect:"/pages/v2.9.X/18f548/"},{path:"/10.v2.9.X文档/086.🍇声明式组件/020.类级别式声明.html",redirect:"/pages/v2.9.X/18f548/"},{name:"v-ffa44e3a",path:"/pages/v2.9.X/9aa85a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ffa44e3a").then(t)}},{path:"/pages/v2.9.X/9aa85a/index.html",redirect:"/pages/v2.9.X/9aa85a/"},{path:"/10.v2.9.X文档/090.🎲用代码动态构造规则/010.说明.html",redirect:"/pages/v2.9.X/9aa85a/"},{name:"v-69f60b1c",path:"/pages/v2.9.X/797830/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-69f60b1c").then(t)}},{path:"/pages/v2.9.X/797830/index.html",redirect:"/pages/v2.9.X/797830/"},{path:"/10.v2.9.X文档/086.🍇声明式组件/030.方法级别式声明.html",redirect:"/pages/v2.9.X/797830/"},{name:"v-10f0512d",path:"/pages/v2.9.X/6bc8fe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-10f0512d").then(t)}},{path:"/pages/v2.9.X/6bc8fe/index.html",redirect:"/pages/v2.9.X/6bc8fe/"},{path:"/10.v2.9.X文档/090.🎲用代码动态构造规则/020.如何构造.html",redirect:"/pages/v2.9.X/6bc8fe/"},{name:"v-75fc0eca",path:"/pages/v2.9.X/79289a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-75fc0eca").then(t)}},{path:"/pages/v2.9.X/79289a/index.html",redirect:"/pages/v2.9.X/79289a/"},{path:"/10.v2.9.X文档/100.🎨高级特性/035.替补组件.html",redirect:"/pages/v2.9.X/79289a/"},{name:"v-21e11e33",path:"/pages/v2.9.X/9f93be/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21e11e33").then(t)}},{path:"/pages/v2.9.X/9f93be/index.html",redirect:"/pages/v2.9.X/9f93be/"},{path:"/10.v2.9.X文档/100.🎨高级特性/030.前置和后置组件.html",redirect:"/pages/v2.9.X/9f93be/"},{name:"v-18ac2dc6",path:"/pages/v2.9.X/0f788f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-18ac2dc6").then(t)}},{path:"/pages/v2.9.X/0f788f/index.html",redirect:"/pages/v2.9.X/0f788f/"},{path:"/10.v2.9.X文档/100.🎨高级特性/050.组件标签.html",redirect:"/pages/v2.9.X/0f788f/"},{name:"v-1c718c24",path:"/pages/v2.9.X/92ef89/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1c718c24").then(t)}},{path:"/pages/v2.9.X/92ef89/index.html",redirect:"/pages/v2.9.X/92ef89/"},{path:"/10.v2.9.X文档/100.🎨高级特性/040.组件别名.html",redirect:"/pages/v2.9.X/92ef89/"},{name:"v-40e52047",path:"/pages/v2.9.X/6e4d15/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-40e52047").then(t)}},{path:"/pages/v2.9.X/6e4d15/index.html",redirect:"/pages/v2.9.X/6e4d15/"},{path:"/10.v2.9.X文档/100.🎨高级特性/036.组件参数.html",redirect:"/pages/v2.9.X/6e4d15/"},{name:"v-46a8dc7a",path:"/pages/v2.9.X/3ee755/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-46a8dc7a").then(t)}},{path:"/pages/v2.9.X/3ee755/index.html",redirect:"/pages/v2.9.X/3ee755/"},{path:"/10.v2.9.X文档/100.🎨高级特性/060.组件事件回调.html",redirect:"/pages/v2.9.X/3ee755/"},{name:"v-0cadd811",path:"/pages/v2.9.X/80e873/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0cadd811").then(t)}},{path:"/pages/v2.9.X/80e873/index.html",redirect:"/pages/v2.9.X/80e873/"},{path:"/10.v2.9.X文档/100.🎨高级特性/070.隐式子流程.html",redirect:"/pages/v2.9.X/80e873/"},{name:"v-253500a4",path:"/pages/v2.9.X/fbb938/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-253500a4").then(t)}},{path:"/pages/v2.9.X/fbb938/index.html",redirect:"/pages/v2.9.X/fbb938/"},{path:"/10.v2.9.X文档/100.🎨高级特性/080.私有投递.html",redirect:"/pages/v2.9.X/fbb938/"},{name:"v-7b67b75f",path:"/pages/v2.9.X/7e9da1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7b67b75f").then(t)}},{path:"/pages/v2.9.X/7e9da1/index.html",redirect:"/pages/v2.9.X/7e9da1/"},{path:"/10.v2.9.X文档/100.🎨高级特性/090.组件重试.html",redirect:"/pages/v2.9.X/7e9da1/"},{name:"v-7526d598",path:"/pages/v2.9.X/204d71/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7526d598").then(t)}},{path:"/pages/v2.9.X/204d71/index.html",redirect:"/pages/v2.9.X/204d71/"},{path:"/10.v2.9.X文档/100.🎨高级特性/100.平滑热刷新.html",redirect:"/pages/v2.9.X/204d71/"},{name:"v-df4a91a0",path:"/pages/v2.9.X/2373f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-df4a91a0").then(t)}},{path:"/pages/v2.9.X/2373f5/index.html",redirect:"/pages/v2.9.X/2373f5/"},{path:"/10.v2.9.X文档/100.🎨高级特性/110.组件切面.html",redirect:"/pages/v2.9.X/2373f5/"},{name:"v-4b48812e",path:"/pages/v2.9.X/e5ed0d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4b48812e").then(t)}},{path:"/pages/v2.9.X/e5ed0d/index.html",redirect:"/pages/v2.9.X/e5ed0d/"},{path:"/10.v2.9.X文档/100.🎨高级特性/120.步骤信息.html",redirect:"/pages/v2.9.X/e5ed0d/"},{name:"v-4d862e92",path:"/pages/v2.9.X/dc9bfe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4d862e92").then(t)}},{path:"/pages/v2.9.X/dc9bfe/index.html",redirect:"/pages/v2.9.X/dc9bfe/"},{path:"/10.v2.9.X文档/100.🎨高级特性/125.异常.html",redirect:"/pages/v2.9.X/dc9bfe/"},{name:"v-3b3b3795",path:"/pages/v2.9.X/4d614c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3b3b3795").then(t)}},{path:"/pages/v2.9.X/4d614c/index.html",redirect:"/pages/v2.9.X/4d614c/"},{path:"/10.v2.9.X文档/100.🎨高级特性/130.打印信息详解.html",redirect:"/pages/v2.9.X/4d614c/"},{name:"v-4027c910",path:"/pages/v2.9.X/47e8f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4027c910").then(t)}},{path:"/pages/v2.9.X/47e8f5/index.html",redirect:"/pages/v2.9.X/47e8f5/"},{path:"/10.v2.9.X文档/100.🎨高级特性/140.自定义请求Id.html",redirect:"/pages/v2.9.X/47e8f5/"},{name:"v-73a75c4c",path:"/pages/v2.9.X/a7e02e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-73a75c4c").then(t)}},{path:"/pages/v2.9.X/a7e02e/index.html",redirect:"/pages/v2.9.X/a7e02e/"},{path:"/10.v2.9.X文档/100.🎨高级特性/150.不同格式规则加载.html",redirect:"/pages/v2.9.X/a7e02e/"},{name:"v-7a595d3c",path:"/pages/v2.9.X/7280ea/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7a595d3c").then(t)}},{path:"/pages/v2.9.X/7280ea/index.html",redirect:"/pages/v2.9.X/7280ea/"},{path:"/10.v2.9.X文档/100.🎨高级特性/160.异步线程池自定义.html",redirect:"/pages/v2.9.X/7280ea/"},{name:"v-29f3fb6c",path:"/pages/v2.9.X/46bbed/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-29f3fb6c").then(t)}},{path:"/pages/v2.9.X/46bbed/index.html",redirect:"/pages/v2.9.X/46bbed/"},{path:"/10.v2.9.X文档/100.🎨高级特性/170.自定义组件执行器.html",redirect:"/pages/v2.9.X/46bbed/"},{name:"v-0d8f95bb",path:"/pages/v2.9.X/e59f3a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0d8f95bb").then(t)}},{path:"/pages/v2.9.X/e59f3a/index.html",redirect:"/pages/v2.9.X/e59f3a/"},{path:"/10.v2.9.X文档/100.🎨高级特性/180.简单监控.html",redirect:"/pages/v2.9.X/e59f3a/"},{name:"v-3aec6ce4",path:"/pages/v2.9.X/0066ae/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3aec6ce4").then(t)}},{path:"/pages/v2.9.X/0066ae/index.html",redirect:"/pages/v2.9.X/0066ae/"},{path:"/10.v2.9.X文档/100.🎨高级特性/190.XML的DTD.html",redirect:"/pages/v2.9.X/0066ae/"},{name:"v-21afc496",path:"/pages/v2.9.X/81cdce/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-21afc496").then(t)}},{path:"/pages/v2.9.X/81cdce/index.html",redirect:"/pages/v2.9.X/81cdce/"},{path:"/10.v2.9.X文档/110.⛱测试用例以及示例/010.测试用例.html",redirect:"/pages/v2.9.X/81cdce/"},{name:"v-65d1f9ad",path:"/pages/v2.9.X/0a8188/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-65d1f9ad").then(t)}},{path:"/pages/v2.9.X/0a8188/index.html",redirect:"/pages/v2.9.X/0a8188/"},{path:"/10.v2.9.X文档/110.⛱测试用例以及示例/020.DEMO案例.html",redirect:"/pages/v2.9.X/0a8188/"},{name:"v-c10bbfe2",path:"/pages/v2.9.X/9bf839/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c10bbfe2").then(t)}},{path:"/pages/v2.9.X/9bf839/index.html",redirect:"/pages/v2.9.X/9bf839/"},{path:"/10.v2.9.X文档/120.性能表现.html",redirect:"/pages/v2.9.X/9bf839/"},{name:"v-55f81e62",path:"/pages/v2.8.X/5816c5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-55f81e62").then(t)}},{path:"/pages/v2.8.X/5816c5/index.html",redirect:"/pages/v2.8.X/5816c5/"},{path:"/15.v2.8.X文档/010.LiteFlow简介.html",redirect:"/pages/v2.8.X/5816c5/"},{name:"v-3dc1ade7",path:"/pages/v2.8.X/724bc3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3dc1ade7").then(t)}},{path:"/pages/v2.8.X/724bc3/index.html",redirect:"/pages/v2.8.X/724bc3/"},{path:"/15.v2.8.X文档/020.项目特性.html",redirect:"/pages/v2.8.X/724bc3/"},{name:"v-4c728b76",path:"/pages/v2.8.X/631fa1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4c728b76").then(t)}},{path:"/pages/v2.8.X/631fa1/index.html",redirect:"/pages/v2.8.X/631fa1/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/005.说明.html",redirect:"/pages/v2.8.X/631fa1/"},{name:"v-4e3584bf",path:"/pages/v2.8.X/82ef41/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4e3584bf").then(t)}},{path:"/pages/v2.8.X/82ef41/index.html",redirect:"/pages/v2.8.X/82ef41/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.html",redirect:"/pages/v2.8.X/82ef41/"},{name:"v-7f801c82",path:"/pages/v2.8.X/df6982/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7f801c82").then(t)}},{path:"/pages/v2.8.X/df6982/index.html",redirect:"/pages/v2.8.X/df6982/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.html",redirect:"/pages/v2.8.X/df6982/"},{name:"v-74eae88c",path:"/pages/v2.8.X/9f4489/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-74eae88c").then(t)}},{path:"/pages/v2.8.X/9f4489/index.html",redirect:"/pages/v2.8.X/9f4489/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.html",redirect:"/pages/v2.8.X/9f4489/"},{name:"v-476157ca",path:"/pages/v2.8.X/0a4573/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-476157ca").then(t)}},{path:"/pages/v2.8.X/0a4573/index.html",redirect:"/pages/v2.8.X/0a4573/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.html",redirect:"/pages/v2.8.X/0a4573/"},{name:"v-dc75ce50",path:"/pages/v2.8.X/495f21/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dc75ce50").then(t)}},{path:"/pages/v2.8.X/495f21/index.html",redirect:"/pages/v2.8.X/495f21/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.html",redirect:"/pages/v2.8.X/495f21/"},{name:"v-ccccf1b6",path:"/pages/v2.8.X/0e0fb5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ccccf1b6").then(t)}},{path:"/pages/v2.8.X/0e0fb5/index.html",redirect:"/pages/v2.8.X/0e0fb5/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.html",redirect:"/pages/v2.8.X/0e0fb5/"},{name:"v-6fb5ca28",path:"/pages/v2.8.X/522432/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6fb5ca28").then(t)}},{path:"/pages/v2.8.X/522432/index.html",redirect:"/pages/v2.8.X/522432/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.html",redirect:"/pages/v2.8.X/522432/"},{name:"v-61b65020",path:"/pages/v2.8.X/8760c4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-61b65020").then(t)}},{path:"/pages/v2.8.X/8760c4/index.html",redirect:"/pages/v2.8.X/8760c4/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.html",redirect:"/pages/v2.8.X/8760c4/"},{name:"v-9d5c8146",path:"/pages/v2.8.X/249d17/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-9d5c8146").then(t)}},{path:"/pages/v2.8.X/249d17/index.html",redirect:"/pages/v2.8.X/249d17/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.html",redirect:"/pages/v2.8.X/249d17/"},{name:"v-0433e063",path:"/pages/v2.8.X/b70ec8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0433e063").then(t)}},{path:"/pages/v2.8.X/b70ec8/index.html",redirect:"/pages/v2.8.X/b70ec8/"},{path:"/15.v2.8.X文档/040.🍢配置项/010.说明.html",redirect:"/pages/v2.8.X/b70ec8/"},{name:"v-2c7663ac",path:"/pages/v2.8.X/151524/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2c7663ac").then(t)}},{path:"/pages/v2.8.X/151524/index.html",redirect:"/pages/v2.8.X/151524/"},{path:"/15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.html",redirect:"/pages/v2.8.X/151524/"},{name:"v-30dcc1bf",path:"/pages/v2.8.X/4594ec/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-30dcc1bf").then(t)}},{path:"/pages/v2.8.X/4594ec/index.html",redirect:"/pages/v2.8.X/4594ec/"},{path:"/15.v2.8.X文档/040.🍢配置项/020.Springboot下的配置项.html",redirect:"/pages/v2.8.X/4594ec/"},{name:"v-07cee6df",path:"/pages/v2.8.X/33833a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-07cee6df").then(t)}},{path:"/pages/v2.8.X/33833a/index.html",redirect:"/pages/v2.8.X/33833a/"},{path:"/15.v2.8.X文档/040.🍢配置项/030.Spring下的配置项.html",redirect:"/pages/v2.8.X/33833a/"},{name:"v-2086a185",path:"/pages/v2.8.X/b5065a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2086a185").then(t)}},{path:"/pages/v2.8.X/b5065a/index.html",redirect:"/pages/v2.8.X/b5065a/"},{path:"/15.v2.8.X文档/040.🍢配置项/040.其他场景代码设置配置项.html",redirect:"/pages/v2.8.X/b5065a/"},{name:"v-70666594",path:"/pages/v2.8.X/6fa87e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-70666594").then(t)}},{path:"/pages/v2.8.X/6fa87e/index.html",redirect:"/pages/v2.8.X/6fa87e/"},{path:"/15.v2.8.X文档/050.🗂规则文件/010.规则文件格式.html",redirect:"/pages/v2.8.X/6fa87e/"},{name:"v-62b15ff8",path:"/pages/v2.8.X/51ddd5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-62b15ff8").then(t)}},{path:"/pages/v2.8.X/51ddd5/index.html",redirect:"/pages/v2.8.X/51ddd5/"},{path:"/15.v2.8.X文档/050.🗂规则文件/020.本地规则文件配置.html",redirect:"/pages/v2.8.X/51ddd5/"},{name:"v-c273b4aa",path:"/pages/v2.8.X/ffc345/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c273b4aa").then(t)}},{path:"/pages/v2.8.X/ffc345/index.html",redirect:"/pages/v2.8.X/ffc345/"},{path:"/15.v2.8.X文档/050.🗂规则文件/030.ZK规则文件配置.html",redirect:"/pages/v2.8.X/ffc345/"},{name:"v-9f99f032",path:"/pages/v2.8.X/8486fb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-9f99f032").then(t)}},{path:"/pages/v2.8.X/8486fb/index.html",redirect:"/pages/v2.8.X/8486fb/"},{path:"/15.v2.8.X文档/055.🔗常规组件/010.普通组件.html",redirect:"/pages/v2.8.X/8486fb/"},{name:"v-3eb52555",path:"/pages/v2.8.X/25f2c0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3eb52555").then(t)}},{path:"/pages/v2.8.X/25f2c0/index.html",redirect:"/pages/v2.8.X/25f2c0/"},{path:"/15.v2.8.X文档/050.🗂规则文件/040.自定义配置源.html",redirect:"/pages/v2.8.X/25f2c0/"},{name:"v-54dc8068",path:"/pages/v2.8.X/c0f5d7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-54dc8068").then(t)}},{path:"/pages/v2.8.X/c0f5d7/index.html",redirect:"/pages/v2.8.X/c0f5d7/"},{path:"/15.v2.8.X文档/055.🔗常规组件/020.选择组件.html",redirect:"/pages/v2.8.X/c0f5d7/"},{name:"v-755d6911",path:"/pages/v2.8.X/16eca9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-755d6911").then(t)}},{path:"/pages/v2.8.X/16eca9/index.html",redirect:"/pages/v2.8.X/16eca9/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/010.说明.html",redirect:"/pages/v2.8.X/16eca9/"},{name:"v-783ff9dc",path:"/pages/v2.8.X/cb0b59/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-783ff9dc").then(t)}},{path:"/pages/v2.8.X/cb0b59/index.html",redirect:"/pages/v2.8.X/cb0b59/"},{path:"/15.v2.8.X文档/055.🔗常规组件/030.条件组件.html",redirect:"/pages/v2.8.X/cb0b59/"},{name:"v-23c101de",path:"/pages/v2.8.X/a590ee/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-23c101de").then(t)}},{path:"/pages/v2.8.X/a590ee/index.html",redirect:"/pages/v2.8.X/a590ee/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/020.串行编排.html",redirect:"/pages/v2.8.X/a590ee/"},{name:"v-b6bf8cf8",path:"/pages/v2.8.X/b3446a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b6bf8cf8").then(t)}},{path:"/pages/v2.8.X/b3446a/index.html",redirect:"/pages/v2.8.X/b3446a/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/030.并行编排.html",redirect:"/pages/v2.8.X/b3446a/"},{name:"v-c7f4ccd2",path:"/pages/v2.8.X/d90483/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c7f4ccd2").then(t)}},{path:"/pages/v2.8.X/d90483/index.html",redirect:"/pages/v2.8.X/d90483/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/040.选择编排.html",redirect:"/pages/v2.8.X/d90483/"},{name:"v-cef6ce3e",path:"/pages/v2.8.X/e76999/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cef6ce3e").then(t)}},{path:"/pages/v2.8.X/e76999/index.html",redirect:"/pages/v2.8.X/e76999/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/045.条件编排.html",redirect:"/pages/v2.8.X/e76999/"},{name:"v-4135901f",path:"/pages/v2.8.X/dc5df7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4135901f").then(t)}},{path:"/pages/v2.8.X/dc5df7/index.html",redirect:"/pages/v2.8.X/dc5df7/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/050.使用子流程.html",redirect:"/pages/v2.8.X/dc5df7/"},{name:"v-4e374058",path:"/pages/v2.8.X/71ff49/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4e374058").then(t)}},{path:"/pages/v2.8.X/71ff49/index.html",redirect:"/pages/v2.8.X/71ff49/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/060.使用子变量.html",redirect:"/pages/v2.8.X/71ff49/"},{name:"v-1d622864",path:"/pages/v2.8.X/af44a6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1d622864").then(t)}},{path:"/pages/v2.8.X/af44a6/index.html",redirect:"/pages/v2.8.X/af44a6/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/080.关于分号.html",redirect:"/pages/v2.8.X/af44a6/"},{name:"v-7b0dfbdd",path:"/pages/v2.8.X/f3dc09/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7b0dfbdd").then(t)}},{path:"/pages/v2.8.X/f3dc09/index.html",redirect:"/pages/v2.8.X/f3dc09/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/090.关于注释.html",redirect:"/pages/v2.8.X/f3dc09/"},{name:"v-7d329ecf",path:"/pages/v2.8.X/74b4bf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7d329ecf").then(t)}},{path:"/pages/v2.8.X/74b4bf/index.html",redirect:"/pages/v2.8.X/74b4bf/"},{path:"/15.v2.8.X文档/070.🌮数据上下文/010.说明.html",redirect:"/pages/v2.8.X/74b4bf/"},{name:"v-2e580152",path:"/pages/v2.8.X/2df3d9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2e580152").then(t)}},{path:"/pages/v2.8.X/2df3d9/index.html",redirect:"/pages/v2.8.X/2df3d9/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/100.组件名包装.html",redirect:"/pages/v2.8.X/2df3d9/"},{name:"v-47a4ff94",path:"/pages/v2.8.X/5156b3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-47a4ff94").then(t)}},{path:"/pages/v2.8.X/5156b3/index.html",redirect:"/pages/v2.8.X/5156b3/"},{path:"/15.v2.8.X文档/060.🧩EL规则的写法/070.复杂编排例子.html",redirect:"/pages/v2.8.X/5156b3/"},{name:"v-6425d832",path:"/pages/v2.8.X/501abf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6425d832").then(t)}},{path:"/pages/v2.8.X/501abf/index.html",redirect:"/pages/v2.8.X/501abf/"},{path:"/15.v2.8.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.html",redirect:"/pages/v2.8.X/501abf/"},{name:"v-7fc3f010",path:"/pages/v2.8.X/f05ed6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7fc3f010").then(t)}},{path:"/pages/v2.8.X/f05ed6/index.html",redirect:"/pages/v2.8.X/f05ed6/"},{path:"/15.v2.8.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.html",redirect:"/pages/v2.8.X/f05ed6/"},{name:"v-5093508b",path:"/pages/v2.8.X/90b2a5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5093508b").then(t)}},{path:"/pages/v2.8.X/90b2a5/index.html",redirect:"/pages/v2.8.X/90b2a5/"},{path:"/15.v2.8.X文档/080.🛩执行器/010.说明.html",redirect:"/pages/v2.8.X/90b2a5/"},{name:"v-5076b136",path:"/pages/v2.8.X/563b67/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5076b136").then(t)}},{path:"/pages/v2.8.X/563b67/index.html",redirect:"/pages/v2.8.X/563b67/"},{path:"/15.v2.8.X文档/080.🛩执行器/030.流程入参.html",redirect:"/pages/v2.8.X/563b67/"},{name:"v-1d9bb488",path:"/pages/v2.8.X/20072e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1d9bb488").then(t)}},{path:"/pages/v2.8.X/20072e/index.html",redirect:"/pages/v2.8.X/20072e/"},{path:"/15.v2.8.X文档/080.🛩执行器/020.执行方法.html",redirect:"/pages/v2.8.X/20072e/"},{name:"v-5713db61",path:"/pages/v2.8.X/6bc8fe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5713db61").then(t)}},{path:"/pages/v2.8.X/6bc8fe/index.html",redirect:"/pages/v2.8.X/6bc8fe/"},{path:"/15.v2.8.X文档/090.🎲用代码动态构造规则/020.如何构造.html",redirect:"/pages/v2.8.X/6bc8fe/"},{name:"v-2a88920a",path:"/pages/v2.8.X/9f653d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2a88920a").then(t)}},{path:"/pages/v2.8.X/9f653d/index.html",redirect:"/pages/v2.8.X/9f653d/"},{path:"/15.v2.8.X文档/080.🛩执行器/040.LiteflowResponse对象.html",redirect:"/pages/v2.8.X/9f653d/"},{name:"v-cabfb2d2",path:"/pages/v2.8.X/9aa85a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cabfb2d2").then(t)}},{path:"/pages/v2.8.X/9aa85a/index.html",redirect:"/pages/v2.8.X/9aa85a/"},{path:"/15.v2.8.X文档/090.🎲用代码动态构造规则/010.说明.html",redirect:"/pages/v2.8.X/9aa85a/"},{name:"v-ece90370",path:"/pages/v2.8.X/40b16f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ece90370").then(t)}},{path:"/pages/v2.8.X/40b16f/index.html",redirect:"/pages/v2.8.X/40b16f/"},{path:"/15.v2.8.X文档/100.🎨高级特性/010.脚本组件.html",redirect:"/pages/v2.8.X/40b16f/"},{name:"v-14a2d8cc",path:"/pages/v2.8.X/f33919/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-14a2d8cc").then(t)}},{path:"/pages/v2.8.X/f33919/index.html",redirect:"/pages/v2.8.X/f33919/"},{path:"/15.v2.8.X文档/100.🎨高级特性/020.声明式组件.html",redirect:"/pages/v2.8.X/f33919/"},{name:"v-3be426db",path:"/pages/v2.8.X/79289a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3be426db").then(t)}},{path:"/pages/v2.8.X/79289a/index.html",redirect:"/pages/v2.8.X/79289a/"},{path:"/15.v2.8.X文档/100.🎨高级特性/035.替补组件.html",redirect:"/pages/v2.8.X/79289a/"},{name:"v-3c536be7",path:"/pages/v2.8.X/9f93be/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3c536be7").then(t)}},{path:"/pages/v2.8.X/9f93be/index.html",redirect:"/pages/v2.8.X/9f93be/"},{path:"/15.v2.8.X文档/100.🎨高级特性/030.前置和后置组件.html",redirect:"/pages/v2.8.X/9f93be/"},{name:"v-68a9682e",path:"/pages/v2.8.X/92ef89/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-68a9682e").then(t)}},{path:"/pages/v2.8.X/92ef89/index.html",redirect:"/pages/v2.8.X/92ef89/"},{path:"/15.v2.8.X文档/100.🎨高级特性/040.组件别名.html",redirect:"/pages/v2.8.X/92ef89/"},{name:"v-0bad5c3a",path:"/pages/v2.8.X/3ee755/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0bad5c3a").then(t)}},{path:"/pages/v2.8.X/3ee755/index.html",redirect:"/pages/v2.8.X/3ee755/"},{path:"/15.v2.8.X文档/100.🎨高级特性/060.组件事件回调.html",redirect:"/pages/v2.8.X/3ee755/"},{name:"v-11410945",path:"/pages/v2.8.X/80e873/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-11410945").then(t)}},{path:"/pages/v2.8.X/80e873/index.html",redirect:"/pages/v2.8.X/80e873/"},{path:"/15.v2.8.X文档/100.🎨高级特性/070.隐式子流程.html",redirect:"/pages/v2.8.X/80e873/"},{name:"v-e0e347f4",path:"/pages/v2.8.X/0f788f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e0e347f4").then(t)}},{path:"/pages/v2.8.X/0f788f/index.html",redirect:"/pages/v2.8.X/0f788f/"},{path:"/15.v2.8.X文档/100.🎨高级特性/050.组件标签.html",redirect:"/pages/v2.8.X/0f788f/"},{name:"v-1b6c34c2",path:"/pages/v2.8.X/7e9da1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1b6c34c2").then(t)}},{path:"/pages/v2.8.X/7e9da1/index.html",redirect:"/pages/v2.8.X/7e9da1/"},{path:"/15.v2.8.X文档/100.🎨高级特性/090.组件重试.html",redirect:"/pages/v2.8.X/7e9da1/"},{name:"v-c7d1a238",path:"/pages/v2.8.X/fbb938/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c7d1a238").then(t)}},{path:"/pages/v2.8.X/fbb938/index.html",redirect:"/pages/v2.8.X/fbb938/"},{path:"/15.v2.8.X文档/100.🎨高级特性/080.私有投递.html",redirect:"/pages/v2.8.X/fbb938/"},{name:"v-6c007330",path:"/pages/v2.8.X/204d71/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6c007330").then(t)}},{path:"/pages/v2.8.X/204d71/index.html",redirect:"/pages/v2.8.X/204d71/"},{path:"/15.v2.8.X文档/100.🎨高级特性/100.平滑热刷新.html",redirect:"/pages/v2.8.X/204d71/"},{name:"v-513deda9",path:"/pages/v2.8.X/e5ed0d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-513deda9").then(t)}},{path:"/pages/v2.8.X/e5ed0d/index.html",redirect:"/pages/v2.8.X/e5ed0d/"},{path:"/15.v2.8.X文档/100.🎨高级特性/120.步骤信息.html",redirect:"/pages/v2.8.X/e5ed0d/"},{name:"v-073ce570",path:"/pages/v2.8.X/2373f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-073ce570").then(t)}},{path:"/pages/v2.8.X/2373f5/index.html",redirect:"/pages/v2.8.X/2373f5/"},{path:"/15.v2.8.X文档/100.🎨高级特性/110.组件切面.html",redirect:"/pages/v2.8.X/2373f5/"},{name:"v-4d06295c",path:"/pages/v2.8.X/dc9bfe/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4d06295c").then(t)}},{path:"/pages/v2.8.X/dc9bfe/index.html",redirect:"/pages/v2.8.X/dc9bfe/"},{path:"/15.v2.8.X文档/100.🎨高级特性/125.异常.html",redirect:"/pages/v2.8.X/dc9bfe/"},{name:"v-5df2031a",path:"/pages/v2.8.X/a7e02e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5df2031a").then(t)}},{path:"/pages/v2.8.X/a7e02e/index.html",redirect:"/pages/v2.8.X/a7e02e/"},{path:"/15.v2.8.X文档/100.🎨高级特性/150.不同格式规则加载.html",redirect:"/pages/v2.8.X/a7e02e/"},{name:"v-003fb755",path:"/pages/v2.8.X/4d614c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-003fb755").then(t)}},{path:"/pages/v2.8.X/4d614c/index.html",redirect:"/pages/v2.8.X/4d614c/"},{path:"/15.v2.8.X文档/100.🎨高级特性/130.打印信息详解.html",redirect:"/pages/v2.8.X/4d614c/"},{name:"v-fa6898ec",path:"/pages/v2.8.X/46bbed/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-fa6898ec").then(t)}},{path:"/pages/v2.8.X/46bbed/index.html",redirect:"/pages/v2.8.X/46bbed/"},{path:"/15.v2.8.X文档/100.🎨高级特性/170.自定义组件执行器.html",redirect:"/pages/v2.8.X/46bbed/"},{name:"v-1033fec4",path:"/pages/v2.8.X/47e8f5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1033fec4").then(t)}},{path:"/pages/v2.8.X/47e8f5/index.html",redirect:"/pages/v2.8.X/47e8f5/"},{path:"/15.v2.8.X文档/100.🎨高级特性/140.自定义请求Id.html",redirect:"/pages/v2.8.X/47e8f5/"},{name:"v-f71c780a",path:"/pages/v2.8.X/e59f3a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f71c780a").then(t)}},{path:"/pages/v2.8.X/e59f3a/index.html",redirect:"/pages/v2.8.X/e59f3a/"},{path:"/15.v2.8.X文档/100.🎨高级特性/180.简单监控.html",redirect:"/pages/v2.8.X/e59f3a/"},{name:"v-121f0e7c",path:"/pages/v2.8.X/7280ea/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-121f0e7c").then(t)}},{path:"/pages/v2.8.X/7280ea/index.html",redirect:"/pages/v2.8.X/7280ea/"},{path:"/15.v2.8.X文档/100.🎨高级特性/160.异步线程池自定义.html",redirect:"/pages/v2.8.X/7280ea/"},{name:"v-df54096c",path:"/pages/v2.8.X/81cdce/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-df54096c").then(t)}},{path:"/pages/v2.8.X/81cdce/index.html",redirect:"/pages/v2.8.X/81cdce/"},{path:"/15.v2.8.X文档/110.⛱测试用例以及示例/010.测试用例.html",redirect:"/pages/v2.8.X/81cdce/"},{name:"v-7537d280",path:"/pages/88c2f2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7537d280").then(t)}},{path:"/pages/88c2f2/index.html",redirect:"/pages/88c2f2/"},{path:"/2.12.0升级指南.html",redirect:"/pages/88c2f2/"},{name:"v-d0b41b10",path:"/pages/88c2f1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d0b41b10").then(t)}},{path:"/pages/88c2f1/index.html",redirect:"/pages/88c2f1/"},{path:"/2.12.4升级指南.html",redirect:"/pages/88c2f1/"},{name:"v-6e38463e",path:"/pages/v2.8.X/0a8188/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6e38463e").then(t)}},{path:"/pages/v2.8.X/0a8188/index.html",redirect:"/pages/v2.8.X/0a8188/"},{path:"/15.v2.8.X文档/110.⛱测试用例以及示例/020.DEMO案例.html",redirect:"/pages/v2.8.X/0a8188/"},{name:"v-28e6e97a",path:"/pages/v2.8.X/9bf839/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-28e6e97a").then(t)}},{path:"/pages/v2.8.X/9bf839/index.html",redirect:"/pages/v2.8.X/9bf839/"},{path:"/15.v2.8.X文档/120.性能表现.html",redirect:"/pages/v2.8.X/9bf839/"},{name:"v-b6cb569e",path:"/pages/v2.7.X/e0508d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b6cb569e").then(t)}},{path:"/pages/v2.7.X/e0508d/index.html",redirect:"/pages/v2.7.X/e0508d/"},{path:"/20.v2.7.X文档/020.项目特性.html",redirect:"/pages/v2.7.X/e0508d/"},{name:"v-dd9b6e5c",path:"/pages/v2.7.X/ad3883/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-dd9b6e5c").then(t)}},{path:"/pages/v2.7.X/ad3883/index.html",redirect:"/pages/v2.7.X/ad3883/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/010.Springboot场景安装运行/030.执行.html",redirect:"/pages/v2.7.X/ad3883/"},{name:"v-392abc59",path:"/pages/v2.7.X/967466/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-392abc59").then(t)}},{path:"/pages/v2.7.X/967466/index.html",redirect:"/pages/v2.7.X/967466/"},{path:"/20.v2.7.X文档/010.LiteFlow简介.html",redirect:"/pages/v2.7.X/967466/"},{name:"v-3a9e92c8",path:"/pages/v2.7.X/fe8369/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3a9e92c8").then(t)}},{path:"/pages/v2.7.X/fe8369/index.html",redirect:"/pages/v2.7.X/fe8369/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/010.Springboot场景安装运行/010.依赖.html",redirect:"/pages/v2.7.X/fe8369/"},{name:"v-16d7e605",path:"/pages/v2.7.X/36c961/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-16d7e605").then(t)}},{path:"/pages/v2.7.X/36c961/index.html",redirect:"/pages/v2.7.X/36c961/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/010.Springboot场景安装运行/020.配置.html",redirect:"/pages/v2.7.X/36c961/"},{name:"v-04a8ea25",path:"/pages/v2.7.X/ecc62a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-04a8ea25").then(t)}},{path:"/pages/v2.7.X/ecc62a/index.html",redirect:"/pages/v2.7.X/ecc62a/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/020.Spring场景安装运行/020.配置.html",redirect:"/pages/v2.7.X/ecc62a/"},{name:"v-b5fc8b30",path:"/pages/v2.7.X/314fee/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b5fc8b30").then(t)}},{path:"/pages/v2.7.X/314fee/index.html",redirect:"/pages/v2.7.X/314fee/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/020.Spring场景安装运行/010.依赖.html",redirect:"/pages/v2.7.X/314fee/"},{name:"v-7f0c511c",path:"/pages/v2.7.X/646cb4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7f0c511c").then(t)}},{path:"/pages/v2.7.X/646cb4/index.html",redirect:"/pages/v2.7.X/646cb4/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/020.Spring场景安装运行/030.执行.html",redirect:"/pages/v2.7.X/646cb4/"},{name:"v-64da3635",path:"/pages/v2.7.X/c5d947/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-64da3635").then(t)}},{path:"/pages/v2.7.X/c5d947/index.html",redirect:"/pages/v2.7.X/c5d947/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/010.说明.html",redirect:"/pages/v2.7.X/c5d947/"},{name:"v-5e9bd66a",path:"/pages/v2.7.X/2c4a45/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5e9bd66a").then(t)}},{path:"/pages/v2.7.X/2c4a45/index.html",redirect:"/pages/v2.7.X/2c4a45/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/030.配置.html",redirect:"/pages/v2.7.X/2c4a45/"},{name:"v-62977c2d",path:"/pages/v2.7.X/83cb46/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-62977c2d").then(t)}},{path:"/pages/v2.7.X/83cb46/index.html",redirect:"/pages/v2.7.X/83cb46/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/020.依赖.html",redirect:"/pages/v2.7.X/83cb46/"},{name:"v-3144e437",path:"/pages/v2.7.X/ac3dc2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3144e437").then(t)}},{path:"/pages/v2.7.X/ac3dc2/index.html",redirect:"/pages/v2.7.X/ac3dc2/"},{path:"/20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/040.执行.html",redirect:"/pages/v2.7.X/ac3dc2/"},{name:"v-44799627",path:"/pages/v2.7.X/82459b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-44799627").then(t)}},{path:"/pages/v2.7.X/82459b/index.html",redirect:"/pages/v2.7.X/82459b/"},{path:"/20.v2.7.X文档/035.配置项/010.说明.html",redirect:"/pages/v2.7.X/82459b/"},{name:"v-1ef5f67a",path:"/pages/v2.7.X/e9ec4f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1ef5f67a").then(t)}},{path:"/pages/v2.7.X/e9ec4f/index.html",redirect:"/pages/v2.7.X/e9ec4f/"},{path:"/20.v2.7.X文档/035.配置项/040.其他场景代码设置配置项.html",redirect:"/pages/v2.7.X/e9ec4f/"},{name:"v-3e2ff606",path:"/pages/v2.7.X/3bc025/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3e2ff606").then(t)}},{path:"/pages/v2.7.X/3bc025/index.html",redirect:"/pages/v2.7.X/3bc025/"},{path:"/20.v2.7.X文档/035.配置项/020.Springboot下的配置项.html",redirect:"/pages/v2.7.X/3bc025/"},{name:"v-3d3e29c6",path:"/pages/v2.7.X/dc0673/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3d3e29c6").then(t)}},{path:"/pages/v2.7.X/dc0673/index.html",redirect:"/pages/v2.7.X/dc0673/"},{path:"/20.v2.7.X文档/035.配置项/030.Spring下的配置项.html",redirect:"/pages/v2.7.X/dc0673/"},{name:"v-70cdd20a",path:"/pages/v2.7.X/3dd60b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-70cdd20a").then(t)}},{path:"/pages/v2.7.X/3dd60b/index.html",redirect:"/pages/v2.7.X/3dd60b/"},{path:"/20.v2.7.X文档/040.规则文件/040.自定义配置源.html",redirect:"/pages/v2.7.X/3dd60b/"},{name:"v-966ef4de",path:"/pages/v2.7.X/b527e6/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-966ef4de").then(t)}},{path:"/pages/v2.7.X/b527e6/index.html",redirect:"/pages/v2.7.X/b527e6/"},{path:"/20.v2.7.X文档/040.规则文件/030.ZK规则文件配置.html",redirect:"/pages/v2.7.X/b527e6/"},{name:"v-268cceea",path:"/pages/v2.7.X/a6fd84/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-268cceea").then(t)}},{path:"/pages/v2.7.X/a6fd84/index.html",redirect:"/pages/v2.7.X/a6fd84/"},{path:"/20.v2.7.X文档/040.规则文件/020.本地规则文件配置.html",redirect:"/pages/v2.7.X/a6fd84/"},{name:"v-b353778c",path:"/pages/v2.7.X/7e3166/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b353778c").then(t)}},{path:"/pages/v2.7.X/7e3166/index.html",redirect:"/pages/v2.7.X/7e3166/"},{path:"/20.v2.7.X文档/040.规则文件/010.规则文件格式.html",redirect:"/pages/v2.7.X/7e3166/"},{name:"v-a37aca76",path:"/pages/v2.7.X/202997/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a37aca76").then(t)}},{path:"/pages/v2.7.X/202997/index.html",redirect:"/pages/v2.7.X/202997/"},{path:"/20.v2.7.X文档/060.使用详细指南/010.开启和关闭.html",redirect:"/pages/v2.7.X/202997/"},{name:"v-bff5a9be",path:"/pages/v2.7.X/e8e603/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-bff5a9be").then(t)}},{path:"/pages/v2.7.X/e8e603/index.html",redirect:"/pages/v2.7.X/e8e603/"},{path:"/20.v2.7.X文档/060.使用详细指南/020.同步异步编排.html",redirect:"/pages/v2.7.X/e8e603/"},{name:"v-549e4cb6",path:"/pages/v2.7.X/182a88/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-549e4cb6").then(t)}},{path:"/pages/v2.7.X/182a88/index.html",redirect:"/pages/v2.7.X/182a88/"},{path:"/20.v2.7.X文档/050.用代码动态构造规则/010.说明.html",redirect:"/pages/v2.7.X/182a88/"},{name:"v-81fe0ba2",path:"/pages/v2.7.X/e0eebf/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-81fe0ba2").then(t)}},{path:"/pages/v2.7.X/e0eebf/index.html",redirect:"/pages/v2.7.X/e0eebf/"},{path:"/20.v2.7.X文档/050.用代码动态构造规则/020.如何构造.html",redirect:"/pages/v2.7.X/e0eebf/"},{name:"v-eaf4644a",path:"/pages/v2.7.X/9c7367/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-eaf4644a").then(t)}},{path:"/pages/v2.7.X/9c7367/index.html",redirect:"/pages/v2.7.X/9c7367/"},{path:"/20.v2.7.X文档/060.使用详细指南/015.规则文件路径.html",redirect:"/pages/v2.7.X/9c7367/"},{name:"v-59a5790e",path:"/pages/v2.7.X/16f927/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-59a5790e").then(t)}},{path:"/pages/v2.7.X/16f927/index.html",redirect:"/pages/v2.7.X/16f927/"},{path:"/20.v2.7.X文档/060.使用详细指南/040.数据上下文.html",redirect:"/pages/v2.7.X/16f927/"},{name:"v-3164109e",path:"/pages/v2.7.X/375299/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3164109e").then(t)}},{path:"/pages/v2.7.X/375299/index.html",redirect:"/pages/v2.7.X/375299/"},{path:"/20.v2.7.X文档/060.使用详细指南/030.执行器.html",redirect:"/pages/v2.7.X/375299/"},{name:"v-22de3825",path:"/pages/v2.7.X/db0fab/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-22de3825").then(t)}},{path:"/pages/v2.7.X/db0fab/index.html",redirect:"/pages/v2.7.X/db0fab/"},{path:"/20.v2.7.X文档/060.使用详细指南/045.Response对象.html",redirect:"/pages/v2.7.X/db0fab/"},{name:"v-706f6f58",path:"/pages/v2.7.X/c284f7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-706f6f58").then(t)}},{path:"/pages/v2.7.X/c284f7/index.html",redirect:"/pages/v2.7.X/c284f7/"},{path:"/20.v2.7.X文档/060.使用详细指南/060.条件组件.html",redirect:"/pages/v2.7.X/c284f7/"},{name:"v-14aed509",path:"/pages/v2.7.X/aab3f7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-14aed509").then(t)}},{path:"/pages/v2.7.X/aab3f7/index.html",redirect:"/pages/v2.7.X/aab3f7/"},{path:"/20.v2.7.X文档/060.使用详细指南/050.普通组件.html",redirect:"/pages/v2.7.X/aab3f7/"},{name:"v-ddcfc118",path:"/pages/v2.7.X/504b45/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ddcfc118").then(t)}},{path:"/pages/v2.7.X/504b45/index.html",redirect:"/pages/v2.7.X/504b45/"},{path:"/20.v2.7.X文档/060.使用详细指南/070.脚本组件.html",redirect:"/pages/v2.7.X/504b45/"},{name:"v-3b6e0af2",path:"/pages/v2.7.X/c7d5f3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3b6e0af2").then(t)}},{path:"/pages/v2.7.X/c7d5f3/index.html",redirect:"/pages/v2.7.X/c7d5f3/"},{path:"/20.v2.7.X文档/060.使用详细指南/100.组件标签.html",redirect:"/pages/v2.7.X/c7d5f3/"},{name:"v-67ee27c8",path:"/pages/v2.7.X/9a30d2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-67ee27c8").then(t)}},{path:"/pages/v2.7.X/9a30d2/index.html",redirect:"/pages/v2.7.X/9a30d2/"},{path:"/20.v2.7.X文档/060.使用详细指南/080.声明式组件.html",redirect:"/pages/v2.7.X/9a30d2/"},{name:"v-57a40646",path:"/pages/v2.7.X/bedc2a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-57a40646").then(t)}},{path:"/pages/v2.7.X/bedc2a/index.html",redirect:"/pages/v2.7.X/bedc2a/"},{path:"/20.v2.7.X文档/060.使用详细指南/090.前置后置组件.html",redirect:"/pages/v2.7.X/bedc2a/"},{name:"v-235f254c",path:"/pages/v2.7.X/4c74f0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-235f254c").then(t)}},{path:"/pages/v2.7.X/4c74f0/index.html",redirect:"/pages/v2.7.X/4c74f0/"},{path:"/20.v2.7.X文档/060.使用详细指南/095.组件别名.html",redirect:"/pages/v2.7.X/4c74f0/"},{name:"v-cdd68b34",path:"/pages/v2.7.X/d22f8f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cdd68b34").then(t)}},{path:"/pages/v2.7.X/d22f8f/index.html",redirect:"/pages/v2.7.X/d22f8f/"},{path:"/20.v2.7.X文档/060.使用详细指南/105.组件事件回调.html",redirect:"/pages/v2.7.X/d22f8f/"},{name:"v-54b99ca9",path:"/pages/v2.7.X/d36e61/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-54b99ca9").then(t)}},{path:"/pages/v2.7.X/d36e61/index.html",redirect:"/pages/v2.7.X/d36e61/"},{path:"/20.v2.7.X文档/060.使用详细指南/120.隐式子流程.html",redirect:"/pages/v2.7.X/d36e61/"},{name:"v-696430cb",path:"/pages/v2.7.X/3f6ca1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-696430cb").then(t)}},{path:"/pages/v2.7.X/3f6ca1/index.html",redirect:"/pages/v2.7.X/3f6ca1/"},{path:"/20.v2.7.X文档/060.使用详细指南/140.组件重试.html",redirect:"/pages/v2.7.X/3f6ca1/"},{name:"v-c5da7924",path:"/pages/v2.7.X/5821d4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c5da7924").then(t)}},{path:"/pages/v2.7.X/5821d4/index.html",redirect:"/pages/v2.7.X/5821d4/"},{path:"/20.v2.7.X文档/060.使用详细指南/110.子流程.html",redirect:"/pages/v2.7.X/5821d4/"},{name:"v-16b5c4e2",path:"/pages/v2.7.X/19c886/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-16b5c4e2").then(t)}},{path:"/pages/v2.7.X/19c886/index.html",redirect:"/pages/v2.7.X/19c886/"},{path:"/20.v2.7.X文档/060.使用详细指南/150.平滑热刷新.html",redirect:"/pages/v2.7.X/19c886/"},{name:"v-52983ae0",path:"/pages/v2.7.X/7aa497/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-52983ae0").then(t)}},{path:"/pages/v2.7.X/7aa497/index.html",redirect:"/pages/v2.7.X/7aa497/"},{path:"/20.v2.7.X文档/060.使用详细指南/130.私有投递.html",redirect:"/pages/v2.7.X/7aa497/"},{name:"v-4a680961",path:"/pages/v2.7.X/85ae47/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4a680961").then(t)}},{path:"/pages/v2.7.X/85ae47/index.html",redirect:"/pages/v2.7.X/85ae47/"},{path:"/20.v2.7.X文档/060.使用详细指南/180.打印信息详解.html",redirect:"/pages/v2.7.X/85ae47/"},{name:"v-15448875",path:"/pages/v2.7.X/a5728b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-15448875").then(t)}},{path:"/pages/v2.7.X/a5728b/index.html",redirect:"/pages/v2.7.X/a5728b/"},{path:"/20.v2.7.X文档/060.使用详细指南/170.步骤信息.html",redirect:"/pages/v2.7.X/a5728b/"},{name:"v-5729ccfc",path:"/pages/v2.7.X/feb764/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5729ccfc").then(t)}},{path:"/pages/v2.7.X/feb764/index.html",redirect:"/pages/v2.7.X/feb764/"},{path:"/20.v2.7.X文档/060.使用详细指南/160.组件切面.html",redirect:"/pages/v2.7.X/feb764/"},{name:"v-c063c074",path:"/pages/v2.7.X/decf9a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c063c074").then(t)}},{path:"/pages/v2.7.X/decf9a/index.html",redirect:"/pages/v2.7.X/decf9a/"},{path:"/20.v2.7.X文档/060.使用详细指南/190.不同格式规则加载.html",redirect:"/pages/v2.7.X/decf9a/"},{name:"v-8f248be2",path:"/pages/v2.7.X/2b3b21/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-8f248be2").then(t)}},{path:"/pages/v2.7.X/2b3b21/index.html",redirect:"/pages/v2.7.X/2b3b21/"},{path:"/20.v2.7.X文档/060.使用详细指南/200.When异步线程池.html",redirect:"/pages/v2.7.X/2b3b21/"},{name:"v-5f412447",path:"/pages/v2.7.X/9ec64b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5f412447").then(t)}},{path:"/pages/v2.7.X/9ec64b/index.html",redirect:"/pages/v2.7.X/9ec64b/"},{path:"/20.v2.7.X文档/060.使用详细指南/220.简单监控.html",redirect:"/pages/v2.7.X/9ec64b/"},{name:"v-a44aed54",path:"/pages/v2.7.X/1a7d84/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a44aed54").then(t)}},{path:"/pages/v2.7.X/1a7d84/index.html",redirect:"/pages/v2.7.X/1a7d84/"},{path:"/20.v2.7.X文档/060.使用详细指南/210.自定义组件执行器.html",redirect:"/pages/v2.7.X/1a7d84/"},{name:"v-72e418fb",path:"/pages/v2.7.X/beadb0/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-72e418fb").then(t)}},{path:"/pages/v2.7.X/beadb0/index.html",redirect:"/pages/v2.7.X/beadb0/"},{path:"/20.v2.7.X文档/070.示例工程/010.测试用例.html",redirect:"/pages/v2.7.X/beadb0/"},{name:"v-436fb586",path:"/pages/v2.7.X/73272c/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-436fb586").then(t)}},{path:"/pages/v2.7.X/73272c/index.html",redirect:"/pages/v2.7.X/73272c/"},{path:"/20.v2.7.X文档/070.示例工程/020.DEMO案例.html",redirect:"/pages/v2.7.X/73272c/"},{name:"v-415eb07f",path:"/pages/v2.7.X/cdfa53/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-415eb07f").then(t)}},{path:"/pages/v2.7.X/cdfa53/index.html",redirect:"/pages/v2.7.X/cdfa53/"},{path:"/20.v2.7.X文档/080.性能表现.html",redirect:"/pages/v2.7.X/cdfa53/"},{name:"v-0d1d299e",path:"/pages/v2.6.X/8c0b63/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0d1d299e").then(t)}},{path:"/pages/v2.6.X/8c0b63/index.html",redirect:"/pages/v2.6.X/8c0b63/"},{path:"/30.v2.6.X文档/020.项目特性.html",redirect:"/pages/v2.6.X/8c0b63/"},{name:"v-64a7d354",path:"/pages/v2.6.X/2d57d5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-64a7d354").then(t)}},{path:"/pages/v2.6.X/2d57d5/index.html",redirect:"/pages/v2.6.X/2d57d5/"},{path:"/30.v2.6.X文档/030.安装和集成/010.Springboot场景安装运行/010.依赖.html",redirect:"/pages/v2.6.X/2d57d5/"},{name:"v-79399e30",path:"/pages/v2.6.X/dfd970/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-79399e30").then(t)}},{path:"/pages/v2.6.X/dfd970/index.html",redirect:"/pages/v2.6.X/dfd970/"},{path:"/30.v2.6.X文档/010.LiteFlow介绍.html",redirect:"/pages/v2.6.X/dfd970/"},{name:"v-461d0c53",path:"/pages/v2.6.X/f50478/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-461d0c53").then(t)}},{path:"/pages/v2.6.X/f50478/index.html",redirect:"/pages/v2.6.X/f50478/"},{path:"/30.v2.6.X文档/030.安装和集成/010.Springboot场景安装运行/020.配置.html",redirect:"/pages/v2.6.X/f50478/"},{name:"v-12d6b6e0",path:"/pages/v2.6.X/73a9e7/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-12d6b6e0").then(t)}},{path:"/pages/v2.6.X/73a9e7/index.html",redirect:"/pages/v2.6.X/73a9e7/"},{path:"/30.v2.6.X文档/030.安装和集成/010.Springboot场景安装运行/030.执行.html",redirect:"/pages/v2.6.X/73a9e7/"},{name:"v-667a2bb6",path:"/pages/v2.6.X/165d6f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-667a2bb6").then(t)}},{path:"/pages/v2.6.X/165d6f/index.html",redirect:"/pages/v2.6.X/165d6f/"},{path:"/30.v2.6.X文档/030.安装和集成/020.Spring场景安装运行/010.依赖.html",redirect:"/pages/v2.6.X/165d6f/"},{name:"v-e1cf439a",path:"/pages/v2.6.X/4e34ba/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e1cf439a").then(t)}},{path:"/pages/v2.6.X/4e34ba/index.html",redirect:"/pages/v2.6.X/4e34ba/"},{path:"/30.v2.6.X文档/030.安装和集成/020.Spring场景安装运行/020.配置.html",redirect:"/pages/v2.6.X/4e34ba/"},{name:"v-71a27340",path:"/pages/v2.6.X/47ef69/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-71a27340").then(t)}},{path:"/pages/v2.6.X/47ef69/index.html",redirect:"/pages/v2.6.X/47ef69/"},{path:"/30.v2.6.X文档/030.安装和集成/020.Spring场景安装运行/030.执行.html",redirect:"/pages/v2.6.X/47ef69/"},{name:"v-cd30b37a",path:"/pages/v2.6.X/d53ad2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cd30b37a").then(t)}},{path:"/pages/v2.6.X/d53ad2/index.html",redirect:"/pages/v2.6.X/d53ad2/"},{path:"/30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/010.说明.html",redirect:"/pages/v2.6.X/d53ad2/"},{name:"v-7dae1c3b",path:"/pages/v2.6.X/9191fb/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7dae1c3b").then(t)}},{path:"/pages/v2.6.X/9191fb/index.html",redirect:"/pages/v2.6.X/9191fb/"},{path:"/30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/020.依赖.html",redirect:"/pages/v2.6.X/9191fb/"},{name:"v-16c02276",path:"/pages/v2.6.X/81d136/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-16c02276").then(t)}},{path:"/pages/v2.6.X/81d136/index.html",redirect:"/pages/v2.6.X/81d136/"},{path:"/30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/040.执行.html",redirect:"/pages/v2.6.X/81d136/"},{name:"v-707b5938",path:"/pages/v2.6.X/80afec/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-707b5938").then(t)}},{path:"/pages/v2.6.X/80afec/index.html",redirect:"/pages/v2.6.X/80afec/"},{path:"/30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/030.配置.html",redirect:"/pages/v2.6.X/80afec/"},{name:"v-67f50c3a",path:"/pages/v2.6.X/c10d7e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-67f50c3a").then(t)}},{path:"/pages/v2.6.X/c10d7e/index.html",redirect:"/pages/v2.6.X/c10d7e/"},{path:"/30.v2.6.X文档/040.规则文件/010.规则文件格式.html",redirect:"/pages/v2.6.X/c10d7e/"},{name:"v-677bc6ea",path:"/pages/v2.6.X/23d0c3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-677bc6ea").then(t)}},{path:"/pages/v2.6.X/23d0c3/index.html",redirect:"/pages/v2.6.X/23d0c3/"},{path:"/30.v2.6.X文档/040.规则文件/020.本地规则文件配置.html",redirect:"/pages/v2.6.X/23d0c3/"},{name:"v-78a45fb6",path:"/pages/v2.6.X/b2143d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-78a45fb6").then(t)}},{path:"/pages/v2.6.X/b2143d/index.html",redirect:"/pages/v2.6.X/b2143d/"},{path:"/30.v2.6.X文档/050.用代码动态构造规则/010.说明.html",redirect:"/pages/v2.6.X/b2143d/"},{name:"v-3ab104de",path:"/pages/v2.6.X/2adc0f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3ab104de").then(t)}},{path:"/pages/v2.6.X/2adc0f/index.html",redirect:"/pages/v2.6.X/2adc0f/"},{path:"/30.v2.6.X文档/040.规则文件/030.ZK规则文件配置.html",redirect:"/pages/v2.6.X/2adc0f/"},{name:"v-ed90420a",path:"/pages/v2.6.X/240fe8/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ed90420a").then(t)}},{path:"/pages/v2.6.X/240fe8/index.html",redirect:"/pages/v2.6.X/240fe8/"},{path:"/30.v2.6.X文档/040.规则文件/040.自定义配置源.html",redirect:"/pages/v2.6.X/240fe8/"},{name:"v-c780dd76",path:"/pages/v2.6.X/1f47ae/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c780dd76").then(t)}},{path:"/pages/v2.6.X/1f47ae/index.html",redirect:"/pages/v2.6.X/1f47ae/"},{path:"/30.v2.6.X文档/060.使用详细指南/010.开启和关闭.html",redirect:"/pages/v2.6.X/1f47ae/"},{name:"v-7e9380af",path:"/pages/v2.6.X/933342/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7e9380af").then(t)}},{path:"/pages/v2.6.X/933342/index.html",redirect:"/pages/v2.6.X/933342/"},{path:"/30.v2.6.X文档/050.用代码动态构造规则/020.如何构造.html",redirect:"/pages/v2.6.X/933342/"},{name:"v-44e111c4",path:"/pages/v2.6.X/07dc9a/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-44e111c4").then(t)}},{path:"/pages/v2.6.X/07dc9a/index.html",redirect:"/pages/v2.6.X/07dc9a/"},{path:"/30.v2.6.X文档/060.使用详细指南/030.执行器.html",redirect:"/pages/v2.6.X/07dc9a/"},{name:"v-3e17b9be",path:"/pages/v2.6.X/25d803/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-3e17b9be").then(t)}},{path:"/pages/v2.6.X/25d803/index.html",redirect:"/pages/v2.6.X/25d803/"},{path:"/30.v2.6.X文档/060.使用详细指南/020.同步异步编排.html",redirect:"/pages/v2.6.X/25d803/"},{name:"v-c23e6ee8",path:"/pages/v2.6.X/eb758e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c23e6ee8").then(t)}},{path:"/pages/v2.6.X/eb758e/index.html",redirect:"/pages/v2.6.X/eb758e/"},{path:"/30.v2.6.X文档/060.使用详细指南/040.数据槽.html",redirect:"/pages/v2.6.X/eb758e/"},{name:"v-ed31df58",path:"/pages/v2.6.X/381ed2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ed31df58").then(t)}},{path:"/pages/v2.6.X/381ed2/index.html",redirect:"/pages/v2.6.X/381ed2/"},{path:"/30.v2.6.X文档/060.使用详细指南/060.条件组件.html",redirect:"/pages/v2.6.X/381ed2/"},{name:"v-5364c5ee",path:"/pages/v2.6.X/43f09b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5364c5ee").then(t)}},{path:"/pages/v2.6.X/43f09b/index.html",redirect:"/pages/v2.6.X/43f09b/"},{path:"/30.v2.6.X文档/060.使用详细指南/050.普通组件.html",redirect:"/pages/v2.6.X/43f09b/"},{name:"v-55eb1e48",path:"/pages/v2.6.X/6f8b42/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-55eb1e48").then(t)}},{path:"/pages/v2.6.X/6f8b42/index.html",redirect:"/pages/v2.6.X/6f8b42/"},{path:"/30.v2.6.X文档/060.使用详细指南/080.声明式组件.html",redirect:"/pages/v2.6.X/6f8b42/"},{name:"v-ceda0374",path:"/pages/v2.6.X/1e7143/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-ceda0374").then(t)}},{path:"/pages/v2.6.X/1e7143/index.html",redirect:"/pages/v2.6.X/1e7143/"},{path:"/30.v2.6.X文档/060.使用详细指南/090.前置后置组件.html",redirect:"/pages/v2.6.X/1e7143/"},{name:"v-52b6e774",path:"/pages/v2.6.X/8f6247/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-52b6e774").then(t)}},{path:"/pages/v2.6.X/8f6247/index.html",redirect:"/pages/v2.6.X/8f6247/"},{path:"/30.v2.6.X文档/060.使用详细指南/070.脚本组件.html",redirect:"/pages/v2.6.X/8f6247/"},{name:"v-05e65a1c",path:"/pages/v2.6.X/87e386/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-05e65a1c").then(t)}},{path:"/pages/v2.6.X/87e386/index.html",redirect:"/pages/v2.6.X/87e386/"},{path:"/30.v2.6.X文档/060.使用详细指南/100.组件标签.html",redirect:"/pages/v2.6.X/87e386/"},{name:"v-493e29ee",path:"/pages/v2.6.X/2be4e2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-493e29ee").then(t)}},{path:"/pages/v2.6.X/2be4e2/index.html",redirect:"/pages/v2.6.X/2be4e2/"},{path:"/30.v2.6.X文档/060.使用详细指南/110.子流程.html",redirect:"/pages/v2.6.X/2be4e2/"},{name:"v-2b02f8cb",path:"/pages/v2.6.X/e441ee/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2b02f8cb").then(t)}},{path:"/pages/v2.6.X/e441ee/index.html",redirect:"/pages/v2.6.X/e441ee/"},{path:"/30.v2.6.X文档/060.使用详细指南/140.组件重试.html",redirect:"/pages/v2.6.X/e441ee/"},{name:"v-42b69329",path:"/pages/v2.6.X/2777ec/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-42b69329").then(t)}},{path:"/pages/v2.6.X/2777ec/index.html",redirect:"/pages/v2.6.X/2777ec/"},{path:"/30.v2.6.X文档/060.使用详细指南/120.隐式子流程.html",redirect:"/pages/v2.6.X/2777ec/"},{name:"v-04b2bb62",path:"/pages/v2.6.X/d0e86d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-04b2bb62").then(t)}},{path:"/pages/v2.6.X/d0e86d/index.html",redirect:"/pages/v2.6.X/d0e86d/"},{path:"/30.v2.6.X文档/060.使用详细指南/150.平滑热刷新.html",redirect:"/pages/v2.6.X/d0e86d/"},{name:"v-18c894fc",path:"/pages/v2.6.X/21d500/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-18c894fc").then(t)}},{path:"/pages/v2.6.X/21d500/index.html",redirect:"/pages/v2.6.X/21d500/"},{path:"/30.v2.6.X文档/060.使用详细指南/160.组件切面.html",redirect:"/pages/v2.6.X/21d500/"},{name:"v-cf5aaae0",path:"/pages/v2.6.X/5466e5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-cf5aaae0").then(t)}},{path:"/pages/v2.6.X/5466e5/index.html",redirect:"/pages/v2.6.X/5466e5/"},{path:"/30.v2.6.X文档/060.使用详细指南/130.私有投递.html",redirect:"/pages/v2.6.X/5466e5/"},{name:"v-5b6866c4",path:"/pages/v2.6.X/ce6352/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5b6866c4").then(t)}},{path:"/pages/v2.6.X/ce6352/index.html",redirect:"/pages/v2.6.X/ce6352/"},{path:"/30.v2.6.X文档/060.使用详细指南/180.步骤打印.html",redirect:"/pages/v2.6.X/ce6352/"},{name:"v-f3b66e04",path:"/pages/v2.6.X/d61011/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f3b66e04").then(t)}},{path:"/pages/v2.6.X/d61011/index.html",redirect:"/pages/v2.6.X/d61011/"},{path:"/30.v2.6.X文档/060.使用详细指南/170.异常处理机制.html",redirect:"/pages/v2.6.X/d61011/"},{name:"v-1f6947c6",path:"/pages/v2.6.X/f67d92/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1f6947c6").then(t)}},{path:"/pages/v2.6.X/f67d92/index.html",redirect:"/pages/v2.6.X/f67d92/"},{path:"/30.v2.6.X文档/060.使用详细指南/190.不同格式规则加载.html",redirect:"/pages/v2.6.X/f67d92/"},{name:"v-83585ee2",path:"/pages/v2.6.X/8c4aba/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-83585ee2").then(t)}},{path:"/pages/v2.6.X/8c4aba/index.html",redirect:"/pages/v2.6.X/8c4aba/"},{path:"/30.v2.6.X文档/060.使用详细指南/200.When异步线程池.html",redirect:"/pages/v2.6.X/8c4aba/"},{name:"v-1ba304f4",path:"/pages/v2.6.X/3ae932/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1ba304f4").then(t)}},{path:"/pages/v2.6.X/3ae932/index.html",redirect:"/pages/v2.6.X/3ae932/"},{path:"/30.v2.6.X文档/070.示例工程/020.DEMO案例.html",redirect:"/pages/v2.6.X/3ae932/"},{name:"v-20dfec47",path:"/pages/v2.6.X/4b18be/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-20dfec47").then(t)}},{path:"/pages/v2.6.X/4b18be/index.html",redirect:"/pages/v2.6.X/4b18be/"},{path:"/30.v2.6.X文档/060.使用详细指南/220.简单监控.html",redirect:"/pages/v2.6.X/4b18be/"},{name:"v-24597525",path:"/pages/liteflowx/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-24597525").then(t)}},{path:"/pages/liteflowx/index.html",redirect:"/pages/liteflowx/"},{path:"/LiteFlowX.html",redirect:"/pages/liteflowx/"},{name:"v-2d75b156",path:"/pages/v2.6.X/48258b/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2d75b156").then(t)}},{path:"/pages/v2.6.X/48258b/index.html",redirect:"/pages/v2.6.X/48258b/"},{path:"/30.v2.6.X文档/060.使用详细指南/210.自定义组件执行器.html",redirect:"/pages/v2.6.X/48258b/"},{name:"v-b0e29e0a",path:"/pages/v2.6.X/45096f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b0e29e0a").then(t)}},{path:"/pages/v2.6.X/45096f/index.html",redirect:"/pages/v2.6.X/45096f/"},{path:"/30.v2.6.X文档/070.示例工程/010.测试用例.html",redirect:"/pages/v2.6.X/45096f/"},{name:"v-d3947202",path:"/pages/v2.6.X/dfd1af/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-d3947202").then(t)}},{path:"/pages/v2.6.X/dfd1af/index.html",redirect:"/pages/v2.6.X/dfd1af/"},{path:"/30.v2.6.X文档/080.性能表现.html",redirect:"/pages/v2.6.X/dfd1af/"},{name:"v-0d95a0b6",path:"/pages/8d6666/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0d95a0b6").then(t)}},{path:"/pages/8d6666/index.html",redirect:"/pages/8d6666/"},{path:"/PPT.html",redirect:"/pages/8d6666/"},{name:"v-f495d4f6",path:"/archives/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-f495d4f6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-719004fe",path:"/pages/8ff021/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-719004fe").then(t)}},{path:"/pages/8ff021/index.html",redirect:"/pages/8ff021/"},{path:"/whats new/080.whats new in v2.12.4.html",redirect:"/pages/8ff021/"},{name:"v-1c3744ee",path:"/pages/8ff019/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1c3744ee").then(t)}},{path:"/pages/8ff019/index.html",redirect:"/pages/8ff019/"},{path:"/whats new/082.whats new in v2.12.2.html",redirect:"/pages/8ff019/"},{name:"v-46e3a4f6",path:"/pages/8ff020/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-46e3a4f6").then(t)}},{path:"/pages/8ff020/index.html",redirect:"/pages/8ff020/"},{path:"/whats new/081.whats new in v2.12.3.html",redirect:"/pages/8ff020/"},{name:"v-1c90bd91",path:"/pages/8ff017/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1c90bd91").then(t)}},{path:"/pages/8ff017/index.html",redirect:"/pages/8ff017/"},{path:"/whats new/084.whats new in v2.12.0.html",redirect:"/pages/8ff017/"},{name:"v-073a8d8d",path:"/pages/8ff018/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-073a8d8d").then(t)}},{path:"/pages/8ff018/index.html",redirect:"/pages/8ff018/"},{path:"/whats new/083.whats new in v2.12.1.html",redirect:"/pages/8ff018/"},{name:"v-99f89dde",path:"/pages/8ff015/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-99f89dde").then(t)}},{path:"/pages/8ff015/index.html",redirect:"/pages/8ff015/"},{path:"/whats new/086.whats new in v2.11.3.html",redirect:"/pages/8ff015/"},{name:"v-c4a4fde6",path:"/pages/8ff016/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-c4a4fde6").then(t)}},{path:"/pages/8ff016/index.html",redirect:"/pages/8ff016/"},{path:"/whats new/085.whats new in v2.11.4.html",redirect:"/pages/8ff016/"},{name:"v-6f4c3dd6",path:"/pages/8ff014/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-6f4c3dd6").then(t)}},{path:"/pages/8ff014/index.html",redirect:"/pages/8ff014/"},{path:"/whats new/087.whats new in v2.11.2.html",redirect:"/pages/8ff014/"},{name:"v-a3bac3ca",path:"/pages/8ff013/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a3bac3ca").then(t)}},{path:"/pages/8ff013/index.html",redirect:"/pages/8ff013/"},{path:"/whats new/088.whats new in v2.11.0.html",redirect:"/pages/8ff013/"},{name:"v-4a5cd6c1",path:"/pages/8ff011/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4a5cd6c1").then(t)}},{path:"/pages/8ff011/index.html",redirect:"/pages/8ff011/"},{path:"/whats new/090.whats new in v2.10.5.html",redirect:"/pages/8ff011/"},{name:"v-e34b70da",path:"/pages/8ff012/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-e34b70da").then(t)}},{path:"/pages/8ff012/index.html",redirect:"/pages/8ff012/"},{path:"/whats new/089.whats new in v2.10.6.html",redirect:"/pages/8ff012/"},{name:"v-009820c9",path:"/pages/8ff010/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-009820c9").then(t)}},{path:"/pages/8ff010/index.html",redirect:"/pages/8ff010/"},{path:"/whats new/091.whats new in v2.10.2.html",redirect:"/pages/8ff010/"},{name:"v-a3023f2a",path:"/pages/8ff007/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a3023f2a").then(t)}},{path:"/pages/8ff007/index.html",redirect:"/pages/8ff007/"},{path:"/whats new/094.whats new in v2.9.7.html",redirect:"/pages/8ff007/"},{name:"v-2b4480d1",path:"/pages/8ff008/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2b4480d1").then(t)}},{path:"/pages/8ff008/index.html",redirect:"/pages/8ff008/"},{path:"/whats new/093.whats new in v2.10.0.html",redirect:"/pages/8ff008/"},{name:"v-15ee50cd",path:"/pages/8ff009/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-15ee50cd").then(t)}},{path:"/pages/8ff009/index.html",redirect:"/pages/8ff009/"},{path:"/whats new/092.whats new in v2.10.1.html",redirect:"/pages/8ff009/"},{name:"v-56ca45aa",path:"/pages/8ff006/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-56ca45aa").then(t)}},{path:"/pages/8ff006/index.html",redirect:"/pages/8ff006/"},{path:"/whats new/095.whats new in v2.9.6.html",redirect:"/pages/8ff006/"},{name:"v-0a924c2a",path:"/pages/8ff005/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0a924c2a").then(t)}},{path:"/pages/8ff005/index.html",redirect:"/pages/8ff005/"},{path:"/whats new/096.whats new in v2.9.5.html",redirect:"/pages/8ff005/"},{name:"v-20d2d6ab",path:"/pages/8ff004/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-20d2d6ab").then(t)}},{path:"/pages/8ff004/index.html",redirect:"/pages/8ff004/"},{path:"/whats new/097.whats new in v2.9.4.html",redirect:"/pages/8ff004/"},{name:"v-46eed36b",path:"/pages/8ff003/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-46eed36b").then(t)}},{path:"/pages/8ff003/index.html",redirect:"/pages/8ff003/"},{path:"/whats new/098.whats new in v2.9.3.html",redirect:"/pages/8ff003/"},{name:"v-27cad9cb",path:"/pages/8ff002/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-27cad9cb").then(t)}},{path:"/pages/8ff002/index.html",redirect:"/pages/8ff002/"},{path:"/whats new/099.whats new in v2.9.1.html",redirect:"/pages/8ff002/"},{name:"v-1f450a8b",path:"/pages/8ff001/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1f450a8b").then(t)}},{path:"/pages/8ff001/index.html",redirect:"/pages/8ff001/"},{path:"/whats new/100.whats new in v2.9.0.html",redirect:"/pages/8ff001/"},{name:"v-1daaa968",path:"/pages/8d8888/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-1daaa968").then(t)}},{path:"/pages/8d8888/index.html",redirect:"/pages/8d8888/"},{path:"/付费社区.html",redirect:"/pages/8d8888/"},{name:"v-636d5f18",path:"/pages/e1e61f/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-636d5f18").then(t)}},{path:"/pages/e1e61f/index.html",redirect:"/pages/e1e61f/"},{path:"/专题解释/01.如何理解上下文这个概念？.html",redirect:"/pages/e1e61f/"},{name:"v-0b1d72b6",path:"/pages/8d7f1e/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0b1d72b6").then(t)}},{path:"/pages/8d7f1e/index.html",redirect:"/pages/8d7f1e/"},{path:"/关于项目.html",redirect:"/pages/8d7f1e/"},{name:"v-49473fe3",path:"/pages/73c2c3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-49473fe3").then(t)}},{path:"/pages/73c2c3/index.html",redirect:"/pages/73c2c3/"},{path:"/加入社区讨论.html",redirect:"/pages/73c2c3/"},{name:"v-59ace5bb",path:"/pages/4848b9/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-59ace5bb").then(t)}},{path:"/pages/4848b9/index.html",redirect:"/pages/4848b9/"},{path:"/升级到2.7.X说明.html",redirect:"/pages/4848b9/"},{name:"v-df9b805c",path:"/pages/ad60b4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-df9b805c").then(t)}},{path:"/pages/ad60b4/index.html",redirect:"/pages/ad60b4/"},{path:"/专题解释/02.Slot是一个什么样的概念，在框架中起到什么样的作用？.html",redirect:"/pages/ad60b4/"},{name:"v-4c31868e",path:"/pages/88c2e2/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-4c31868e").then(t)}},{path:"/pages/88c2e2/index.html",redirect:"/pages/88c2e2/"},{path:"/升级到2.8.X说明.html",redirect:"/pages/88c2e2/"},{name:"v-5a2193b7",path:"/pages/88c2f3/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-5a2193b7").then(t)}},{path:"/pages/88c2f3/index.html",redirect:"/pages/88c2f3/"},{path:"/升级到2.9.X说明.html",redirect:"/pages/88c2f3/"},{name:"v-66788692",path:"/pages/ae4dd5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-66788692").then(t)}},{path:"/pages/ae4dd5/index.html",redirect:"/pages/ae4dd5/"},{path:"/参与开发.html",redirect:"/pages/ae4dd5/"},{name:"v-0276baae",path:"/pages/fb599d/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-0276baae").then(t)}},{path:"/pages/fb599d/index.html",redirect:"/pages/fb599d/"},{path:"/支持/01.支持.html",redirect:"/pages/fb599d/"},{name:"v-7ddee6a8",path:"/pages/b52ac5/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-7ddee6a8").then(t)}},{path:"/pages/b52ac5/index.html",redirect:"/pages/b52ac5/"},{path:"/支持/02.赞助者列表.html",redirect:"/pages/b52ac5/"},{name:"v-fe3c68fe",path:"/pages/88c2f4/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-fe3c68fe").then(t)}},{path:"/pages/88c2f4/index.html",redirect:"/pages/88c2f4/"},{path:"/升级到2.9.3说明.html",redirect:"/pages/88c2f4/"},{name:"v-53f8d4bb",path:"/pages/88c2d1/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-53f8d4bb").then(t)}},{path:"/pages/88c2d1/index.html",redirect:"/pages/88c2d1/"},{path:"/更新记录.html",redirect:"/pages/88c2d1/"},{name:"v-b83e32ac",path:"/pages/9b9f41/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-b83e32ac").then(t)}},{path:"/pages/9b9f41/index.html",redirect:"/pages/9b9f41/"},{path:"/用户.html",redirect:"/pages/9b9f41/"},{name:"v-2619eb8a",path:"/pages/845dff/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-2619eb8a").then(t)}},{path:"/pages/845dff/index.html",redirect:"/pages/845dff/"},{path:"/问答.html",redirect:"/pages/845dff/"},{name:"v-a9f0e71a",path:"/pages/ae4d66/",component:xt,beforeEnter:(n,e,t)=>{ue("Layout","v-a9f0e71a").then(t)}},{path:"/pages/ae4d66/index.html",redirect:"/pages/ae4d66/"},{path:"/项目成员.html",redirect:"/pages/ae4d66/"},{path:"*",component:xt}],At={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/logo.svg"}],["meta",{name:"keywords",content:"liteflow,liteflow官网,规则引擎,流程引擎,开源,java规则引擎,rule engine,open source"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"wwads-cn-verify",content:"6c4b761a28b734fe93831e3fb400ce87"}],["script",{async:!0,src:"https://cdn.wwads.cn/js/makemoney.js",type:"text/javascript"}],["script",{},'\n    // 万维广告“禁止”广告拦截\n    // function called if wwads is blocked\n    // https://github.com/bytegravity/whitelist-wwads\n    function ABDetected() {\n      var adBlockDetected_div = document.createElement("div");\n      document.body.appendChild(adBlockDetected_div);\n      var navbar = document.querySelector(".navbar");\n      navbar.style.cssText="transition:top 300ms;top:33px";\n      adBlockDetected_div.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; background: #FF3861; color: #fff; z-index: 9999999999; font-size: 14px; text-align: center; line-height: 1.5; font-weight: bold; padding-top: 6px; padding-bottom: 6px;";\n      adBlockDetected_div.innerHTML = "我们的广告服务商 <a style=\'color:#fff;text-decoration:underline\' target=\'_blank\' href=\'https://wwads.cn/page/end-user-privacy\'>并不跟踪您的隐私</a>，为了支持本站的长期运营，请将我们的网站 <a style=\'color: #fff;text-decoration:underline\' target=\'_blank\' href=\'https://wwads.cn/page/whitelist-wwads\'>加入广告拦截器的白名单</a>。";\n      document.getElementsByTagName("body")[0].appendChild(adBlockDetected_div);\n      // add a close button to the right side of the div\n      var adBlockDetected_close = document.createElement("div");\n      adBlockDetected_close.style.cssText = "position: absolute; top: 0; right: 10px; width: 30px; height: 30px; background: #FF3861; color: #fff; z-index: 9999999999; line-height: 30px; cursor: pointer;";\n      adBlockDetected_close.innerHTML = "×";\n      adBlockDetected_div.appendChild(adBlockDetected_close);\n      // add a click event to the close button\n      adBlockDetected_close.onclick = function() {\n      this.parentNode.parentNode.removeChild(this.parentNode);\n      navbar.style.cssText="transition:top 300ms;top:0";\n      };\n    }\n\n    function vote() {\n      var voteDetected_div = document.createElement("div");\n      voteDetected_div.style.cssText = "position: absolute; top: 0; left: 0; width: 100%; background: #7bbfea; color: #fff; z-index: 9999999999; font-size: 14px; text-align: center; line-height: 1.5; font-weight: bold; padding-top: 6px; padding-bottom: 6px;";\n      voteDetected_div.innerHTML = "<a style=\'color:#fff;text-decoration:underline\' target=\'_blank\' href=\'xxxxxx\'>LiteFlow 正在参与“2021年度 OSC 中国开源项目”评选，请为我们投上宝贵的一票，谢谢！</a>";\n      document.getElementsByTagName("body")[0].appendChild(voteDetected_div);\n      voteDetected_div.onclick = function() {\n        this.remove();\n      };\n    }\n\n    function docReady(t) {\n      "complete" === document.readyState ||\n      "interactive" === document.readyState\n        ? setTimeout(t, 1)\n        : document.addEventListener("DOMContentLoaded", t);\n    }\n\n    //check if wwads\' fire function was blocked after document is ready with 3s timeout (waiting the ad loading)\n    docReady(function () {\n      setTimeout(function () {\n        if( window._AdBlockInit === undefined ){\n            ABDetected();\n        }\n      }, 3000);\n    });\n    \n    console.log("%c 人不一定要逆风翻盘，但一定要向阳而生 %c", "color: #ffffff; background: #f1404b; padding:5px 0;", "background: #030307; padding:5px 0;");\n  ']],pages:[{title:"🍤LiteFlow简介",frontmatter:{title:"🍤LiteFlow简介",date:"2022-06-16T17:51:48.000Z",permalink:"/pages/5816c5/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/010.LiteFlow%E7%AE%80%E4%BB%8B.html",relativePath:"07.v2.12.X文档/010.LiteFlow简介.md",key:"v-6396017e",path:"/pages/5816c5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"LiteFlow框架的优势",slug:"liteflow框架的优势",normalizedTitle:"liteflow框架的优势",charIndex:390},{level:2,title:"LiteFlow的设计原则",slug:"liteflow的设计原则",normalizedTitle:"liteflow的设计原则",charIndex:934},{level:2,title:"LiteFlow不适用于哪些场景",slug:"liteflow不适用于哪些场景",normalizedTitle:"liteflow不适用于哪些场景",charIndex:1524},{level:2,title:"LiteFlow适用于哪些场景",slug:"liteflow适用于哪些场景",normalizedTitle:"liteflow适用于哪些场景",charIndex:1756}],headersStr:"前言 LiteFlow框架的优势 LiteFlow的设计原则 LiteFlow不适用于哪些场景 LiteFlow适用于哪些场景",content:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nLiteFlow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# LiteFlow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用LiteFlow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。LiteFlow拥有开源规则引擎最为简单的DSL语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nLiteFlow的脚本组件，支持众多脚本语言，完全和Java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nLiteFlow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用LiteFlow，轻而易举，你立马唾手可得！\n\n\n# LiteFlow的设计原则\n\nLiteFlow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。\n\n\n# LiteFlow不适用于哪些场景\n\nLiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。\n\n提示\n\n这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转的工作流，推荐使用：\n\nflowlong\n\n> 真正的国产工作流引擎，json 格式实例模型、简易审批流程设计器、为中国特色审批匠心打造\n\n以及flowable这两个框架。\n\n\n# LiteFlow适用于哪些场景\n\nLiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",normalizedContent:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统rpc调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？liteflow为解耦逻辑而生，为编排而生，在使用liteflow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nliteflow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# liteflow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用liteflow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用liteflow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。liteflow拥有开源规则引擎最为简单的dsl语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nliteflow的脚本组件，支持众多脚本语言，完全和java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nliteflow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用liteflow，轻而易举，你立马唾手可得！\n\n\n# liteflow的设计原则\n\nliteflow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到liteflow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以liteflow能做到统一解耦的组件和灵活的装配。\n\n\n# liteflow不适用于哪些场景\n\nliteflow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，a审批完应该是b审批，然后再流转到c角色。\n\n提示\n\n这里申明下，liteflow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转的工作流，推荐使用：\n\nflowlong\n\n> 真正的国产工作流引擎，json 格式实例模型、简易审批流程设计器、为中国特色审批匠心打造\n\n以及flowable这两个框架。\n\n\n# liteflow适用于哪些场景\n\nliteflow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用liteflow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/logo.svg",heroText:"LiteFlow",tagline:"🚀 轻量，快速，稳定可编排的组件式规则引擎",slogan:'<div class="slo">Make your code amazing.</div>',actions:[{actionText:"⛵️ v2.12.4 进入文档",actionLink:"/pages/5816c5/",actionClass:"action-button-liteflowx"},{actionText:"👑 LF CLUB社区",actionLink:"/pages/8d8888/",actionClass:"action-button-liteflowx"},{actionText:"🌟 为LiteFlow点星",actionLink:"https://gitee.com/dromara/liteFlow",actionClass:"action-button-liteflowx"}],bannerBg:"none",features:[{title:"🧬 强大的EL",details:"简单低学习成本的EL，丰富的关键字，能完成任意模式的逻辑编排。小身材，大能量。"},{title:"🧩 皆为组件",details:"拥有独特的设计理念，所有逻辑皆为组件。上下文隔离，组件单一职责，组件可以复用且互相解耦。"},{title:"📑 脚本支持",details:"除了java，你还可以用多达8种脚本语言来书写你的逻辑：Java，Groovy，Kotlin，Js，Python，Lua，QLExpress，Aviator。"},{title:"🛖 规则存储",details:"支持把规则和脚本存在任何关系型数据库，并且支持大部分的注册中心，支持zk，nacos，etcd，apollo，redis。"},{title:"🍃 平滑热刷",details:"无论是编排规则，还是脚本组件，你都可以在不用重启应用的情况下进行即时刷新。实时替换逻辑。"},{title:"⭐️ 支持度广",details:"JDK8~JDK17，Spring 2.X ~ Spring 3.X，统统支持。非Spring也给予了支持。"},{title:"🍱 高级特性",details:"超多的高级特性，每一个都能贴合你的业务，利用高级特性让你的复杂场景瞬间变得简单且灵动。"},{title:"🏤 社区强大",details:"多达几千人的使用者社区，及时给你答疑解惑。并且在国内多家一线企业中落地运用。"},{title:"🪁 可靠性强",details:"对系统的额外消耗极小，性能强悍。多达2000个测试用例保障了LiteFlow的质量。"}],postList:"none",notices:[{id:"Liteflow-2.12.4",title:"🚀 LiteFlow v2.12.4 发布！",content:'<div><p>2024-10-13</p><ul><li>全新的Java插件，支持lambda和泛型</li><li>推出LiteFlow的生命周期体系</li><li>支持SQL插件自定义语句查询</li></ul></div><p style="text-align: right;"><a href="/pages/8ff021/">查看详情</a></p>',isHtmlContent:!0}]},regularPath:"/",relativePath:"index.md",key:"v-784de8c4",path:"/",headers:[{level:2,title:"🌈 特别赞助",slug:"🌈-特别赞助",normalizedTitle:"🌈 特别赞助",charIndex:2},{level:2,title:"🍬特性",slug:"🍬特性",normalizedTitle:"🍬特性",charIndex:2276},{level:2,title:"✨ 最新版本",slug:"✨-最新版本",normalizedTitle:"✨ 最新版本",charIndex:3253},{level:2,title:"🎉 致谢",slug:"🎉-致谢",normalizedTitle:"🎉 致谢",charIndex:3628},{level:2,title:"🏡 代码托管",slug:"🏡-代码托管",normalizedTitle:"🏡 代码托管",charIndex:4027},{level:2,title:"💪🏻 参与开发",slug:"💪🏻-参与开发",normalizedTitle:"💪🏻 参与开发",charIndex:4043},{level:2,title:"🍭 架构图",slug:"🍭-架构图",normalizedTitle:"🍭 架构图",charIndex:4110},{level:2,title:"🌏 知识星球",slug:"🌏-知识星球",normalizedTitle:"🌏 知识星球",charIndex:4122},{level:2,title:"🐳 Dromara组织成员",slug:"🐳-dromara组织成员",normalizedTitle:"🐳 dromara组织成员",charIndex:4140},{level:2,title:"🧲 友情链接",slug:"🧲-友情链接",normalizedTitle:"🧲 友情链接",charIndex:4168}],headersStr:"🌈 特别赞助 🍬特性 ✨ 最新版本 🎉 致谢 🏡 代码托管 💪🏻 参与开发 🍭 架构图 🌏 知识星球 🐳 Dromara组织成员 🧲 友情链接",content:"# 🌈 特别赞助\n\nMISBoot低代码开发平台\n\n零代码应用快速搭建\n让开发更简单\n\n力软低代码平台\n\n引擎式开发，适应多变业务场景，使用无限制，100%源码授权\n\nSnowy\n\n国内首个国密前后端分离快速开发平台，中国式工作流、独家双模式租户\n\n云程低代码平台\n\n采用springboot+vue技术，可私有化部署，可交付源代码\n\n驰骋工作流引擎\n\n专注流程表单引擎领域研发20年，100%核心源代码开放\n\nFastBee物联网平台\n\n更适合中小企业和个人使用的开源物联网平台\n\nJNPF低代码开发平台\n\n技术双引擎系统，无限制业务场景，永久使用权，全源码交付\n\n明道云HAP超级应用平台\n\n不止零代码，融合多元能力，就是能解决很多问题\n\n速众 AI 低代码开发平台\n\n原生基于 LiteFlow，推动软件企业在 AI 浪潮中抢占市场先机\n\n- name: MISBoot低代码开发平台\n  desc: 零代码应用快速搭建<br>让开发更简单\n  avatar: /img/donate/misboot.png\n  link: https://www.misboot.com/?from=LiteFlow\n  bgColor: '#ba4552'\n  textColor: '#FFFFFF'\n  expired: '2025-11-21'\n- name: 力软低代码平台\n  desc: 引擎式开发，适应多变业务场景，使用无限制，100%源码授权\n  avatar: /img/donate/liruan.png\n  link: https://www.learun.cn?fuid=03\n  bgColor: '#148ce9'\n  textColor: '#FFFFFF'\n  expired: '2025-07-10'\n- name: Snowy\n  desc: 国内首个国密前后端分离快速开发平台，中国式工作流、独家双模式租户\n  avatar: /img/donate/snowy.png\n  link: https://xiaonuo.vip\n  bgColor: '#1373CC'\n  textColor: '#ffffff'\n  expired: '2025-11-04'\n- name: 云程低代码平台\n  desc: 采用springboot+vue技术，可私有化部署，可交付源代码\n  avatar: /img/donate/yuncheng.png\n  link: http://www.yunchengxc.com/\n  bgColor: '#A6A1F3'\n  textColor: '#FFFFFF'\n  expired: '2025-10-31'\n- name: 驰骋工作流引擎\n  desc: 专注流程表单引擎领域研发20年，100%核心源代码开放\n  avatar: /img/donate/chicheng.png\n  link: https://ccbpm.cn/?frm=liteFlow\n  bgColor: '#2c61a9'\n  textColor: '#FFFFFF'\n  expired: '2028-01-05'\n- name: FastBee物联网平台\n  desc: 更适合中小企业和个人使用的开源物联网平台\n  avatar: /img/donate/fb.gif\n  link: https://fastbee.cn/\n  bgColor: '#f4dec8'\n  textColor: '#000000'\n  expired: '2025-02-20'\n- name: JNPF低代码开发平台\n  desc: 技术双引擎系统，无限制业务场景，永久使用权，全源码交付\n  avatar: /img/donate/yinmai.png\n  link: https://www.jnpfsoft.com/index.html?from=liteflow\n  bgColor: '#aaccff'\n  textColor: '#000000'\n  expired: '2025-04-12'\n- name: 明道云HAP超级应用平台\n  desc: 不止零代码，融合多元能力，就是能解决很多问题\n  avatar: /img/donate/mdy.png\n  link: https://www.mingdao.com?s=utm_49=utm_source=liteflow&utm_medium=banner&utm_campaign=%E5%93%81%E7%89%8C%E6%8E%A8%E5%B9%BF&utm_content=IT%E8%B5%8B%E8%83%BD%E4%B8%9A%E5%8A%A1\n  bgColor: '#2196F3'\n  textColor: '#FFFFFF'\n  expired: '2025-06-25'\n- name: 速众 AI 低代码开发平台\n  desc: 原生基于 LiteFlow，推动软件企业在 AI 浪潮中抢占市场先机\n  avatar: /img/donate/suzhong.png\n  link: https://www.suconnect.com\n  bgColor: '#2C2C2C'\n  textColor: '#FFFFFF'\n  expired: '2025-06-25'\n\n\n\n\n\n成为赞助者\n\n\n\n# 🍬特性\n\n * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，Nacos，Etcd，Zookeeper，Apollo，Redis。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * Springboot支持全面： 支持Springboot 2.X到最新的Springboot 3.X。\n * 脚本语言支持： 可以定义脚本语言节点，支持Groovy，Java，Javascript，QLExpress，Python，Lua，Aviator。未来还会支持更多的脚本语言。\n * 脚本和Java全打通： 所有脚本语言均可调用Java方法，甚至于可以引用任意的实例，在脚本中调用RPC也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时多年的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。\n\n\n\n# ✨ 最新版本\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring-boot-starter</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n新版本稳定吗？\n\n我们每一次发布版本，都会补充大量的测试用例。庞大的测试用例数目几乎覆盖到每一个已有功能的细节点。\n\n并且我们会跑超大量的并发压力测试，以上所有的通过后，我们才会谨慎的提交代码覆盖主分支进行发版。\n\n你大可不必担心新版本不稳定的情况，况且，我们有良好的社区群。基本上有问必答，如出现bug，基本上隔天必解决。\n\n所以，请放心的使用！\n\n\n另外LiteFlow通过了墨菲安全的检测，为0风险框架！\n\n\n\n\n\n# 🎉 致谢\n\nLiteFlow自从2020年开源以来，获得了很多人的支持。目前社区群5000多人，Gitee上6k Stars，Github上2.8k Stars，感谢各位支持者的一路同行，我们会努力把国产的规则引擎做到极致。\n\nLiteFlow在2021获得“OSC 年度最受欢迎中国开源软件”殊荣。\n\nLiteFlow在2022年获得“Gitee最有价值开源项目“奖项（GVP）。\n\nLiteFlow在2022年成为了\"中国信通院可信开源社区共同体(TWOS)成员\"。\n\nLiteFlow于2024年获得\"GitCode G-Star毕业项目\"认证！\n\n感谢以上官方平台对LiteFlow项目的推荐和肯定。\n\nLiteFlow首页的背景由插画师森阳提供，感谢她的创作，如需要插画商业合作小伙伴可以联系她：\n\n> 邮件：sssenyang@qq.com | 微信：ArtSenyang\n\n\n\n# 🏡 代码托管\n\n\n\n\n\n\n# 💪🏻 参与开发\n\n欢迎各路好汉一起来参与完善 LiteFlow，我们期待你的 PR！\n\n如果想贡献，请先查看参与开发。\n\n\n\n# 🍭 架构图\n\n\n\n# 🌏 知识星球\n\n\n\n\n\n\n\n\n# 🐳 Dromara组织成员\n\n\n\n\n\n\n\n\n\n\n\n# 🧲 友情链接\n\n\n\n\n\n\n\n",normalizedContent:"# 🌈 特别赞助\n\nmisboot低代码开发平台\n\n零代码应用快速搭建\n让开发更简单\n\n力软低代码平台\n\n引擎式开发，适应多变业务场景，使用无限制，100%源码授权\n\nsnowy\n\n国内首个国密前后端分离快速开发平台，中国式工作流、独家双模式租户\n\n云程低代码平台\n\n采用springboot+vue技术，可私有化部署，可交付源代码\n\n驰骋工作流引擎\n\n专注流程表单引擎领域研发20年，100%核心源代码开放\n\nfastbee物联网平台\n\n更适合中小企业和个人使用的开源物联网平台\n\njnpf低代码开发平台\n\n技术双引擎系统，无限制业务场景，永久使用权，全源码交付\n\n明道云hap超级应用平台\n\n不止零代码，融合多元能力，就是能解决很多问题\n\n速众 ai 低代码开发平台\n\n原生基于 liteflow，推动软件企业在 ai 浪潮中抢占市场先机\n\n- name: misboot低代码开发平台\n  desc: 零代码应用快速搭建<br>让开发更简单\n  avatar: /img/donate/misboot.png\n  link: https://www.misboot.com/?from=liteflow\n  bgcolor: '#ba4552'\n  textcolor: '#ffffff'\n  expired: '2025-11-21'\n- name: 力软低代码平台\n  desc: 引擎式开发，适应多变业务场景，使用无限制，100%源码授权\n  avatar: /img/donate/liruan.png\n  link: https://www.learun.cn?fuid=03\n  bgcolor: '#148ce9'\n  textcolor: '#ffffff'\n  expired: '2025-07-10'\n- name: snowy\n  desc: 国内首个国密前后端分离快速开发平台，中国式工作流、独家双模式租户\n  avatar: /img/donate/snowy.png\n  link: https://xiaonuo.vip\n  bgcolor: '#1373cc'\n  textcolor: '#ffffff'\n  expired: '2025-11-04'\n- name: 云程低代码平台\n  desc: 采用springboot+vue技术，可私有化部署，可交付源代码\n  avatar: /img/donate/yuncheng.png\n  link: http://www.yunchengxc.com/\n  bgcolor: '#a6a1f3'\n  textcolor: '#ffffff'\n  expired: '2025-10-31'\n- name: 驰骋工作流引擎\n  desc: 专注流程表单引擎领域研发20年，100%核心源代码开放\n  avatar: /img/donate/chicheng.png\n  link: https://ccbpm.cn/?frm=liteflow\n  bgcolor: '#2c61a9'\n  textcolor: '#ffffff'\n  expired: '2028-01-05'\n- name: fastbee物联网平台\n  desc: 更适合中小企业和个人使用的开源物联网平台\n  avatar: /img/donate/fb.gif\n  link: https://fastbee.cn/\n  bgcolor: '#f4dec8'\n  textcolor: '#000000'\n  expired: '2025-02-20'\n- name: jnpf低代码开发平台\n  desc: 技术双引擎系统，无限制业务场景，永久使用权，全源码交付\n  avatar: /img/donate/yinmai.png\n  link: https://www.jnpfsoft.com/index.html?from=liteflow\n  bgcolor: '#aaccff'\n  textcolor: '#000000'\n  expired: '2025-04-12'\n- name: 明道云hap超级应用平台\n  desc: 不止零代码，融合多元能力，就是能解决很多问题\n  avatar: /img/donate/mdy.png\n  link: https://www.mingdao.com?s=utm_49=utm_source=liteflow&utm_medium=banner&utm_campaign=%e5%93%81%e7%89%8c%e6%8e%a8%e5%b9%bf&utm_content=it%e8%b5%8b%e8%83%bd%e4%b8%9a%e5%8a%a1\n  bgcolor: '#2196f3'\n  textcolor: '#ffffff'\n  expired: '2025-06-25'\n- name: 速众 ai 低代码开发平台\n  desc: 原生基于 liteflow，推动软件企业在 ai 浪潮中抢占市场先机\n  avatar: /img/donate/suzhong.png\n  link: https://www.suconnect.com\n  bgcolor: '#2c2c2c'\n  textcolor: '#ffffff'\n  expired: '2025-06-25'\n\n\n\n\n\n成为赞助者\n\n\n\n# 🍬特性\n\n * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用liteflow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，nacos，etcd，zookeeper，apollo，redis。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * springboot支持全面： 支持springboot 2.x到最新的springboot 3.x。\n * 脚本语言支持： 可以定义脚本语言节点，支持groovy，java，javascript，qlexpress，python，lua，aviator。未来还会支持更多的脚本语言。\n * 脚本和java全打通： 所有脚本语言均可调用java方法，甚至于可以引用任意的实例，在脚本中调用rpc也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时多年的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。\n\n\n\n# ✨ 最新版本\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring-boot-starter</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n新版本稳定吗？\n\n我们每一次发布版本，都会补充大量的测试用例。庞大的测试用例数目几乎覆盖到每一个已有功能的细节点。\n\n并且我们会跑超大量的并发压力测试，以上所有的通过后，我们才会谨慎的提交代码覆盖主分支进行发版。\n\n你大可不必担心新版本不稳定的情况，况且，我们有良好的社区群。基本上有问必答，如出现bug，基本上隔天必解决。\n\n所以，请放心的使用！\n\n\n另外liteflow通过了墨菲安全的检测，为0风险框架！\n\n\n\n\n\n# 🎉 致谢\n\nliteflow自从2020年开源以来，获得了很多人的支持。目前社区群5000多人，gitee上6k stars，github上2.8k stars，感谢各位支持者的一路同行，我们会努力把国产的规则引擎做到极致。\n\nliteflow在2021获得“osc 年度最受欢迎中国开源软件”殊荣。\n\nliteflow在2022年获得“gitee最有价值开源项目“奖项（gvp）。\n\nliteflow在2022年成为了\"中国信通院可信开源社区共同体(twos)成员\"。\n\nliteflow于2024年获得\"gitcode g-star毕业项目\"认证！\n\n感谢以上官方平台对liteflow项目的推荐和肯定。\n\nliteflow首页的背景由插画师森阳提供，感谢她的创作，如需要插画商业合作小伙伴可以联系她：\n\n> 邮件：sssenyang@qq.com | 微信：artsenyang\n\n\n\n# 🏡 代码托管\n\n\n\n\n\n\n# 💪🏻 参与开发\n\n欢迎各路好汉一起来参与完善 liteflow，我们期待你的 pr！\n\n如果想贡献，请先查看参与开发。\n\n\n\n# 🍭 架构图\n\n\n\n# 🌏 知识星球\n\n\n\n\n\n\n\n\n# 🐳 dromara组织成员\n\n\n\n\n\n\n\n\n\n\n\n# 🧲 友情链接\n\n\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"☕️JDK支持度",frontmatter:{title:"☕️JDK支持度",date:"2023-07-21T18:07:20.000Z",permalink:"/pages/7cf080/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/010.JDK%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"07.v2.12.X文档/021.🧁环境支持/010.JDK支持度.md",key:"v-da1df29a",path:"/pages/7cf080/",headersStr:null,content:"LiteFlow要求的最低的JDK版本为8，支持JDK8~JDK17所有的版本。\n\n如果你使用JDK11以上，确保LiteFlow的版本为v2.10.6及其以上版本。\n\n因为LiteFlow从v2.10.6开始，对JDK11和JDK17进行了详细的用例测试，通过了全部的1800多个测试用例。而在v2.10.6以下版本，在JDK11以上是未经过测试用例保障的。\n\n特别需要注意的是，如果你使用JDK9及其以上的版本，请确保jvm参数加上以下参数\n\n--add-opens java.base/sun.reflect.annotation=ALL-UNNAMED\n",normalizedContent:"liteflow要求的最低的jdk版本为8，支持jdk8~jdk17所有的版本。\n\n如果你使用jdk11以上，确保liteflow的版本为v2.10.6及其以上版本。\n\n因为liteflow从v2.10.6开始，对jdk11和jdk17进行了详细的用例测试，通过了全部的1800多个测试用例。而在v2.10.6以下版本，在jdk11以上是未经过测试用例保障的。\n\n特别需要注意的是，如果你使用jdk9及其以上的版本，请确保jvm参数加上以下参数\n\n--add-opens java.base/sun.reflect.annotation=all-unnamed\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍓项目特性",frontmatter:{title:"🍓项目特性",date:"2022-06-01T21:13:18.000Z",permalink:"/pages/724bc3/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/020.%E9%A1%B9%E7%9B%AE%E7%89%B9%E6%80%A7.html",relativePath:"07.v2.12.X文档/020.项目特性.md",key:"v-4119261a",path:"/pages/724bc3/",headersStr:null,content:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看即懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，Nacos，Etcd，Zookeeper，Apollo，Redis。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * Springboot支持全面： 支持Springboot 2.X到最新的Springboot 3.X。\n * 脚本语言支持： 可以定义脚本语言节点，支持Groovy，Java，Kotlin，Javascript，QLExpress，Python，Lua，Aviator。未来还会支持更多的脚本语言。\n * 脚本和Java全打通： 所有脚本语言均可调用Java方法，甚至于可以引用任意的实例，在脚本中调用RPC也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",normalizedContent:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看即懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用liteflow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，nacos，etcd，zookeeper，apollo，redis。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * springboot支持全面： 支持springboot 2.x到最新的springboot 3.x。\n * 脚本语言支持： 可以定义脚本语言节点，支持groovy，java，kotlin，javascript，qlexpress，python，lua，aviator。未来还会支持更多的脚本语言。\n * 脚本和java全打通： 所有脚本语言均可调用java方法，甚至于可以引用任意的实例，在脚本中调用rpc也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🗣环境支持说明",frontmatter:{title:"🗣环境支持说明",date:"2024-11-18T11:39:00.000Z",permalink:"/pages/c1a488/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/005.%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/021.🧁环境支持/005.环境支持说明.md",key:"v-74a4f0e5",path:"/pages/c1a488/",headersStr:null,content:"这章里JDK和Spring体系的支持度是指：\n\nLiteFlow官方的Release版本在这些环境的范围内是通过了超过2000多个测试用例的，但是这些版本之外的环境，没有进行过详细测试，但是并不代表无法使用，只是使用中出现的问题，需要自行去排查。",normalizedContent:"这章里jdk和spring体系的支持度是指：\n\nliteflow官方的release版本在这些环境的范围内是通过了超过2000多个测试用例的，但是这些版本之外的环境，没有进行过详细测试，但是并不代表无法使用，只是使用中出现的问题，需要自行去排查。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring的支持度",frontmatter:{title:"🌱Spring的支持度",date:"2023-07-21T18:24:20.000Z",permalink:"/pages/2d12db/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/030.Spring%E7%9A%84%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"07.v2.12.X文档/021.🧁环境支持/030.Spring的支持度.md",key:"v-10b2fb62",path:"/pages/2d12db/",headersStr:null,content:"如果你不使用Springboot，只使用Spring。\n\nLiteFlow要求的Spring的最低版本为Spring 5.0。\n\n支持的范围是Spring 5.X ~ Spring 6.X。\n\n当然如果你使用了最新的Spring 6.X，相应的JDK版本也要切换为JDK17。\n\n如果你想使用Spring快速开始学习，请参考Spring场景安装运行。",normalizedContent:"如果你不使用springboot，只使用spring。\n\nliteflow要求的spring的最低版本为spring 5.0。\n\n支持的范围是spring 5.x ~ spring 6.x。\n\n当然如果你使用了最新的spring 6.x，相应的jdk版本也要切换为jdk17。\n\n如果你想使用spring快速开始学习，请参考spring场景安装运行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot支持度",frontmatter:{title:"🌿Springboot支持度",date:"2023-07-21T18:20:37.000Z",permalink:"/pages/891e0f/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/020.Springboot%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"07.v2.12.X文档/021.🧁环境支持/020.Springboot支持度.md",key:"v-7d89a885",path:"/pages/891e0f/",headersStr:null,content:"LiteFlow要求的Springboot的最低的版本是2.0。\n\n支持的范围是Springboot 2.X ~ Springboot 3.X。\n\n当然如果你使用了最新的Springboot 3.X，相应的JDK版本也要切换为JDK17。\n\n如果你想使用Springboot快速开始学习，请参考Springboot场景安装运行。",normalizedContent:"liteflow要求的springboot的最低的版本是2.0。\n\n支持的范围是springboot 2.x ~ springboot 3.x。\n\n当然如果你使用了最新的springboot 3.x，相应的jdk版本也要切换为jdk17。\n\n如果你想使用springboot快速开始学习，请参考springboot场景安装运行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/df6982/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md",key:"v-64008660",path:"/pages/df6982/",headersStr:null,content:"LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring-boot-starter</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"liteflow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring-boot-starter</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/9f4489/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md",key:"v-4fa2d74e",path:"/pages/9f4489/",headersStr:null,content:'声明启动类：\n\n@SpringBootApplication\n//把你定义的组件扫入Spring上下文中\n@ComponentScan({"com.xxx.xxx.cmp"})\npublic class LiteflowExampleApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(LiteflowExampleApplication.class, args);\n    }\n}\n\n\n然后你就可以在Springboot任意被Spring托管的类中拿到flowExecutor，进行执行链路：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'声明启动类：\n\n@springbootapplication\n//把你定义的组件扫入spring上下文中\n@componentscan({"com.xxx.xxx.cmp"})\npublic class liteflowexampleapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(liteflowexampleapplication.class, args);\n    }\n}\n\n\n然后你就可以在springboot任意被spring托管的类中拿到flowexecutor，进行执行链路：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/0a4573/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md",key:"v-b316b3ca",path:"/pages/0a4573/",headersStr:null,content:"针对于使用了Spring但没有使用SpringBoot的项目\n\n<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring</artifactId>\n\t<version>2.12.4.1</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"针对于使用了spring但没有使用springboot的项目\n\n<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring</artifactid>\n\t<version>2.12.4.1</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/82ef41/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md",key:"v-f415f82a",path:"/pages/82ef41/",headers:[{level:2,title:"组件的定义",slug:"组件的定义",normalizedTitle:"组件的定义",charIndex:2},{level:2,title:"SpringBoot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:453},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:620}],headersStr:"组件的定义 SpringBoot配置文件 规则文件的定义",content:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文。\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# SpringBoot配置文件\n\n然后，在你的SpringBoot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c);\n    </chain>\n</flow>\n\n\nSpringBoot在启动时会自动装载规则文件。',normalizedContent:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保springboot会扫描到这些组件并注册进上下文。\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# springboot配置文件\n\n然后，在你的springboot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c);\n    </chain>\n</flow>\n\n\nspringboot在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:49:31.000Z",permalink:"/pages/631fa1/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/005.%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/005.说明.md",key:"v-816334e8",path:"/pages/631fa1/",headersStr:null,content:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验LiteFlow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的Hello World里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到LiteFlow的优雅之处。",normalizedContent:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验liteflow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的hello world里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到liteflow的优雅之处。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/495f21/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md",key:"v-8c9751b4",path:"/pages/495f21/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"Spring xml中的配置",slug:"spring-xml中的配置",normalizedTitle:"spring xml中的配置",charIndex:452},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:1166}],headersStr:"定义你的组件 Spring xml中的配置 规则文件的定义",content:'# 定义你的组件\n\n你需要定义并实现一些组件，确保Spring会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# Spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springAware" class="com.yomahub.liteflow.spi.spring.SpringAware"/>\n\n<bean class="com.yomahub.liteflow.spring.ComponentScanner"/>\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor" depends-on="springAware">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\x3c!-- 如果上述enableLog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.MonitorBus">\n    <constructor-arg ref="liteflowConfig" />\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c)\n    </chain>\n</flow>\n\n\nSpring在启动时会自动装载规则文件。',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件，确保spring会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springaware" class="com.yomahub.liteflow.spi.spring.springaware"/>\n\n<bean class="com.yomahub.liteflow.spring.componentscanner"/>\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor" depends-on="springaware">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\x3c!-- 如果上述enablelog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.monitorbus">\n    <constructor-arg ref="liteflowconfig" />\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c)\n    </chain>\n</flow>\n\n\nspring在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-02T19:49:57.000Z",permalink:"/pages/0e0fb5/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md",key:"v-73b71fee",path:"/pages/0e0fb5/",headersStr:null,content:'和SpringBoot的执行方式一样，没有任何区别，你可以在你的任何受Spring托管的类里注入FlowExecutor进行执行：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'和springboot的执行方式一样，没有任何区别，你可以在你的任何受spring托管的类里注入flowexecutor进行执行：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/8760c4/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E4%BE%9D%E8%B5%96.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md",key:"v-06a73ca4",path:"/pages/8760c4/",headersStr:null,content:"<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-core</artifactId>\n\t<version>2.12.4.1</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-core</artifactid>\n\t<version>2.12.4.1</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/522432/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md",key:"v-28ee3436",path:"/pages/522432/",headersStr:null,content:"虽说Springboot/Spring已经成为了Java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合Spring我始终觉得是瑕疵，有点代码洁癖），现在在非Spring体系的环境中也能使用LiteFlow框架带来的便捷和高效。\n\nLiteFlow文档中提到的98%以上的特性功能都能在非Spring体系中生效。其中不生效的特性和功能有：\n\n * ruleSource的模糊路径匹配特性在非Spring体系下不生效\n * LiteflowComponent在非Spring体系下无法使用\n * 监控功能在非Spring体系中无法使用",normalizedContent:"虽说springboot/spring已经成为了java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合spring我始终觉得是瑕疵，有点代码洁癖），现在在非spring体系的环境中也能使用liteflow框架带来的便捷和高效。\n\nliteflow文档中提到的98%以上的特性功能都能在非spring体系中生效。其中不生效的特性和功能有：\n\n * rulesource的模糊路径匹配特性在非spring体系下不生效\n * liteflowcomponent在非spring体系下无法使用\n * 监控功能在非spring体系中无法使用",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/249d17/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E9%85%8D%E7%BD%AE.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md",key:"v-8b088f8e",path:"/pages/249d17/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"规则文件的配置",slug:"规则文件的配置",normalizedTitle:"规则文件的配置",charIndex:381}],headersStr:"定义你的组件 规则文件的配置",content:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.AComponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.BComponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.CComponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tTHEN(a, b, c);\n\t</chain>\n</flow>\n',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.acomponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.bcomponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.ccomponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tthen(a, b, c);\n\t</chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-06T23:15:50.000Z",permalink:"/pages/151524/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/040.%E6%89%A7%E8%A1%8C.html",relativePath:"07.v2.12.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md",key:"v-abbd7ec8",path:"/pages/151524/",headers:[{level:2,title:"初始化你的FlowExecutor执行器",slug:"初始化你的flowexecutor执行器",normalizedTitle:"初始化你的flowexecutor执行器",charIndex:2},{level:2,title:"用FlowExecutor执行",slug:"用flowexecutor执行",normalizedTitle:"用flowexecutor执行",charIndex:331}],headersStr:"初始化你的FlowExecutor执行器 用FlowExecutor执行",content:'# 初始化你的FlowExecutor执行器\n\n通过以下代码你可以轻易的初始化FlowExecutor处理器：\n\nLiteflowConfig config = new LiteflowConfig();\nconfig.setRuleSource("config/flow.el.xml");\nFlowExecutor flowExecutor = FlowExecutorHolder.loadInstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化FlowExecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用FlowExecutor执行\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'# 初始化你的flowexecutor执行器\n\n通过以下代码你可以轻易的初始化flowexecutor处理器：\n\nliteflowconfig config = new liteflowconfig();\nconfig.setrulesource("config/flow.el.xml");\nflowexecutor flowexecutor = flowexecutorholder.loadinstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化flowexecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用flowexecutor执行\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-06T21:42:12.000Z",permalink:"/pages/b70ec8/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/010.%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/040.🍢配置项/010.说明.md",key:"v-1822b90e",path:"/pages/b70ec8/",headersStr:null,content:"LiteFlow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",normalizedContent:"liteflow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot下的配置项",frontmatter:{title:"🌿Springboot下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/4594ec/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/020.Springboot%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"07.v2.12.X文档/040.🍢配置项/020.Springboot下的配置项.md",key:"v-4e84c0e3",path:"/pages/4594ec/",headersStr:null,content:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zkNode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#FlowExecutor的execute2Future的线程数，默认为64\nliteflow.main-executor-works=64\n#FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n#自定义请求ID的生成类，LiteFlow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n#并行节点的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n#异步线程最长的等待时间(只用于when)，默认值为15000\nliteflow.when-max-wait-time=15000\n#异步线程最长的等待时间单位(只用于when)，默认值为MILLISECONDS，毫秒\nliteflow.when-max-wait-time-unit=MILLISECONDS\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#并行循环子项线程池最大线程数，默认为16\nliteflow.parallel-max-workers=16\n#并行循环子项线程池等待队列数，默认为512\nliteflow.parallel-queue-limit=512\n#并行循环子项的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n#设置解析模式，一共有三种模式，PARSE_ALL_ON_START | PARSE_ALL_ON_FIRST_EXEC | PARSE_ONE_ON_FIRST_EXEC\nliteflow.parse-mode=PARSE_ALL_ON_START\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#是否开启本地文件监听，默认为false\nliteflow.enable-monitor-file=false\n#是否开启快速解析模式，默认为false\nliteflow.fast-load=false\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #FlowExecutor的execute2Future的线程数，默认为64\n  main-executor-works: 64\n  #FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\n  main-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n  #自定义请求ID的生成类，LiteFlow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n  #并行节点的线程池Builder，LiteFlow提供了默认的Builder\n  thread-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n  #异步线程最长的等待时间(只用于when)，默认值为15000\n  when-max-wait-time: 15000\n  #异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒\n  when-max-wait-time-unit: MILLISECONDS\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #并行循环子项线程池最大线程数，默认为16\n  parallel-max-workers: 16\n  #并行循环子项线程池等待队列数，默认为512\n  parallel-queue-limit: 512\n  #并行循环子项的线程池Builder，LiteFlow提供了默认的Builder\n  parallel-loop-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultParallelLoopExecutorBuilder\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #设置解析模式，一共有三种模式，PARSE_ALL_ON_START | PARSE_ALL_ON_FIRST_EXEC | PARSE_ONE_ON_FIRST_EXEC\n  parse-mode: PARSE_ALL_ON_START\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #是否开启本地文件监听，默认为false\n  enable-monitor-file: false\n  #是否开启快速解析模式，默认为false\n  fast-load: false\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",normalizedContent:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zknode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#flowexecutor的execute2future的线程数，默认为64\nliteflow.main-executor-works=64\n#flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n#自定义请求id的生成类，liteflow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n#并行节点的线程池builder，liteflow提供了默认的builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n#异步线程最长的等待时间(只用于when)，默认值为15000\nliteflow.when-max-wait-time=15000\n#异步线程最长的等待时间单位(只用于when)，默认值为milliseconds，毫秒\nliteflow.when-max-wait-time-unit=milliseconds\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#并行循环子项线程池最大线程数，默认为16\nliteflow.parallel-max-workers=16\n#并行循环子项线程池等待队列数，默认为512\nliteflow.parallel-queue-limit=512\n#并行循环子项的线程池builder，liteflow提供了默认的builder\nliteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n#设置解析模式，一共有三种模式，parse_all_on_start | parse_all_on_first_exec | parse_one_on_first_exec\nliteflow.parse-mode=parse_all_on_start\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#是否开启本地文件监听，默认为false\nliteflow.enable-monitor-file=false\n#是否开启快速解析模式，默认为false\nliteflow.fast-load=false\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #flowexecutor的execute2future的线程数，默认为64\n  main-executor-works: 64\n  #flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\n  main-executor-class: com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n  #自定义请求id的生成类，liteflow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n  #并行节点的线程池builder，liteflow提供了默认的builder\n  thread-executor-class: com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n  #异步线程最长的等待时间(只用于when)，默认值为15000\n  when-max-wait-time: 15000\n  #异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒\n  when-max-wait-time-unit: milliseconds\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #并行循环子项线程池最大线程数，默认为16\n  parallel-max-workers: 16\n  #并行循环子项线程池等待队列数，默认为512\n  parallel-queue-limit: 512\n  #并行循环子项的线程池builder，liteflow提供了默认的builder\n  parallel-loop-executor-class: com.yomahub.liteflow.thread.liteflowdefaultparallelloopexecutorbuilder\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #设置解析模式，一共有三种模式，parse_all_on_start | parse_all_on_first_exec | parse_one_on_first_exec\n  parse-mode: parse_all_on_start\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #是否开启本地文件监听，默认为false\n  enable-monitor-file: false\n  #是否开启快速解析模式，默认为false\n  fast-load: false\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵其他场景代码设置配置项",frontmatter:{title:"🌵其他场景代码设置配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/b5065a/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/040.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"07.v2.12.X文档/040.🍢配置项/040.其他场景代码设置配置项.md",key:"v-af74883a",path:"/pages/b5065a/",headersStr:null,content:'LiteflowConfig config = new LiteflowConfig();\n//规则文件路径\nconfig.setRuleSource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setEnable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setPrintBanner(true);\n//zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setZkNode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setSlotSize(1024);\n//FlowExecutor的execute2Future的线程数，默认为64\nconfig.setMainExecutorWorks(64);\n//FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nconfig.setMainExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder");\n//自定义请求ID的生成类，LiteFlow提供了默认的生成类\nconfig.setRequestIdGeneratorClass("com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator");\n//并行节点的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setThreadExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder");\n//异步线程最长的等待时间(只用于when)，默认值为15000\nconfig.setWhenMaxWaitTime(15000);\n//异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒\nconfig.setWhenMaxWaitTimeUnit(TimeUnit.MILLISECONDS);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setWhenMaxWorkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setWhenQueueLimit(512);\n//并行循环子项线程池最大线程数，默认为16\nconfig.setParallelMaxWorkers(16)\n//并行循环子项线程池等待队列数，默认为512\nconfig.setParallelQueueLimit(512)\n//并行循环子项的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setParallelLoopExecutorClass(com.yomahub.liteflow.thread.LiteFlowDefaultParallelLoopExecutorBuilder)\n//设置解析模式，一共有三种模式，PARSE_ALL_ON_START | PARSE_ALL_ON_FIRST_EXEC | PARSE_ONE_ON_FIRST_EXEC\nconfig.setParseMode(ParseModeEnum.PARSE_ALL_ON_START);\n//全局重试次数，默认为0\nconfig.setRetryCount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setSupportMultipleType(false);\n//全局默认节点执行器\nconfig.setNodeExecutorClass("com.yomahub.liteflow.flow.executor.DefaultNodeExecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setPrintExecutionLog(true);\n//是否开启本地文件监听，默认为false\nconfig.setEnableMonitorFile(false);\n//是否开启快速解析模式，默认为false\nconfig.setFastLoad(false);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setEnableLog(false);\n//监控队列存储大小，默认值为200\nconfig.setQueueLimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setDelay(300000L);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setPeriod(300000L);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'liteflowconfig config = new liteflowconfig();\n//规则文件路径\nconfig.setrulesource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setenable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setprintbanner(true);\n//zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setzknode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setslotsize(1024);\n//flowexecutor的execute2future的线程数，默认为64\nconfig.setmainexecutorworks(64);\n//flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nconfig.setmainexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder");\n//自定义请求id的生成类，liteflow提供了默认的生成类\nconfig.setrequestidgeneratorclass("com.yomahub.liteflow.flow.id.defaultrequestidgenerator");\n//并行节点的线程池builder，liteflow提供了默认的builder\nconfig.setthreadexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder");\n//异步线程最长的等待时间(只用于when)，默认值为15000\nconfig.setwhenmaxwaittime(15000);\n//异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒\nconfig.setwhenmaxwaittimeunit(timeunit.milliseconds);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setwhenmaxworkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setwhenqueuelimit(512);\n//并行循环子项线程池最大线程数，默认为16\nconfig.setparallelmaxworkers(16)\n//并行循环子项线程池等待队列数，默认为512\nconfig.setparallelqueuelimit(512)\n//并行循环子项的线程池builder，liteflow提供了默认的builder\nconfig.setparallelloopexecutorclass(com.yomahub.liteflow.thread.liteflowdefaultparallelloopexecutorbuilder)\n//设置解析模式，一共有三种模式，parse_all_on_start | parse_all_on_first_exec | parse_one_on_first_exec\nconfig.setparsemode(parsemodeenum.parse_all_on_start);\n//全局重试次数，默认为0\nconfig.setretrycount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setsupportmultipletype(false);\n//全局默认节点执行器\nconfig.setnodeexecutorclass("com.yomahub.liteflow.flow.executor.defaultnodeexecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setprintexecutionlog(true);\n//是否开启本地文件监听，默认为false\nconfig.setenablemonitorfile(false);\n//是否开启快速解析模式，默认为false\nconfig.setfastload(false);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setenablelog(false);\n//监控队列存储大小，默认值为200\nconfig.setqueuelimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setdelay(300000l);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setperiod(300000l);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📔规则文件格式",frontmatter:{title:"📔规则文件格式",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/6fa87e/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/010.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/010.规则文件格式.md",key:"v-dd188c24",path:"/pages/6fa87e/",headers:[{level:2,title:"规则组成部分",slug:"规则组成部分",normalizedTitle:"规则组成部分",charIndex:147}],headersStr:"规则组成部分",content:'LiteFlow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nLiteFlow的规则文件非常轻量，非常容易上手。主要由Node节点和Chain节点组成。\n\n提示\n\n必须要说明的是，Node节点在Springboot/Spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到Spring上下文中。\n\n在非Spring环境体系中，Node节点是必须的。如果不配置Node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nXML在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.ACmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.BCmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.CCmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.DCmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(\n            a, b, WHEN(c,d)\n        );\n    </chain>\n</flow>\n\n\nJSON在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.TestCustomParser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ACmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.BCmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.CCmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.DCmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "THEN(a, b, WHEN(c, d))"\n      }\n    ]\n  }\n}\n\n\nYAML在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.TestCustomParser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.ACmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.BCmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.CCmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.DCmp\n  chain:\n    - name: chain1\n      value: "THEN(a, b, WHEN(c, d))"\n',normalizedContent:'liteflow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nliteflow的规则文件非常轻量，非常容易上手。主要由node节点和chain节点组成。\n\n提示\n\n必须要说明的是，node节点在springboot/spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到spring上下文中。\n\n在非spring环境体系中，node节点是必须的。如果不配置node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nxml在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.acmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.bcmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.ccmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.dcmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(\n            a, b, when(c,d)\n        );\n    </chain>\n</flow>\n\n\njson在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.testcustomparser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.acmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.bcmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ccmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.dcmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "then(a, b, when(c, d))"\n      }\n    ]\n  }\n}\n\n\nyaml在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.testcustomparser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.acmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.bcmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.ccmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.dcmp\n  chain:\n    - name: chain1\n      value: "then(a, b, when(c, d))"\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring下的配置项",frontmatter:{title:"🌱Spring下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/33833a/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/030.Spring%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"07.v2.12.X文档/040.🍢配置项/030.Spring下的配置项.md",key:"v-0dcffefe",path:"/pages/33833a/",headersStr:null,content:'<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printBanner" value="true"/> \n    \x3c!-- zkNode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zkNode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotSize" value="1024"/> \n    \x3c!-- FlowExecutor的execute2Future的线程数，默认为64 --\x3e\n    <property name="mainExecutorWorks" value="64"/> \n    \x3c!-- FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="mainExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder"/>\n    \x3c!-- 自定义请求ID的生成类，LiteFlow提供了默认的生成类 --\x3e\n    <property name="requestIdGeneratorClass" value="com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator"/>\n    \x3c!-- 并行节点的线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder"/> \n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为15000 --\x3e\n    <property name="whenMaxWaitTime" value="15000"/>\n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒 --\x3e\n    <property name="whenMaxWaitTimeUnit" value="MILLISECONDS"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenMaxWorkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenQueueLimit" value="512"/>\n    \x3c!-- 并行循环子项线程池最大线程数，默认为16--\x3e\n    <property name="parallelMaxWorkers" value="16"/>\n    \x3c!-- 并行循环子项线程池等待队列数，默认为512--\x3e\n    <property name="parallelQueueLimit" value="512"/>\n    \x3c!-- 并行循环子项的线程池Builder，LiteFlow提供了默认的Builder--\x3e\n    <property name="parallelLoopExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultParallelLoopExecutorBuilder"/>\n    \x3c!-- 设置解析模式，一共有三种模式，PARSE_ALL_ON_START | PARSE_ALL_ON_FIRST_EXEC | PARSE_ONE_ON_FIRST_EXEC --\x3e\n    <property name="parseMode" value="PARSE_ALL_ON_START"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retryCount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportMultipleType" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeExecutorClass" value="com.yomahub.liteflow.flow.executor.DefaultNodeExecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printExecutionLog" value="true"/>\n    \x3c!-- 是否开启本地文件监听，默认为false --\x3e\n    <property name="enableMonitorFile" value="false"/>\n    \x3c!-- 是否开启快速解析模式，默认为false --\x3e\n    <property name="fastLoad" value="false"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enableLog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queueLimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/>\n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printbanner" value="true"/> \n    \x3c!-- zknode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zknode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotsize" value="1024"/> \n    \x3c!-- flowexecutor的execute2future的线程数，默认为64 --\x3e\n    <property name="mainexecutorworks" value="64"/> \n    \x3c!-- flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="mainexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder"/>\n    \x3c!-- 自定义请求id的生成类，liteflow提供了默认的生成类 --\x3e\n    <property name="requestidgeneratorclass" value="com.yomahub.liteflow.flow.id.defaultrequestidgenerator"/>\n    \x3c!-- 并行节点的线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder"/> \n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为15000 --\x3e\n    <property name="whenmaxwaittime" value="15000"/>\n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒 --\x3e\n    <property name="whenmaxwaittimeunit" value="milliseconds"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenmaxworkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenqueuelimit" value="512"/>\n    \x3c!-- 并行循环子项线程池最大线程数，默认为16--\x3e\n    <property name="parallelmaxworkers" value="16"/>\n    \x3c!-- 并行循环子项线程池等待队列数，默认为512--\x3e\n    <property name="parallelqueuelimit" value="512"/>\n    \x3c!-- 并行循环子项的线程池builder，liteflow提供了默认的builder--\x3e\n    <property name="parallelloopexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultparallelloopexecutorbuilder"/>\n    \x3c!-- 设置解析模式，一共有三种模式，parse_all_on_start | parse_all_on_first_exec | parse_one_on_first_exec --\x3e\n    <property name="parsemode" value="parse_all_on_start"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retrycount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportmultipletype" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeexecutorclass" value="com.yomahub.liteflow.flow.executor.defaultnodeexecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printexecutionlog" value="true"/>\n    \x3c!-- 是否开启本地文件监听，默认为false --\x3e\n    <property name="enablemonitorfile" value="false"/>\n    \x3c!-- 是否开启快速解析模式，默认为false --\x3e\n    <property name="fastload" value="false"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enablelog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queuelimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/>\n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📗ZK规则文件配置源",frontmatter:{title:"📗ZK规则文件配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/ffc345/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/030.ZK%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/030.ZK规则文件配置源.md",key:"v-1506da02",path:"/pages/ffc345/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:17},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:651},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:787},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1210},{level:2,title:"脚本key的语言配置",slug:"脚本key的语言配置",normalizedTitle:"脚本key的语言配置",charIndex:1278},{level:2,title:"规则的启用关闭和脚本启用关闭",slug:"规则的启用关闭和脚本启用关闭",normalizedTitle:"规则的启用关闭和脚本启用关闭",charIndex:1423},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1852}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 脚本key的语言配置 规则的启用关闭和脚本启用关闭 小例子",content:'# 依赖\n\nLiteFlow支持把配置放在zk集群中，基于zk的通知机制，LiteFlow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-zk</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectStr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainPath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectStr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectStr   zk的连接串，可以是集群\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在ZK中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key的格式为：规则ID[:是否启用]，其中方括号内的为可选项，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:boolean_script:布尔脚本组件s2\n\n关于脚本类型，可以参照脚本语言介绍这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nLiteFlow也支持在zk节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则ID[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手ZK规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'# 依赖\n\nliteflow支持把配置放在zk集群中，基于zk的通知机制，liteflow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-zk</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectstr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainpath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectstr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectstr   zk的连接串，可以是集群\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在zk中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key的格式为：规则id[:是否启用]，其中方括号内的为可选项，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:boolean_script:布尔脚本组件s2\n\n关于脚本类型，可以参照脚本语言介绍这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nliteflow也支持在zk节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则id[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手zk规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📕本地规则文件配置",frontmatter:{title:"📕本地规则文件配置",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/51ddd5/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/020.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/020.本地规则文件配置.md",key:"v-55b0e3c4",path:"/pages/51ddd5/",headers:[{level:2,title:"常规配置",slug:"常规配置",normalizedTitle:"常规配置",charIndex:173},{level:2,title:"工程内指定多个路径",slug:"工程内指定多个路径",normalizedTitle:"工程内指定多个路径",charIndex:463},{level:2,title:"绝对路径指定多个路径",slug:"绝对路径指定多个路径",normalizedTitle:"绝对路径指定多个路径",charIndex:656},{level:2,title:"绝对路径指定模糊路径",slug:"绝对路径指定模糊路径",normalizedTitle:"绝对路径指定模糊路径",charIndex:757}],headersStr:"常规配置 工程内指定多个路径 绝对路径指定多个路径 绝对路径指定模糊路径",content:"在LiteFlow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是LiteFlow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n或者\n\nliteflow.rule-source=classpath:config/flow.el.xml\n\n\n以上两种是等价的。\n\n如果想扫描所有其他jar包中的类路径，可以使用classpath*::\n\nliteflow.rule-source=classpath*:config/liteflow/**/*.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 工程内指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用Spring EL表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n\n# 绝对路径指定多个路径\n\n绝对路径也可以用,或者;进行分隔：\n\nliteflow.rule-source=/data/lf/flow1.el.xml,/data/lf/flow2.el.xml\n\n\n\n# 绝对路径指定模糊路径\n\n你可以用*和**来进行模糊匹配：\n\nliteflow.rule-source=/data/lf/**/*Rule.xml\n\n\n以上则表示，在/data/lf/ 这个目录下，以及多级子目录下的所有匹配*Rule这个文件命名并且以xml结尾的所有文件。",normalizedContent:"在liteflow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是liteflow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n或者\n\nliteflow.rule-source=classpath:config/flow.el.xml\n\n\n以上两种是等价的。\n\n如果想扫描所有其他jar包中的类路径，可以使用classpath*::\n\nliteflow.rule-source=classpath*:config/liteflow/**/*.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 工程内指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用spring el表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n\n# 绝对路径指定多个路径\n\n绝对路径也可以用,或者;进行分隔：\n\nliteflow.rule-source=/data/lf/flow1.el.xml,/data/lf/flow2.el.xml\n\n\n\n# 绝对路径指定模糊路径\n\n你可以用*和**来进行模糊匹配：\n\nliteflow.rule-source=/data/lf/**/*rule.xml\n\n\n以上则表示，在/data/lf/ 这个目录下，以及多级子目录下的所有匹配*rule这个文件命名并且以xml结尾的所有文件。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📘SQL数据库配置源",frontmatter:{title:"📘SQL数据库配置源",date:"2022-10-06T23:18:42.000Z",permalink:"/pages/236b4f/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/040.SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/040.SQL数据库配置源.md",key:"v-1dffa9d7",path:"/pages/236b4f/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:64},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:32},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:2324},{level:2,title:"使用你项目中的dataSource来进行连接",slug:"使用你项目中的datasource来进行连接",normalizedTitle:"使用你项目中的datasource来进行连接",charIndex:6741},{level:2,title:"轮询自动刷新",slug:"轮询自动刷新",normalizedTitle:"轮询自动刷新",charIndex:554},{level:2,title:"自定义规则/脚本表过滤SQL",slug:"自定义规则-脚本表过滤sql",normalizedTitle:"自定义规则/脚本表过滤sql",charIndex:7748},{level:2,title:"支持决策路由",slug:"支持决策路由",normalizedTitle:"支持决策路由",charIndex:8074},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:8180}],headersStr:"依赖 配置 配置说明 使用你项目中的dataSource来进行连接 轮询自动刷新 自定义规则/脚本表过滤SQL 支持决策路由 小例子",content:'版本支持：\n\nLiteFlow原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准SQL语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-sql</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverClassName: com.mysql.cj.jdbc.Driver\n    username: root\n    password: 123456\n    applicationName: demo\n    #是否开启SQL日志\n    sqlLogEnabled: true\n    #是否开启SQL数据轮询自动刷新机制 默认不开启\n    pollingEnabled: true\n    pollingIntervalSeconds: 60\n    pollingStartSeconds: 60\n    #以下是chain表的配置，这个一定得有\n    chainTableName: chain\n    chainApplicationNameField: application_name\n    chainNameField: chain_name\n    elDataField: el_data\n    #以下是决策路由字段的配置，如果你没用到决策路由，可以不配置\n    routeField: route\n    namespaceField: namespace\n    #是否启用这条规则\n    chainEnableField: enable\n    #规则表自定义过滤SQL\n    chainCustomSql: 这里设置自定义规则表SQL\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scriptTableName: script\n    scriptApplicationNameField: application_name\n    scriptIdField: script_id\n    scriptNameField: script_name\n    scriptDataField: script_data\n    scriptTypeField: script_type\n    scriptLanguageField: script_language\n    #是否启用这条脚本\n    scriptEnableField: enable\n    #脚本表自定义过滤SQL\n    scriptCustomSql: 这里设置自定义脚本表SQL\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverClassName":"com.mysql.cj.jdbc.Driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationName": "demo",\\\n  "sqlLogEnabled": true,\\\n  "pollingEnabled": true,\\\n  "pollingIntervalSeconds": 60,\\\n  "pollingStartSeconds": 60,\\\n  "chainTableName": "chain",\\\n  "chainApplicationNameField": "application_name",\\\n  "chainNameField": "chain_name",\\\n  "elDataField": "el_data",\\\n  "routeField": "route",\\\n  "namespaceField": "namespace",\\\n  "chainEnableField": "enable",\\\n  "chainCustomSql": "这里设置自定义规则表SQL",\\\n  "scriptTableName": "script",\\\n  "scriptApplicationNameField": "application_name",\\\n  "scriptIdField": "script_id",\\\n  "scriptNameField": "script_name",\\\n  "scriptDataField": "script_data",\\\n  "scriptTypeField": "script_type",\\\n  "scriptLanguageField": "script_language",\\\n  "scriptEnableField": "enable",\\\n  "scriptCustomSql": "这里设置自定义脚本表SQL"\n  }\n\n\n\n# 配置说明\n\nLiteFlow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明                                                          是否必须\nurl                          jdbc的连接url                                                  否，如果使用自有数据源可以不配置\ndriverClassName              驱动器类名                                                       否，如果使用自有数据源可以不配置\nusername                     数据库用户名                                                      否，如果使用自有数据源可以不配置\npassword                     数据库密码                                                       否，如果使用自有数据源可以不配置\napplicationName              你的应用名称                                                      是\nsqlLogEnabled                是否开启SQL日志 默认开启                                              否\npollingEnabled               是否开启SQL数据轮询自动刷新机制 默认不开启                                     否，不配置就是不开启\npollingIntervalSeconds       SQL数据轮询时间间隔(s) 默认为60s                                       否\npollingStartSeconds          规则配置后首次轮询的起始时间(s) 默认为60s                                    否\nchainTableName               编排规则表的表名                                                    是\nchainApplicationNameField    编排规则表中应用名称存储字段名                                             是\nchainNameField               规则名称存储的字段名                                                  是\nelDataField                  EL表达式的字段(只存EL)                                              是\nrouteField                   决策路由EL字段                                                    否\nnamespaceField               namespace字段                                                 否\nchainEnableField             此chain是否生效，此字段最好在mysql中定义成tinyInt类型，1为生效，0为不生效              否，如果不配置，默认就是生效\nchainCustomSql               可以设置自定义的规则表过滤SQL                                            否\nscriptTableName              你的脚本存储表的表名                                                  是\nscriptApplicationNameField   脚本表中应用名称存储字段名                                               是\nscriptIdField                脚本组件的Id的字段名                                                 是\nscriptNameField              脚本组件名称的字段名                                                  是\nscriptDataField              脚本数据的字段名                                                    是\nscriptTypeField              脚本类型的字段名(类型参照脚本语言介绍)                                        是\nscriptLanguageField          脚本语言类型（groovy | qlexpress | js | python | lua | aviator |   否，如果只有一种脚本类型，可以不配置\n                             java | kotlin）\nscriptEnableField            此脚本是否生效，此字段最好在mysql中定义成tinyInt类型，1为生效，0为不生效                 否，如果不配置，默认就是生效\nscriptCustomSql              可以设置自定义的脚本表过滤SQL                                            否\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nID   APPLICATION_NAME   CHAIN_NAME   CHAIN_DESC   EL_DATA                 CREATE_TIME           ENABLE\n1    demo               chain1       测试流程1        THEN(a, b, c, s1,s2);   2022-09-19 19:31:00   1\n\n脚本表：liteflow_script\n\nID   APPLICATION_NAME   SCRIPT_ID   SCRIPT_NAME   SCRIPT_DATA                                                  SCRIPT_TYPE   SCRIPT_LANGUAGE   CREATE_TIME           ENABLE\n1    demo               s1          脚本s1          import cn.hutool.core.date.DateUtil                          script        groovy            2022-09-19 19:31:00   1\n                                                  def date = DateUtil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultContext.setData("demoDate", date)\n                                                  class Student {\n                                                  int studentID\n                                                  String studentName\n                                                  }\n                                                  Student student = new Student() student.studentID = 100301\n                                                  student.studentName = "张三"\n                                                  defaultContext.setData("student",student) def a=3\n                                                  def b=2\n                                                  defaultContext.setData("s1",a*b)\n2    demo               s2          脚本s2          defaultContext.setData("s2","hello")                         script        groovy            2022-09-19 19:31:00   1\n\n\n# 使用你项目中的dataSource来进行连接\n\nLiteFlow支持了使用项目中已存在的Datasource来进行数据库连接。如果你项目中已有链接配置，比如：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/poseidon\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n那么你在rule-source-ext-data-map中无需再配置以下几项：\n\nurl: jdbc:mysql://localhost:3306/poseidon\ndriverClassName: com.mysql.cj.jdbc.Driver\nusername: root\npassword: 123456\n\n\n提示\n\n需要注意的是，如果你的系统中声明了多个数据源，那么LiteFlow会自动判断该选用哪个数据源。\n\n如果你的系统中使用了动态数据源，那么请确保默认数据源是含有LiteFlow链路数据的表数据的。\n\n\n# 轮询自动刷新\n\nLiteFlow支持SQL数据源轮询模式的自动刷新机制。你可以在配置项中通过pollingEnabled: true来开启自动刷新：\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    pollingEnabled: true\n    ##以下非必须，默认1分钟\n    pollingIntervalSeconds: 60\n    pollingStartSeconds: 60\n    ...\n\n\nliteflow.rule-source-ext-data={\\\n  ...\\\n  "pollingEnabled": true,\\\n  "pollingIntervalSeconds": 60,\\\n  "pollingStartSeconds": 60,\\\n  ...\n  }\n\n\n轮询模式的自动刷新根据预设的时间间隔定时拉取SQL中的数据，与本地保存的数据SHA值进行对比来判断是否需要更新数据。\n\n定时轮询存在些微的性能消耗；受轮询间隔限制，数据更新有一定延迟性。\n\n\n# 自定义规则/脚本表过滤SQL\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    chainCustomSql: 这里设置自定义规则表SQL\n    scriptCustomSql: 这里设置自定义脚本表SQL\n    ...\n\n\n以上两个属性可以用来自定义你的过滤SQL。这里的配置的是完整的SQL。\n\n配置了自定义过滤SQL，则会完全忽略applicationName和enable属性了，完全根据你的自定义SQL来去查询了，但是返回的字段还是要符合开发者配置的映射字段。\n\n这个特性比较适合想自定义查询规则/脚本表的开发者，突破框架的applicationName和enable的限制。\n\n\n# 支持决策路由\n\n只需要配置routeField和namespaceFiled字段，并在数据库对应的映射字段存入决策路由的表达式即可开启数据库对决策路由的支持。\n\n决策路由的具体使用方式请看决策路由用法。\n\n\n# 小例子\n\n为了让大家能简单上手SQL规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'版本支持：\n\nliteflow原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准sql语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-sql</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverclassname: com.mysql.cj.jdbc.driver\n    username: root\n    password: 123456\n    applicationname: demo\n    #是否开启sql日志\n    sqllogenabled: true\n    #是否开启sql数据轮询自动刷新机制 默认不开启\n    pollingenabled: true\n    pollingintervalseconds: 60\n    pollingstartseconds: 60\n    #以下是chain表的配置，这个一定得有\n    chaintablename: chain\n    chainapplicationnamefield: application_name\n    chainnamefield: chain_name\n    eldatafield: el_data\n    #以下是决策路由字段的配置，如果你没用到决策路由，可以不配置\n    routefield: route\n    namespacefield: namespace\n    #是否启用这条规则\n    chainenablefield: enable\n    #规则表自定义过滤sql\n    chaincustomsql: 这里设置自定义规则表sql\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scripttablename: script\n    scriptapplicationnamefield: application_name\n    scriptidfield: script_id\n    scriptnamefield: script_name\n    scriptdatafield: script_data\n    scripttypefield: script_type\n    scriptlanguagefield: script_language\n    #是否启用这条脚本\n    scriptenablefield: enable\n    #脚本表自定义过滤sql\n    scriptcustomsql: 这里设置自定义脚本表sql\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverclassname":"com.mysql.cj.jdbc.driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationname": "demo",\\\n  "sqllogenabled": true,\\\n  "pollingenabled": true,\\\n  "pollingintervalseconds": 60,\\\n  "pollingstartseconds": 60,\\\n  "chaintablename": "chain",\\\n  "chainapplicationnamefield": "application_name",\\\n  "chainnamefield": "chain_name",\\\n  "eldatafield": "el_data",\\\n  "routefield": "route",\\\n  "namespacefield": "namespace",\\\n  "chainenablefield": "enable",\\\n  "chaincustomsql": "这里设置自定义规则表sql",\\\n  "scripttablename": "script",\\\n  "scriptapplicationnamefield": "application_name",\\\n  "scriptidfield": "script_id",\\\n  "scriptnamefield": "script_name",\\\n  "scriptdatafield": "script_data",\\\n  "scripttypefield": "script_type",\\\n  "scriptlanguagefield": "script_language",\\\n  "scriptenablefield": "enable",\\\n  "scriptcustomsql": "这里设置自定义脚本表sql"\n  }\n\n\n\n# 配置说明\n\nliteflow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明                                                          是否必须\nurl                          jdbc的连接url                                                  否，如果使用自有数据源可以不配置\ndriverclassname              驱动器类名                                                       否，如果使用自有数据源可以不配置\nusername                     数据库用户名                                                      否，如果使用自有数据源可以不配置\npassword                     数据库密码                                                       否，如果使用自有数据源可以不配置\napplicationname              你的应用名称                                                      是\nsqllogenabled                是否开启sql日志 默认开启                                              否\npollingenabled               是否开启sql数据轮询自动刷新机制 默认不开启                                     否，不配置就是不开启\npollingintervalseconds       sql数据轮询时间间隔(s) 默认为60s                                       否\npollingstartseconds          规则配置后首次轮询的起始时间(s) 默认为60s                                    否\nchaintablename               编排规则表的表名                                                    是\nchainapplicationnamefield    编排规则表中应用名称存储字段名                                             是\nchainnamefield               规则名称存储的字段名                                                  是\neldatafield                  el表达式的字段(只存el)                                              是\nroutefield                   决策路由el字段                                                    否\nnamespacefield               namespace字段                                                 否\nchainenablefield             此chain是否生效，此字段最好在mysql中定义成tinyint类型，1为生效，0为不生效              否，如果不配置，默认就是生效\nchaincustomsql               可以设置自定义的规则表过滤sql                                            否\nscripttablename              你的脚本存储表的表名                                                  是\nscriptapplicationnamefield   脚本表中应用名称存储字段名                                               是\nscriptidfield                脚本组件的id的字段名                                                 是\nscriptnamefield              脚本组件名称的字段名                                                  是\nscriptdatafield              脚本数据的字段名                                                    是\nscripttypefield              脚本类型的字段名(类型参照脚本语言介绍)                                        是\nscriptlanguagefield          脚本语言类型（groovy | qlexpress | js | python | lua | aviator |   否，如果只有一种脚本类型，可以不配置\n                             java | kotlin）\nscriptenablefield            此脚本是否生效，此字段最好在mysql中定义成tinyint类型，1为生效，0为不生效                 否，如果不配置，默认就是生效\nscriptcustomsql              可以设置自定义的脚本表过滤sql                                            否\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nid   application_name   chain_name   chain_desc   el_data                 create_time           enable\n1    demo               chain1       测试流程1        then(a, b, c, s1,s2);   2022-09-19 19:31:00   1\n\n脚本表：liteflow_script\n\nid   application_name   script_id   script_name   script_data                                                  script_type   script_language   create_time           enable\n1    demo               s1          脚本s1          import cn.hutool.core.date.dateutil                          script        groovy            2022-09-19 19:31:00   1\n                                                  def date = dateutil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultcontext.setdata("demodate", date)\n                                                  class student {\n                                                  int studentid\n                                                  string studentname\n                                                  }\n                                                  student student = new student() student.studentid = 100301\n                                                  student.studentname = "张三"\n                                                  defaultcontext.setdata("student",student) def a=3\n                                                  def b=2\n                                                  defaultcontext.setdata("s1",a*b)\n2    demo               s2          脚本s2          defaultcontext.setdata("s2","hello")                         script        groovy            2022-09-19 19:31:00   1\n\n\n# 使用你项目中的datasource来进行连接\n\nliteflow支持了使用项目中已存在的datasource来进行数据库连接。如果你项目中已有链接配置，比如：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver\nspring.datasource.url=jdbc:mysql://localhost:3306/poseidon\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n那么你在rule-source-ext-data-map中无需再配置以下几项：\n\nurl: jdbc:mysql://localhost:3306/poseidon\ndriverclassname: com.mysql.cj.jdbc.driver\nusername: root\npassword: 123456\n\n\n提示\n\n需要注意的是，如果你的系统中声明了多个数据源，那么liteflow会自动判断该选用哪个数据源。\n\n如果你的系统中使用了动态数据源，那么请确保默认数据源是含有liteflow链路数据的表数据的。\n\n\n# 轮询自动刷新\n\nliteflow支持sql数据源轮询模式的自动刷新机制。你可以在配置项中通过pollingenabled: true来开启自动刷新：\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    pollingenabled: true\n    ##以下非必须，默认1分钟\n    pollingintervalseconds: 60\n    pollingstartseconds: 60\n    ...\n\n\nliteflow.rule-source-ext-data={\\\n  ...\\\n  "pollingenabled": true,\\\n  "pollingintervalseconds": 60,\\\n  "pollingstartseconds": 60,\\\n  ...\n  }\n\n\n轮询模式的自动刷新根据预设的时间间隔定时拉取sql中的数据，与本地保存的数据sha值进行对比来判断是否需要更新数据。\n\n定时轮询存在些微的性能消耗；受轮询间隔限制，数据更新有一定延迟性。\n\n\n# 自定义规则/脚本表过滤sql\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    chaincustomsql: 这里设置自定义规则表sql\n    scriptcustomsql: 这里设置自定义脚本表sql\n    ...\n\n\n以上两个属性可以用来自定义你的过滤sql。这里的配置的是完整的sql。\n\n配置了自定义过滤sql，则会完全忽略applicationname和enable属性了，完全根据你的自定义sql来去查询了，但是返回的字段还是要符合开发者配置的映射字段。\n\n这个特性比较适合想自定义查询规则/脚本表的开发者，突破框架的applicationname和enable的限制。\n\n\n# 支持决策路由\n\n只需要配置routefield和namespacefiled字段，并在数据库对应的映射字段存入决策路由的表达式即可开启数据库对决策路由的支持。\n\n决策路由的具体使用方式请看决策路由用法。\n\n\n# 小例子\n\n为了让大家能简单上手sql规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📋Nacos配置源",frontmatter:{title:"📋Nacos配置源",date:"2022-10-06T23:19:04.000Z",permalink:"/pages/09b776/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/050.Nacos%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/050.Nacos配置源.md",key:"v-f4a518ac",path:"/pages/09b776/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:37},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:28},{level:2,title:"对阿里云MSE的支持",slug:"对阿里云mse的支持",normalizedTitle:"对阿里云mse的支持",charIndex:693},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:979},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:1213},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1483},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1557}],headersStr:"依赖 配置 对阿里云MSE的支持 配置说明 存储数据说明 自动刷新 小例子",content:'版本支持：\n\nLiteFlow原生支持了Nacos的规则配置源。\n\n\n# 依赖\n\n如果使用Nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-nacos</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serverAddr: 127.0.0.1:8848\n    dataId: demo_rule\n    group: DEFAULT_GROUP\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serverAddr":"127.0.0.1:8848",\\\n    "dataId":"demo_rule",\\\n    "group":"DEFAULT_GROUP",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 对阿里云MSE的支持\n\n自从v2.11.4开始，LiteFlow对阿里云的MSE也进行了支持，配置如下:\n\nliteflow.rule-source-ext-data={\\\n    "serverAddr":"127.0.0.1:8848",\\\n    "dataId":"demo_rule",\\\n    "group":"DEFAULT_GROUP",\\\n    "namespace":"your namespace id",\\\n    "accessKey":"xxxxxxxxxx",\\\n    "secretKey":"xxxxxxxxxx"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserverAddr   nacos的连接串\ndataId       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\naccessKey    阿里云的accessKey\nsecretKey    阿里云的secretKey\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用Nacos配置源的时候，Nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      THEN(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此Nacos配置源插件，凡是Nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手Nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'版本支持：\n\nliteflow原生支持了nacos的规则配置源。\n\n\n# 依赖\n\n如果使用nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-nacos</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serveraddr: 127.0.0.1:8848\n    dataid: demo_rule\n    group: default_group\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serveraddr":"127.0.0.1:8848",\\\n    "dataid":"demo_rule",\\\n    "group":"default_group",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 对阿里云mse的支持\n\n自从v2.11.4开始，liteflow对阿里云的mse也进行了支持，配置如下:\n\nliteflow.rule-source-ext-data={\\\n    "serveraddr":"127.0.0.1:8848",\\\n    "dataid":"demo_rule",\\\n    "group":"default_group",\\\n    "namespace":"your namespace id",\\\n    "accesskey":"xxxxxxxxxx",\\\n    "secretkey":"xxxxxxxxxx"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserveraddr   nacos的连接串\ndataid       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\naccesskey    阿里云的accesskey\nsecretkey    阿里云的secretkey\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用nacos配置源的时候，nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      then(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此nacos配置源插件，凡是nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🗄Etcd配置源",frontmatter:{title:"🗄Etcd配置源",date:"2022-10-06T23:19:17.000Z",permalink:"/pages/4bfac2/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/060.Etcd%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/060.Etcd配置源.md",key:"v-a5710d10",path:"/pages/4bfac2/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:36},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:27},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:575},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:707},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1132},{level:2,title:"脚本key的语言配置",slug:"脚本key的语言配置",normalizedTitle:"脚本key的语言配置",charIndex:1204},{level:2,title:"规则的启用关闭和脚本启用关闭",slug:"规则的启用关闭和脚本启用关闭",normalizedTitle:"规则的启用关闭和脚本启用关闭",charIndex:1349},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1780}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 脚本key的语言配置 规则的启用关闭和脚本启用关闭 小例子",content:'版本支持：\n\nLiteFlow原生支持了Etcd的规则配置源。\n\n\n# 依赖\n\n如果使用Etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-etcd</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainPath: /liteflow/chain\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在Etcd中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key的格式为：规则ID[:是否启用]，其中方括号内的为可选项，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:boolean_script:布尔脚本组件s2\n\n关于脚本类型，可以参照脚本语言介绍这一章节。\n\n\n# 自动刷新\n\n使用了此Etcd配置源插件，凡是Etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nLiteFlow也支持在Etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则ID[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手Etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'版本支持：\n\nliteflow原生支持了etcd的规则配置源。\n\n\n# 依赖\n\n如果使用etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-etcd</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainpath: /liteflow/chain\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在etcd中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key的格式为：规则id[:是否启用]，其中方括号内的为可选项，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:boolean_script:布尔脚本组件s2\n\n关于脚本类型，可以参照脚本语言介绍这一章节。\n\n\n# 自动刷新\n\n使用了此etcd配置源插件，凡是etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nliteflow也支持在etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则id[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📜Apollo配置源",frontmatter:{title:"📜Apollo配置源",date:"2022-12-12T22:42:40.000Z",permalink:"/pages/bea809/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/065.Apollo%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/065.Apollo配置源.md",key:"v-8ba74128",path:"/pages/bea809/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:55},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:26},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:523},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:608},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1299},{level:2,title:"脚本key的语言配置",slug:"脚本key的语言配置",normalizedTitle:"脚本key的语言配置",charIndex:1378},{level:2,title:"规则的启用关闭和脚本启用关闭",slug:"规则的启用关闭和脚本启用关闭",normalizedTitle:"规则的启用关闭和脚本启用关闭",charIndex:1523}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 脚本key的语言配置 规则的启用关闭和脚本启用关闭",content:'版本支持：\n\nLiteFlow原生支持了Apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用Apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-apollo</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainNamespace: chainConfig\n    scriptNamespace: scriptConfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainNamespace":"chainConfig",\\\n    "scriptNamespace":"scriptConfig"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainNamespace    规则命名空间名称\nscriptNamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在Apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在LiteFlow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在Apollo中需要为规则单独创建一个Namespace，数据类型选择properties，那么这个Namespace 下的每一对kv都是一个规则\n\nkey的格式为：规则ID[:是否启用]，其中方括号内的为可选项，value为单纯的EL（THEN(a,b,c)）\n\n假设你的规则命名空间为:chainConfig，那么配置形式样例如下：\n\nNAMESPACE：CHAINCONFIG   \nchain1                  THEN(a, b, c);\nchain2                  IF(x, b).ELIF(y, c).ELSE(d);\n\n对于脚本命名空间来说，节点的key有固定格式：脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据。\n\n假设你的脚本命名空间为：scriptConfig，那么配置形式样例如下：\n\nNAMESPACE：SCRIPTCONFIG    \ns1:script:脚本组件1           defaultContext.setData("s1","hello")\ns2:boolean_script:脚本组件2   if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\nApollo支持推送配置数据的变更，凡是在Apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nLiteFlow也支持在Etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则ID[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。',normalizedContent:'版本支持：\n\nliteflow原生支持了apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-apollo</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainnamespace: chainconfig\n    scriptnamespace: scriptconfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainnamespace":"chainconfig",\\\n    "scriptnamespace":"scriptconfig"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainnamespace    规则命名空间名称\nscriptnamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在liteflow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在apollo中需要为规则单独创建一个namespace，数据类型选择properties，那么这个namespace 下的每一对kv都是一个规则\n\nkey的格式为：规则id[:是否启用]，其中方括号内的为可选项，value为单纯的el（then(a,b,c)）\n\n假设你的规则命名空间为:chainconfig，那么配置形式样例如下：\n\nnamespace：chainconfig   \nchain1                  then(a, b, c);\nchain2                  if(x, b).elif(y, c).else(d);\n\n对于脚本命名空间来说，节点的key有固定格式：脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据。\n\n假设你的脚本命名空间为：scriptconfig，那么配置形式样例如下：\n\nnamespace：scriptconfig    \ns1:script:脚本组件1           defaultcontext.setdata("s1","hello")\ns2:boolean_script:脚本组件2   if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\napollo支持推送配置数据的变更，凡是在apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nliteflow也支持在etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则id[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置说明",frontmatter:{title:"配置说明",date:"2023-08-28T00:29:24.000Z",permalink:"/pages/38dcf8/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/066.%F0%9F%93%91Redis%E9%85%8D%E7%BD%AE%E6%BA%90/010.%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/066.📑Redis配置源/010.配置说明.md",key:"v-7955259c",path:"/pages/38dcf8/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:37},{level:2,title:"配置模式",slug:"配置模式",normalizedTitle:"配置模式",charIndex:278},{level:2,title:"配置模式选择",slug:"配置模式选择",normalizedTitle:"配置模式选择",charIndex:498}],headersStr:"依赖 配置模式 配置模式选择",content:"版本支持：\n\nLiteFlow原生支持了Redis的规则配置源。\n\n\n# 依赖\n\n如果使用Redis作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-redis</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可。\n\n\n# 配置模式\n\nRedis配置源支持平滑热刷新，在刷新机制上实现了【轮询】和【订阅】两种模式，可通过配置自由选择。\n\n> 【轮询模式】：基于Redis的Hash结构，通过定时轮询的方式进行规则刷新，轮询频率可配置，轮询间隔内有一定刷新延迟。\n> \n> 【订阅模式】：基于Redisson客户端的RMapCache存储结构，只支持使用Redisson客户端，可实现规则的实时平滑刷新。\n\n两种模式的插件依赖相同，仅通过配置参数加以区分。 如果没有配置模式选择，默认为轮询模式。\n\n两种模式的工作原理及具体配置方式详见对应子菜单：\n\nRedis配置源-轮询模式\n\nRedis配置源-订阅模式\n\n\n# 配置模式选择\n\n基于两种工作模式的特点，推荐根据实际需要进行选择。\n\n>  * 如果你需要采用其他Redis客户端 (如Jedis等)，且接受轮询间隔内的数据刷新延迟，推荐你配置为【轮询模式】\n> \n>  * 如果你需要确保规则刷新的实时性，不容忍轮询间隔内的延迟，且接受使用Redisson，推荐你配置为【订阅模式】",normalizedContent:"版本支持：\n\nliteflow原生支持了redis的规则配置源。\n\n\n# 依赖\n\n如果使用redis作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-redis</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可。\n\n\n# 配置模式\n\nredis配置源支持平滑热刷新，在刷新机制上实现了【轮询】和【订阅】两种模式，可通过配置自由选择。\n\n> 【轮询模式】：基于redis的hash结构，通过定时轮询的方式进行规则刷新，轮询频率可配置，轮询间隔内有一定刷新延迟。\n> \n> 【订阅模式】：基于redisson客户端的rmapcache存储结构，只支持使用redisson客户端，可实现规则的实时平滑刷新。\n\n两种模式的插件依赖相同，仅通过配置参数加以区分。 如果没有配置模式选择，默认为轮询模式。\n\n两种模式的工作原理及具体配置方式详见对应子菜单：\n\nredis配置源-轮询模式\n\nredis配置源-订阅模式\n\n\n# 配置模式选择\n\n基于两种工作模式的特点，推荐根据实际需要进行选择。\n\n>  * 如果你需要采用其他redis客户端 (如jedis等)，且接受轮询间隔内的数据刷新延迟，推荐你配置为【轮询模式】\n> \n>  * 如果你需要确保规则刷新的实时性，不容忍轮询间隔内的延迟，且接受使用redisson，推荐你配置为【订阅模式】",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"轮询模式配置",frontmatter:{title:"轮询模式配置",date:"2023-08-23T19:55:26.000Z",permalink:"/pages/186747/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/066.%F0%9F%93%91Redis%E9%85%8D%E7%BD%AE%E6%BA%90/020.%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/066.📑Redis配置源/020.轮询模式配置.md",key:"v-20415b54",path:"/pages/186747/",headers:[{level:2,title:"工作原理",slug:"工作原理",normalizedTitle:"工作原理",charIndex:28},{level:2,title:"配置参数",slug:"配置参数",normalizedTitle:"配置参数",charIndex:485},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:1582},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:2143},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:2957},{level:2,title:"模式优缺点",slug:"模式优缺点",normalizedTitle:"模式优缺点",charIndex:3036},{level:2,title:"脚本key的语言配置",slug:"脚本key的语言配置",normalizedTitle:"脚本key的语言配置",charIndex:3305},{level:2,title:"规则的启用关闭和脚本启用关闭",slug:"规则的启用关闭和脚本启用关闭",normalizedTitle:"规则的启用关闭和脚本启用关闭",charIndex:3450},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:3881}],headersStr:"工作原理 配置参数 配置说明 存储数据说明 自动刷新 模式优缺点 脚本key的语言配置 规则的启用关闭和脚本启用关闭 小例子",content:'Redis配置源的规则刷新机制默认为轮询模式。\n\n\n# 工作原理\n\n轮询模式以 定时拉取 的方式进行规则数据刷新。\n\n在拉取方式的具体设计上主要考虑到两个因素。其一，若每次去Redis中拉取规则数据，需要再次解析和编译，会对框架性能造成很大影响； 其二，大部分时间拉取的数据并无变化，无用功较多。\n\n考虑到如上两个问题，轮询模式数据拉取的工作方式设定为：\n\n> 1、首次在Redis中获取数据后，将数据以KV结构缓存到本地，key为chainId/scriptId (以下简称数据Id)，value为数据的指纹值 (SHA-1值)。相较于原始数据，指纹值数据量小，缓存占用空间可忽略不计。\n> \n> \n> 2、此后的每次轮询中，无需拉取全部数据，而是在Redis端调用脚本计算当前数据的指纹值，仅传输数据Id及对应指纹值。\n> \n> \n> 3、将拉取获得的最新指纹值与本地缓存的指纹值对比，对于发生变化的数据，针对性地根据数据Id从Redis中获取最新数据值，更新规则元数据，同时更新本地缓存指纹值。\n\n以上设定中，首次轮询起始时间、轮询时间间隔均可自由配置。\n\n\n# 配置参数\n\nRedis配置源支持单点和哨兵两种模式。轮询模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redisMode: sentinel\n    masterName: mymaster\n    sentinelAddress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    #下面两项可以选配(2.12.2+支持)\n    connectionPoolSize: 2\n    connectionMinimumIdleSize: 4\n    #下面这几项必须得配置\n    mode: poll\n    pollingInterval: 60\n    pollingStartTime: 60\n    chainDataBase: 1\n    chainKey: chainKey\n    #如果你没有脚本组件，以下可以不配置\n    scriptDataBase: 1\n    scriptKey: scriptKey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redisMode":"sentinel",\\\n      "masterName":"mymaster",\\\n      "sentinelAddress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"poll",\\\n      "pollingInterval":60,\\\n      "pollingStartTime":60,\\\n      "chainDataBase":1,\\\n      "chainKey":"chainKey",\\\n      "scriptDataBase":1,\\\n      "scriptKey":"scriptKey"\\\n}\n\n\n\n# 配置说明\n\n配置项                说明\nredisMode          Redis模式，single为单点，sentinel为哨兵，默认为单点\nhost               单点模式Redis连接IP地址\nport               单点模式Redis连接端口号\nmasterName         哨兵模式主节点名\nsentinelAddress    哨兵模式哨兵节点连接地址 ip:port\nusername           Redis的用户名 (Redis 6.0及以上)\npassword           Redis的密码\nmode               规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchainDataBase      规则数据的数据库号\nchainKey           规则数据的Redis key名\nscriptDataBase     脚本组件的数据库号\nscriptKey          脚本组件的Redis key名\npollingInterval    轮询时间间隔(s)，默认为60s\npollingStartTime   规则配置后首次轮询的起始时间(s)，默认为60s\n\n\n# 存储数据说明\n\n提示\n\n在轮询模式中，规则和脚本数据均以Redis Hash结构存储，配置项chainKey和scriptKey即为该Hash的名字。\n\n你可以在redis UI客户端直接存入数据，如果使用redis client框架以代码的方式存入时，一定要注意编码，比如以Redisson存储规则时，一定要设置Codec为StringCodec。\n\n对于规则来说，你在Redis中需要为规则单独创建一个Hash类型的数据，这个Hash内的每个键值对就是一个规则，Hash内的每一个键的格式为：规则ID[:是否启用]，其中方括号内的为可选项，值为单纯的EL（THEN(a,b,c)）。\n\n假设你的规则Hash数据键名为:chains，那么配置形式样例如下：\n\nREDIS HASHKEY：CHAINS   \nchain1                 THEN(a, b, c);\nchain2                 IF(x, b).ELIF(y, c).ELSE(d);\n\n对于脚本来说，Hash中的field有固定格式：脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据\n\n假设你的脚本Hash数据键名为:scripts，那么配置形式样例如下：\n\nREDIS HASHKEY：SCRIPTS     \ns1:script:脚本组件1           defaultContext.setData("s1","hello")\ns2:script:脚本组件2:js        defaultContext.setData("s2","hello")\ns3:boolean_script:脚本组件3   if(a > 100){return true;}else{return false;}\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n\n# 自动刷新\n\n使用了此Redis配置源插件的轮询模式，凡是在配置的Redis键内的数据改动，会依据设定的轮询参数定期拉取并更新数据，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，轮询模式在性能方面做出了权衡：\n\n> 【优势】\n> \n>  * 能做到按需拉取真实数据，缓存占用空间小；\n>  * 计算脚本预先缓存到服务端，不影响Redis服务端性能；\n>  * 基于Redis原生Hash结构存储，可通过任意客户端或命令行操作数据。\n> \n> 【劣势】\n> \n>  * 受轮询间隔限制，数据更新不实时；\n>  * 客户端定时轮询存在性能消耗，但仅做指纹值对比，传输数据量小，实际性能影响很小。\n\n如果对数据数据延迟容忍度高，且希望Redis客户端不受限的情况下，推荐采用轮询模式。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nLiteFlow也支持在Etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则ID[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手Redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'redis配置源的规则刷新机制默认为轮询模式。\n\n\n# 工作原理\n\n轮询模式以 定时拉取 的方式进行规则数据刷新。\n\n在拉取方式的具体设计上主要考虑到两个因素。其一，若每次去redis中拉取规则数据，需要再次解析和编译，会对框架性能造成很大影响； 其二，大部分时间拉取的数据并无变化，无用功较多。\n\n考虑到如上两个问题，轮询模式数据拉取的工作方式设定为：\n\n> 1、首次在redis中获取数据后，将数据以kv结构缓存到本地，key为chainid/scriptid (以下简称数据id)，value为数据的指纹值 (sha-1值)。相较于原始数据，指纹值数据量小，缓存占用空间可忽略不计。\n> \n> \n> 2、此后的每次轮询中，无需拉取全部数据，而是在redis端调用脚本计算当前数据的指纹值，仅传输数据id及对应指纹值。\n> \n> \n> 3、将拉取获得的最新指纹值与本地缓存的指纹值对比，对于发生变化的数据，针对性地根据数据id从redis中获取最新数据值，更新规则元数据，同时更新本地缓存指纹值。\n\n以上设定中，首次轮询起始时间、轮询时间间隔均可自由配置。\n\n\n# 配置参数\n\nredis配置源支持单点和哨兵两种模式。轮询模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redismode: sentinel\n    mastername: mymaster\n    sentineladdress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    #下面两项可以选配(2.12.2+支持)\n    connectionpoolsize: 2\n    connectionminimumidlesize: 4\n    #下面这几项必须得配置\n    mode: poll\n    pollinginterval: 60\n    pollingstarttime: 60\n    chaindatabase: 1\n    chainkey: chainkey\n    #如果你没有脚本组件，以下可以不配置\n    scriptdatabase: 1\n    scriptkey: scriptkey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redismode":"sentinel",\\\n      "mastername":"mymaster",\\\n      "sentineladdress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"poll",\\\n      "pollinginterval":60,\\\n      "pollingstarttime":60,\\\n      "chaindatabase":1,\\\n      "chainkey":"chainkey",\\\n      "scriptdatabase":1,\\\n      "scriptkey":"scriptkey"\\\n}\n\n\n\n# 配置说明\n\n配置项                说明\nredismode          redis模式，single为单点，sentinel为哨兵，默认为单点\nhost               单点模式redis连接ip地址\nport               单点模式redis连接端口号\nmastername         哨兵模式主节点名\nsentineladdress    哨兵模式哨兵节点连接地址 ip:port\nusername           redis的用户名 (redis 6.0及以上)\npassword           redis的密码\nmode               规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchaindatabase      规则数据的数据库号\nchainkey           规则数据的redis key名\nscriptdatabase     脚本组件的数据库号\nscriptkey          脚本组件的redis key名\npollinginterval    轮询时间间隔(s)，默认为60s\npollingstarttime   规则配置后首次轮询的起始时间(s)，默认为60s\n\n\n# 存储数据说明\n\n提示\n\n在轮询模式中，规则和脚本数据均以redis hash结构存储，配置项chainkey和scriptkey即为该hash的名字。\n\n你可以在redis ui客户端直接存入数据，如果使用redis client框架以代码的方式存入时，一定要注意编码，比如以redisson存储规则时，一定要设置codec为stringcodec。\n\n对于规则来说，你在redis中需要为规则单独创建一个hash类型的数据，这个hash内的每个键值对就是一个规则，hash内的每一个键的格式为：规则id[:是否启用]，其中方括号内的为可选项，值为单纯的el（then(a,b,c)）。\n\n假设你的规则hash数据键名为:chains，那么配置形式样例如下：\n\nredis hashkey：chains   \nchain1                 then(a, b, c);\nchain2                 if(x, b).elif(y, c).else(d);\n\n对于脚本来说，hash中的field有固定格式：脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据\n\n假设你的脚本hash数据键名为:scripts，那么配置形式样例如下：\n\nredis hashkey：scripts     \ns1:script:脚本组件1           defaultcontext.setdata("s1","hello")\ns2:script:脚本组件2:js        defaultcontext.setdata("s2","hello")\ns3:boolean_script:脚本组件3   if(a > 100){return true;}else{return false;}\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n\n# 自动刷新\n\n使用了此redis配置源插件的轮询模式，凡是在配置的redis键内的数据改动，会依据设定的轮询参数定期拉取并更新数据，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，轮询模式在性能方面做出了权衡：\n\n> 【优势】\n> \n>  * 能做到按需拉取真实数据，缓存占用空间小；\n>  * 计算脚本预先缓存到服务端，不影响redis服务端性能；\n>  * 基于redis原生hash结构存储，可通过任意客户端或命令行操作数据。\n> \n> 【劣势】\n> \n>  * 受轮询间隔限制，数据更新不实时；\n>  * 客户端定时轮询存在性能消耗，但仅做指纹值对比，传输数据量小，实际性能影响很小。\n\n如果对数据数据延迟容忍度高，且希望redis客户端不受限的情况下，推荐采用轮询模式。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nliteflow也支持在etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则id[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📎普通组件",frontmatter:{title:"📎普通组件",date:"2022-06-29T17:53:36.000Z",permalink:"/pages/8486fb/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/010.%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/055.🔗常规组件/010.普通组件.md",key:"v-e067da7e",path:"/pages/8486fb/",headers:[{level:2,title:"可以覆盖的方法",slug:"可以覆盖的方法",normalizedTitle:"可以覆盖的方法",charIndex:335},{level:3,title:"isAccess",slug:"isaccess",normalizedTitle:"isaccess",charIndex:369},{level:3,title:"isContinueOnError",slug:"iscontinueonerror",normalizedTitle:"iscontinueonerror",charIndex:422},{level:3,title:"isEnd",slug:"isend",normalizedTitle:"isend",charIndex:472},{level:3,title:"beforeProcess和afterProcess",slug:"beforeprocess和afterprocess",normalizedTitle:"beforeprocess和afterprocess",charIndex:667},{level:3,title:"onSuccess和onError",slug:"onsuccess和onerror",normalizedTitle:"onsuccess和onerror",charIndex:797},{level:3,title:"rollback",slug:"rollback",normalizedTitle:"rollback",charIndex:845},{level:2,title:"This关键字可以调用的方法",slug:"this关键字可以调用的方法",normalizedTitle:"this关键字可以调用的方法",charIndex:881},{level:3,title:"获取上下文",slug:"获取上下文",normalizedTitle:"获取上下文",charIndex:900},{level:3,title:"getNodeId",slug:"getnodeid",normalizedTitle:"getnodeid",charIndex:978},{level:3,title:"getName",slug:"getname",normalizedTitle:"getname",charIndex:1001},{level:3,title:"getChainName",slug:"getchainname",normalizedTitle:"getchainname",charIndex:1022},{level:3,title:"getRequestData",slug:"getrequestdata",normalizedTitle:"getrequestdata",charIndex:1053},{level:3,title:"setIsEnd",slug:"setisend",normalizedTitle:"setisend",charIndex:613},{level:3,title:"getTag",slug:"gettag",normalizedTitle:"gettag",charIndex:1284},{level:3,title:"invoke和invoke2Response",slug:"invoke和invoke2response",normalizedTitle:"invoke和invoke2response",charIndex:1328},{level:2,title:"@LiteflowComponent",slug:"liteflowcomponent",normalizedTitle:"@liteflowcomponent",charIndex:58}],headersStr:"可以覆盖的方法 isAccess isContinueOnError isEnd beforeProcess和afterProcess onSuccess和onError rollback This关键字可以调用的方法 获取上下文 getNodeId getName getChainName getRequestData setIsEnd getTag invoke和invoke2Response @LiteflowComponent",content:'普通组件节点需要继承NodeComponent，可用于THEN和WHEN关键字中。\n\n需要实现process方法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n提示\n\n@LiteflowComponent继承自@Component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@LiteflowComponent的参数a，就是你在写EL规则时需要用到组件ID。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isAccess\n\n推荐实现isAccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# isContinueOnError\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isEnd\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# beforeProcess和afterProcess\n\n流程的前置和后置处理器，其中前置处理器，在isAccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onSuccess和onError\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# rollback\n\n流程失败后的回滚方法，详情请参考组件回滚。\n\n\n# This关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getContextBean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getNodeId\n\n获取组件ID。\n\n\n# getName\n\n获取组件别名。\n\n\n# getChainName\n\n获取当前执行的流程名称。\n\n\n# getRequestData\n\n获取流程的初始参数。\n\n\n# setIsEnd\n\n表示是否立即结束整个流程 ，用法为this.setIsEnd(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# getTag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2Response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @LiteflowComponent\n\n@LiteflowComponent注解是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'普通组件节点需要继承nodecomponent，可用于then和when关键字中。\n\n需要实现process方法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n提示\n\n@liteflowcomponent继承自@component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@liteflowcomponent的参数a，就是你在写el规则时需要用到组件id。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isaccess\n\n推荐实现isaccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# iscontinueonerror\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isend\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# beforeprocess和afterprocess\n\n流程的前置和后置处理器，其中前置处理器，在isaccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onsuccess和onerror\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# rollback\n\n流程失败后的回滚方法，详情请参考组件回滚。\n\n\n# this关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getcontextbean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getnodeid\n\n获取组件id。\n\n\n# getname\n\n获取组件别名。\n\n\n# getchainname\n\n获取当前执行的流程名称。\n\n\n# getrequestdata\n\n获取流程的初始参数。\n\n\n# setisend\n\n表示是否立即结束整个流程 ，用法为this.setisend(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# gettag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @liteflowcomponent\n\n@liteflowcomponent注解是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"订阅模式配置",frontmatter:{title:"订阅模式配置",date:"2023-08-28T00:31:38.000Z",permalink:"/pages/3f553f/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/066.%F0%9F%93%91Redis%E9%85%8D%E7%BD%AE%E6%BA%90/030.%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/066.📑Redis配置源/030.订阅模式配置.md",key:"v-9b96d50a",path:"/pages/3f553f/",headers:[{level:2,title:"工作原理",slug:"工作原理",normalizedTitle:"工作原理",charIndex:37},{level:2,title:"配置参数",slug:"配置参数",normalizedTitle:"配置参数",charIndex:1},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:1428},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:1896},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:2746},{level:2,title:"模式优缺点",slug:"模式优缺点",normalizedTitle:"模式优缺点",charIndex:2832},{level:2,title:"脚本key的语言配置",slug:"脚本key的语言配置",normalizedTitle:"脚本key的语言配置",charIndex:3026},{level:2,title:"规则的启用关闭和脚本启用关闭",slug:"规则的启用关闭和脚本启用关闭",normalizedTitle:"规则的启用关闭和脚本启用关闭",charIndex:3171},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:3602}],headersStr:"工作原理 配置参数 配置说明 存储数据说明 自动刷新 模式优缺点 脚本key的语言配置 规则的启用关闭和脚本启用关闭 小例子",content:'在配置参数中添加mode:sub，可将规则刷新机制选为订阅模式。\n\n\n# 工作原理\n\n订阅模式基于Pub/Sub机制，依赖于Redisson中RMapCache结构的监听功能。\n\n考虑到轮询模式无法保证规则刷新的实时性，因此提供订阅模式的刷新机制，即客户端修改数据后发送一个事件，LiteFlow订阅到该事件后进行数据刷新。\n\n> 基于Pub/Sub机制，若采用Redis原生Hash结构，则修改数据方需要增加额外的开发成本来发送事件。 为降低用户修改规则的开发成本，Redis配置源的订阅模式选择采用Redisson的RMapCache结构。\n> \n> \n> RMapCache可看作自带监听功能的Redis Hash结构，其底层通过创建额外的Key和Lua脚本，自动使用Pub/Sub来实现监听机制。\n\n需要注意的是，由于Redisson对RMapCache结构中的field和value进行了改动，并非纯文本。故对数据的读取和修改均只能使用Redisson客户端进行。\n\n\n# 配置参数\n\nRedis配置源支持单点和哨兵两种模式。订阅模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redisMode: sentinel\n    masterName: mymaster\n    sentinelAddress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    #下面两项可以选配(2.12.2+支持)\n    connectionPoolSize: 2\n    connectionMinimumIdleSize: 4\n    #下面的几项必须配置\n    mode: sub\n    chainDataBase: 1\n    chainKey: chainKey\n    #如果你没有脚本组件，以下可以不配置\n    scriptDataBase: 1\n    scriptKey: scriptKey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redisMode":"sentinel",\\\n      "masterName":"mymaster",\\\n      "sentinelAddress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"sub",\\\n      "chainDataBase":1,\\\n      "chainKey":"chainKey",\\\n      "scriptDataBase":1,\\\n      "scriptKey":"scriptKey"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nredisMode         Redis模式，single为单点，sentinel为哨兵，默认为单点\nhost              单点模式Redis连接IP地址\nport              单点模式Redis连接端口号\nmasterName        哨兵模式主节点名\nsentinelAddress   哨兵模式哨兵节点连接地址 ip:port\nusername          Redis的用户名 (Redis 6.0及以上)\npassword          Redis的密码\nmode              规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchainDataBase     规则数据的数据库号\nchainKey          规则数据的Redis key名\nscriptDataBase    脚本组件的数据库号\nscriptKey         脚本组件的Redis key名\n\n\n# 存储数据说明\n\n提示\n\n在订阅模式中，规则和脚本数据均以Redisson RMapCache结构存储，配置项chainKey和scriptKey即为该RMapCache的名字。\n\n对于规则来说，你需要使用Redisson客户端，为规则单独创建一个RMapCache类型的数据，这个结构内的每个键值对就是一个规则，RMapCache内的key的格式为：规则ID[:是否启用]，其中方括号内的为可选项，value为单纯的EL（THEN(a,b,c)）。\n\n假设你的规则RMapCache数据键名为:chains，那么利用Redisson客户端的数据操作如下：\n\nRMapCache<String, String> chains = redissonClient.getMapCache("chains");\nchains.put("chain1", "THEN(a, b, c);");\nchains.put("chain2", "IF(x, b).ELIF(y, c).ELSE(d);");\n\n\n对于脚本来说，RMapCache中的key有固定格式：脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据\n\n假设你的脚本RMapCache数据键名为:scripts，那么利用Redisson客户端的数据操作如下：\n\nRMapCache<String, String> scripts = redissonClient.getMapCache("scripts");\nscripts.put("s1:script:脚本组件1", "defaultContext.setData(\\"test1\\",\\"hello\\");");\nscripts.put("s2:script:脚本组件2:js", "defaultContext.setData(\\"test2\\",\\"hello\\");");\n\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此Redis配置源插件的订阅模式，凡是在配置的RMapCache对象内的数据改动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，订阅模式有如下优势和局限性：\n\n> 【优势】\n> \n>  * 数据刷新实时性高；\n>  * 能够做到按需刷新，不产生额外的通知成本；\n>  * 监听性能较高。\n> \n> 【劣势】\n> \n>  * 基于独有数据结构，Redis客户端只能使用Redisson。\n\n如果对数据数据延迟容忍度低，希望保证实时性，且接受使用Redisson，推荐采用订阅模式。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nLiteFlow也支持在Etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则ID[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手Redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'在配置参数中添加mode:sub，可将规则刷新机制选为订阅模式。\n\n\n# 工作原理\n\n订阅模式基于pub/sub机制，依赖于redisson中rmapcache结构的监听功能。\n\n考虑到轮询模式无法保证规则刷新的实时性，因此提供订阅模式的刷新机制，即客户端修改数据后发送一个事件，liteflow订阅到该事件后进行数据刷新。\n\n> 基于pub/sub机制，若采用redis原生hash结构，则修改数据方需要增加额外的开发成本来发送事件。 为降低用户修改规则的开发成本，redis配置源的订阅模式选择采用redisson的rmapcache结构。\n> \n> \n> rmapcache可看作自带监听功能的redis hash结构，其底层通过创建额外的key和lua脚本，自动使用pub/sub来实现监听机制。\n\n需要注意的是，由于redisson对rmapcache结构中的field和value进行了改动，并非纯文本。故对数据的读取和修改均只能使用redisson客户端进行。\n\n\n# 配置参数\n\nredis配置源支持单点和哨兵两种模式。订阅模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redismode: sentinel\n    mastername: mymaster\n    sentineladdress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    #下面两项可以选配(2.12.2+支持)\n    connectionpoolsize: 2\n    connectionminimumidlesize: 4\n    #下面的几项必须配置\n    mode: sub\n    chaindatabase: 1\n    chainkey: chainkey\n    #如果你没有脚本组件，以下可以不配置\n    scriptdatabase: 1\n    scriptkey: scriptkey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redismode":"sentinel",\\\n      "mastername":"mymaster",\\\n      "sentineladdress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"sub",\\\n      "chaindatabase":1,\\\n      "chainkey":"chainkey",\\\n      "scriptdatabase":1,\\\n      "scriptkey":"scriptkey"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nredismode         redis模式，single为单点，sentinel为哨兵，默认为单点\nhost              单点模式redis连接ip地址\nport              单点模式redis连接端口号\nmastername        哨兵模式主节点名\nsentineladdress   哨兵模式哨兵节点连接地址 ip:port\nusername          redis的用户名 (redis 6.0及以上)\npassword          redis的密码\nmode              规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchaindatabase     规则数据的数据库号\nchainkey          规则数据的redis key名\nscriptdatabase    脚本组件的数据库号\nscriptkey         脚本组件的redis key名\n\n\n# 存储数据说明\n\n提示\n\n在订阅模式中，规则和脚本数据均以redisson rmapcache结构存储，配置项chainkey和scriptkey即为该rmapcache的名字。\n\n对于规则来说，你需要使用redisson客户端，为规则单独创建一个rmapcache类型的数据，这个结构内的每个键值对就是一个规则，rmapcache内的key的格式为：规则id[:是否启用]，其中方括号内的为可选项，value为单纯的el（then(a,b,c)）。\n\n假设你的规则rmapcache数据键名为:chains，那么利用redisson客户端的数据操作如下：\n\nrmapcache<string, string> chains = redissonclient.getmapcache("chains");\nchains.put("chain1", "then(a, b, c);");\nchains.put("chain2", "if(x, b).elif(y, c).else(d);");\n\n\n对于脚本来说，rmapcache中的key有固定格式：脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，其中方括号内的为可选项。 value为脚本数据\n\n假设你的脚本rmapcache数据键名为:scripts，那么利用redisson客户端的数据操作如下：\n\nrmapcache<string, string> scripts = redissonclient.getmapcache("scripts");\nscripts.put("s1:script:脚本组件1", "defaultcontext.setdata(\\"test1\\",\\"hello\\");");\nscripts.put("s2:script:脚本组件2:js", "defaultcontext.setdata(\\"test2\\",\\"hello\\");");\n\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此redis配置源插件的订阅模式，凡是在配置的rmapcache对象内的数据改动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，订阅模式有如下优势和局限性：\n\n> 【优势】\n> \n>  * 数据刷新实时性高；\n>  * 能够做到按需刷新，不产生额外的通知成本；\n>  * 监听性能较高。\n> \n> 【劣势】\n> \n>  * 基于独有数据结构，redis客户端只能使用redisson。\n\n如果对数据数据延迟容忍度低，希望保证实时性，且接受使用redisson，推荐采用订阅模式。\n\n\n# 脚本key的语言配置\n\n如果你只依赖了一种脚本语言插件包，那么语言这项是不需要配置的。会自动识别的。如果你配置了多语言脚本，那么脚本语言这一项，是必须要写的。\n\n比如s1:boolean_script:布尔脚本s1:js。\n\n关于脚本的多语言共存，请参考多脚本语言混合共存这一章。\n\n\n# 规则的启用关闭和脚本启用关闭\n\nliteflow也支持在etcd节点上保留数据的同时关闭和启动规则/脚本。\n\n之前说到规则的key的固定格式为规则id[:是否启用]，如果配置chain1:false，那么这个规则就是关闭状态。相当于逻辑删除。\n\n当然如果你只是配置key为chain1，那么等价于chain1:true。\n\n对于脚本key来说，固定格式为脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]，如果配置s1:script:脚本s1:groovy:false，那么这个脚本就是关闭状态，相当于逻辑删除。\n\n如果不配置最后一项，比如s1:script:脚本s1:groovy，那么等价于s1:script:脚本s1:groovy:true。\n\n提示\n\n对于规则key或者脚本key来说，一定要以冒号为分隔符对应好位置，如果你想配置是否启动，那么是在第5项，前面4项就必须要写，如果你写成s1:script:脚本s1:false那将会报错。\n\n\n# 小例子\n\n为了让大家能简单上手redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📙自定义配置源",frontmatter:{title:"📙自定义配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/25f2c0/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E6%BA%90/070.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"07.v2.12.X文档/050.🗂规则以及配置源/070.自定义配置源.md",key:"v-0ac95c8f",path:"/pages/25f2c0/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:1273}],headersStr:"说明 配置路径",content:'# 说明\n\nLiteFlow原生只允许一种配置源，比如你使用了数据库配置源，那么就无法使用redis配置源了，你无法一部分规则/脚本从数据库取，另一部分从redis中取。\n\n如果你希望整合两种或以上的配置源，又或者你想从其他框架不支持的地方获取规则/脚本，就需要用到自定义配置源了。\n\n这部分LiteFlow只提供扩展接口，需要开发者自己开发的。\n\n事实上LiteFlow支持的配置源，也是扩展这个接口来实现的。有兴趣的，可以看看源码。\n\nLiteFlow提供三种格式的扩展源，分别是：\n\nXML形式的规则文件请继承ClassXmlFlowELParser\n\nJSON形式的规则文件请继承ClassJsonFlowELParser\n\nYML形式的规则文件请继承ClassYmlFlowELParser\n\n提示\n\n框架原生提供的配置源插件其实都是继承于ClassXmlFlowELParser的，其实格式对于插件来说没那么重要，因为真正存储的地方可以只存关键数据，而不用是xml/json/yaml。插件拿到关键数据后，可以组装成相应格式形式。\n\n这部分对于具体使用者来说，是黑盒的。\n\n以下以XML形式的自定义源配置类举例：\n\npublic class TestCustomParser extends ClassXmlFlowELParser {\n\n\t@Override\n\tpublic String parseCustom() {\n\t\tSystem.out.println("进入自定义parser");\n\t\tString xmlContent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlContent;\n\t}\n}\n\n\n无论你数据存在几个地方，或者是存于哪个存储。中间逻辑需要开发者自己实现，并组装成完成的xml并返回。就是这种形式：\n\n<flow>\n    <nodes>\n        <node id="脚本id1" name="脚本名称" type="script" language="脚本语言">\n            ...\n        </node>\n\n        <node id="脚本id2" name="脚本名称" type="script" language="脚本语言">\n            ...\n        </node>\n        \n        ...\n    </nodes>\n    \n    <chain name="chain1">\n        ...\n    </chain>\n\n    <chain name="chain2">\n        ...\n    </chain>\n    \n    ...\n</flow>\n\n\n提示\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@Autowired和@Resources等标签\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n\n关于el_xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以EL的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',normalizedContent:'# 说明\n\nliteflow原生只允许一种配置源，比如你使用了数据库配置源，那么就无法使用redis配置源了，你无法一部分规则/脚本从数据库取，另一部分从redis中取。\n\n如果你希望整合两种或以上的配置源，又或者你想从其他框架不支持的地方获取规则/脚本，就需要用到自定义配置源了。\n\n这部分liteflow只提供扩展接口，需要开发者自己开发的。\n\n事实上liteflow支持的配置源，也是扩展这个接口来实现的。有兴趣的，可以看看源码。\n\nliteflow提供三种格式的扩展源，分别是：\n\nxml形式的规则文件请继承classxmlflowelparser\n\njson形式的规则文件请继承classjsonflowelparser\n\nyml形式的规则文件请继承classymlflowelparser\n\n提示\n\n框架原生提供的配置源插件其实都是继承于classxmlflowelparser的，其实格式对于插件来说没那么重要，因为真正存储的地方可以只存关键数据，而不用是xml/json/yaml。插件拿到关键数据后，可以组装成相应格式形式。\n\n这部分对于具体使用者来说，是黑盒的。\n\n以下以xml形式的自定义源配置类举例：\n\npublic class testcustomparser extends classxmlflowelparser {\n\n\t@override\n\tpublic string parsecustom() {\n\t\tsystem.out.println("进入自定义parser");\n\t\tstring xmlcontent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlcontent;\n\t}\n}\n\n\n无论你数据存在几个地方，或者是存于哪个存储。中间逻辑需要开发者自己实现，并组装成完成的xml并返回。就是这种形式：\n\n<flow>\n    <nodes>\n        <node id="脚本id1" name="脚本名称" type="script" language="脚本语言">\n            ...\n        </node>\n\n        <node id="脚本id2" name="脚本名称" type="script" language="脚本语言">\n            ...\n        </node>\n        \n        ...\n    </nodes>\n    \n    <chain name="chain1">\n        ...\n    </chain>\n\n    <chain name="chain2">\n        ...\n    </chain>\n    \n    ...\n</flow>\n\n\n提示\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@autowired和@resources等标签\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n\n关于el_xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以el的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"✂️选择组件",frontmatter:{title:"✂️选择组件",date:"2022-06-29T17:58:54.000Z",permalink:"/pages/c0f5d7/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/020.%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/055.🔗常规组件/020.选择组件.md",key:"v-013aca90",path:"/pages/c0f5d7/",headers:[{level:2,title:"根据nodeId进行选择",slug:"根据nodeid进行选择",normalizedTitle:"根据nodeid进行选择",charIndex:153},{level:2,title:"根据表达式的id进行选择",slug:"根据表达式的id进行选择",normalizedTitle:"根据表达式的id进行选择",charIndex:496},{level:2,title:"根据tag进行选择",slug:"根据tag进行选择",normalizedTitle:"根据tag进行选择",charIndex:882},{level:2,title:"表达式tag的选择",slug:"表达式tag的选择",normalizedTitle:"表达式tag的选择",charIndex:2358},{level:2,title:"链路tag的选择",slug:"链路tag的选择",normalizedTitle:"链路tag的选择",charIndex:2502}],headersStr:"根据nodeId进行选择 根据表达式的id进行选择 根据tag进行选择 表达式tag的选择 链路tag的选择",content:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于SWITCH关键字中。\n\n关于SWITCH表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承NodeSwitchComponent。\n\n需要实现方法processSwitch方法。\n\n\n# 根据nodeId进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c);\n</chain>\n\n\n这个方法需要返回String类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, WHEN(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nLiteFlow支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    THEN(\n        a,\n        SWITCH(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class GSwitchCmp extends NodeSwitchComponent {\n\n\t@Override\n\tpublic String processSwitch() throws Exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetId是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetId是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetId是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetId是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetId是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetId是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetId是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetId是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 表达式tag的选择\n\nLiteFlow支持了表达式的tag选择，比如：\n\n<chain name="chain1">\n    SWITCH(a).to(b, WHEN(c,d).tag("w1"));\n</chain>\n\n\na中返回tag:w1或者:w1就能选择到后面的表达式。\n\n\n# 链路tag的选择\n\n也支持链路tag的选择，比如：\n\n<chain name="chain1">\n    SWITCH(a).to(b, sub.tag("w1"));\n</chain>\n\n<chain name="sub">\n    THEN(c,d);\n</chain>\n\n\n事实上，a无论返回sub还是tag:w1都能选择到后面的链路。',normalizedContent:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于switch关键字中。\n\n关于switch表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承nodeswitchcomponent。\n\n需要实现方法processswitch方法。\n\n\n# 根据nodeid进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, c);\n</chain>\n\n\n这个方法需要返回string类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, when(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nliteflow支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    then(\n        a,\n        switch(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class gswitchcmp extends nodeswitchcomponent {\n\n\t@override\n\tpublic string processswitch() throws exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetid是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetid是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetid是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetid是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetid是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetid是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetid是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetid是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 表达式tag的选择\n\nliteflow支持了表达式的tag选择，比如：\n\n<chain name="chain1">\n    switch(a).to(b, when(c,d).tag("w1"));\n</chain>\n\n\na中返回tag:w1或者:w1就能选择到后面的表达式。\n\n\n# 链路tag的选择\n\n也支持链路tag的选择，比如：\n\n<chain name="chain1">\n    switch(a).to(b, sub.tag("w1"));\n</chain>\n\n<chain name="sub">\n    then(c,d);\n</chain>\n\n\n事实上，a无论返回sub还是tag:w1都能选择到后面的链路。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⛓布尔组件",frontmatter:{title:"⛓布尔组件",date:"2022-08-26T12:25:04.000Z",permalink:"/pages/cb0b59/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/030.%E5%B8%83%E5%B0%94%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/055.🔗常规组件/030.布尔组件.md",key:"v-38b0ef02",path:"/pages/cb0b59/",headersStr:null,content:'版本支持：\n\nLiteFlow提供了布尔组件的定义。\n\n布尔组件是以前IF组件，WHILE组件，BREAK组件的统一。他们三个组件有共同特征，都是返回布尔类型，所以将三个组件类型合三为一，成为了布尔组件。\n\n布尔组件可用于以下关键字中：\n\nIF...ELIF...ELSE，可以参考条件编排这一章。\n\nWHILE...DO...，可以参考循环编排这一章。\n\nFOR...DO...BREAK,WHILE...DO...BREAK,ITERATOR...DO...BREAK，可以参考循环编排这一章。\n\n布尔组件的定义，需要继承NodeBooleanComponent：\n\n@Component("x")\npublic class XCmp extends NodeBooleanComponent {\n\t@Override\n\tpublic boolean processBoolean() throws Exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n布尔组件的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'版本支持：\n\nliteflow提供了布尔组件的定义。\n\n布尔组件是以前if组件，while组件，break组件的统一。他们三个组件有共同特征，都是返回布尔类型，所以将三个组件类型合三为一，成为了布尔组件。\n\n布尔组件可用于以下关键字中：\n\nif...elif...else，可以参考条件编排这一章。\n\nwhile...do...，可以参考循环编排这一章。\n\nfor...do...break,while...do...break,iterator...do...break，可以参考循环编排这一章。\n\n布尔组件的定义，需要继承nodebooleancomponent：\n\n@component("x")\npublic class xcmp extends nodebooleancomponent {\n\t@override\n\tpublic boolean processboolean() throws exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n布尔组件的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬次数循环组件",frontmatter:{title:"🧬次数循环组件",date:"2022-10-06T15:04:44.000Z",permalink:"/pages/5f971f/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/040.%E6%AC%A1%E6%95%B0%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/055.🔗常规组件/040.次数循环组件.md",key:"v-fb57a1fe",path:"/pages/5f971f/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:10},{level:2,title:"当前循环下标获取",slug:"当前循环下标获取",normalizedTitle:"当前循环下标获取",charIndex:444},{level:2,title:"多层嵌套循环中获取下标",slug:"多层嵌套循环中获取下标",normalizedTitle:"多层嵌套循环中获取下标",charIndex:550}],headersStr:"用法 当前循环下标获取 多层嵌套循环中获取下标",content:'版本支持：\n\n\n# 用法\n\nLiteFlow提供了次数循环组件。返回的是一个int值的循环次数。 主要用于FOR...DO...表达式。\n\n关于FOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\nf节点的定义，需要继承NodeForComponent，需要实现processFor方法：\n\n@LiteflowComponent("f")\npublic class FCmp extends NodeForComponent {\n    @Override\n    public int processFor() throws Exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 当前循环下标获取\n\n关键字FOR...DO...中DO里面的任意java组件都可以通过this.getLoopIndex()来获得当前循环层的下标。\n\n在脚本中通过_meta.loopIndex来获取。\n\n\n# 多层嵌套循环中获取下标\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    FOR(x).DO(\n        FOR(y).DO(\n            FOR(z).DO(\n                THEN(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前循环下标：this.getLoopIndex()或者this.getPreNLoopIndex(0)，这2者是等价的\n\na组件要取到第二层循环下标：this.getPreLoopIndex()或者this.getPreNLoopIndex(1)，这2者是等价的\n\na组件要取到第一层循环下标：this.getPreNLoopIndex(2)\n\n唯一要关注的就是getPreNLoopIndex这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。',normalizedContent:'版本支持：\n\n\n# 用法\n\nliteflow提供了次数循环组件。返回的是一个int值的循环次数。 主要用于for...do...表达式。\n\n关于for...do...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\nf节点的定义，需要继承nodeforcomponent，需要实现processfor方法：\n\n@liteflowcomponent("f")\npublic class fcmp extends nodeforcomponent {\n    @override\n    public int processfor() throws exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 当前循环下标获取\n\n关键字for...do...中do里面的任意java组件都可以通过this.getloopindex()来获得当前循环层的下标。\n\n在脚本中通过_meta.loopindex来获取。\n\n\n# 多层嵌套循环中获取下标\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    for(x).do(\n        for(y).do(\n            for(z).do(\n                then(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前循环下标：this.getloopindex()或者this.getprenloopindex(0)，这2者是等价的\n\na组件要取到第二层循环下标：this.getpreloopindex()或者this.getprenloopindex(1)，这2者是等价的\n\na组件要取到第一层循环下标：this.getprenloopindex(2)\n\n唯一要关注的就是getprenloopindex这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-29T15:30:16.000Z",permalink:"/pages/16eca9/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/010.%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/010.说明.md",key:"v-b6fbb606",path:"/pages/16eca9/",headersStr:null,content:"在本章，将说明如何撰写规则表达式。\n\nLiteFlow在2.8.X版本中设计了非常强大的规则表达式。一切复杂的流程在LiteFlow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",normalizedContent:"在本章，将说明如何撰写规则表达式。\n\nliteflow在2.8.x版本中设计了非常强大的规则表达式。一切复杂的流程在liteflow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌴串行编排",frontmatter:{title:"🌴串行编排",date:"2022-06-29T15:28:24.000Z",permalink:"/pages/a590ee/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/020.%E4%B8%B2%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/020.串行编排.md",key:"v-644c1664",path:"/pages/a590ee/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:2},{level:2,title:"等价用法",slug:"等价用法",normalizedTitle:"等价用法",charIndex:201}],headersStr:"基本用法 等价用法",content:'# 基本用法\n\n如果你要依次执行a,b,c,d四个组件，你可以用THEN关键字，需要注意的是，THEN必须大写。\n\n<chain name="chain1">\n    THEN(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    THEN(a, b, THEN(c, d));\n</chain>\n\n\n图示\n\n\n# 等价用法\n\n由于THEN关键字用来表示串行在语义上有些不妥，但是为了兼容，又没法完全替换。所以后期版本同时支持了SER关键字，和THEN是完全等价的。\n\n<chain name="chain1">\n    SER(a, b, c, d);\n</chain>\n',normalizedContent:'# 基本用法\n\n如果你要依次执行a,b,c,d四个组件，你可以用then关键字，需要注意的是，then必须大写。\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    then(a, b, then(c, d));\n</chain>\n\n\n图示\n\n\n# 等价用法\n\n由于then关键字用来表示串行在语义上有些不妥，但是为了兼容，又没法完全替换。所以后期版本同时支持了ser关键字，和then是完全等价的。\n\n<chain name="chain1">\n    ser(a, b, c, d);\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⌛️迭代循环组件",frontmatter:{title:"⌛️迭代循环组件",date:"2023-02-09T10:40:52.000Z",permalink:"/pages/64262b/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/055.%E8%BF%AD%E4%BB%A3%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/055.🔗常规组件/055.迭代循环组件.md",key:"v-6a15ff77",path:"/pages/64262b/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:10},{level:2,title:"当前迭代对象的获取",slug:"当前迭代对象的获取",normalizedTitle:"当前迭代对象的获取",charIndex:557},{level:2,title:"多层嵌套循环中获取迭代对象",slug:"多层嵌套循环中获取迭代对象",normalizedTitle:"多层嵌套循环中获取迭代对象",charIndex:668}],headersStr:"用法 当前迭代对象的获取 多层嵌套循环中获取迭代对象",content:'版本支持：\n\n\n# 用法\n\nLiteFlow支持了迭代循环组件，相当于Java语言的Iterator关键字，主要用于ITERATOR...DO...表达式。\n\n关于ITERATOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\nx节点的定义，需要继承NodeIteratorComponent，需要实现processIterator方法：\n\n@LiteflowComponent("x")\npublic class XCmp extends NodeIteratorComponent {\n    @Override\n    public Iterator<?> processIterator() throws Exception {\n        List<String> list = ListUtil.toList("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 当前迭代对象的获取\n\n关键字ITERATOR...DO...中DO里面所有的节点都可以通过this.getCurrLoopObj()获得迭代循环的当前对象。\n\n在脚本中通过_meta.loopObject来获取。\n\n\n# 多层嵌套循环中获取迭代对象\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    ITERATOR(x).DO(\n        ITERATOR(y).DO(\n            ITERATOR(z).DO(\n                THEN(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前迭代对象：this.getCurrLoopObj()或者this.getPreNLoopObj(0)，这2者是等价的\n\na组件要取到第二层迭代对象：this.getPreLoopObj()或者this.getPreNLoopObj(1)，这2者是等价的\n\na组件要取到第一层迭代对象：this.getPreNLoopObj(2)\n\n唯一要关注的就是getPreNLoopObj这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。',normalizedContent:'版本支持：\n\n\n# 用法\n\nliteflow支持了迭代循环组件，相当于java语言的iterator关键字，主要用于iterator...do...表达式。\n\n关于iterator...do...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\nx节点的定义，需要继承nodeiteratorcomponent，需要实现processiterator方法：\n\n@liteflowcomponent("x")\npublic class xcmp extends nodeiteratorcomponent {\n    @override\n    public iterator<?> processiterator() throws exception {\n        list<string> list = listutil.tolist("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 当前迭代对象的获取\n\n关键字iterator...do...中do里面所有的节点都可以通过this.getcurrloopobj()获得迭代循环的当前对象。\n\n在脚本中通过_meta.loopobject来获取。\n\n\n# 多层嵌套循环中获取迭代对象\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    iterator(x).do(\n        iterator(y).do(\n            iterator(z).do(\n                then(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前迭代对象：this.getcurrloopobj()或者this.getprenloopobj(0)，这2者是等价的\n\na组件要取到第二层迭代对象：this.getpreloopobj()或者this.getprenloopobj(1)，这2者是等价的\n\na组件要取到第一层迭代对象：this.getprenloopobj(2)\n\n唯一要关注的就是getprenloopobj这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎋并行编排",frontmatter:{title:"🎋并行编排",date:"2022-06-29T16:46:16.000Z",permalink:"/pages/b3446a/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/030.%E5%B9%B6%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/030.并行编排.md",key:"v-060c75b8",path:"/pages/b3446a/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:2},{level:2,title:"等价用法",slug:"等价用法",normalizedTitle:"等价用法",charIndex:111},{level:2,title:"和串行嵌套起来(一)",slug:"和串行嵌套起来-一",normalizedTitle:"和串行嵌套起来(一)",charIndex:228},{level:2,title:"和串行嵌套起来(二)",slug:"和串行嵌套起来-二",normalizedTitle:"和串行嵌套起来(二)",charIndex:403},{level:2,title:"忽略错误",slug:"忽略错误",normalizedTitle:"忽略错误",charIndex:546},{level:2,title:"任一节点先执行完则忽略其他",slug:"任一节点先执行完则忽略其他",normalizedTitle:"任一节点先执行完则忽略其他",charIndex:760},{level:2,title:"指定任意节点先执行完则忽略其他",slug:"指定任意节点先执行完则忽略其他",normalizedTitle:"指定任意节点先执行完则忽略其他",charIndex:1006},{level:2,title:"开启WHEN线程池隔离",slug:"开启when线程池隔离",normalizedTitle:"开启when线程池隔离",charIndex:1572},{level:2,title:"关于组的概念",slug:"关于组的概念",normalizedTitle:"关于组的概念",charIndex:1867}],headersStr:"基本用法 等价用法 和串行嵌套起来(一) 和串行嵌套起来(二) 忽略错误 任一节点先执行完则忽略其他 指定任意节点先执行完则忽略其他 开启WHEN线程池隔离 关于组的概念",content:'# 基本用法\n\n如果你要并行执行a,b,c三个组件，你可以用WHEN关键字，需要注意的是，WHEN必须大写。\n\n<chain name="chain1">\n    WHEN(a, b, c);\n</chain>\n\n\n\n# 等价用法\n\n由于WHEN关键字用来表示并行语义上并不是很妥当，所以后期版本同时支持了PAR关键字，和WHEN是完全等价的。\n\n<chain name="chain1">\n    PAR(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把THEN和WHEN结合起来用，看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nWHEN关键字提供了一个子关键字ignoreError(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).ignoreError(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nWHEN关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 指定任意节点先执行完则忽略其他\n\nLiteFlow支持了并行编排中指定节点的执行则忽略其他，WHEN 关键字新增子关键字 must (不可为空)，可用于指定需等待执行的任意节点，可以为 1 个或者多个，若指定的所有节点率先完成，则继续往下执行，忽略同级别的其他任务，用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).must(b, c),\n        f\n    );\n</chain>\n\n\n以上流程中，must指定了b,c，则b，c是一定会被执行完毕了，如果b，c执行完毕了后d还未执行完，则忽略，直接执行下一个组件f。\n\n以上是单节点的用法，must还可以指定一个或多个表达式。比如\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d).id("t1"), e).must(b, "t1"),\n        f\n    );\n</chain>\n\n\n在这个表达式中WHEN里有一个嵌套的THEN，如果需要指定这个表达式，则需要给这个表达式设置一个id，must里需要指定这个id，需要注意的是，must里指定id，需要用引号括起来。\n\n\n# 开启WHEN线程池隔离\n\n目前liteflow设计里when线程池，如果你不单独设置自定义线程池，那么就会用默认的线程池。而这个线程池，是所有的when共同一个。\n\nLiteFlow从2.11.1开始，提供一个liteflow.when-thread-pool-isolate参数，默认为false，如果设为true，则会开启WHEN的线程池隔离机制，这意味着每一个when都会有单独的线程池。这个特性对于运行复杂的嵌套when时是可以提升运行速度的且规避掉一些锁的问题。\n\n你可以如下配置来开启：\n\nliteflow.when-thread-pool-isolate=true\n\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.X版本中，我们去除了组的概念。\n\n用EL表达式，其实你写2个不同的WHEN就是2个组。比如：\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b),\n        WHEN(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',normalizedContent:'# 基本用法\n\n如果你要并行执行a,b,c三个组件，你可以用when关键字，需要注意的是，when必须大写。\n\n<chain name="chain1">\n    when(a, b, c);\n</chain>\n\n\n\n# 等价用法\n\n由于when关键字用来表示并行语义上并不是很妥当，所以后期版本同时支持了par关键字，和when是完全等价的。\n\n<chain name="chain1">\n    par(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把then和when结合起来用，看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nwhen关键字提供了一个子关键字ignoreerror(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).ignoreerror(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nwhen关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 指定任意节点先执行完则忽略其他\n\nliteflow支持了并行编排中指定节点的执行则忽略其他，when 关键字新增子关键字 must (不可为空)，可用于指定需等待执行的任意节点，可以为 1 个或者多个，若指定的所有节点率先完成，则继续往下执行，忽略同级别的其他任务，用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).must(b, c),\n        f\n    );\n</chain>\n\n\n以上流程中，must指定了b,c，则b，c是一定会被执行完毕了，如果b，c执行完毕了后d还未执行完，则忽略，直接执行下一个组件f。\n\n以上是单节点的用法，must还可以指定一个或多个表达式。比如\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d).id("t1"), e).must(b, "t1"),\n        f\n    );\n</chain>\n\n\n在这个表达式中when里有一个嵌套的then，如果需要指定这个表达式，则需要给这个表达式设置一个id，must里需要指定这个id，需要注意的是，must里指定id，需要用引号括起来。\n\n\n# 开启when线程池隔离\n\n目前liteflow设计里when线程池，如果你不单独设置自定义线程池，那么就会用默认的线程池。而这个线程池，是所有的when共同一个。\n\nliteflow从2.11.1开始，提供一个liteflow.when-thread-pool-isolate参数，默认为false，如果设为true，则会开启when的线程池隔离机制，这意味着每一个when都会有单独的线程池。这个特性对于运行复杂的嵌套when时是可以提升运行速度的且规避掉一些锁的问题。\n\n你可以如下配置来开启：\n\nliteflow.when-thread-pool-isolate=true\n\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.x版本中，我们去除了组的概念。\n\n用el表达式，其实你写2个不同的when就是2个组。比如：\n\n<chain name="chain1">\n    then(\n        when(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    then(\n        when(a, b),\n        when(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌾选择编排",frontmatter:{title:"🌾选择编排",date:"2022-06-29T17:15:38.000Z",permalink:"/pages/d90483/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/040.%E9%80%89%E6%8B%A9%E7%BC%96%E6%8E%92.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/040.选择编排.md",key:"v-75b7ef26",path:"/pages/d90483/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:164},{level:2,title:"DEFAULT关键字",slug:"default关键字",normalizedTitle:"default关键字",charIndex:273},{level:2,title:"和THEN,WHEN嵌套起来",slug:"和then-when嵌套起来",normalizedTitle:"和then,when嵌套起来",charIndex:478},{level:2,title:"选择编排中的id语法",slug:"选择编排中的id语法",normalizedTitle:"选择编排中的id语法",charIndex:668},{level:2,title:"选择编排中的tag语法",slug:"选择编排中的tag语法",normalizedTitle:"选择编排中的tag语法",charIndex:1262}],headersStr:"最基本的例子 DEFAULT关键字 和THEN,WHEN嵌套起来 选择编排中的id语法 选择编排中的tag语法",content:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入A流程，如果返回结果2，则进入B流程，如果返回结果3，则进入C流程。在有些流程定义中也被定义为排他网关。\n\n这个通过LiteFLow的表达式也非常容易实现，你可以用SWITCH...TO的组合关键字，注意的是SWITCH必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# DEFAULT关键字\n\nLiteFlow对选择编排新增了一个DEFAULT关键字。用法为SWITCH...TO...DEFAULT。\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(x).TO(a, b, c).DEFAULT(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然DEFAULT里面也可以是一个表达式。\n\n\n# 和THEN,WHEN嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(\n            b,\n            SWITCH(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个SWITCH中套THEN和WHEN的例子。\n\n如果你阅读过选择组件这一章，就应该知道，LiteFlow通过选择组件的返回来确定该选择什么。\n\n那么如果SWITCH中套一个THEN，那么选择组件如果要选择这个THEN应该返回什么呢？\n\nLiteFlow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回t1:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        //do your biz\n        return "t1";\n    }\n}\n\n\n\n# 选择编排中的tag语法\n\n事实上，除了给表达式赋值id属性之外，你还可以给表达式赋值tag属性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).tag("t1")\n        ),\n        f\n    );\n</chain>\n\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        return "tag:t1";\n        //以下这种也是可以的\n        return ":t1";\n    }\n}\n\n\n选择组件还有其他返回形式，详情请见选择组件这一章。',normalizedContent:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入a流程，如果返回结果2，则进入b流程，如果返回结果3，则进入c流程。在有些流程定义中也被定义为排他网关。\n\n这个通过liteflow的表达式也非常容易实现，你可以用switch...to的组合关键字，注意的是switch必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    switch(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# default关键字\n\nliteflow对选择编排新增了一个default关键字。用法为switch...to...default。\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(x).to(a, b, c).default(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然default里面也可以是一个表达式。\n\n\n# 和then,when嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            b,\n            switch(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个switch中套then和when的例子。\n\n如果你阅读过选择组件这一章，就应该知道，liteflow通过选择组件的返回来确定该选择什么。\n\n那么如果switch中套一个then，那么选择组件如果要选择这个then应该返回什么呢？\n\nliteflow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回t1:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        //do your biz\n        return "t1";\n    }\n}\n\n\n\n# 选择编排中的tag语法\n\n事实上，除了给表达式赋值id属性之外，你还可以给表达式赋值tag属性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).tag("t1")\n        ),\n        f\n    );\n</chain>\n\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        return "tag:t1";\n        //以下这种也是可以的\n        return ":t1";\n    }\n}\n\n\n选择组件还有其他返回形式，详情请见选择组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵条件编排",frontmatter:{title:"🌵条件编排",date:"2022-08-26T14:13:55.000Z",permalink:"/pages/e76999/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/045.%E6%9D%A1%E4%BB%B6%E7%BC%96%E6%8E%92.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/045.条件编排.md",key:"v-7dd444d7",path:"/pages/e76999/",headers:[{level:2,title:"IF的二元表达式",slug:"if的二元表达式",normalizedTitle:"if的二元表达式",charIndex:202},{level:2,title:"IF的三元表达式",slug:"if的三元表达式",normalizedTitle:"if的三元表达式",charIndex:359},{level:2,title:"ELSE表达式",slug:"else表达式",normalizedTitle:"else表达式",charIndex:525},{level:2,title:"ELIF表达式",slug:"elif表达式",normalizedTitle:"elif表达式",charIndex:703}],headersStr:"IF的二元表达式 IF的三元表达式 ELSE表达式 ELIF表达式",content:'版本支持：\n\nLiteFlow提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在LiteFlow EL语法中有一些不一样的用法。\n\n以下IF和ELIF的第一个参数要求定义布尔组件，关于如何定义请参考布尔组件这一章节。\n\n\n# IF的二元表达式\n\n我们先来看IF关键字的二元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# IF的三元表达式\n\n我们接下来再来看IF关键字的三元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# ELSE表达式\n\nLiteFlow也提供了ELSE表达式，IF的二元表达式+ELSE表达式等同于IF三元表达式，比如：\n\n<chain name="chain1">\n    IF(x, a).ELSE(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n\n# ELIF表达式\n\nELIF关键字的用法其实和java语言的else if类似，可以跟多个，和IF二元表达式参数一样，一般最后还会跟个ELSE，用于多重条件的判断：\n\n<chain name="chain1">\n    IF(x1, a).ELIF(x2, b).ELIF(x3, c).ELIF(x4, d).ELSE(THEN(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有IF的二元表达式后面才能跟ELIF，如果IF三元表达式后面跟ELIF，最后一个表达式会被ELIF的表达式覆盖，就比如：\n\n<chain name="chain1">\n    IF(x1, a, b).ELIF(x2, c).ELSE(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实IF三元表达式已经能表达一切的可能了，有多重条件也可以不用ELIF，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    IF(\n        x1,\n        a, \n        IF(\n            x2,\n            b,\n            IF(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用ELIF来代替。',normalizedContent:'版本支持：\n\nliteflow提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在liteflow el语法中有一些不一样的用法。\n\n以下if和elif的第一个参数要求定义布尔组件，关于如何定义请参考布尔组件这一章节。\n\n\n# if的二元表达式\n\n我们先来看if关键字的二元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# if的三元表达式\n\n我们接下来再来看if关键字的三元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# else表达式\n\nliteflow也提供了else表达式，if的二元表达式+else表达式等同于if三元表达式，比如：\n\n<chain name="chain1">\n    if(x, a).else(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n\n# elif表达式\n\nelif关键字的用法其实和java语言的else if类似，可以跟多个，和if二元表达式参数一样，一般最后还会跟个else，用于多重条件的判断：\n\n<chain name="chain1">\n    if(x1, a).elif(x2, b).elif(x3, c).elif(x4, d).else(then(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有if的二元表达式后面才能跟elif，如果if三元表达式后面跟elif，最后一个表达式会被elif的表达式覆盖，就比如：\n\n<chain name="chain1">\n    if(x1, a, b).elif(x2, c).else(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实if三元表达式已经能表达一切的可能了，有多重条件也可以不用elif，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    if(\n        x1,\n        a, \n        if(\n            x2,\n            b,\n            if(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用elif来代替。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌳循环编排",frontmatter:{title:"🌳循环编排",date:"2022-10-06T15:13:06.000Z",permalink:"/pages/fbf715/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/046.%E5%BE%AA%E7%8E%AF%E7%BC%96%E6%8E%92.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/046.循环编排.md",key:"v-6823ac97",path:"/pages/fbf715/",headers:[{level:2,title:"FOR循环",slug:"for循环",normalizedTitle:"for循环",charIndex:33},{level:2,title:"WHILE循环",slug:"while循环",normalizedTitle:"while循环",charIndex:307},{level:2,title:"ITERATOR迭代循环",slug:"iterator迭代循环",normalizedTitle:"iterator迭代循环",charIndex:456},{level:2,title:"BREAK",slug:"break",normalizedTitle:"break",charIndex:646},{level:2,title:"多层嵌套循环中获取下标",slug:"多层嵌套循环中获取下标",normalizedTitle:"多层嵌套循环中获取下标",charIndex:935},{level:2,title:"多层嵌套循环中获取迭代对象",slug:"多层嵌套循环中获取迭代对象",normalizedTitle:"多层嵌套循环中获取迭代对象",charIndex:1355},{level:2,title:"脚本中获取循环下标和迭代对象",slug:"脚本中获取循环下标和迭代对象",normalizedTitle:"脚本中获取循环下标和迭代对象",charIndex:1784},{level:2,title:"异步循环",slug:"异步循环",normalizedTitle:"异步循环",charIndex:1835}],headersStr:"FOR循环 WHILE循环 ITERATOR迭代循环 BREAK 多层嵌套循环中获取下标 多层嵌套循环中获取迭代对象 脚本中获取循环下标和迭代对象 异步循环",content:'版本支持：\n\nLiteFlow提供了循环编排表达式组合。\n\n\n# FOR循环\n\nFOR循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    FOR(5).DO(THEN(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# WHILE循环\n\nWHILE循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b));\n</chain>\n\n\n其中w这个节点需要为布尔组件，返回一个布尔值，为true则继续循环，如何定义请参照布尔组件。\n\n\n# ITERATOR迭代循环\n\nITERATOR迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# BREAK\n\nLiteFlow同样也支持BREAK语法，代表退出循环。\n\nBREAK关键字可以跟在FOR和WHILE后面，通常用法为：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n其中c这个节点需要为布尔组件，返回一个布尔值，为true则退出循环。如何定义请参考布尔组件。\n\n提示\n\nBREAK关键字是在每次循环的末尾进行判断的。\n\n\n# 多层嵌套循环中获取下标\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    FOR(x).DO(\n        FOR(y).DO(\n            FOR(z).DO(\n                THEN(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前循环下标：this.getLoopIndex()或者this.getPreNLoopIndex(0)，这2者是等价的\n\na组件要取到第二层循环下标：this.getPreLoopIndex()或者this.getPreNLoopIndex(1)，这2者是等价的\n\na组件要取到第一层循环下标：this.getPreNLoopIndex(2)\n\n唯一要关注的就是getPreNLoopIndex这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。\n\n\n# 多层嵌套循环中获取迭代对象\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    ITERATOR(x).DO(\n        ITERATOR(y).DO(\n            ITERATOR(z).DO(\n                THEN(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前迭代对象：this.getCurrLoopObj()或者this.getPreNLoopObj(0)，这2者是等价的\n\na组件要取到第二层迭代对象：this.getPreLoopObj()或者this.getPreNLoopObj(1)，这2者是等价的\n\na组件要取到第一层迭代对象：this.getPreNLoopObj(2)\n\n唯一要关注的就是getPreNLoopObj这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。\n\n\n# 脚本中获取循环下标和迭代对象\n\n具体内容请参照脚本与Java进行交互中的元数据获取方式之二。\n\n\n# 异步循环\n\nLiteFlow支持了异步循环特性，关于异步循环请参考高级特性中的异步循环模式。',normalizedContent:'版本支持：\n\nliteflow提供了循环编排表达式组合。\n\n\n# for循环\n\nfor循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    for(5).do(then(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# while循环\n\nwhile循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    while(w).do(then(a, b));\n</chain>\n\n\n其中w这个节点需要为布尔组件，返回一个布尔值，为true则继续循环，如何定义请参照布尔组件。\n\n\n# iterator迭代循环\n\niterator迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# break\n\nliteflow同样也支持break语法，代表退出循环。\n\nbreak关键字可以跟在for和while后面，通常用法为：\n\n<chain name="chain1">\n    for(f).do(then(a, b)).break(c);\n</chain>\n\n\n<chain name="chain1">\n    while(w).do(then(a, b)).break(c);\n</chain>\n\n\n其中c这个节点需要为布尔组件，返回一个布尔值，为true则退出循环。如何定义请参考布尔组件。\n\n提示\n\nbreak关键字是在每次循环的末尾进行判断的。\n\n\n# 多层嵌套循环中获取下标\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    for(x).do(\n        for(y).do(\n            for(z).do(\n                then(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前循环下标：this.getloopindex()或者this.getprenloopindex(0)，这2者是等价的\n\na组件要取到第二层循环下标：this.getpreloopindex()或者this.getprenloopindex(1)，这2者是等价的\n\na组件要取到第一层循环下标：this.getprenloopindex(2)\n\n唯一要关注的就是getprenloopindex这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。\n\n\n# 多层嵌套循环中获取迭代对象\n\n如果在一个3层嵌套循环里：\n\n<chain name="chain1">\n    iterator(x).do(\n        iterator(y).do(\n            iterator(z).do(\n                then(a,b)\n            )\n        )\n    );\n</chain>\n\n\na组件要取到当前迭代对象：this.getcurrloopobj()或者this.getprenloopobj(0)，这2者是等价的\n\na组件要取到第二层迭代对象：this.getpreloopobj()或者this.getprenloopobj(1)，这2者是等价的\n\na组件要取到第一层迭代对象：this.getprenloopobj(2)\n\n唯一要关注的就是getprenloopobj这个方法，里面的数字代表了往前取多少层，数字0就代表了当前层。以此类推。\n\n\n# 脚本中获取循环下标和迭代对象\n\n具体内容请参照脚本与java进行交互中的元数据获取方式之二。\n\n\n# 异步循环\n\nliteflow支持了异步循环特性，关于异步循环请参考高级特性中的异步循环模式。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎃捕获异常表达式",frontmatter:{title:"🎃捕获异常表达式",date:"2023-03-16T22:27:28.000Z",permalink:"/pages/f53b51/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/047.%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/047.捕获异常表达式.md",key:"v-6e0c9def",path:"/pages/f53b51/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:34},{level:2,title:"搭配循环使用",slug:"搭配循环使用",normalizedTitle:"搭配循环使用",charIndex:551}],headersStr:"基本用法 搭配循环使用",content:'版本支持：\n\nLiteFlow提供了捕获异常的表达式组合。\n\n\n# 基本用法\n\n具体用法为CATCH...DO:\n\n<chain name="chain1">\n    CATCH(\n        THEN(a,b)\n    ).DO(c)\n</chain>\n\n\n上述语法表示，如果a组件出现异常并抛出，则不会执行b组件，会直接执行c组件。\n\n在c组件中，可以通过this.getSlot().getException()来获取异常。\n\n同时，当用了CATCH表达式之后，即便在CATCH包裹的组件有异常抛出，整个流程返回的LiteflowResponse中的isSuccess方法仍然为true，getCause中也没有任何的Exception。如果你写过java程序，应该会对这样的机制很容易理解。因为异常已经被你自己处理掉了。\n\n同时CATCH也可以不加DO，比如：\n\n<chain name="chain1">\n    THEN(\n        CATCH(\n            THEN(a,b)\n        ),\n        c\n    )\n</chain>\n\n\n上面这段表达式不管a,b有没有抛出异常，最终总会执行c。如果a抛出异常，那么最终执行链路就为a==>c\n\n\n# 搭配循环使用\n\nCATCH表达式和循环表达式搭配起来使用，还能做出java中continue的效果，比如：\n\n<chain name="chain1">\n    FOR(x).DO(\n        CATCH(\n            THEN(a,b,c)\n        )\n    )\n</chain>\n\n\n如果你希望在b组件中达成某一个条件就不执行c，继续循环，那么你可以借助CATCH语法，只要在b组件中往外抛一个异常即可。\n\n我相信这种用法对于写程序的同学来说，应该不用过多解释。',normalizedContent:'版本支持：\n\nliteflow提供了捕获异常的表达式组合。\n\n\n# 基本用法\n\n具体用法为catch...do:\n\n<chain name="chain1">\n    catch(\n        then(a,b)\n    ).do(c)\n</chain>\n\n\n上述语法表示，如果a组件出现异常并抛出，则不会执行b组件，会直接执行c组件。\n\n在c组件中，可以通过this.getslot().getexception()来获取异常。\n\n同时，当用了catch表达式之后，即便在catch包裹的组件有异常抛出，整个流程返回的liteflowresponse中的issuccess方法仍然为true，getcause中也没有任何的exception。如果你写过java程序，应该会对这样的机制很容易理解。因为异常已经被你自己处理掉了。\n\n同时catch也可以不加do，比如：\n\n<chain name="chain1">\n    then(\n        catch(\n            then(a,b)\n        ),\n        c\n    )\n</chain>\n\n\n上面这段表达式不管a,b有没有抛出异常，最终总会执行c。如果a抛出异常，那么最终执行链路就为a==>c\n\n\n# 搭配循环使用\n\ncatch表达式和循环表达式搭配起来使用，还能做出java中continue的效果，比如：\n\n<chain name="chain1">\n    for(x).do(\n        catch(\n            then(a,b,c)\n        )\n    )\n</chain>\n\n\n如果你希望在b组件中达成某一个条件就不执行c，继续循环，那么你可以借助catch语法，只要在b组件中往外抛一个异常即可。\n\n我相信这种用法对于写程序的同学来说，应该不用过多解释。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄与或非表达式",frontmatter:{title:"🍄与或非表达式",date:"2023-04-11T21:28:38.000Z",permalink:"/pages/a8b344/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/048.%E4%B8%8E%E6%88%96%E9%9D%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/048.与或非表达式.md",key:"v-91b16664",path:"/pages/a8b344/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:10},{level:2,title:"可以用的地方",slug:"可以用的地方",normalizedTitle:"可以用的地方",charIndex:667},{level:2,title:"复杂嵌套",slug:"复杂嵌套",normalizedTitle:"复杂嵌套",charIndex:797}],headersStr:"基本用法 可以用的地方 复杂嵌套",content:'版本支持：\n\n\n# 基本用法\n\nLiteFlow提供了与或非表达式，就是AND，OR，NOT表达式。\n\n通过之前的几小章，应该可以知道，有些编排需要返回一个布尔值，比如条件编排：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n其中x组件应该为布尔组件，返回的是一个布尔值。\n\n但是如果这个布尔值并不是由一个组件决定的，而是由多个组件决定的呢。这里就可以用与或非表达式了。\n\n假设这里的条件是要由x和y共同决定，利用与或非表达式中的AND:\n\n<chain name="chain1">\n    IF(AND(x,y), a, b);\n</chain>\n\n\n上述AND的意思是，如果x和y都为true，则为真，会执行组件a，如果x和y有一个为false，则执行b。\n\nAND里面可以有多个布尔组件或者与或非表达式。\n\n同理，这里也可以用OR来表示：\n\n<chain name="chain1">\n    IF(OR(x,y), a, b);\n</chain>\n\n\n上述OR的意思是，只要x和y中的一个为true，则为真，否则为假。\n\nOR里面可以有多个组件或者与或非表达式。\n\nNOT就是非的意思，比如：\n\n<chain name="chain1">\n    IF(NOT(x), a, b);\n</chain>\n\n\n如果x返回true，则经过非运算后，为假，执行b，如果x返回false，则经过非运算后，为真，执行a。\n\nNOT里面只能有一个布尔组件或者与或非表达式。\n\n\n# 可以用的地方\n\n在LiteFlow所有EL表达式中，返回布尔值的地方都可以用与或非表达式，除了上述的IF外，还可以用在WHILE，BREAK表达式中。\n\n提示\n\n如果你在THEN表达式中用与或非表达式，会报错的，因为普通组件并非是一个布尔值的的返回。\n\n\n# 复杂嵌套\n\n与或非表达式也可以进行多级嵌套，比如：\n\n<chain name="chain1">\n    IF(\n        OR(\n            AND(x1, x3), NOT(OR(x3, x4))\n        ),\n        a, b\n    );\n</chain>\n\n\n类似于这种，其实概念和java的与或非都一样，无非就是换了种写法。',normalizedContent:'版本支持：\n\n\n# 基本用法\n\nliteflow提供了与或非表达式，就是and，or，not表达式。\n\n通过之前的几小章，应该可以知道，有些编排需要返回一个布尔值，比如条件编排：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n其中x组件应该为布尔组件，返回的是一个布尔值。\n\n但是如果这个布尔值并不是由一个组件决定的，而是由多个组件决定的呢。这里就可以用与或非表达式了。\n\n假设这里的条件是要由x和y共同决定，利用与或非表达式中的and:\n\n<chain name="chain1">\n    if(and(x,y), a, b);\n</chain>\n\n\n上述and的意思是，如果x和y都为true，则为真，会执行组件a，如果x和y有一个为false，则执行b。\n\nand里面可以有多个布尔组件或者与或非表达式。\n\n同理，这里也可以用or来表示：\n\n<chain name="chain1">\n    if(or(x,y), a, b);\n</chain>\n\n\n上述or的意思是，只要x和y中的一个为true，则为真，否则为假。\n\nor里面可以有多个组件或者与或非表达式。\n\nnot就是非的意思，比如：\n\n<chain name="chain1">\n    if(not(x), a, b);\n</chain>\n\n\n如果x返回true，则经过非运算后，为假，执行b，如果x返回false，则经过非运算后，为真，执行a。\n\nnot里面只能有一个布尔组件或者与或非表达式。\n\n\n# 可以用的地方\n\n在liteflow所有el表达式中，返回布尔值的地方都可以用与或非表达式，除了上述的if外，还可以用在while，break表达式中。\n\n提示\n\n如果你在then表达式中用与或非表达式，会报错的，因为普通组件并非是一个布尔值的的返回。\n\n\n# 复杂嵌套\n\n与或非表达式也可以进行多级嵌套，比如：\n\n<chain name="chain1">\n    if(\n        or(\n            and(x1, x3), not(or(x3, x4))\n        ),\n        a, b\n    );\n</chain>\n\n\n类似于这种，其实概念和java的与或非都一样，无非就是换了种写法。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍂使用子变量",frontmatter:{title:"🍂使用子变量",date:"2022-07-01T19:01:33.000Z",permalink:"/pages/71ff49/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/060.%E4%BD%BF%E7%94%A8%E5%AD%90%E5%8F%98%E9%87%8F.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/060.使用子变量.md",key:"v-679dde1e",path:"/pages/71ff49/",headersStr:null,content:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为LiteFlow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = THEN(C, WHEN(J, K));\n    w1 = WHEN(Q, THEN(P, R)).id("w01");\n    t2 = THEN(H, I);\n    \n    THEN(\n        A, B,\n        WHEN(t1, D, t2),\n        SWITCH(X).to(M, N, w1),\n        Z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',normalizedContent:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为liteflow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = then(c, when(j, k));\n    w1 = when(q, then(p, r)).id("w01");\n    t2 = then(h, i);\n    \n    then(\n        a, b,\n        when(t1, d, t2),\n        switch(x).to(m, n, w1),\n        z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"💐复杂编排例子",frontmatter:{title:"💐复杂编排例子",date:"2022-06-29T21:29:06.000Z",permalink:"/pages/5156b3/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/070.%E5%A4%8D%E6%9D%82%E7%BC%96%E6%8E%92%E4%BE%8B%E5%AD%90.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/070.复杂编排例子.md",key:"v-1b8a9604",path:"/pages/5156b3/",headers:[{level:2,title:"复杂例子一",slug:"复杂例子一",normalizedTitle:"复杂例子一",charIndex:85},{level:2,title:"复杂例子二",slug:"复杂例子二",normalizedTitle:"复杂例子二",charIndex:840},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1905}],headersStr:"复杂例子一 复杂例子二 总结",content:'经过上面几小章，你是不是已经大致了解了LiteFlow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        WHEN(\n            THEN(B, C),\n            THEN(D, E, F),\n            THEN(\n                SWITCH(G).to(\n                    THEN(H, I, WHEN(J, K)).id("t1"),\n                    THEN(L, M).id("t2")\n                ),\n                N\n            )\n        ),\n        Z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = THEN(B, C);\n    item2 = THEN(D, E, F);\n    item3_1 = THEN(H, I, WHEN(J, K)).id("t1");\n    item3_2 = THEN(L, M).id("t2");\n    item3 = THEN(SWITCH(G).to(item3_1, item3_2), N);\n    \n    THEN(\n        A,\n        WHEN(item1, item2, item3),\n        Z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        SWITCH(B).to(\n            THEN(D, E, F).id("t1"),\n            THEN(\n                C,\n                WHEN(\n                    THEN(\n                        SWITCH(G).to(THEN(H, I).id("t2"), J),\n                        K\n                    ),\n                    THEN(L, M)\n                )\n            ).id("t3")\n        ),\n        Z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = THEN(D, E, F).id("t1");\n    \n    item2_1 = THEN(\n        SWITCH(G).to(\n            THEN(H, I).id("t2"),\n            J\n        ),\n        K\n    );\n    \n    item2_2 = THEN(L, M);\n    \n    item2 = THEN(C, WHEN(item2_1, item2_2)).id("t3");\n    \n    THEN(\n        A,\n        SWITCH(B).to(item1, item2),\n        Z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest2\n\n\n# 总结\n\nLiteFlow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',normalizedContent:'经过上面几小章，你是不是已经大致了解了liteflow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            then(b, c),\n            then(d, e, f),\n            then(\n                switch(g).to(\n                    then(h, i, when(j, k)).id("t1"),\n                    then(l, m).id("t2")\n                ),\n                n\n            )\n        ),\n        z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = then(b, c);\n    item2 = then(d, e, f);\n    item3_1 = then(h, i, when(j, k)).id("t1");\n    item3_2 = then(l, m).id("t2");\n    item3 = then(switch(g).to(item3_1, item3_2), n);\n    \n    then(\n        a,\n        when(item1, item2, item3),\n        z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            then(d, e, f).id("t1"),\n            then(\n                c,\n                when(\n                    then(\n                        switch(g).to(then(h, i).id("t2"), j),\n                        k\n                    ),\n                    then(l, m)\n                )\n            ).id("t3")\n        ),\n        z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = then(d, e, f).id("t1");\n    \n    item2_1 = then(\n        switch(g).to(\n            then(h, i).id("t2"),\n            j\n        ),\n        k\n    );\n    \n    item2_2 = then(l, m);\n    \n    item2 = then(c, when(item2_1, item2_2)).id("t3");\n    \n    then(\n        a,\n        switch(b).to(item1, item2),\n        z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.complexelspringboottest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.complexelspringboottest2\n\n\n# 总结\n\nliteflow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍁使用子流程",frontmatter:{title:"🍁使用子流程",date:"2022-07-01T19:00:46.000Z",permalink:"/pages/dc5df7/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/050.%E4%BD%BF%E7%94%A8%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/050.使用子流程.md",key:"v-3856a03d",path:"/pages/dc5df7/",headersStr:null,content:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    THEN(\n        A, B,\n        WHEN(\n            THEN(C, WHEN(J, K)),\n            D,\n            THEN(H, I)\n        ),\n        SWITCH(X).to(\n            M,\n            N,\n            WHEN(Q, THEN(P, R)).id("w01")\n        ),\n        Z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nLiteFlow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainChain">\n    THEN(\n    \tA, B,\n    \tWHEN(chain1, D, chain2),\n    \tSWITCH(X).to(M, N, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tTHEN(C, WHEN(J, K));\n</chain>\n\n<chain name="chain2">\n  \tTHEN(H, I);\n</chain>\n\n<chain name="chain3">\n  \tWHEN(Q, THEN(P, R)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',normalizedContent:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    then(\n        a, b,\n        when(\n            then(c, when(j, k)),\n            d,\n            then(h, i)\n        ),\n        switch(x).to(\n            m,\n            n,\n            when(q, then(p, r)).id("w01")\n        ),\n        z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nliteflow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainchain">\n    then(\n    \ta, b,\n    \twhen(chain1, d, chain2),\n    \tswitch(x).to(m, n, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tthen(c, when(j, k));\n</chain>\n\n<chain name="chain2">\n  \tthen(h, i);\n</chain>\n\n<chain name="chain3">\n  \twhen(q, then(p, r)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌻关于分号",frontmatter:{title:"🌻关于分号",date:"2022-07-10T10:58:25.000Z",permalink:"/pages/af44a6/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/080.%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/080.关于分号.md",key:"v-2af994e8",path:"/pages/af44a6/",headersStr:null,content:'大家可能注意到了，在EL规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nLiteFlow的EL规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    THEN(\n        a, \n        b, \n        WHEN(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = THEN(a, b);\n    w1 = WHEN(c, d);\n    \n    THEN(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为LiteFlow的IDEA插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',normalizedContent:'大家可能注意到了，在el规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nliteflow的el规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    then(a, b, when(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    then(\n        a, \n        b, \n        when(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = then(a, b);\n    w1 = when(c, d);\n    \n    then(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为liteflow的idea插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌰关于注释",frontmatter:{title:"🌰关于注释",date:"2022-07-19T10:34:21.000Z",permalink:"/pages/f3dc09/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/090.%E5%85%B3%E4%BA%8E%E6%B3%A8%E9%87%8A.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/090.关于注释.md",key:"v-7c7541bf",path:"/pages/f3dc09/",headersStr:null,content:'在LiteFlow的EL规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    THEN(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        WHEN(c, d)\n    )\n</chain>\n',normalizedContent:'在liteflow的el规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    then(a, b, when(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    then(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        when(c, d)\n    )\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐚组件名包装",frontmatter:{title:"🐚组件名包装",date:"2022-07-26T23:58:18.000Z",permalink:"/pages/2df3d9/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/100.%E7%BB%84%E4%BB%B6%E5%90%8D%E5%8C%85%E8%A3%85.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/100.组件名包装.md",key:"v-7c35f060",path:"/pages/2df3d9/",headersStr:null,content:'LiteFlow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88Cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    THEN(a, b, 88Cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nLiteFlow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    THEN(a, b, node("88Cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',normalizedContent:'liteflow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    then(a, b, 88cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nliteflow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    then(a, b, node("88cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🔆验证规则",frontmatter:{title:"🔆验证规则",date:"2022-12-01T00:10:24.000Z",permalink:"/pages/395fd0/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/110.%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99.html",relativePath:"07.v2.12.X文档/060.🧩EL规则的写法/110.验证规则.md",key:"v-10e549cd",path:"/pages/395fd0/",headersStr:null,content:'版本支持：\n\nLiteFlow为规则EL提供了一个验证的方法接口，用于验证EL是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourMethod() {\n    boolean isValid = LiteFlowChainELBuilder.validate("THEN(a, b, h)");\n    ...\n}\n\n\n带异常的调用方法\n\npublic void yourMethod() {\n    ValidationResp resp = LiteFlowChainELBuilder.validateWithEx("THEN(a, b, h)");\n    if (!resp.isSuccess()){\n        log.error(resp.getCause());\n    }\n}\n',normalizedContent:'版本支持：\n\nliteflow为规则el提供了一个验证的方法接口，用于验证el是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourmethod() {\n    boolean isvalid = liteflowchainelbuilder.validate("then(a, b, h)");\n    ...\n}\n\n\n带异常的调用方法\n\npublic void yourmethod() {\n    validationresp resp = liteflowchainelbuilder.validatewithex("then(a, b, h)");\n    if (!resp.issuccess()){\n        log.error(resp.getcause());\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯数据上下文的定义和使用",frontmatter:{title:"🌯数据上下文的定义和使用",date:"2022-07-01T23:49:40.000Z",permalink:"/pages/501abf/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/020.%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8.html",relativePath:"07.v2.12.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.md",key:"v-2afc8f15",path:"/pages/501abf/",headers:[{level:2,title:"默认上下文",slug:"默认上下文",normalizedTitle:"默认上下文",charIndex:2},{level:2,title:"自定义上下文",slug:"自定义上下文",normalizedTitle:"自定义上下文",charIndex:224},{level:2,title:"多上下文",slug:"多上下文",normalizedTitle:"多上下文",charIndex:829},{level:2,title:"利用超类获取上下文",slug:"利用超类获取上下文",normalizedTitle:"利用超类获取上下文",charIndex:1530},{level:2,title:"利用别名获取上下文",slug:"利用别名获取上下文",normalizedTitle:"利用别名获取上下文",charIndex:2129}],headersStr:"默认上下文 自定义上下文 多上下文 利用超类获取上下文 利用别名获取上下文",content:'# 默认上下文\n\nLiteFlow提供了一个默认的数据上下文的实现：DefaultContext。这个默认的实现其实里面主要存储数据的容器就是一个Map。\n\n你可以通过DefaultContext中的setData方法放入数据，通过getData方法获得数据。\n\n建议\n\nDefaultContext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的Bean当做上下文进行传入。LiteFlow对上下文的Bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, CustomContext.class);\n\n\n传入之后， LiteFlow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tCustomContext context = this.getContextBean(CustomContext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，如果你只有一个上下文，那么和上面是等价的\n\t\t//CustomContext context = this.getFirstContextBean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nLiteFlow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, OrderContext.class, UserContext.class, SignContext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tOrderContext orderContext = this.getContextBean(OrderContext.class);\n\t\tUserContext userContext = this.getContextBean(UserContext.class);\n\t\tSignContext signContext = this.getContextBean(SignContext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是OrderContext，那么也可以用这个方法\n\t\t//OrderContext orderContext = this.getFirstContextBean();\n\t\t...\n\t}\n}\n\n\n\n# 利用超类获取上下文\n\n从上面的例子可以得知，获取上下文可以通过对象的class来取到。\n\n但是在有些场景中，尤其是要定义一些通用组件的时候。用特定对象的class来取就有些不合适了。这就显得不是很通用。\n\n为了适配通用组件这个场景。LiteFlow支持了利用超类来获得上下文。\n\n例如，你定义了一个OrderContext:\n\npublic class OrderContext extends BaseContext{\n    ...\n}\n\n\n调用的时候：\n\nflowExecutor.execute2Resp("chain1", 流程初始参数, OrderContext.class);\n\n\n那么你在某些通用组件里可以通过它的超类BaseContext类型来获取到上下文:\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tCustomContext context = this.getContextBean(BaseContext.class);\n\t\t...\n\t}\n}\n\n\n提示\n\n如果在一个链路请求中有多个上下文，并且都是某一个超类的子类，你再用超类去获取，只会获取到第一个上下文。这点请注意。\n\n\n# 利用别名获取上下文\n\n关于这个特性请参考给上下文设置别名章节。',normalizedContent:'# 默认上下文\n\nliteflow提供了一个默认的数据上下文的实现：defaultcontext。这个默认的实现其实里面主要存储数据的容器就是一个map。\n\n你可以通过defaultcontext中的setdata方法放入数据，通过getdata方法获得数据。\n\n建议\n\ndefaultcontext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的bean当做上下文进行传入。liteflow对上下文的bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, customcontext.class);\n\n\n传入之后， liteflow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tcustomcontext context = this.getcontextbean(customcontext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，如果你只有一个上下文，那么和上面是等价的\n\t\t//customcontext context = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nliteflow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, ordercontext.class, usercontext.class, signcontext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tordercontext ordercontext = this.getcontextbean(ordercontext.class);\n\t\tusercontext usercontext = this.getcontextbean(usercontext.class);\n\t\tsigncontext signcontext = this.getcontextbean(signcontext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是ordercontext，那么也可以用这个方法\n\t\t//ordercontext ordercontext = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n\n\n\n# 利用超类获取上下文\n\n从上面的例子可以得知，获取上下文可以通过对象的class来取到。\n\n但是在有些场景中，尤其是要定义一些通用组件的时候。用特定对象的class来取就有些不合适了。这就显得不是很通用。\n\n为了适配通用组件这个场景。liteflow支持了利用超类来获得上下文。\n\n例如，你定义了一个ordercontext:\n\npublic class ordercontext extends basecontext{\n    ...\n}\n\n\n调用的时候：\n\nflowexecutor.execute2resp("chain1", 流程初始参数, ordercontext.class);\n\n\n那么你在某些通用组件里可以通过它的超类basecontext类型来获取到上下文:\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tcustomcontext context = this.getcontextbean(basecontext.class);\n\t\t...\n\t}\n}\n\n\n提示\n\n如果在一个链路请求中有多个上下文，并且都是某一个超类的子类，你再用超类去获取，只会获取到第一个上下文。这点请注意。\n\n\n# 利用别名获取上下文\n\n关于这个特性请参考给上下文设置别名章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T23:35:36.000Z",permalink:"/pages/74b4bf/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/010.%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/070.🌮数据上下文/010.说明.md",key:"v-108d3743",path:"/pages/74b4bf/",headersStr:null,content:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在LiteFlow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nLiteFlow对此有独特的设计理念，平时我们写瀑布流的程序时，A调用B，那A一定要把B所需要的参数传递给B，而在LiteFlow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在LiteFlow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",normalizedContent:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在liteflow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nliteflow对此有独特的设计理念，平时我们写瀑布流的程序时，a调用b，那a一定要把b所需要的参数传递给b，而在liteflow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在liteflow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪶用初始化好的上下文传入",frontmatter:{title:"🪶用初始化好的上下文传入",date:"2022-08-17T23:30:42.000Z",permalink:"/pages/f05ed6/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/030.%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A5%BD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%A0%E5%85%A5.html",relativePath:"07.v2.12.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.md",key:"v-8aa45958",path:"/pages/f05ed6/",headersStr:null,content:'版本支持：\n\n你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getRequestData()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nLiteFlow允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到FlowExecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nOrderContext orderContext = new OrderContext();\norderContext.setOrderNo("SO11223344");\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", null, orderContext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',normalizedContent:'版本支持：\n\n你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getrequestdata()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nliteflow允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到flowexecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nordercontext ordercontext = new ordercontext();\nordercontext.setorderno("so11223344");\nliteflowresponse response = flowexecutor.execute2resp("chain1", null, ordercontext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥨给上下文设置别名",frontmatter:{title:"🥨给上下文设置别名",date:"2024-04-12T17:52:58.000Z",permalink:"/pages/e71ced/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/040.%E7%BB%99%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D.html",relativePath:"07.v2.12.X文档/070.🌮数据上下文/040.给上下文设置别名.md",key:"v-51d49431",path:"/pages/e71ced/",headersStr:null,content:'版本支持：\n\nLiteFlow还支持给上下文设置别名，只需要在上下文中进行标注就可以了：\n\n@ContextBean("anyName")\npublic class YourContext {\n    ...\n}\n\n\n执行时还是老样子：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, YourContext.class);\n\n\n或者\n\nYourContext context = new YourContext();\ncontext.setXxxx(yyy);\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, context);\n\n\n然后在组件中可以根据别名去拿这个上下文：\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tTestContext context = this.getContextBean("anyName");\n\t\t...\n\t}\n}\n\n\n这个特性，尤其是在你要使用多上下文，并且两个上下文是一个类的时候特别有用，因为用class的方式去取有可能就会取错，而别名的方式就可以很好的规避这点。\n\n提示\n\n如果你的上下文没声明@ContextBean，其实也是可以通过名称取到的，这时的名称就是上下文className，并且首字母小写。比如你的上下文类名为PriceContext，那么你通过this.getContextBean("priceContext");也是可以取到的。',normalizedContent:'版本支持：\n\nliteflow还支持给上下文设置别名，只需要在上下文中进行标注就可以了：\n\n@contextbean("anyname")\npublic class yourcontext {\n    ...\n}\n\n\n执行时还是老样子：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, yourcontext.class);\n\n\n或者\n\nyourcontext context = new yourcontext();\ncontext.setxxxx(yyy);\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, context);\n\n\n然后在组件中可以根据别名去拿这个上下文：\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\ttestcontext context = this.getcontextbean("anyname");\n\t\t...\n\t}\n}\n\n\n这个特性，尤其是在你要使用多上下文，并且两个上下文是一个类的时候特别有用，因为用class的方式去取有可能就会取错，而别名的方式就可以很好的规避这点。\n\n提示\n\n如果你的上下文没声明@contextbean，其实也是可以通过名称取到的，这时的名称就是上下文classname，并且首字母小写。比如你的上下文类名为pricecontext，那么你通过this.getcontextbean("pricecontext");也是可以取到的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T22:30:36.000Z",permalink:"/pages/90b2a5/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/010.%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/080.🛩执行器/010.说明.md",key:"v-f6731782",path:"/pages/90b2a5/",headersStr:null,content:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合Hello World章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",normalizedContent:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合hello world章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎡执行方法",frontmatter:{title:"🎡执行方法",date:"2022-07-01T23:03:12.000Z",permalink:"/pages/20072e/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/020.%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.html",relativePath:"07.v2.12.X文档/080.🛩执行器/020.执行方法.md",key:"v-eca5b5e8",path:"/pages/20072e/",headers:[{level:2,title:"返回类型为LiteflowResponse",slug:"返回类型为liteflowresponse",normalizedTitle:"返回类型为liteflowresponse",charIndex:86},{level:2,title:"返回类型为Future",slug:"返回类型为future",normalizedTitle:"返回类型为future",charIndex:667}],headersStr:"返回类型为LiteflowResponse 返回类型为Future",content:"你可以在Springboot/Spring体系中的任何被Spring上下文管理的类中进行注入FlowExecutor。\n\nFlowExecutor有多个重载方法。\n\n\n# 返回类型为LiteflowResponse\n\n//参数为流程ID，无初始流程入参，上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId)\n//第一个参数为流程ID，第二个参数为流程入参。上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId, Object param);\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文class\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文的Bean\npublic LiteflowResponse execute2Resp(String chainId, Object param, Object... contextBeanArray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为Future\n\npublic Future<LiteflowResponse> execute2Future(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，LiteFlow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现ExecutorBuilder接口：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n",normalizedContent:"你可以在springboot/spring体系中的任何被spring上下文管理的类中进行注入flowexecutor。\n\nflowexecutor有多个重载方法。\n\n\n# 返回类型为liteflowresponse\n\n//参数为流程id，无初始流程入参，上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid)\n//第一个参数为流程id，第二个参数为流程入参。上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid, object param);\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文class\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文的bean\npublic liteflowresponse execute2resp(string chainid, object param, object... contextbeanarray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为future\n\npublic future<liteflowresponse> execute2future(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，liteflow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现executorbuilder接口：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥙上下文参数注入",frontmatter:{title:"🥙上下文参数注入",date:"2024-05-30T10:50:09.000Z",permalink:"/pages/8777f8/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/050.%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5.html",relativePath:"07.v2.12.X文档/070.🌮数据上下文/050.上下文参数注入.md",key:"v-184bd5cb",path:"/pages/8777f8/",headersStr:null,content:'版本支持：\n\n提示\n\n请注意，这个特性只适用于声明式组件。普通的继承式组件并不支持！\n\n以下所有例子采用方法级别式声明。类级别式声明也是可以用此特性的。\n\n我们在组件里面写业务，首先肯定就是要拿到上下文，在声明式组件里通常的写法为：\n\n@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS,nodeType = NodeTypeEnum.COMMON, nodeId = "b")\npublic void processB(NodeComponent bindCmp) {\n    YourContext context = bindCmp.getContextBean(YourContext.class);\n    //从context中取到业务数据进行处理\n    User user = context.getUser();\n    ...\n}\n\n\n如果组件一多，那免不了每次都要写这么一句拿context，虽然不影响什么性能，但是非常繁琐。\n\nLiteFlow从2.12.1开始推出了上下文参数注入特性，可以在方法参数中注入你所需的上下文数据，从而直接拿到，无需再每次取一次了。\n\n假设你的上下文如下：\n\npublic class TestContext {\n\n    private User user;\n\n    private String data1;\n    \n    //getter setter 省略   \n}\n\n\n你在声明式组件中使用@LiteflowFact来定义你的注入型参数：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeType = NodeTypeEnum.COMMON, nodeId = "a")\n    public void processA(NodeComponent bindCmp,\n                        @LiteflowFact("user") User user) {\n        user.setName("jack");\n    }\n}\n\n\n使用参数注入特性，可以把上下文中已有的值注入到方法参数上，上面这个例子你就可以直接获得上下文中user这个对象。\n\n如果对象比较深，你还可以通过点操作符的方式：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeType = NodeTypeEnum.COMMON, nodeId = "a")\n    public void processA(NodeComponent bindCmp,\n                        @LiteflowFact("user.company.address") String address) {\n        //do biz\n    }\n}\n\n\n以上这个例子表示address参数取自于上下文中的User对象中的Company对象中的address字段。\n\n当然你也可以注入多个：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeType = NodeTypeEnum.COMMON, nodeId = "a")\n    public void processA(NodeComponent bindCmp,\n                        @LiteflowFact("user.name") String name,\n                        @LiteflowFact("data1") String data1) {\n        //do biz\n    }\n}\n\n\n你在@LiteflowFact中写的表达式，会自动的从上下文中搜索相应的参数。即使你有多个上下文，也无需去指定上下文。\n\n但是有一种情况，在使用时要注意：假设你有两个上下文，TestContext1和TestContext2，在这两个上下文里都有user这个对象，并且两个user里的信息是不一样的。这时你通过@LiteflowFact("user") User user这样去拿，拿到的是第一个user，在不同环境上可能还不一样。\n\n所以使用上下文参数注入特性时，如果有多个上下文，请确保注入的对象，在多个上下文中只有一份，否则会有错乱情况。',normalizedContent:'版本支持：\n\n提示\n\n请注意，这个特性只适用于声明式组件。普通的继承式组件并不支持！\n\n以下所有例子采用方法级别式声明。类级别式声明也是可以用此特性的。\n\n我们在组件里面写业务，首先肯定就是要拿到上下文，在声明式组件里通常的写法为：\n\n@liteflowmethod(value = liteflowmethodenum.process,nodetype = nodetypeenum.common, nodeid = "b")\npublic void processb(nodecomponent bindcmp) {\n    yourcontext context = bindcmp.getcontextbean(yourcontext.class);\n    //从context中取到业务数据进行处理\n    user user = context.getuser();\n    ...\n}\n\n\n如果组件一多，那免不了每次都要写这么一句拿context，虽然不影响什么性能，但是非常繁琐。\n\nliteflow从2.12.1开始推出了上下文参数注入特性，可以在方法参数中注入你所需的上下文数据，从而直接拿到，无需再每次取一次了。\n\n假设你的上下文如下：\n\npublic class testcontext {\n\n    private user user;\n\n    private string data1;\n    \n    //getter setter 省略   \n}\n\n\n你在声明式组件中使用@liteflowfact来定义你的注入型参数：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodetype = nodetypeenum.common, nodeid = "a")\n    public void processa(nodecomponent bindcmp,\n                        @liteflowfact("user") user user) {\n        user.setname("jack");\n    }\n}\n\n\n使用参数注入特性，可以把上下文中已有的值注入到方法参数上，上面这个例子你就可以直接获得上下文中user这个对象。\n\n如果对象比较深，你还可以通过点操作符的方式：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodetype = nodetypeenum.common, nodeid = "a")\n    public void processa(nodecomponent bindcmp,\n                        @liteflowfact("user.company.address") string address) {\n        //do biz\n    }\n}\n\n\n以上这个例子表示address参数取自于上下文中的user对象中的company对象中的address字段。\n\n当然你也可以注入多个：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodetype = nodetypeenum.common, nodeid = "a")\n    public void processa(nodecomponent bindcmp,\n                        @liteflowfact("user.name") string name,\n                        @liteflowfact("data1") string data1) {\n        //do biz\n    }\n}\n\n\n你在@liteflowfact中写的表达式，会自动的从上下文中搜索相应的参数。即使你有多个上下文，也无需去指定上下文。\n\n但是有一种情况，在使用时要注意：假设你有两个上下文，testcontext1和testcontext2，在这两个上下文里都有user这个对象，并且两个user里的信息是不一样的。这时你通过@liteflowfact("user") user user这样去拿，拿到的是第一个user，在不同环境上可能还不一样。\n\n所以使用上下文参数注入特性时，如果有多个上下文，请确保注入的对象，在多个上下文中只有一份，否则会有错乱情况。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎢流程入参",frontmatter:{title:"🎢流程入参",date:"2022-07-02T00:38:44.000Z",permalink:"/pages/563b67/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/030.%E6%B5%81%E7%A8%8B%E5%85%A5%E5%8F%82.html",relativePath:"07.v2.12.X文档/080.🛩执行器/030.流程入参.md",key:"v-42def230",path:"/pages/563b67/",headersStr:null,content:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户Id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的Bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tYourBean requestBean = this.getRequestData();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getRequestData()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',normalizedContent:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tyourbean requestbean = this.getrequestdata();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getrequestdata()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎈LiteflowResponse对象",frontmatter:{title:"🎈LiteflowResponse对象",date:"2022-07-02T00:52:14.000Z",permalink:"/pages/9f653d/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/040.LiteflowResponse%E5%AF%B9%E8%B1%A1.html",relativePath:"07.v2.12.X文档/080.🛩执行器/040.LiteflowResponse对象.md",key:"v-64d81acc",path:"/pages/9f653d/",headers:[{level:2,title:"流程执行是否成功",slug:"流程执行是否成功",normalizedTitle:"流程执行是否成功",charIndex:110},{level:2,title:"获取异常信息",slug:"获取异常信息",normalizedTitle:"获取异常信息",charIndex:284},{level:2,title:"获得执行步骤详细信息",slug:"获得执行步骤详细信息",normalizedTitle:"获得执行步骤详细信息",charIndex:525},{level:2,title:"上下文数据",slug:"上下文数据",normalizedTitle:"上下文数据",charIndex:934},{level:2,title:"获得步骤字符串信息",slug:"获得步骤字符串信息",normalizedTitle:"获得步骤字符串信息",charIndex:1560},{level:2,title:"获得超时对象",slug:"获得超时对象",normalizedTitle:"获得超时对象",charIndex:2002}],headersStr:"流程执行是否成功 获取异常信息 获得执行步骤详细信息 上下文数据 获得步骤字符串信息 获得超时对象",content:'在执行器返回中，用的最多的就是返回一个LiteFlowResponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n提示\n\n这个对象并不适合进行序列化返回，应用层如果想返回一些数据，应当自己构建对象。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nboolean isSuccess = response.isSuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程isSuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了LiteFlowResponse对象之后，可以这样获得上下文Bean：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nCustomContext context = response.getContextBean(CustomContext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//CustomContext context = response.getFirstContextBean();\n\n\n对于多上下文来说，也是一样的用法：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, OrderContext.class, UserContext.class);\nOrderContext orderContext = response.getContextBean(OrderContext.class);\nUserContext userContext = response.getContextBean(UserContext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nString stepStr = response.getExecuteStepStrWithTime();\n\n\n这个字符串打印出来结果如下：\n\na[组件A]<201>==>b[组件B]<300>==>m[组件M]<1205>\n\n\n这里的表达形式为组件ID[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getExecuteStepStrWithoutTime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。\n\n\n# 获得超时对象\n\n你可以调用liteflowResponse.getTimeoutItems()方法来获得超时的对象Id。',normalizedContent:'在执行器返回中，用的最多的就是返回一个liteflowresponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n提示\n\n这个对象并不适合进行序列化返回，应用层如果想返回一些数据，应当自己构建对象。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nboolean issuccess = response.issuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程issuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了liteflowresponse对象之后，可以这样获得上下文bean：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\ncustomcontext context = response.getcontextbean(customcontext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//customcontext context = response.getfirstcontextbean();\n\n\n对于多上下文来说，也是一样的用法：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, ordercontext.class, usercontext.class);\nordercontext ordercontext = response.getcontextbean(ordercontext.class);\nusercontext usercontext = response.getcontextbean(usercontext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nstring stepstr = response.getexecutestepstrwithtime();\n\n\n这个字符串打印出来结果如下：\n\na[组件a]<201>==>b[组件b]<300>==>m[组件m]<1205>\n\n\n这里的表达形式为组件id[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getexecutestepstrwithouttime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。\n\n\n# 获得超时对象\n\n你可以调用liteflowresponse.gettimeoutitems()方法来获得超时的对象id。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌭脚本语言介绍",frontmatter:{title:"🌭脚本语言介绍",date:"2023-08-27T22:54:15.000Z",permalink:"/pages/38c781/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/005.%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/005.脚本语言介绍.md",key:"v-013d839a",path:"/pages/38c781/",headersStr:null,content:"在前面几个章节中，我们介绍了LiteFlow是用EL表达式来驱动组件执行顺序的。\n\n可见组件是LiteFlow的最小逻辑执行单元。\n\n而组件在前面几章的介绍中，都是需要你自己去定义类的。而定义类通常用于相对固定的逻辑，EL表达式能够即时调整，但是定义成类的组件中的逻辑还是要重启系统才能调整。\n\n但是在实际业务场景中，有的场景需要实时的去调整小部分逻辑，那怎么办呢。\n\n这就需要LiteFlow提供的脚本组件特性了。\n\n脚本组件，顾名思义就是不再需要你去用类去定义组件了，而是用脚本来定义组件。而脚本也是可以被即时调整的。\n\n脚本组件也是LiteFlow框架中非常重要且极具有特色的一个特性，利用EL+脚本组件，你可以做出一套极其灵活的系统。无论是执行顺序，还是关键逻辑，均可进行热刷新。\n\nLiteFlow在启动时就对脚本进行了预编译，虽然脚本的执行性能肯定比不过原生java，但是性能不会差太多，因为脚本方便且灵活可以热刷，这是java类所做不到的。\n\nLiteFlow中目前支持的脚本语言多达8种。下面一小章会大致说下每一种脚本语言该如何运用。\n\n * groovy\n * js\n * python\n * qlexpress\n * lua\n * aviator\n * java\n * kotlin\n\n提示\n\n虽然脚本组件拥有可热刷新的特性，但是依旧不推荐把一个系统里所有的逻辑都写成脚本组件，因为并不是所有的逻辑都需要热修改。\n\n推荐把需要灵活经常变的逻辑写成脚本组件，固定不变的逻辑还是用java类来写。java类+脚本组件+EL的组合是官方最为推荐的方式。",normalizedContent:"在前面几个章节中，我们介绍了liteflow是用el表达式来驱动组件执行顺序的。\n\n可见组件是liteflow的最小逻辑执行单元。\n\n而组件在前面几章的介绍中，都是需要你自己去定义类的。而定义类通常用于相对固定的逻辑，el表达式能够即时调整，但是定义成类的组件中的逻辑还是要重启系统才能调整。\n\n但是在实际业务场景中，有的场景需要实时的去调整小部分逻辑，那怎么办呢。\n\n这就需要liteflow提供的脚本组件特性了。\n\n脚本组件，顾名思义就是不再需要你去用类去定义组件了，而是用脚本来定义组件。而脚本也是可以被即时调整的。\n\n脚本组件也是liteflow框架中非常重要且极具有特色的一个特性，利用el+脚本组件，你可以做出一套极其灵活的系统。无论是执行顺序，还是关键逻辑，均可进行热刷新。\n\nliteflow在启动时就对脚本进行了预编译，虽然脚本的执行性能肯定比不过原生java，但是性能不会差太多，因为脚本方便且灵活可以热刷，这是java类所做不到的。\n\nliteflow中目前支持的脚本语言多达8种。下面一小章会大致说下每一种脚本语言该如何运用。\n\n * groovy\n * js\n * python\n * qlexpress\n * lua\n * aviator\n * java\n * kotlin\n\n提示\n\n虽然脚本组件拥有可热刷新的特性，但是依旧不推荐把一个系统里所有的逻辑都写成脚本组件，因为并不是所有的逻辑都需要热修改。\n\n推荐把需要灵活经常变的逻辑写成脚本组件，固定不变的逻辑还是用java类来写。java类+脚本组件+el的组合是官方最为推荐的方式。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧀Javascript脚本引擎",frontmatter:{title:"🧀Javascript脚本引擎",date:"2023-08-28T00:05:24.000Z",permalink:"/pages/07f433/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/020.Javascript%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/020.Javascript脚本引擎.md",key:"v-09fb6ac2",path:"/pages/07f433/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:84},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:1031},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:1222}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n对于Javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持ES5。另一种是基于GraalJs引擎实现，支持ES6。\n\n如果你使用jdk8，你可以选用下面任意一种脚本引擎，而jdk11和jdk17，你只能选用graaljs引擎，因为jdk8之后的jdk已经移除了jdk自带的Nashorn JavaScript引擎。\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-javascript</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-graaljs</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例\n\n<node id="s1" name="普通脚本1" type="script" language="js">\n    <![CDATA[\n        var a=3;\n        var b=2;\n        var c=1;\n        var d=5;\n\n        function addByArray(values) {\n            var sum = 0;\n            for (var i = 0; i < values.length; i++) {\n                sum += values[i];\n            }\n            return sum;\n        }\n\n        var result = addByArray([a,b,c,d]);\n\n        defaultContext.setData("s1",parseInt(result));\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，你可以用js的绝大部分语法特性，甚至还可以在脚本里定义Function。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n对于javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持es5。另一种是基于graaljs引擎实现，支持es6。\n\n如果你使用jdk8，你可以选用下面任意一种脚本引擎，而jdk11和jdk17，你只能选用graaljs引擎，因为jdk8之后的jdk已经移除了jdk自带的nashorn javascript引擎。\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-javascript</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-graaljs</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例\n\n<node id="s1" name="普通脚本1" type="script" language="js">\n    <![cdata[\n        var a=3;\n        var b=2;\n        var c=1;\n        var d=5;\n\n        function addbyarray(values) {\n            var sum = 0;\n            for (var i = 0; i < values.length; i++) {\n                sum += values[i];\n            }\n            return sum;\n        }\n\n        var result = addbyarray([a,b,c,d]);\n\n        defaultcontext.setdata("s1",parseint(result));\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，你可以用js的绝大部分语法特性，甚至还可以在脚本里定义function。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"☕️Java脚本引擎",frontmatter:{title:"☕️Java脚本引擎",date:"2023-08-28T00:13:47.000Z",permalink:"/pages/2b8afb/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/030.Java%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/030.Java脚本引擎.md",key:"v-4b84ca42",path:"/pages/2b8afb/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:94},{level:2,title:"为什么提供两个实现引擎",slug:"为什么提供两个实现引擎",normalizedTitle:"为什么提供两个实现引擎",charIndex:617},{level:2,title:"两个引擎的优劣势",slug:"两个引擎的优劣势",normalizedTitle:"两个引擎的优劣势",charIndex:791},{level:2,title:"使用(liteflow-script-java)",slug:"使用-liteflow-script-java",normalizedTitle:"使用(liteflow-script-java)",charIndex:1068},{level:2,title:"使用(liteflow-script-javax)",slug:"使用-liteflow-script-javax",normalizedTitle:"使用(liteflow-script-javax)",charIndex:2879},{level:2,title:"和Java类进行交互",slug:"和java类进行交互",normalizedTitle:"和java类进行交互",charIndex:4728},{level:2,title:"如何取Spring上下文中的数据",slug:"如何取spring上下文中的数据",normalizedTitle:"如何取spring上下文中的数据",charIndex:4889}],headersStr:"介绍 依赖 为什么提供两个实现引擎 两个引擎的优劣势 使用(liteflow-script-java) 使用(liteflow-script-javax) 和Java类进行交互 如何取Spring上下文中的数据",content:'# 介绍\n\nLiteFlow支持了用Java本身作为脚本语言的特性。\n\n也就是说，在写组件脚本时，你可以完全用Java自身的语法来写脚本。同样这部分的脚本，也是可以进行热刷新的。\n\n\n# 依赖\n\nLiteFlow提供了两种不同的Java脚本引擎，分别是：\n\nliteflow-script-java：以Janino为底层来实现。版本支持：\n\n你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-java</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\nliteflow-script-javax：以Liquor为底层来实现。版本支持：\n\n你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-javax</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n提示\n\n使用以Liquor为核心的javax插件，部署运行的时候必须为JDK，而不能是JRE，这点要注意下。\n\n\n# 为什么提供两个实现引擎\n\nliteflow-script-java是以前就提供的。而liteflow-script-javax是后来提供的。他们两个引擎在底层选型上面不同。运行机制不同。使用起来的实现接口也略微有些区别。为了向前兼容。选择另外提供一个脚本引擎。而没有覆盖原有的引擎。\n\n要注意的是，这2个插件只能二选一，不能并存同时依赖。\n\n\n# 两个引擎的优劣势\n\n两个引擎的对比，也就是底层所用引擎Janino和Liquor的对比。\n\nJanino的优点是编译和运行速度都非常快，缺点是只支持Jdk 6的语法，不支持lambda和泛型。\n\nLiquor的优点是运行速度非常快，支持jdk的所有语法，缺点是编译速度比较慢。\n\n这里推荐一般使用者使用Liquor为底层的liteflow-script-javax插件。\n\n如果你的逻辑是每次通过动态构建脚本节点去运行（可以参考用代码动态构造规则-构造Node），那么推荐还是用Janino为底层的liteflow-script-java插件。\n\n\n# 使用(liteflow-script-java)\n\n使用liteflow-script-java插件，需要像如下去定义，以下是个例子：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![CDATA[\n    import com.yomahub.liteflow.slot.DefaultContext;\n    import com.yomahub.liteflow.spi.holder.ContextAwareHolder;\n    import com.yomahub.liteflow.test.script.java.common.cmp.TestDomain;\n    import com.yomahub.liteflow.script.body.JaninoCommonScriptBody;\n    import com.yomahub.liteflow.script.ScriptExecuteWrap;\n\n    public class Demo implements JaninoCommonScriptBody{\n        public Void body(ScriptExecuteWrap wrap){\n            int v1 = 2;\n            int v2 = 3;\n            DefaultContext ctx = (DefaultContext)wrap.cmp.getFirstContextBean();\n            ctx.setData("s1", v1 * v2);\n\n            TestDomain domain = (TestDomain)ContextAwareHolder.loadContextAware().getBean(TestDomain.class);\n\n            String str = domain.sayHello("jack");\n            ctx.setData("hi", str);\n\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\nscript：普通脚本节点，需要实现JaninoCommonScriptBody接口，脚本里返回null即可。\n\nswitch_script：选择脚本节点，需要实现JaninoSwitchScriptBody接口，脚本里需要返回选择的节点Id。\n\nboolean_script：布尔脚本节点，需要实现JaninoBooleanScriptBody接口，脚本里需要返回true/false。\n\nfor_script：数量循环节点，需要实现JaninoForScriptBody接口，脚本里需要返回数值类型，表示循环次数。\n\n正如上面所说到那样，使用liteflow-script-java是没有lambda语法的，并且不支持泛型。 所以以上很多地方要进行强转，例如：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![CDATA[\n    ...\n\n    public class Demo implements JaninoCommonScriptBody{\n        public Void body(ScriptExecuteWrap wrap){\n            ...\n            DefaultContext ctx = (DefaultContext)wrap.cmp.getFirstContextBean();\n            ...\n            TestDomain domain = (TestDomain)ContextAwareHolder.loadContextAware().getBean(TestDomain.class);\n            ...\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\n\n# 使用(liteflow-script-javax)\n\n使用liteflow-script-java插件，需要像如下去定义，以下是个例子：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![CDATA[\n    import cn.hutool.core.collection.ListUtil;\n    import com.alibaba.fastjson2.JSON;\n    import com.yomahub.liteflow.script.body.CommonScriptBody;\n    import com.yomahub.liteflow.slot.DefaultContext;\n    import com.yomahub.liteflow.spi.holder.ContextAwareHolder;\n    import com.yomahub.liteflow.test.script.javax.common.cmp.Person;\n    import com.yomahub.liteflow.test.script.javax.common.cmp.TestDomain;\n    import com.yomahub.liteflow.script.ScriptExecuteWrap;\n    import java.util.List;\n    import java.util.function.ToIntFunction;\n\n    public class Demo implements CommonScriptBody {\n        public Void body(ScriptExecuteWrap wrap) {\n            int v1 = 2;\n            int v2 = 3;\n            DefaultContext ctx = wrap.getCmp().getFirstContextBean();\n            ctx.setData("s1", v1 * v2);\n\n            TestDomain domain = ContextAwareHolder.loadContextAware().getBean(TestDomain.class);\n            System.out.println(domain);\n            String str = domain.sayHello("jack");\n            ctx.setData("hi", str);\n\n            List<Person> personList = ListUtil.toList(\n                    new Person("jack", 15000),\n                    new Person("tom", 13500),\n                    new Person("peter", 18600)\n            );\n\n            int totalSalary = personList.stream().mapToInt(Person::getSalary).sum();\n\n            System.out.println(totalSalary);\n            ctx.setData("salary", 47100);\n\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\nscript：普通脚本节点，需要实现CommonScriptBody接口，脚本里返回null即可。\n\nswitch_script：选择脚本节点，需要实现SwitchScriptBody接口，脚本里需要返回选择的节点Id。\n\nboolean_script：布尔脚本节点，需要实现BooleanScriptBody接口，脚本里需要返回true/false。\n\nfor_script：数量循环节点，需要实现ForScriptBody接口，脚本里需要返回数值类型，表示循环次数。\n\n\n# 和Java类进行交互\n\n由于Java作为脚本，是需要定义一个类的。并且实现其接口所定义的方法。\n\n方法里有ScriptExecuteWrap这个参数。而warp.cmp就是当前的NodeComponent，等同于this，所以你可以用warp.cmp来调取上下文，或者是元数据。使用方式和Java类组件是一致的。\n\n\n# 如何取Spring上下文中的数据\n\n值得注意的是，虽然脚本组件完全是Java的语法，但是你无法用@Resource或者@Autowired来进行注入spring的bean。\n\nLiteFlow提供一个方法，用来获取Spring中的bean数据，如下示例（如果是liteflow-script-java要进行强转类型）\n\nUserDomain domain = ContextAwareHolder.loadContextAware().getBean(UserDomain.class);\n\n\n这样就可以获得在spring上下文中注入的UserDomain对象了。',normalizedContent:'# 介绍\n\nliteflow支持了用java本身作为脚本语言的特性。\n\n也就是说，在写组件脚本时，你可以完全用java自身的语法来写脚本。同样这部分的脚本，也是可以进行热刷新的。\n\n\n# 依赖\n\nliteflow提供了两种不同的java脚本引擎，分别是：\n\nliteflow-script-java：以janino为底层来实现。版本支持：\n\n你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-java</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\nliteflow-script-javax：以liquor为底层来实现。版本支持：\n\n你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-javax</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n提示\n\n使用以liquor为核心的javax插件，部署运行的时候必须为jdk，而不能是jre，这点要注意下。\n\n\n# 为什么提供两个实现引擎\n\nliteflow-script-java是以前就提供的。而liteflow-script-javax是后来提供的。他们两个引擎在底层选型上面不同。运行机制不同。使用起来的实现接口也略微有些区别。为了向前兼容。选择另外提供一个脚本引擎。而没有覆盖原有的引擎。\n\n要注意的是，这2个插件只能二选一，不能并存同时依赖。\n\n\n# 两个引擎的优劣势\n\n两个引擎的对比，也就是底层所用引擎janino和liquor的对比。\n\njanino的优点是编译和运行速度都非常快，缺点是只支持jdk 6的语法，不支持lambda和泛型。\n\nliquor的优点是运行速度非常快，支持jdk的所有语法，缺点是编译速度比较慢。\n\n这里推荐一般使用者使用liquor为底层的liteflow-script-javax插件。\n\n如果你的逻辑是每次通过动态构建脚本节点去运行（可以参考用代码动态构造规则-构造node），那么推荐还是用janino为底层的liteflow-script-java插件。\n\n\n# 使用(liteflow-script-java)\n\n使用liteflow-script-java插件，需要像如下去定义，以下是个例子：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![cdata[\n    import com.yomahub.liteflow.slot.defaultcontext;\n    import com.yomahub.liteflow.spi.holder.contextawareholder;\n    import com.yomahub.liteflow.test.script.java.common.cmp.testdomain;\n    import com.yomahub.liteflow.script.body.janinocommonscriptbody;\n    import com.yomahub.liteflow.script.scriptexecutewrap;\n\n    public class demo implements janinocommonscriptbody{\n        public void body(scriptexecutewrap wrap){\n            int v1 = 2;\n            int v2 = 3;\n            defaultcontext ctx = (defaultcontext)wrap.cmp.getfirstcontextbean();\n            ctx.setdata("s1", v1 * v2);\n\n            testdomain domain = (testdomain)contextawareholder.loadcontextaware().getbean(testdomain.class);\n\n            string str = domain.sayhello("jack");\n            ctx.setdata("hi", str);\n\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\nscript：普通脚本节点，需要实现janinocommonscriptbody接口，脚本里返回null即可。\n\nswitch_script：选择脚本节点，需要实现janinoswitchscriptbody接口，脚本里需要返回选择的节点id。\n\nboolean_script：布尔脚本节点，需要实现janinobooleanscriptbody接口，脚本里需要返回true/false。\n\nfor_script：数量循环节点，需要实现janinoforscriptbody接口，脚本里需要返回数值类型，表示循环次数。\n\n正如上面所说到那样，使用liteflow-script-java是没有lambda语法的，并且不支持泛型。 所以以上很多地方要进行强转，例如：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![cdata[\n    ...\n\n    public class demo implements janinocommonscriptbody{\n        public void body(scriptexecutewrap wrap){\n            ...\n            defaultcontext ctx = (defaultcontext)wrap.cmp.getfirstcontextbean();\n            ...\n            testdomain domain = (testdomain)contextawareholder.loadcontextaware().getbean(testdomain.class);\n            ...\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\n\n# 使用(liteflow-script-javax)\n\n使用liteflow-script-java插件，需要像如下去定义，以下是个例子：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![cdata[\n    import cn.hutool.core.collection.listutil;\n    import com.alibaba.fastjson2.json;\n    import com.yomahub.liteflow.script.body.commonscriptbody;\n    import com.yomahub.liteflow.slot.defaultcontext;\n    import com.yomahub.liteflow.spi.holder.contextawareholder;\n    import com.yomahub.liteflow.test.script.javax.common.cmp.person;\n    import com.yomahub.liteflow.test.script.javax.common.cmp.testdomain;\n    import com.yomahub.liteflow.script.scriptexecutewrap;\n    import java.util.list;\n    import java.util.function.tointfunction;\n\n    public class demo implements commonscriptbody {\n        public void body(scriptexecutewrap wrap) {\n            int v1 = 2;\n            int v2 = 3;\n            defaultcontext ctx = wrap.getcmp().getfirstcontextbean();\n            ctx.setdata("s1", v1 * v2);\n\n            testdomain domain = contextawareholder.loadcontextaware().getbean(testdomain.class);\n            system.out.println(domain);\n            string str = domain.sayhello("jack");\n            ctx.setdata("hi", str);\n\n            list<person> personlist = listutil.tolist(\n                    new person("jack", 15000),\n                    new person("tom", 13500),\n                    new person("peter", 18600)\n            );\n\n            int totalsalary = personlist.stream().maptoint(person::getsalary).sum();\n\n            system.out.println(totalsalary);\n            ctx.setdata("salary", 47100);\n\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\nscript：普通脚本节点，需要实现commonscriptbody接口，脚本里返回null即可。\n\nswitch_script：选择脚本节点，需要实现switchscriptbody接口，脚本里需要返回选择的节点id。\n\nboolean_script：布尔脚本节点，需要实现booleanscriptbody接口，脚本里需要返回true/false。\n\nfor_script：数量循环节点，需要实现forscriptbody接口，脚本里需要返回数值类型，表示循环次数。\n\n\n# 和java类进行交互\n\n由于java作为脚本，是需要定义一个类的。并且实现其接口所定义的方法。\n\n方法里有scriptexecutewrap这个参数。而warp.cmp就是当前的nodecomponent，等同于this，所以你可以用warp.cmp来调取上下文，或者是元数据。使用方式和java类组件是一致的。\n\n\n# 如何取spring上下文中的数据\n\n值得注意的是，虽然脚本组件完全是java的语法，但是你无法用@resource或者@autowired来进行注入spring的bean。\n\nliteflow提供一个方法，用来获取spring中的bean数据，如下示例（如果是liteflow-script-java要进行强转类型）\n\nuserdomain domain = contextawareholder.loadcontextaware().getbean(userdomain.class);\n\n\n这样就可以获得在spring上下文中注入的userdomain对象了。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥏Groovy脚本引擎",frontmatter:{title:"🥏Groovy脚本引擎",date:"2023-08-27T22:56:01.000Z",permalink:"/pages/36877b/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/010.Groovy%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/010.Groovy脚本引擎.md",key:"v-59a98c42",path:"/pages/36877b/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:1202},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:1393}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用groovy脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-groovy</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="groovy">\n    <![CDATA[\n    import cn.hutool.core.collection.ListUtil\n    import cn.hutool.core.date.DateUtil\n\n    import java.util.function.Consumer\n    import java.util.function.Function\n    import java.util.stream.Collectors\n\n    def date = DateUtil.parse("2022-10-17 13:31:43")\n    println(date)\n    defaultContext.setData("demoDate", date)\n\n    List<String> list = ListUtil.toList("a", "b", "c")\n\n    List<String> resultList = list.stream().map(s -> "hello," + s).collect(Collectors.toList())\n\n    defaultContext.setData("resultList", resultList)\n\n    class Student {\n        int studentID\n        String studentName\n    }\n\n    Student student = new Student()\n    student.studentID = 100301\n    student.studentName = "张三"\n    defaultContext.setData("student", student)\n\n    def a = 3\n    def b = 2\n    defaultContext.setData("s1", a * b)\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，可以看到，groovy的脚本语言还是非常类似于java的。甚至还可以在脚本里定义类。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用groovy脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-groovy</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="groovy">\n    <![cdata[\n    import cn.hutool.core.collection.listutil\n    import cn.hutool.core.date.dateutil\n\n    import java.util.function.consumer\n    import java.util.function.function\n    import java.util.stream.collectors\n\n    def date = dateutil.parse("2022-10-17 13:31:43")\n    println(date)\n    defaultcontext.setdata("demodate", date)\n\n    list<string> list = listutil.tolist("a", "b", "c")\n\n    list<string> resultlist = list.stream().map(s -> "hello," + s).collect(collectors.tolist())\n\n    defaultcontext.setdata("resultlist", resultlist)\n\n    class student {\n        int studentid\n        string studentname\n    }\n\n    student student = new student()\n    student.studentid = 100301\n    student.studentname = "张三"\n    defaultcontext.setdata("student", student)\n\n    def a = 3\n    def b = 2\n    defaultcontext.setdata("s1", a * b)\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，可以看到，groovy的脚本语言还是非常类似于java的。甚至还可以在脚本里定义类。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥞QLExpress脚本引擎",frontmatter:{title:"🥞QLExpress脚本引擎",date:"2023-08-28T00:47:19.000Z",permalink:"/pages/19db6d/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/040.QLExpress%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/040.QLExpress脚本引擎.md",key:"v-25df2f08",path:"/pages/19db6d/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:182},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:586},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:777}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\nQLExpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-qlexpress</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本" type="script">\n    <![CDATA[\n        a=3;\n        b=2;\n        defaultContext.setData("s1",a*b);\n    ]]>\n</node>\n\n<node id="s2" name="条件脚本" type="switch_script">\n    <![CDATA[\n        count = defaultContext.getData("count");\n        if(count > 100){\n            return "a";\n        }else{\n            return "b";\n        }\n    ]]>\n</node>\n\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\nqlexpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-qlexpress</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本" type="script">\n    <![cdata[\n        a=3;\n        b=2;\n        defaultcontext.setdata("s1",a*b);\n    ]]>\n</node>\n\n<node id="s2" name="条件脚本" type="switch_script">\n    <![cdata[\n        count = defaultcontext.getdata("count");\n        if(count > 100){\n            return "a";\n        }else{\n            return "b";\n        }\n    ]]>\n</node>\n\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍧Python脚本引擎",frontmatter:{title:"🍧Python脚本引擎",date:"2023-08-28T00:48:36.000Z",permalink:"/pages/114982/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/050.Python%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/050.Python脚本引擎.md",key:"v-e98a58fc",path:"/pages/114982/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:1154},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:1345}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用python脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-python</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n提示\n\npython解析执行依赖Jython环境，不安装部署启动会报错（IDEA里不会报错），环境安装说明如下\n\n一、下载安装Jython Installer\n\nhttps://www.jython.org/download\n\n二、Springboot启动类添加代码\n\nProperties props = new Properties();\nProperties preprops = System.getProperties();\nprops.put("python.home", jython安装目录);\nPythonInterpreter.initialize (preprops, props, new String[]{});\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="python">\n    <![CDATA[\n        import json\n\n        x=\'{"name": "杰克", "age": 25, "nationality": "China"}\'\n        jsonData=json.loads(x)\n        name=jsonData[\'name\']\n        defaultContext.setData("name", name.decode(\'utf-8\'))\n\n\n        a=6\n        b=10\n        if a>5:\n            b=5\n            print \'hello\'\n        else:\n            print \'hi\'\n        defaultContext.setData("s1",a*b)\n    ]]>\n</node>\n\n\n上面的例子为python语法，你甚至可以引入一些python的原有的包来做逻辑。对于复杂的逻辑，推荐直接调用java类，关于如何和java互动请看下面。\n\n提示\n\n如果遇到中文乱码的现象，请使用decode函数，比如：\n\nprint \'你好\'.decode(\'UTF-8\')\n\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用python脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-python</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n提示\n\npython解析执行依赖jython环境，不安装部署启动会报错（idea里不会报错），环境安装说明如下\n\n一、下载安装jython installer\n\nhttps://www.jython.org/download\n\n二、springboot启动类添加代码\n\nproperties props = new properties();\nproperties preprops = system.getproperties();\nprops.put("python.home", jython安装目录);\npythoninterpreter.initialize (preprops, props, new string[]{});\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="python">\n    <![cdata[\n        import json\n\n        x=\'{"name": "杰克", "age": 25, "nationality": "china"}\'\n        jsondata=json.loads(x)\n        name=jsondata[\'name\']\n        defaultcontext.setdata("name", name.decode(\'utf-8\'))\n\n\n        a=6\n        b=10\n        if a>5:\n            b=5\n            print \'hello\'\n        else:\n            print \'hi\'\n        defaultcontext.setdata("s1",a*b)\n    ]]>\n</node>\n\n\n上面的例子为python语法，你甚至可以引入一些python的原有的包来做逻辑。对于复杂的逻辑，推荐直接调用java类，关于如何和java互动请看下面。\n\n提示\n\n如果遇到中文乱码的现象，请使用decode函数，比如：\n\nprint \'你好\'.decode(\'utf-8\')\n\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍝Lua脚本引擎",frontmatter:{title:"🍝Lua脚本引擎",date:"2023-08-28T00:48:55.000Z",permalink:"/pages/5f0cc7/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/060.Lua%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/060.Lua脚本引擎.md",key:"v-5f974606",path:"/pages/5f0cc7/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:577},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:768}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用lua脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-lua</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script">\n    <![CDATA[\n        local a=6\n        local b=10\n        if(a>5) then\n            b=5\n        else\n            b=2\n        end\n        defaultContext:setData("s1",a*b)\n        defaultContext:setData("s2",_meta:get("nodeId"))\n    ]]>\n</node>\n\n\n在lua中，调用java方法是用:来调用的，并不是.，比如defaultContext:setData("s1",a*b)。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用lua脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-lua</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script">\n    <![cdata[\n        local a=6\n        local b=10\n        if(a>5) then\n            b=5\n        else\n            b=2\n        end\n        defaultcontext:setdata("s1",a*b)\n        defaultcontext:setdata("s2",_meta:get("nodeid"))\n    ]]>\n</node>\n\n\n在lua中，调用java方法是用:来调用的，并不是.，比如defaultcontext:setdata("s1",a*b)。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥠Kotlin脚本引擎",frontmatter:{title:"🥠Kotlin脚本引擎",date:"2024-05-30T19:00:23.000Z",permalink:"/pages/7c44ca/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/080.Kotlin%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/080.Kotlin脚本引擎.md",key:"v-516cdc82",path:"/pages/7c44ca/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:10},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:14},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:694}],headersStr:"依赖 使用 脚本类型",content:'版本支持：\n\n\n# 依赖\n\n使用aviator脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-kotlin</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" type="script" language="kotlin">\n    import com.yomahub.liteflow.slot.DefaultContext\n\n    fun sum(a: Int, b: Int) = a + b\n    var a = 2\n    var b = 3\n    // 从 bindings 中获取上下文\n    val defaultContext = bindings["defaultContext"] as DefaultContext\n    defaultContext.setData("s1", sum(a, b))\n    println("Hello Kotlin!")\n</node>\n\n\n在kotlin脚本中，上下文的获取一定要加bindings这个关键字。当然不仅仅是上下文，一切元信息里的东西都要加上这个关键字。\n\n关于脚本中如何取到上下文以及和Java类进行交互的细节请看脚本与Java进行交互这章。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。',normalizedContent:'版本支持：\n\n\n# 依赖\n\n使用aviator脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-kotlin</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" type="script" language="kotlin">\n    import com.yomahub.liteflow.slot.defaultcontext\n\n    fun sum(a: int, b: int) = a + b\n    var a = 2\n    var b = 3\n    // 从 bindings 中获取上下文\n    val defaultcontext = bindings["defaultcontext"] as defaultcontext\n    defaultcontext.setdata("s1", sum(a, b))\n    println("hello kotlin!")\n</node>\n\n\n在kotlin脚本中，上下文的获取一定要加bindings这个关键字。当然不仅仅是上下文，一切元信息里的东西都要加上这个关键字。\n\n关于脚本中如何取到上下文以及和java类进行交互的细节请看脚本与java进行交互这章。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥐Aviator脚本引擎",frontmatter:{title:"🥐Aviator脚本引擎",date:"2023-08-28T00:49:08.000Z",permalink:"/pages/bad4b0/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/070.Aviator%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/010.🍫脚本语言种类/070.Aviator脚本引擎.md",key:"v-410b3c24",path:"/pages/bad4b0/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:772},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:963}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用aviator脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-aviator</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="aviator">\n    <![CDATA[\n        use java.util.Date;\n        use cn.hutool.core.date.DateUtil;\n        let d = DateUtil.formatDateTime(new Date());\n        println(d);\n\n        a = 2;\n        b = 3;\n\n        setData(defaultContext, "s1", a*b);\n    ]]>\n</node>\n\n\n在aviator中，你同样可以导入java的包名，直接调用java的方法。\n\n在aviator中，调用java方式和其他不一样，比如我们上下文是UserContext，在其他脚本语言中调用是用userContext.setName("jack")，而在aviator脚本中，调用方式是setName(userContext, "jack")，也就是method(bean, args)这种形式，有点类似java反射的invoke形式。这点要注意下。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用aviator脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-aviator</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="aviator">\n    <![cdata[\n        use java.util.date;\n        use cn.hutool.core.date.dateutil;\n        let d = dateutil.formatdatetime(new date());\n        println(d);\n\n        a = 2;\n        b = 3;\n\n        setdata(defaultcontext, "s1", a*b);\n    ]]>\n</node>\n\n\n在aviator中，你同样可以导入java的包名，直接调用java的方法。\n\n在aviator中，调用java方式和其他不一样，比如我们上下文是usercontext，在其他脚本语言中调用是用usercontext.setname("jack")，而在aviator脚本中，调用方式是setname(usercontext, "jack")，也就是method(bean, args)这种形式，有点类似java反射的invoke形式。这点要注意下。\n\n\n# 脚本类型\n\n要注意的是，type分为4种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nboolean_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\n注意\n\n脚本组件中无法定义循环迭代组件。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍱多脚本语言混合共存",frontmatter:{title:"🍱多脚本语言混合共存",date:"2023-03-16T22:49:23.000Z",permalink:"/pages/acba2c/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/020.%E5%A4%9A%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E5%85%B1%E5%AD%98.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/020.多脚本语言混合共存.md",key:"v-dfbe432c",path:"/pages/acba2c/",headersStr:null,content:'版本支持：\n\nLiteFlow支持了多脚本语言混合共存的特性。你完全可以在规则文件内用不同的脚本语言书写不同的逻辑。\n\n当然有个前提：你使用了多个脚本，必须引入多个脚本对应的依赖，依赖选项在脚本语言种类有说过。\n\n比如你可以这样定义多个脚本：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="groovy脚本" type="script" language="groovy">\n            <![CDATA[\n                class Student {\n                    int studentID\n                    String studentName\n                }\n\n                Student student = new Student()\n                student.studentID = 100301\n                student.studentName = "张三"\n                defaultContext.setData("student", student)\n\n                def a = 3\n                def b = 2\n                defaultContext.setData("s1", a * b)\n            ]]>\n        </node>\n\n        <node id="s2" name="js脚本" type="script" language="js">\n            <![CDATA[\n                var student = defaultContext.getData("student");\n                student.studentID = 10032;\n            ]]>\n        </node>\n\n        <node id="s3" name="python脚本" type="script" language="python">\n            <![CDATA[\n                a = 3\n                s1 = defaultContext.getData("s1")\n                defaultContext.setData("s1",s1*a)\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, s1, b, s2, c, s3);\n    </chain>\n</flow>\n\n\n以上规则中，其中a,b,c为java组件，s1是groovy组件，s2是javascript组件，s3是python组件。\n\nLiteFlow能非常方便的能进行混合编排，并且实现参数互通。',normalizedContent:'版本支持：\n\nliteflow支持了多脚本语言混合共存的特性。你完全可以在规则文件内用不同的脚本语言书写不同的逻辑。\n\n当然有个前提：你使用了多个脚本，必须引入多个脚本对应的依赖，依赖选项在脚本语言种类有说过。\n\n比如你可以这样定义多个脚本：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="groovy脚本" type="script" language="groovy">\n            <![cdata[\n                class student {\n                    int studentid\n                    string studentname\n                }\n\n                student student = new student()\n                student.studentid = 100301\n                student.studentname = "张三"\n                defaultcontext.setdata("student", student)\n\n                def a = 3\n                def b = 2\n                defaultcontext.setdata("s1", a * b)\n            ]]>\n        </node>\n\n        <node id="s2" name="js脚本" type="script" language="js">\n            <![cdata[\n                var student = defaultcontext.getdata("student");\n                student.studentid = 10032;\n            ]]>\n        </node>\n\n        <node id="s3" name="python脚本" type="script" language="python">\n            <![cdata[\n                a = 3\n                s1 = defaultcontext.getdata("s1")\n                defaultcontext.setdata("s1",s1*a)\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, s1, b, s2, c, s3);\n    </chain>\n</flow>\n\n\n以上规则中，其中a,b,c为java组件，s1是groovy组件，s2是javascript组件，s3是python组件。\n\nliteflow能非常方便的能进行混合编排，并且实现参数互通。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣脚本与Java进行交互",frontmatter:{title:"🍣脚本与Java进行交互",date:"2022-10-05T14:18:24.000Z",permalink:"/pages/d861c8/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/015.%E8%84%9A%E6%9C%AC%E4%B8%8EJava%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/015.脚本与Java进行交互.md",key:"v-a3cae70c",path:"/pages/d861c8/",headers:[{level:2,title:"和上下文进行交互",slug:"和上下文进行交互",normalizedTitle:"和上下文进行交互",charIndex:110},{level:2,title:"自定义上下文引用名称",slug:"自定义上下文引用名称",normalizedTitle:"自定义上下文引用名称",charIndex:649},{level:2,title:"元数据获取方式之一",slug:"元数据获取方式之一",normalizedTitle:"元数据获取方式之一",charIndex:948},{level:2,title:"元数据获取方式之二",slug:"元数据获取方式之二",normalizedTitle:"元数据获取方式之二",charIndex:1324},{level:2,title:"和自定义的JavaBean进行交互",slug:"和自定义的javabean进行交互",normalizedTitle:"和自定义的javabean进行交互",charIndex:1491},{level:2,title:"直接注入方法",slug:"直接注入方法",normalizedTitle:"直接注入方法",charIndex:2841}],headersStr:"和上下文进行交互 自定义上下文引用名称 元数据获取方式之一 元数据获取方式之二 和自定义的JavaBean进行交互 直接注入方法",content:'提示\n\n这章只适用于groovy,js,python,qlexpress,lua,aviator这6种脚本语言。\n\nv2.11.0新增的Java脚本语言和Java类的交互方式在Java脚本引擎中已做了详细说明。\n\n\n# 和上下文进行交互\n\n因为LiteFlow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的className的驼峰形式来获取数据。\n\n比如你的上下文类叫OrderContext，那么脚本中的就用orderContext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取UserContext中的userName对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![CDATA[\n        //你可以这样定义\n        def name = userContext.userName;\n        //也可以这样定义，如果你对userName有getter方法的话\n        def name = userContext.getUserName();\n        //同理，你可以调用数据上下文中的任意方法\n        userContext.doYourMethod();\n    ]]>\n</node>\n\n\n\n# 自定义上下文引用名称\n\n上文提到，在脚本中默认的上下文引用规则为上下文类的simpleClassName，比如你的上下文为UserContext，那么脚本就用userContext去引用。\n\n那么可不可以自定义这个上下文的名称呢？\n\n可以。LiteFlow从2.10.0版本开始支持这个功能，如果你不想用userContext来引用，那么只需加一个@ContextBean的注解即可完成：\n\n@ContextBean("userCtx")\npublic class UserContext {\n    ...\n}\n\n\n这样定义后，那么脚本中，你就可以用userCtx关键字去引用上下文了。\n\n\n# 元数据获取方式之一\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotIndex: slot下标，可以通过FlowBus.getSlot(slotIndex)来获得slot数据\n * currChainId: 当前执行chain的名称\n * nodeId: 当前执行node的Id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpData: 组件规则参数，关于cmpData的说明请查看组件参数\n * loopIndex: 在循环中的循环下标\n * loopObject: 在迭代循环中的循环对象\n * requestData: 流程初始参数\n * subRequestData: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 元数据获取方式之二\n\n你也可以通过_meta.cmp来获取当前的组件对象。\n\n你可以理解_meta.cmp为this关键字，那既然如此，那this可以获取的资源，在脚本里也可以，比如想获取tag就是_meta.cmp.getTag()，想通过别名获取上下文就是_meta.cmp.getContextBean("xxx")。\n\n\n# 和自定义的JavaBean进行交互\n\nLiteFlow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@ScriptBean标注，即可完成注入。\n\n@Component\n@ScriptBean("demo")\npublic class DemoBean1 {\n\n    @Resource\n    private DemoBean2 demoBean2;\n\n    public String getDemoStr1(){\n        return "hello";\n    }\n\n    public String getDemoStr2(String name){\n        return demoBean2.getDemoStr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getDemoStr1()和getDemoStr2()方法了。\n\n我们在LiteFlow 2.9.5版本支持了@ScriptBean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", includeMethodName = {"test1","test2"})\npublic class DemoBean3 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", excludeMethodName = {"test2","test3"})\npublic class DemoBean4 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@ScriptBean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nScriptBeanManager.addScriptBean("demo", new DemoBean());\n\n\n\n# 直接注入方法\n\n如果你有一个java类，里面有100个方法，而我只想暴露其1个给脚本使用，用@ScriptBean可能会把整个bean都暴露出去，有没有方法呢？\n\n有。LiteFlow从2.9.5开始加入了@ScriptMethod注解，在方法上进行标注：\n\n@Component\npublic class DemoBean1 {\n\n    @ScriptMethod("demo")\n    public String getDemoStr1() {\n        return "hello";\n    }\n\n    public String method2() {\n       ...\n    }\n       \n    public String method3() {\n       ...\n    }\n    \n    ...\n}\n\n\n这样，你就可以在脚本中用demo.getDemoStr1()来调用到相应的java方法了。\n\n提示\n\n当然这里的前提同样是：java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@ScriptMethod注解也是没用的。',normalizedContent:'提示\n\n这章只适用于groovy,js,python,qlexpress,lua,aviator这6种脚本语言。\n\nv2.11.0新增的java脚本语言和java类的交互方式在java脚本引擎中已做了详细说明。\n\n\n# 和上下文进行交互\n\n因为liteflow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的classname的驼峰形式来获取数据。\n\n比如你的上下文类叫ordercontext，那么脚本中的就用ordercontext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取usercontext中的username对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![cdata[\n        //你可以这样定义\n        def name = usercontext.username;\n        //也可以这样定义，如果你对username有getter方法的话\n        def name = usercontext.getusername();\n        //同理，你可以调用数据上下文中的任意方法\n        usercontext.doyourmethod();\n    ]]>\n</node>\n\n\n\n# 自定义上下文引用名称\n\n上文提到，在脚本中默认的上下文引用规则为上下文类的simpleclassname，比如你的上下文为usercontext，那么脚本就用usercontext去引用。\n\n那么可不可以自定义这个上下文的名称呢？\n\n可以。liteflow从2.10.0版本开始支持这个功能，如果你不想用usercontext来引用，那么只需加一个@contextbean的注解即可完成：\n\n@contextbean("userctx")\npublic class usercontext {\n    ...\n}\n\n\n这样定义后，那么脚本中，你就可以用userctx关键字去引用上下文了。\n\n\n# 元数据获取方式之一\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotindex: slot下标，可以通过flowbus.getslot(slotindex)来获得slot数据\n * currchainid: 当前执行chain的名称\n * nodeid: 当前执行node的id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpdata: 组件规则参数，关于cmpdata的说明请查看组件参数\n * loopindex: 在循环中的循环下标\n * loopobject: 在迭代循环中的循环对象\n * requestdata: 流程初始参数\n * subrequestdata: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 元数据获取方式之二\n\n你也可以通过_meta.cmp来获取当前的组件对象。\n\n你可以理解_meta.cmp为this关键字，那既然如此，那this可以获取的资源，在脚本里也可以，比如想获取tag就是_meta.cmp.gettag()，想通过别名获取上下文就是_meta.cmp.getcontextbean("xxx")。\n\n\n# 和自定义的javabean进行交互\n\nliteflow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@scriptbean标注，即可完成注入。\n\n@component\n@scriptbean("demo")\npublic class demobean1 {\n\n    @resource\n    private demobean2 demobean2;\n\n    public string getdemostr1(){\n        return "hello";\n    }\n\n    public string getdemostr2(string name){\n        return demobean2.getdemostr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getdemostr1()和getdemostr2()方法了。\n\n我们在liteflow 2.9.5版本支持了@scriptbean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", includemethodname = {"test1","test2"})\npublic class demobean3 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", excludemethodname = {"test2","test3"})\npublic class demobean4 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@scriptbean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nscriptbeanmanager.addscriptbean("demo", new demobean());\n\n\n\n# 直接注入方法\n\n如果你有一个java类，里面有100个方法，而我只想暴露其1个给脚本使用，用@scriptbean可能会把整个bean都暴露出去，有没有方法呢？\n\n有。liteflow从2.9.5开始加入了@scriptmethod注解，在方法上进行标注：\n\n@component\npublic class demobean1 {\n\n    @scriptmethod("demo")\n    public string getdemostr1() {\n        return "hello";\n    }\n\n    public string method2() {\n       ...\n    }\n       \n    public string method3() {\n       ...\n    }\n    \n    ...\n}\n\n\n这样，你就可以在脚本中用demo.getdemostr1()来调用到相应的java方法了。\n\n提示\n\n当然这里的前提同样是：java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@scriptmethod注解也是没用的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯文件脚本的定义",frontmatter:{title:"🌯文件脚本的定义",date:"2022-10-05T14:16:29.000Z",permalink:"/pages/f7acfd/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/030.%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9A%E4%B9%89.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/030.文件脚本的定义.md",key:"v-2e126258",path:"/pages/f7acfd/",headers:[{level:2,title:"相对位置的文件脚本",slug:"相对位置的文件脚本",normalizedTitle:"相对位置的文件脚本",charIndex:2},{level:2,title:"绝对位置的文件脚本",slug:"绝对位置的文件脚本",normalizedTitle:"绝对位置的文件脚本",charIndex:619}],headersStr:"相对位置的文件脚本 绝对位置的文件脚本",content:'# 相对位置的文件脚本\n\nLiteFlow支持脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟IDE对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, IF(s3, b, c));\n    </chain>\n</flow>\n\n\n\n# 绝对位置的文件脚本\n\nLiteFlow支持脚本文件的绝对路径，你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="/data/liteflow/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="/data/liteflow/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="/data/liteflow/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, IF(s3, b, c));\n    </chain>\n</flow>\n',normalizedContent:'# 相对位置的文件脚本\n\nliteflow支持脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟ide对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        then(d, if(s3, b, c));\n    </chain>\n</flow>\n\n\n\n# 绝对位置的文件脚本\n\nliteflow支持脚本文件的绝对路径，你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="/data/liteflow/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="/data/liteflow/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="/data/liteflow/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        then(d, if(s3, b, c));\n    </chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍘动态刷新脚本",frontmatter:{title:"🍘动态刷新脚本",date:"2022-10-05T22:47:47.000Z",permalink:"/pages/cbcb14/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/050.%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E8%84%9A%E6%9C%AC.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/050.动态刷新脚本.md",key:"v-2dc6750e",path:"/pages/cbcb14/",headersStr:null,content:"版本支持：\n\n其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n这里做一个摘用，你可以调用如下的代码进行脚本的热刷新：\n\nFlowBus.reloadScript(nodeId, script);\n",normalizedContent:"版本支持：\n\n其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n这里做一个摘用，你可以调用如下的代码进行脚本的热刷新：\n\nflowbus.reloadscript(nodeid, script);\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🗑卸载脚本",frontmatter:{title:"🗑卸载脚本",date:"2024-04-10T16:28:25.000Z",permalink:"/pages/28ad17/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/070.%E5%8D%B8%E8%BD%BD%E8%84%9A%E6%9C%AC.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/070.卸载脚本.md",key:"v-2972917a",path:"/pages/28ad17/",headersStr:null,content:"版本支持：\n\nLiteFlow提供了卸载脚本的接口，你可以这么使用：\n\nFlowBus.unloadScriptNode(String nodeId);\n\n\n此方法不仅会卸载编译好的script，也会在元数据中删除相应的节点。",normalizedContent:"版本支持：\n\nliteflow提供了卸载脚本的接口，你可以这么使用：\n\nflowbus.unloadscriptnode(string nodeid);\n\n\n此方法不仅会卸载编译好的script，也会在元数据中删除相应的节点。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍦验证脚本",frontmatter:{title:"🍦验证脚本",date:"2024-04-10T16:12:44.000Z",permalink:"/pages/a5f7d9/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/060.%E9%AA%8C%E8%AF%81%E8%84%9A%E6%9C%AC.html",relativePath:"07.v2.12.X文档/085.🍋脚本组件/060.验证脚本.md",key:"v-a2e02dc6",path:"/pages/a5f7d9/",headersStr:null,content:"版本支持：\n\nLiteFlow提供了验证脚本的接口，你可以这么使用，去验证一个脚本是否规范：\n\nboolean isValid = ScriptValidator.validate(script);\n\n\n返回布尔值，true为通过检查，反之亦然。",normalizedContent:"版本支持：\n\nliteflow提供了验证脚本的接口，你可以这么使用，去验证一个脚本是否规范：\n\nboolean isvalid = scriptvalidator.validate(script);\n\n\n返回布尔值，true为通过检查，反之亦然。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥭什么叫声明式组件",frontmatter:{title:"🥭什么叫声明式组件",date:"2022-10-05T23:19:02.000Z",permalink:"/pages/46f0fa/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/010.%E4%BB%80%E4%B9%88%E5%8F%AB%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/086.🍇声明式组件/010.什么叫声明式组件.md",key:"v-c370ebdc",path:"/pages/46f0fa/",headersStr:null,content:"何谓声明式组件？\n\n之前章节介绍的一些类型的组件，在写法上需要你自己去定义一个类去继承诸如NodeComponent之类的父类。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成LiteFlow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。\n\n提示\n\n目前声明式组件只能在springboot环境中使用.",normalizedContent:"何谓声明式组件？\n\n之前章节介绍的一些类型的组件，在写法上需要你自己去定义一个类去继承诸如nodecomponent之类的父类。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成liteflow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。\n\n提示\n\n目前声明式组件只能在springboot环境中使用.",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧅类级别式声明",frontmatter:{title:"🧅类级别式声明",date:"2022-10-05T23:22:17.000Z",permalink:"/pages/18f548/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/020.%E7%B1%BB%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"07.v2.12.X文档/086.🍇声明式组件/020.类级别式声明.md",key:"v-ac912cf0",path:"/pages/18f548/",headers:[{level:2,title:"普通组件的声明",slug:"普通组件的声明",normalizedTitle:"普通组件的声明",charIndex:147},{level:2,title:"选择组件的声明",slug:"选择组件的声明",normalizedTitle:"选择组件的声明",charIndex:1984},{level:2,title:"布尔组件的声明",slug:"布尔组件的声明",normalizedTitle:"布尔组件的声明",charIndex:2327},{level:2,title:"数值循环组件的声明",slug:"数值循环组件的声明",normalizedTitle:"数值循环组件的声明",charIndex:2643},{level:2,title:"迭代循环组件的声明",slug:"迭代循环组件的声明",normalizedTitle:"迭代循环组件的声明",charIndex:2918},{level:2,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:1516}],headersStr:"普通组件的声明 选择组件的声明 布尔组件的声明 数值循环组件的声明 迭代循环组件的声明 注意点",content:'类级别式声明主要用处就是通过注解形式让普通的java bean变成LiteFlow的组件。无需通过继承类或者实现接口的方式。\n\n由于LiteFlow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@LiteflowComponent("a")\npublic class ACmp{\n  \n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS, nodeType = NodeTypeEnum.COMMON)\n\tpublic void processAcmp(NodeComponent bindCmp) {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)\n\tpublic boolean isAcmpAccess(NodeComponent bindCmp){\n\t\treturn true;\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.BEFORE_PROCESS)\n\tpublic void beforeAcmp(NodeComponent bindCmp){\n\t\tSystem.out.println("before A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.AFTER_PROCESS)\n\tpublic void afterAcmp(NodeComponent bindCmp){\n\t\tSystem.out.println("after A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_SUCCESS)\n\tpublic void onAcmpSuccess(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp success");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_ERROR)\n\tpublic void onAcmpError(NodeComponent bindCmp, Exception e){\n\t\tSystem.out.println("Acmp error");\n\t}\n\t\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_END)\n\tpublic boolean isAcmpEnd(NodeComponent bindCmp) {\n\t\treturn false;\n\t}\n    \n    @LiteflowMethod(value = LiteFlowMethodEnum.ROLLBACK)\n    public void rollbackA(NodeComponent bindCmp) throws Exception {\n        System.out.println("ACmp rollback!");\n    }\n}\n\n\n使用者无需继承NodeComponent了，相应的方法上加上LiteflowMethod注解，即可完成对任意自定义类的组件化工作。\n\n其中LiteFlowMethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n关于参数的参数，这里需要注意的是，方法上参数必须传入NodeComponent bindCmp这个参数，而且必须是第一个参数。\n\n比如原先的process()，那么在声明式里就是yourMethodName(NodeComponent bindCmp)。\n\n如果是原先的onError(Exception e)，那么在声明式里就是yourMethodName(NodeComponent bindCmp, Exception e)。\n\n规律很明显，就是原先的参数保留，在第一个位置插入NodeComponent对象，代替原先的this。\n\n以前获取上下文Bean是用this关键字，现在只需从bindCmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如布尔组件的processBoolean方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.SWITCH参数。\n\n@LiteflowComponent("e")\npublic class ECmp{\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeType = NodeTypeEnum.SWITCH)\n    public String processSwitch(NodeComponent bindCmp) throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 布尔组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.BOOLEAN参数。可用于IF，WHILE，BREAK关键字中\n\n@Component("x")\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BOOLEAN, nodeType = NodeTypeEnum.BOOLEAN)\n\tpublic boolean processBoolean(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.FOR参数。\n\n@Component("x")\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeType = NodeTypeEnum.FOR)\n\tpublic int processFor(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 迭代循环组件的声明\n\n@Component("x")\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_ITERATOR, nodeType = NodeTypeEnum.ITERATOR)\n\tpublic int processIterator(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn list.iterator();\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processXxx一样的方式去声明。',normalizedContent:'类级别式声明主要用处就是通过注解形式让普通的java bean变成liteflow的组件。无需通过继承类或者实现接口的方式。\n\n由于liteflow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@liteflowcomponent("a")\npublic class acmp{\n  \n\t@liteflowmethod(liteflowmethodenum.process, nodetype = nodetypeenum.common)\n\tpublic void processacmp(nodecomponent bindcmp) {\n\t\tsystem.out.println("acmp executed!");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.is_access)\n\tpublic boolean isacmpaccess(nodecomponent bindcmp){\n\t\treturn true;\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.before_process)\n\tpublic void beforeacmp(nodecomponent bindcmp){\n\t\tsystem.out.println("before a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.after_process)\n\tpublic void afteracmp(nodecomponent bindcmp){\n\t\tsystem.out.println("after a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_success)\n\tpublic void onacmpsuccess(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp success");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_error)\n\tpublic void onacmperror(nodecomponent bindcmp, exception e){\n\t\tsystem.out.println("acmp error");\n\t}\n\t\n\t@liteflowmethod(liteflowmethodenum.is_end)\n\tpublic boolean isacmpend(nodecomponent bindcmp) {\n\t\treturn false;\n\t}\n    \n    @liteflowmethod(value = liteflowmethodenum.rollback)\n    public void rollbacka(nodecomponent bindcmp) throws exception {\n        system.out.println("acmp rollback!");\n    }\n}\n\n\n使用者无需继承nodecomponent了，相应的方法上加上liteflowmethod注解，即可完成对任意自定义类的组件化工作。\n\n其中liteflowmethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n关于参数的参数，这里需要注意的是，方法上参数必须传入nodecomponent bindcmp这个参数，而且必须是第一个参数。\n\n比如原先的process()，那么在声明式里就是yourmethodname(nodecomponent bindcmp)。\n\n如果是原先的onerror(exception e)，那么在声明式里就是yourmethodname(nodecomponent bindcmp, exception e)。\n\n规律很明显，就是原先的参数保留，在第一个位置插入nodecomponent对象，代替原先的this。\n\n以前获取上下文bean是用this关键字，现在只需从bindcmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如布尔组件的processboolean方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.switch参数。\n\n@liteflowcomponent("e")\npublic class ecmp{\n\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodetype = nodetypeenum.switch)\n    public string processswitch(nodecomponent bindcmp) throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 布尔组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.boolean参数。可用于if，while，break关键字中\n\n@component("x")\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_boolean, nodetype = nodetypeenum.boolean)\n\tpublic boolean processboolean(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.for参数。\n\n@component("x")\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_for, nodetype = nodetypeenum.for)\n\tpublic int processfor(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 迭代循环组件的声明\n\n@component("x")\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_iterator, nodetype = nodetypeenum.iterator)\n\tpublic int processiterator(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn list.iterator();\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processxxx一样的方式去声明。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥥方法级别式声明",frontmatter:{title:"🥥方法级别式声明",date:"2022-10-05T23:40:08.000Z",permalink:"/pages/797830/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/030.%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"07.v2.12.X文档/086.🍇声明式组件/030.方法级别式声明.md",key:"v-5f9481d8",path:"/pages/797830/",headersStr:null,content:'版本支持：\n\nLiteFlow推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    //普通组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeName = "A组件")\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    //SWITCH组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeId = "b", nodeName = "B组件", nodeType = NodeTypeEnum.SWITCH)\n    public String processB(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //布尔组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BOOLEAN, nodeId = "c", nodeName = "C组件", nodeType = NodeTypeEnum.BOOLEAN)\n    public boolean processC(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //FOR组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeId = "d", nodeName = "D组件", nodeType = NodeTypeEnum.FOR)\n    public int processD(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //迭代组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_ITERATOR, nodeId = "e", nodeName = "E组件", nodeType = NodeTypeEnum.ITERATOR)\n    public int processE(NodeComponent bindCmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@LiteflowMethod注解上的nodeId一定要写。\n\nLiteFlow从v2.10.6开始，新增了nodeName的属性。方便对声明式的组件进行命名。这个属性是可选的。\n\n普通组件上的nodeType因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodeType = NodeTypeEnum.COMMON。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如布尔组件的processBoolean方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public boolean isAccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void onSuccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BOOLEAN, nodeId = "f", nodeType = NodeTypeEnum.BOOLEAN)\n    public boolean processF(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "f", nodeType = NodeTypeEnum.BOOLEAN)\n    public boolean isAccessF(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "f", nodeType = NodeTypeEnum.BOOLEAN)\n    public void onSuccessF(NodeComponent bindCmp){\n        ...\n    }\n}\n',normalizedContent:'版本支持：\n\nliteflow推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    //普通组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodename = "a组件")\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    //switch组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodeid = "b", nodename = "b组件", nodetype = nodetypeenum.switch)\n    public string processb(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //布尔组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_boolean, nodeid = "c", nodename = "c组件", nodetype = nodetypeenum.boolean)\n    public boolean processc(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //for组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_for, nodeid = "d", nodename = "d组件", nodetype = nodetypeenum.for)\n    public int processd(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //迭代组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_iterator, nodeid = "e", nodename = "e组件", nodetype = nodetypeenum.iterator)\n    public int processe(nodecomponent bindcmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@liteflowmethod注解上的nodeid一定要写。\n\nliteflow从v2.10.6开始，新增了nodename的属性。方便对声明式的组件进行命名。这个属性是可选的。\n\n普通组件上的nodetype因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodetype = nodetypeenum.common。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如布尔组件的processboolean方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodetype = nodetypeenum.common)\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "a", nodetype = nodetypeenum.common)\n    public boolean isaccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "a", nodetype = nodetypeenum.common)\n    public void onsuccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.process_boolean, nodeid = "f", nodetype = nodetypeenum.boolean)\n    public boolean processf(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "f", nodetype = nodetypeenum.boolean)\n    public boolean isaccessf(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "f", nodetype = nodetypeenum.boolean)\n    public void onsuccessf(nodecomponent bindcmp){\n        ...\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:56:32.000Z",permalink:"/pages/9aa85a/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/010.%E8%AF%B4%E6%98%8E.html",relativePath:"07.v2.12.X文档/090.🎲用代码动态构造规则/010.说明.md",key:"v-67644772",path:"/pages/9aa85a/",headersStr:null,content:"之前的章节讲述的是通过规则文件去构造流程。\n\nLiteFlow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，ruleSource不用去定义。完全用代码去构建。\n\n事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的API意义在于：\n\n有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n\nLiteFlow设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",normalizedContent:"之前的章节讲述的是通过规则文件去构造流程。\n\nliteflow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，rulesource不用去定义。完全用代码去构建。\n\n事实上，liteflow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的api意义在于：\n\n有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n\nliteflow设计了非常简单的构造方法链式api，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌰构造EL",frontmatter:{title:"🌰构造EL",date:"2023-10-11T21:54:09.000Z",permalink:"/pages/a3cb4b/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/030.%E6%9E%84%E9%80%A0EL.html",relativePath:"07.v2.12.X文档/090.🎲用代码动态构造规则/030.构造EL.md",key:"v-5c54cd7e",path:"/pages/a3cb4b/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"构建一个EL表达式",slug:"构建一个el表达式",normalizedTitle:"构建一个el表达式",charIndex:232},{level:2,title:"格式化输出EL表达式",slug:"格式化输出el表达式",normalizedTitle:"格式化输出el表达式",charIndex:1309},{level:2,title:"目前支持的表达式和关键字",slug:"目前支持的表达式和关键字",normalizedTitle:"目前支持的表达式和关键字",charIndex:1628},{level:2,title:"EL表达式参数校验",slug:"el表达式参数校验",normalizedTitle:"el表达式参数校验",charIndex:5543},{level:2,title:"不包装的Node",slug:"不包装的node",normalizedTitle:"不包装的node",charIndex:5729}],headersStr:"依赖 构建一个EL表达式 格式化输出EL表达式 目前支持的表达式和关键字 EL表达式参数校验 不包装的Node",content:'# 依赖\n\n从2.11.1版本开始，你可以在代码中动态组装EL表达式，包括创建、修改、输出EL表达式。\n\n如果需要在代码中动态构建EL表达式，需要添加以下额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-el-builder</artifactId>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 构建一个EL表达式\n\n你可以通过工厂类ELBus创建任何一个EL表达式。比如对于这样一个EL表达式：\n\n图示\n\n可以调用如下方法组装该表达式：\n\n// 组装EL表达式\nThenELWrapper el = ELBus.then("a",\n\t\tELBus.when("b").when(ELBus.then("c", "d")),\n\t\t"e");\n\n\n可以调用toEL()方法输出EL表达式：\n\nTHEN(node("a"),WHEN(node("b"),THEN(node("c"),node("d"))),node("e"))\n\n\n提示\n\n为了避免可能的冲突，node("")将组件名进行了包装，以确保Node的名称与LiteFlow组件名规范不发生冲突。更详细的内容请查看组件名包装。\n\n除了构建表达式之外，你也可以在表达式中调用表达式的关键字，比如为选择组件的子组件设置id、tag，设置并行组件的any关键字等等。如下例所示：\n\n\x3c!-- 目标EL表达式 --\x3e\n<chain name="chain1">\nwhenData = \'{"name":"zhangsan","age":18}\';\n\nWHEN(\n\tnode("a"),\n\tWHEN(\n\t\tnode("b").data(whenData),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n</chain>\n\n\n可以通过以下方法组装出该EL表达式，调用对应的关键字，并输出对应的表达式。\n\n// EL表达式组装\nWhenELWrapper el = ELBus.when("a",\n\t\tELBus.when(ELBus.node("b").data("whenData", "{\\"name\\":\\"zhangsan\\",\\"age\\":18}"))\n\t\t     .when("c")\n\t\t\t .id("this is a id"),\n\t\t"d").tag("this is a tag").any(true);\n\n\n该EL表达式输出如下：\n\nwhenData = \'{"name":"zhangsan","age":18}\';\nWHEN(node("a"),WHEN(node("b").data(whenData),node("c")).id("this is a id"),node("d")).any(true).tag("this is a tag")\n\n\n\n# 格式化输出EL表达式\n\n容易能发现toEL()方法输出的EL表达式是一行字符串，不方便查看以及校验EL表达式是否正确。可以使用 toEL(true) 方法以树形结构输出EL表达式。对于上一个例子中的EL表达式，调用el.toEL(true)方法，得到树型结构表达式输出如下：\n\nwhenData = \'{"name":"zhangsan","age":18}\';\nWHEN(\n\tnode("a"),\n\tWHEN(\n\t\tnode("b").data(whenData),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n\n\n\n# 目前支持的表达式和关键字\n\n目前支持到2.11.1版本的所有EL表达式，包括其中的关键字和高级特性。当前支持的详细内容如下表：\n\nEL表达式     创建方法                    支持调用方法                                          支持关键字\n串行编排      ELBus.then              then(Object ... objects)                        pre\n                                                                                  finally\n                                                                                  tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n并行编排      ELBus.when              when(Object ... objects)                        any\n                                                                                  ignoreError\n                                                                                  customThreadExecutor\n                                                                                  must\n                                                                                  tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n选择编排      ELBus.switch            to(Object... objects)                           tag\n                                  defaultOpt(Object object)                       id\n                                                                                  maxWaitSeconds\n条件编排      ELBus.ifOpt             elseOpt(Object falseObject)                     tag\n                                  elIfOpt(Object ifObject, Object trueObject)     id\n                                                                                  maxWaitSeconds\n循环编排      ELBus.forOpt            doOpt(Object object)                            parallel\n          ELBus.whileOpt          breakOpt(Object object) (ITERATOR迭代器循环表达式不支持)   tag\n          ELBus.iteratorOpt                                                       id\n                                                                                  maxWaitSeconds\n捕获异常表达式   ELBus.catchException    doOpt(Object object)                            tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n与表达式      ELBus.and               and(Object ... object)                          tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n或表达式      ELBus.or                or(Object ... object)                           tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n非表达式      ELBus.not                                                               tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n单节点表达式    ELBus.node                                                              tag\n                                                                                  data\n                                                                                  maxWaitSeconds\n前置组件      通过then组件的pre关键字创建                                                       tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n后置组件      通过then组件的finally关键字创建                                                   tag\n                                                                                  id\n\n\n# EL表达式参数校验\n\n组装表达式时会对表达式的参数类型进行校验。包括是否为单节点组件、是否允许为与或非表达式等。比如，WHILE表达式WHILE(w).DO(THEN(a, b)); 中，w需要是返回布尔值的节点或与或非表达式。\n\n更多测试样例请在 liteflow-testcase-el/liteflow-testcase-el-builder 模块中查看。\n\n\n# 不包装的Node\n\n如果用ELBus.node("a")这种，最后toEL()出来的是node("a")，这是经过包装过的组件，这种包装过的组件在启动时不会检查a存不存在，而在执行时当a不存在时，会调用a的降级组件。\n\n关于降级组件请参照组件降级这一章。\n\n如果不希望出来的是包装过的，可以用ELBus.commonNode("a")，那最后toEL()出来就是a。这种同样适用于放一个chainId。',normalizedContent:'# 依赖\n\n从2.11.1版本开始，你可以在代码中动态组装el表达式，包括创建、修改、输出el表达式。\n\n如果需要在代码中动态构建el表达式，需要添加以下额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-el-builder</artifactid>\n    <version>2.12.4.1</version>\n</dependency>\n\n\n\n# 构建一个el表达式\n\n你可以通过工厂类elbus创建任何一个el表达式。比如对于这样一个el表达式：\n\n图示\n\n可以调用如下方法组装该表达式：\n\n// 组装el表达式\nthenelwrapper el = elbus.then("a",\n\t\telbus.when("b").when(elbus.then("c", "d")),\n\t\t"e");\n\n\n可以调用toel()方法输出el表达式：\n\nthen(node("a"),when(node("b"),then(node("c"),node("d"))),node("e"))\n\n\n提示\n\n为了避免可能的冲突，node("")将组件名进行了包装，以确保node的名称与liteflow组件名规范不发生冲突。更详细的内容请查看组件名包装。\n\n除了构建表达式之外，你也可以在表达式中调用表达式的关键字，比如为选择组件的子组件设置id、tag，设置并行组件的any关键字等等。如下例所示：\n\n\x3c!-- 目标el表达式 --\x3e\n<chain name="chain1">\nwhendata = \'{"name":"zhangsan","age":18}\';\n\nwhen(\n\tnode("a"),\n\twhen(\n\t\tnode("b").data(whendata),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n</chain>\n\n\n可以通过以下方法组装出该el表达式，调用对应的关键字，并输出对应的表达式。\n\n// el表达式组装\nwhenelwrapper el = elbus.when("a",\n\t\telbus.when(elbus.node("b").data("whendata", "{\\"name\\":\\"zhangsan\\",\\"age\\":18}"))\n\t\t     .when("c")\n\t\t\t .id("this is a id"),\n\t\t"d").tag("this is a tag").any(true);\n\n\n该el表达式输出如下：\n\nwhendata = \'{"name":"zhangsan","age":18}\';\nwhen(node("a"),when(node("b").data(whendata),node("c")).id("this is a id"),node("d")).any(true).tag("this is a tag")\n\n\n\n# 格式化输出el表达式\n\n容易能发现toel()方法输出的el表达式是一行字符串，不方便查看以及校验el表达式是否正确。可以使用 toel(true) 方法以树形结构输出el表达式。对于上一个例子中的el表达式，调用el.toel(true)方法，得到树型结构表达式输出如下：\n\nwhendata = \'{"name":"zhangsan","age":18}\';\nwhen(\n\tnode("a"),\n\twhen(\n\t\tnode("b").data(whendata),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n\n\n\n# 目前支持的表达式和关键字\n\n目前支持到2.11.1版本的所有el表达式，包括其中的关键字和高级特性。当前支持的详细内容如下表：\n\nel表达式     创建方法                    支持调用方法                                          支持关键字\n串行编排      elbus.then              then(object ... objects)                        pre\n                                                                                  finally\n                                                                                  tag\n                                                                                  id\n                                                                                  maxwaitseconds\n并行编排      elbus.when              when(object ... objects)                        any\n                                                                                  ignoreerror\n                                                                                  customthreadexecutor\n                                                                                  must\n                                                                                  tag\n                                                                                  id\n                                                                                  maxwaitseconds\n选择编排      elbus.switch            to(object... objects)                           tag\n                                  defaultopt(object object)                       id\n                                                                                  maxwaitseconds\n条件编排      elbus.ifopt             elseopt(object falseobject)                     tag\n                                  elifopt(object ifobject, object trueobject)     id\n                                                                                  maxwaitseconds\n循环编排      elbus.foropt            doopt(object object)                            parallel\n          elbus.whileopt          breakopt(object object) (iterator迭代器循环表达式不支持)   tag\n          elbus.iteratoropt                                                       id\n                                                                                  maxwaitseconds\n捕获异常表达式   elbus.catchexception    doopt(object object)                            tag\n                                                                                  id\n                                                                                  maxwaitseconds\n与表达式      elbus.and               and(object ... object)                          tag\n                                                                                  id\n                                                                                  maxwaitseconds\n或表达式      elbus.or                or(object ... object)                           tag\n                                                                                  id\n                                                                                  maxwaitseconds\n非表达式      elbus.not                                                               tag\n                                                                                  id\n                                                                                  maxwaitseconds\n单节点表达式    elbus.node                                                              tag\n                                                                                  data\n                                                                                  maxwaitseconds\n前置组件      通过then组件的pre关键字创建                                                       tag\n                                                                                  id\n                                                                                  maxwaitseconds\n后置组件      通过then组件的finally关键字创建                                                   tag\n                                                                                  id\n\n\n# el表达式参数校验\n\n组装表达式时会对表达式的参数类型进行校验。包括是否为单节点组件、是否允许为与或非表达式等。比如，while表达式while(w).do(then(a, b)); 中，w需要是返回布尔值的节点或与或非表达式。\n\n更多测试样例请在 liteflow-testcase-el/liteflow-testcase-el-builder 模块中查看。\n\n\n# 不包装的node\n\n如果用elbus.node("a")这种，最后toel()出来的是node("a")，这是经过包装过的组件，这种包装过的组件在启动时不会检查a存不存在，而在执行时当a不存在时，会调用a的降级组件。\n\n关于降级组件请参照组件降级这一章。\n\n如果不希望出来的是包装过的，可以用elbus.commonnode("a")，那最后toel()出来就是a。这种同样适用于放一个chainid。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥜构造Node",frontmatter:{title:"🥜构造Node",date:"2023-10-12T10:46:15.000Z",permalink:"/pages/5bbee3/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/020.%E6%9E%84%E9%80%A0Node.html",relativePath:"07.v2.12.X文档/090.🎲用代码动态构造规则/020.构造Node.md",key:"v-7347303e",path:"/pages/5bbee3/",headers:[{level:2,title:"什么时候构造",slug:"什么时候构造",normalizedTitle:"什么时候构造",charIndex:93},{level:2,title:"构造Node",slug:"构造node",normalizedTitle:"构造node",charIndex:145}],headersStr:"什么时候构造 构造Node",content:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造Node\n\n提示\n\n你可以像以下那样构造一个普通的Node，当然在spring/springboot环境，大多数情况你无需去构建一个Node，因为只要你的组件上标有@Component/@LiteflowComponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看定义脚本组件\n\n//构建一个普通组件\nLiteFlowNodeBuilder.createCommonNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个选择组件\nLiteFlowNodeBuilder.createSwitchNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个普通脚本组件\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本选择组件\nLiteFlowNodeBuilder.createScriptSwitchNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setFile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@LiteflowComponent或者@Component，如果项目是spring体系的话，LiteFlow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@Autowired和@Resource等等之类的spring任何注解。',normalizedContent:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造node\n\n提示\n\n你可以像以下那样构造一个普通的node，当然在spring/springboot环境，大多数情况你无需去构建一个node，因为只要你的组件上标有@component/@liteflowcomponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看定义脚本组件\n\n//构建一个普通组件\nliteflownodebuilder.createcommonnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个选择组件\nliteflownodebuilder.createswitchnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个普通脚本组件\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本选择组件\nliteflownodebuilder.createscriptswitchnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setfile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@liteflowcomponent或者@component，如果项目是spring体系的话，liteflow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@autowired和@resource等等之类的spring任何注解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍞构造Chain",frontmatter:{title:"🍞构造Chain",date:"2023-10-12T10:46:15.000Z",permalink:"/pages/cd0445/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/040.%E6%9E%84%E9%80%A0Chain.html",relativePath:"07.v2.12.X文档/090.🎲用代码动态构造规则/040.构造Chain.md",key:"v-432c3864",path:"/pages/cd0445/",headers:[{level:2,title:"构建一个Chain",slug:"构建一个chain",normalizedTitle:"构建一个chain",charIndex:2},{level:2,title:"使用动态组装EL表达式构建Chain",slug:"使用动态组装el表达式构建chain",normalizedTitle:"使用动态组装el表达式构建chain",charIndex:324},{level:2,title:"销毁一个Chain",slug:"销毁一个chain",normalizedTitle:"销毁一个chain",charIndex:681}],headersStr:"构建一个Chain 使用动态组装EL表达式构建Chain 销毁一个Chain",content:'# 构建一个Chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个EL表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 使用动态组装EL表达式构建Chain\n\n从2.11.1版本开始，您可以根据实际需求动态地构建EL表达式，而不仅仅限于使用固定的字符串。如下例所示：\n\n// 动态组装el表达式\nELWrapper el = ELBus.then("a", "b", ELBus.when("c", "d"));\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n\t// 输出el表达式\n    el.toEL()\n).build();\n\n\n请注意，上述示例仅用于演示目的，实际使用时，您需要根据具体的业务逻辑和数据结构来组装EL表达式，并将其应用于相应的Chain。\n\n如果使用动态组装的EL表达式，需要引入额外依赖。具体请参考构造EL。\n\n\n# 销毁一个Chain\n\nLiteFlow中允许你手动运行以下代码来销毁一个流程：\n\nFlowBus.removeChain("你的流程ID")\n',normalizedContent:'# 构建一个chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个el表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 使用动态组装el表达式构建chain\n\n从2.11.1版本开始，您可以根据实际需求动态地构建el表达式，而不仅仅限于使用固定的字符串。如下例所示：\n\n// 动态组装el表达式\nelwrapper el = elbus.then("a", "b", elbus.when("c", "d"));\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n\t// 输出el表达式\n    el.toel()\n).build();\n\n\n请注意，上述示例仅用于演示目的，实际使用时，您需要根据具体的业务逻辑和数据结构来组装el表达式，并将其应用于相应的chain。\n\n如果使用动态组装的el表达式，需要引入额外依赖。具体请参考构造el。\n\n\n# 销毁一个chain\n\nliteflow中允许你手动运行以下代码来销毁一个流程：\n\nflowbus.removechain("你的流程id")\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍮启动不检查规则",frontmatter:{title:"🍮启动不检查规则",date:"2024-04-08T18:23:21.000Z",permalink:"/pages/891f36/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/095.%F0%9F%8D%BC%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/030.%E5%90%AF%E5%8A%A8%E4%B8%8D%E6%A3%80%E6%9F%A5%E8%A7%84%E5%88%99.html",relativePath:"07.v2.12.X文档/095.🍼元数据管理/030.启动不检查规则.md",key:"v-d76fa88e",path:"/pages/891f36/",headersStr:null,content:"版本支持：\n\nLiteFlow默认启动的时候都需要解析规则，但是在协作开发的时候，很可能有些组件还没有，但是规则里却写上了这个组件。这就会导致启动报错。\n\n为此，框架提供了一个新的全局参数供用户配置：\n\nliteflow.parse-mode=PARSE_ONE_ON_FIRST_EXEC\n\n\n如果设置成PARSE_ONE_ON_FIRST_EXEC那就不会启动时检查规则。\n\n这个parse-mode一共有三种值：\n\n设置值                       含义\nPARSE_ALL_ON_START        启动时解析所有的规则，不配置默认就是这个值\nPARSE_ALL_ON_FIRST_EXEC   启动时不解析规则，但是第一次执行任意规则时，解析所有的\nPARSE_ONE_ON_FIRST_EXEC   启动时不解析规则，但是第一次执行相关规则时，只解析对应的规则\n\n同时以前的parse-on-start参数废弃。\n\n之前的parse-on-start=true就等同于现在的PARSE_ALL_ON_START。parse-on-start=false就等同于现在的PARSE_ALL_ON_FIRST_EXEC。\n\n官方建议，如果你希望启动时不检查规则，直接设置PARSE_ONE_ON_FIRST_EXEC就可以了。",normalizedContent:"版本支持：\n\nliteflow默认启动的时候都需要解析规则，但是在协作开发的时候，很可能有些组件还没有，但是规则里却写上了这个组件。这就会导致启动报错。\n\n为此，框架提供了一个新的全局参数供用户配置：\n\nliteflow.parse-mode=parse_one_on_first_exec\n\n\n如果设置成parse_one_on_first_exec那就不会启动时检查规则。\n\n这个parse-mode一共有三种值：\n\n设置值                       含义\nparse_all_on_start        启动时解析所有的规则，不配置默认就是这个值\nparse_all_on_first_exec   启动时不解析规则，但是第一次执行任意规则时，解析所有的\nparse_one_on_first_exec   启动时不解析规则，但是第一次执行相关规则时，只解析对应的规则\n\n同时以前的parse-on-start参数废弃。\n\n之前的parse-on-start=true就等同于现在的parse_all_on_start。parse-on-start=false就等同于现在的parse_all_on_first_exec。\n\n官方建议，如果你希望启动时不检查规则，直接设置parse_one_on_first_exec就可以了。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍖平滑热刷新",frontmatter:{title:"🍖平滑热刷新",date:"2022-07-03T11:04:48.000Z",permalink:"/pages/204d71/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/095.%F0%9F%8D%BC%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/020.%E5%B9%B3%E6%BB%91%E7%83%AD%E5%88%B7%E6%96%B0.html",relativePath:"07.v2.12.X文档/095.🍼元数据管理/020.平滑热刷新.md",key:"v-31e646a2",path:"/pages/204d71/",headers:[{level:2,title:"自动刷新的场景",slug:"自动刷新的场景",normalizedTitle:"自动刷新的场景",charIndex:147},{level:2,title:"主动调用代码全量刷新",slug:"主动调用代码全量刷新",normalizedTitle:"主动调用代码全量刷新",charIndex:469},{level:2,title:"单独刷新某一个规则",slug:"单独刷新某一个规则",normalizedTitle:"单独刷新某一个规则",charIndex:953},{level:2,title:"单独刷新某一个决策规则",slug:"单独刷新某一个决策规则",normalizedTitle:"单独刷新某一个决策规则",charIndex:1246},{level:2,title:"单独刷新某一个脚本",slug:"单独刷新某一个脚本",normalizedTitle:"单独刷新某一个脚本",charIndex:1365}],headersStr:"自动刷新的场景 主动调用代码全量刷新 单独刷新某一个规则 单独刷新某一个决策规则 单独刷新某一个脚本",content:'LiteFlow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\n\n\n# 自动刷新的场景\n\n自动刷新包括了规则以及脚本。\n\n如果你使用LiteFlow原生支持的zookeeper，etcd，nacos，apollo等插件（关于如何集成插件，请参考规则文件这一大章节），不需要你做任何事，只要规则更改之后，会自动热平滑刷新。\n\n\n如果你是基于本地磁盘规则文件的，并且开启了自动监听设置，那么更改流程后也会自动平滑刷新。关于如何开启自动监听，请参考本地规则文件监听这一章。\n\n\n如果你使用了LiteFlow原生支持的sql，redis这两个插件，并开启了轮询开关，在你更新了规则或脚本之后，也会自动平滑热刷新。但是受限于轮询间隔时间，会有一定的延时。\n\n关于这个场景，可以参考SQL数据库配置源以及轮询模式配置。\n\n\n# 主动调用代码全量刷新\n\n主动刷新包括了规则以及脚本。\n\n如果你使用了数据库作为规则文件的存储方式，或是你自己实现了自定义配置源，那么LiteFlow还提供了一种基于代码刷新的方式。\n\n\n你可以在spring容器中拿到FlowExecutor对象后，调用以下接口：\n\nflowExecutor.reloadRule();\n\n\n这个方法会按照启动时的方式去拉取你最新的所有规则以及组件配置信息，进行平滑热刷新。\n\n\n这样调用有以下2点注意事项：\n\n提示\n\n1.这样刷新是全量刷新，不过各位同学不用担心其性能，经测试，LiteFlow框架一秒可以刷新1000条规则左右，这都是一些cpu级别的操作，如果你规则没有上大几千，几w条，那么推荐这种方式。\n\n2.如果你的应用是多节点部署的，必须在每个节点上都要刷新，因为规则是存储在jvm内存里的。这就意味着，如果你把刷新规则做成一个rpc接口（诸如dubbo接口之类的），那么rpc接口只会调用到其中一个节点，也就是说，只会有一个节点的规则会刷新。\n\n正确的做法是：利用mq发一个消息，让各个节点去监听到，进行刷新。\n\n\n\n# 单独刷新某一个规则\n\n如果你的规则比较多，成千上万条，又或者你就是不想全量刷新。希望单独刷新某个改动的规则。\n\n那么LiteFlow也提供了相应的方式。\n\n你可以利用以下api来进行刷新：\n\nFlowBus.reloadChain("chain1", "THEN(a, b, c)");\n\n\n提示\n\n既然是指定刷新，那么必须你要获取到改动的EL内容，然后再利用动态代码构建重新build下就可以了，这种方式会自动替换缓存中已有的规则。这种方式不用在build之前销毁流程。\n\n如果是多服务节点部署的情况下，还是要遵循每个节点要都刷新，上面已经说明具体建议的方式。这里不再赘述。\n\n\n# 单独刷新某一个决策规则\n\n如果你使用了决策路由，那么可以通过FlowBus连带决策体一起进行刷新：\n\nFlowBus.reloadChain("chain1", "THEN(a, b, c)", "AND(r1, r2)");\n\n\n\n# 单独刷新某一个脚本\n\n如果你想要用代码方式来刷新一个指定的脚本，可以这么做：\n\nFlowBus.reloadScript(nodeId, script);\n',normalizedContent:'liteflow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\n\n\n# 自动刷新的场景\n\n自动刷新包括了规则以及脚本。\n\n如果你使用liteflow原生支持的zookeeper，etcd，nacos，apollo等插件（关于如何集成插件，请参考规则文件这一大章节），不需要你做任何事，只要规则更改之后，会自动热平滑刷新。\n\n\n如果你是基于本地磁盘规则文件的，并且开启了自动监听设置，那么更改流程后也会自动平滑刷新。关于如何开启自动监听，请参考本地规则文件监听这一章。\n\n\n如果你使用了liteflow原生支持的sql，redis这两个插件，并开启了轮询开关，在你更新了规则或脚本之后，也会自动平滑热刷新。但是受限于轮询间隔时间，会有一定的延时。\n\n关于这个场景，可以参考sql数据库配置源以及轮询模式配置。\n\n\n# 主动调用代码全量刷新\n\n主动刷新包括了规则以及脚本。\n\n如果你使用了数据库作为规则文件的存储方式，或是你自己实现了自定义配置源，那么liteflow还提供了一种基于代码刷新的方式。\n\n\n你可以在spring容器中拿到flowexecutor对象后，调用以下接口：\n\nflowexecutor.reloadrule();\n\n\n这个方法会按照启动时的方式去拉取你最新的所有规则以及组件配置信息，进行平滑热刷新。\n\n\n这样调用有以下2点注意事项：\n\n提示\n\n1.这样刷新是全量刷新，不过各位同学不用担心其性能，经测试，liteflow框架一秒可以刷新1000条规则左右，这都是一些cpu级别的操作，如果你规则没有上大几千，几w条，那么推荐这种方式。\n\n2.如果你的应用是多节点部署的，必须在每个节点上都要刷新，因为规则是存储在jvm内存里的。这就意味着，如果你把刷新规则做成一个rpc接口（诸如dubbo接口之类的），那么rpc接口只会调用到其中一个节点，也就是说，只会有一个节点的规则会刷新。\n\n正确的做法是：利用mq发一个消息，让各个节点去监听到，进行刷新。\n\n\n\n# 单独刷新某一个规则\n\n如果你的规则比较多，成千上万条，又或者你就是不想全量刷新。希望单独刷新某个改动的规则。\n\n那么liteflow也提供了相应的方式。\n\n你可以利用以下api来进行刷新：\n\nflowbus.reloadchain("chain1", "then(a, b, c)");\n\n\n提示\n\n既然是指定刷新，那么必须你要获取到改动的el内容，然后再利用动态代码构建重新build下就可以了，这种方式会自动替换缓存中已有的规则。这种方式不用在build之前销毁流程。\n\n如果是多服务节点部署的情况下，还是要遵循每个节点要都刷新，上面已经说明具体建议的方式。这里不再赘述。\n\n\n# 单独刷新某一个决策规则\n\n如果你使用了决策路由，那么可以通过flowbus连带决策体一起进行刷新：\n\nflowbus.reloadchain("chain1", "then(a, b, c)", "and(r1, r2)");\n\n\n\n# 单独刷新某一个脚本\n\n如果你想要用代码方式来刷新一个指定的脚本，可以这么做：\n\nflowbus.reloadscript(nodeid, script);\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⛰概念以及介绍",frontmatter:{title:"⛰概念以及介绍",date:"2024-04-10T21:29:22.000Z",permalink:"/pages/7cb165/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/095.%F0%9F%8D%BC%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/010.%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E4%BB%8B%E7%BB%8D.html",relativePath:"07.v2.12.X文档/095.🍼元数据管理/010.概念以及介绍.md",key:"v-0dc67eba",path:"/pages/7cb165/",headersStr:null,content:"在LiteFlow框架中，最重要的两个概念就是规则以及组件。\n\n框架提供了一个元数据管理器FlowBus用来管理这两大元素。\n\n对于所有解析后的规则都保存在FlowBus中的chainMap中，并且FlowBus也提供了若干静态方法来对规则进行管理。\n\n对于规则的管理，常用的方法都提供，比如说判断一个chain是否存在，获得一个chain,删除一个chain等。具体方法这里不再细说，看方法名就可以轻松判断出来。\n\n对于组件来说，所有注册的节点都应该在nodeMap中，如果开发者发现自己的组件并不在nodeMap中，说明并未注册成功。在没注册的情况下执行链路，就会报组件不存在这样的错误。\n\nFlowBus同样对组件也提供了一些基本的方法供操作。",normalizedContent:"在liteflow框架中，最重要的两个概念就是规则以及组件。\n\n框架提供了一个元数据管理器flowbus用来管理这两大元素。\n\n对于所有解析后的规则都保存在flowbus中的chainmap中，并且flowbus也提供了若干静态方法来对规则进行管理。\n\n对于规则的管理，常用的方法都提供，比如说判断一个chain是否存在，获得一个chain,删除一个chain等。具体方法这里不再细说，看方法名就可以轻松判断出来。\n\n对于组件来说，所有注册的节点都应该在nodemap中，如果开发者发现自己的组件并不在nodemap中，说明并未注册成功。在没注册的情况下执行链路，就会报组件不存在这样的错误。\n\nflowbus同样对组件也提供了一些基本的方法供操作。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🫔查看指定规则下的所有组件",frontmatter:{title:"🫔查看指定规则下的所有组件",date:"2024-04-10T22:03:03.000Z",permalink:"/pages/b0bb54/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/095.%F0%9F%8D%BC%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/040.%E6%9F%A5%E7%9C%8B%E6%8C%87%E5%AE%9A%E8%A7%84%E5%88%99%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/095.🍼元数据管理/040.查看指定规则下的所有组件.md",key:"v-3c44b12e",path:"/pages/b0bb54/",headersStr:null,content:'版本支持：\n\nLiteFlow中的FlowBus也支持查看某一个规则下的所有组件：\n\nList<Node> nodeList = FlowBus.getNodesByChainId("chain1");\n',normalizedContent:'版本支持：\n\nliteflow中的flowbus也支持查看某一个规则下的所有组件：\n\nlist<node> nodelist = flowbus.getnodesbychainid("chain1");\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🏖概念以及介绍",frontmatter:{title:"🏖概念以及介绍",date:"2024-04-13T13:14:55.000Z",permalink:"/pages/ec1ac4/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/097.%F0%9F%A7%AE%E5%86%B3%E7%AD%96%E8%B7%AF%E7%94%B1/010.%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E4%BB%8B%E7%BB%8D.html",relativePath:"07.v2.12.X文档/097.🧮决策路由/010.概念以及介绍.md",key:"v-9ef5bc66",path:"/pages/ec1ac4/",headersStr:null,content:"版本支持：\n\n在之前的介绍中，LiteFlow执行一个规则主要是依赖FlowExecutor来执行，需要指定一个规则Id。\n\n但是在有些场景中，使用者定义若干个规则，具体执行哪个规则事先并不知道。需要依靠入参去动态判断执行某一个或多个规则。\n\n在之前的介绍中，除非你定义一个主规则。通过SWITCH去判断，来执行哪个子规则。其实也不是不可以。但是本质上还是执行一个规则。只不过通过这个主规则把子规则给串起来而已。并且想要同时执行多个规则，也是需要刻意去编排的。初学者并不知道如何去比编排这样的规则场景。\n\n为此，LiteFlow推出了决策路由特性，也就是说，现在LiteFlow支持不指定规则，在所有规则中通过对决策表达式的判断来动态执行规则。符合决策表达式的规则则执行，不符合的不予以执行。\n\n这个特性能很好的解决需要动态决策的场景。",normalizedContent:"版本支持：\n\n在之前的介绍中，liteflow执行一个规则主要是依赖flowexecutor来执行，需要指定一个规则id。\n\n但是在有些场景中，使用者定义若干个规则，具体执行哪个规则事先并不知道。需要依靠入参去动态判断执行某一个或多个规则。\n\n在之前的介绍中，除非你定义一个主规则。通过switch去判断，来执行哪个子规则。其实也不是不可以。但是本质上还是执行一个规则。只不过通过这个主规则把子规则给串起来而已。并且想要同时执行多个规则，也是需要刻意去编排的。初学者并不知道如何去比编排这样的规则场景。\n\n为此，liteflow推出了决策路由特性，也就是说，现在liteflow支持不指定规则，在所有规则中通过对决策表达式的判断来动态执行规则。符合决策表达式的规则则执行，不符合的不予以执行。\n\n这个特性能很好的解决需要动态决策的场景。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐮启动时生命周期",frontmatter:{title:"🐮启动时生命周期",date:"2024-10-13T20:56:21.000Z",permalink:"/pages/ef098d/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/098.%F0%9F%98%B8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/010.%E5%90%AF%E5%8A%A8%E6%97%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"07.v2.12.X文档/098.😸生命周期/010.启动时生命周期.md",key:"v-dc09fe22",path:"/pages/ef098d/",headers:[{level:2,title:"规则构造前后",slug:"规则构造前后",normalizedTitle:"规则构造前后",charIndex:71},{level:2,title:"节点构造前后",slug:"节点构造前后",normalizedTitle:"节点构造前后",charIndex:449},{level:2,title:"脚本引擎初始化后",slug:"脚本引擎初始化后",normalizedTitle:"脚本引擎初始化后",charIndex:818}],headersStr:"规则构造前后 节点构造前后 脚本引擎初始化后",content:"版本支持：\n\nLiteFlow在启动时提供了一些生命周期接口，开发者可以根据需要去实现它们，从而做到在启动的特定时机插入自己的逻辑。\n\n\n# 规则构造前后\n\n这个生命周期发生在LiteFlow去构造Chain的时候。开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@Component\npublic class TestChainLifeCycle implements PostProcessChainBuildLifeCycle {\n    @Override\n    public void postProcessBeforeChainBuild(Chain chain) {\n        //do something\n    }\n\n    @Override\n    public void postProcessAfterChainBuild(Chain chain) {\n        //do something\n    }\n}\n\n\n\n# 节点构造前后\n\n这个生命周期发生在LiteFlow去构造Node的时候，开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@Component\npublic class TestNodeLifeCycle implements PostProcessNodeBuildLifeCycle {\n    @Override\n    public void postProcessBeforeNodeBuild(Node node) {\n        //do something\n    }\n\n    @Override\n    public void postProcessAfterNodeBuild(Node node) {\n        //do something\n    }\n}\n\n\n\n# 脚本引擎初始化后\n\n这个生命周期发生在脚本引擎初始化后（如果你有引入脚本插件的话），开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\npublic class TestScriptInitLifeCycle implements PostProcessScriptEngineInitLifeCycle {\n    @Override\n    public void postProcessAfterScriptEngineInit(Object engine) {\n        //do something\n    }\n}\n\n\n请注意，这个engine对象在各个脚本插件下是不同的。需要强转下\n\n对于Groovy / Aviator / JS(JDK) / Kotlin / Lua 这些脚本语言来说，由于都是采用JSR23的实现方式，这里的engine对象为javax.script.ScriptEngine。\n\n对于JS(GraalJs)来说，这里的engine对象为org.graalvm.polyglot.Engine。\n\n对于Python来说，这里的engine对象为org.python.util.PythonInterpreter。\n\n对于QLExpress来说，这里的engine对象为com.ql.util.express.ExpressRunner。\n\n对于Java(Janino) / Java(Liquor) 来说，由于他们都是通过静态类去执行，所以这里的engine对象没有，为null。\n\n提示\n\n同一个生命周期声明多个并不会覆盖，而是会挨个执行。",normalizedContent:"版本支持：\n\nliteflow在启动时提供了一些生命周期接口，开发者可以根据需要去实现它们，从而做到在启动的特定时机插入自己的逻辑。\n\n\n# 规则构造前后\n\n这个生命周期发生在liteflow去构造chain的时候。开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@component\npublic class testchainlifecycle implements postprocesschainbuildlifecycle {\n    @override\n    public void postprocessbeforechainbuild(chain chain) {\n        //do something\n    }\n\n    @override\n    public void postprocessafterchainbuild(chain chain) {\n        //do something\n    }\n}\n\n\n\n# 节点构造前后\n\n这个生命周期发生在liteflow去构造node的时候，开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@component\npublic class testnodelifecycle implements postprocessnodebuildlifecycle {\n    @override\n    public void postprocessbeforenodebuild(node node) {\n        //do something\n    }\n\n    @override\n    public void postprocessafternodebuild(node node) {\n        //do something\n    }\n}\n\n\n\n# 脚本引擎初始化后\n\n这个生命周期发生在脚本引擎初始化后（如果你有引入脚本插件的话），开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\npublic class testscriptinitlifecycle implements postprocessscriptengineinitlifecycle {\n    @override\n    public void postprocessafterscriptengineinit(object engine) {\n        //do something\n    }\n}\n\n\n请注意，这个engine对象在各个脚本插件下是不同的。需要强转下\n\n对于groovy / aviator / js(jdk) / kotlin / lua 这些脚本语言来说，由于都是采用jsr23的实现方式，这里的engine对象为javax.script.scriptengine。\n\n对于js(graaljs)来说，这里的engine对象为org.graalvm.polyglot.engine。\n\n对于python来说，这里的engine对象为org.python.util.pythoninterpreter。\n\n对于qlexpress来说，这里的engine对象为com.ql.util.express.expressrunner。\n\n对于java(janino) / java(liquor) 来说，由于他们都是通过静态类去执行，所以这里的engine对象没有，为null。\n\n提示\n\n同一个生命周期声明多个并不会覆盖，而是会挨个执行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐳执行时生命周期",frontmatter:{title:"🐳执行时生命周期",date:"2024-10-13T20:56:44.000Z",permalink:"/pages/f6ae9e/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/098.%F0%9F%98%B8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/020.%E6%89%A7%E8%A1%8C%E6%97%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"07.v2.12.X文档/098.😸生命周期/020.执行时生命周期.md",key:"v-184ed96b",path:"/pages/f6ae9e/",headers:[{level:2,title:"FlowExecutor执行前后",slug:"flowexecutor执行前后",normalizedTitle:"flowexecutor执行前后",charIndex:72},{level:2,title:"Chain执行前后",slug:"chain执行前后",normalizedTitle:"chain执行前后",charIndex:525}],headersStr:"FlowExecutor执行前后 Chain执行前后",content:'版本支持：\n\nLiteFlow在执行时也提供了一些生命周期接口，开发者可以根据需要去实现它们，从而做到在执行的特定时机插入自己的逻辑。\n\n\n# FlowExecutor执行前后\n\n这个生命周期发生在FlowExecutor对象执行规则的时候，每执行一次FlowExecutor就会调用一次。\n\n开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@Component\npublic class TestFlowExecuteLifeCycle implements PostProcessFlowExecuteLifeCycle {\n    @Override\n    public void postProcessBeforeFlowExecute(String chainId, Slot slot) {\n        //do something\n    }\n\n    @Override\n    public void postProcessAfterFlowExecute(String chainId, Slot slot) {\n        //do something\n    }\n}\n\n\n\n# Chain执行前后\n\n这个生命周期发生在Chain对象执行的时候，每执行一次Chain就会调用一次。\n\n开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@Component\npublic class TestChainExecuteLifeCycle implements PostProcessChainExecuteLifeCycle {\n    @Override\n    public void postProcessBeforeChainExecute(String chainId, Slot slot) {\n        //do something\n    }\n\n    @Override\n    public void postProcessAfterChainExecute(String chainId, Slot slot) {\n        //do something\n    }\n}\n\n\n这个和FlowExecutor执行生命周期还是有区别的。比如执行以下规则mainChain：\n\n<chain id="mainChain">\n    THEN(a, b, subChain);\n</chain>\n\n<chain id="subChain">\n    WHEN(c, d);\n</chain>\n\n\n那么每执行一次，FlowExecutor的生命周期只会被触发1次，而Chain的生命周期会被触发2次，分别是mainChain执行前后和subChain执行前后。\n\n提示\n\n通过Slot对象其实可以拿到上下文，错误，Step很多元信息。',normalizedContent:'版本支持：\n\nliteflow在执行时也提供了一些生命周期接口，开发者可以根据需要去实现它们，从而做到在执行的特定时机插入自己的逻辑。\n\n\n# flowexecutor执行前后\n\n这个生命周期发生在flowexecutor对象执行规则的时候，每执行一次flowexecutor就会调用一次。\n\n开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@component\npublic class testflowexecutelifecycle implements postprocessflowexecutelifecycle {\n    @override\n    public void postprocessbeforeflowexecute(string chainid, slot slot) {\n        //do something\n    }\n\n    @override\n    public void postprocessafterflowexecute(string chainid, slot slot) {\n        //do something\n    }\n}\n\n\n\n# chain执行前后\n\n这个生命周期发生在chain对象执行的时候，每执行一次chain就会调用一次。\n\n开发者只要实现如下接口，并注册到spring/solon的上下文中，就可以声明了。\n\n@component\npublic class testchainexecutelifecycle implements postprocesschainexecutelifecycle {\n    @override\n    public void postprocessbeforechainexecute(string chainid, slot slot) {\n        //do something\n    }\n\n    @override\n    public void postprocessafterchainexecute(string chainid, slot slot) {\n        //do something\n    }\n}\n\n\n这个和flowexecutor执行生命周期还是有区别的。比如执行以下规则mainchain：\n\n<chain id="mainchain">\n    then(a, b, subchain);\n</chain>\n\n<chain id="subchain">\n    when(c, d);\n</chain>\n\n\n那么每执行一次，flowexecutor的生命周期只会被触发1次，而chain的生命周期会被触发2次，分别是mainchain执行前后和subchain执行前后。\n\n提示\n\n通过slot对象其实可以拿到上下文，错误，step很多元信息。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍒前置和后置组件",frontmatter:{title:"🍒前置和后置组件",date:"2022-07-02T22:51:41.000Z",permalink:"/pages/9f93be/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/030.%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E7%BB%84%E4%BB%B6.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/030.前置和后置组件.md",key:"v-710f7ada",path:"/pages/9f93be/",headers:[{level:2,title:"前置组件",slug:"前置组件",normalizedTitle:"前置组件",charIndex:11},{level:2,title:"后置节点",slug:"后置节点",normalizedTitle:"后置节点",charIndex:259},{level:2,title:"顺序问题",slug:"顺序问题",normalizedTitle:"顺序问题",charIndex:446},{level:2,title:"层级和范围",slug:"层级和范围",normalizedTitle:"层级和范围",charIndex:732}],headersStr:"前置组件 后置节点 顺序问题 层级和范围",content:'LiteFlow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用PRE关键字(必须大写)来表示:\n\n<chain name="chain1">\n    THEN(\n        PRE(p1, p2), \n        a, b, c, \n        WHEN(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受Exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用FINALLY关键字(必须大写)表示：\n\n<chain name="chain1">\n    THEN(\n        a, b, c, \n        FINALLY(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，PRE和FINALLY可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    THEN(\n        PRE(a), c, d, FINALLY(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    THEN(\n        FINALLY(f1, f2), c, PRE(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nLiteFlow 2.9.5中能支持PRE和FINALLY写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\nPRE和FINALLY只能写在THEN表达式中，如果你写在WHEN表达式中或者其他诸如SWITCH,IF的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = THEN(PRE(p1, p2), THEN(a, b, c), FINALLY(f1, f2));\n    THEN(PRE(p1, p2), c1, FINALLY(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',normalizedContent:'liteflow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用pre关键字(必须大写)来表示:\n\n<chain name="chain1">\n    then(\n        pre(p1, p2), \n        a, b, c, \n        when(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用finally关键字(必须大写)表示：\n\n<chain name="chain1">\n    then(\n        a, b, c, \n        finally(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，pre和finally可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    then(\n        pre(a), c, d, finally(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    then(\n        finally(f1, f2), c, pre(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nliteflow 2.9.5中能支持pre和finally写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\npre和finally只能写在then表达式中，如果你写在when表达式中或者其他诸如switch,if的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = then(pre(p1, p2), then(a, b, c), finally(f1, f2));\n    then(pre(p1, p2), c1, finally(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍽决策路由用法",frontmatter:{title:"🍽决策路由用法",date:"2024-04-13T13:29:12.000Z",permalink:"/pages/b7ed78/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/097.%F0%9F%A7%AE%E5%86%B3%E7%AD%96%E8%B7%AF%E7%94%B1/020.%E5%86%B3%E7%AD%96%E8%B7%AF%E7%94%B1%E7%94%A8%E6%B3%95.html",relativePath:"07.v2.12.X文档/097.🧮决策路由/020.决策路由用法.md",key:"v-16f910af",path:"/pages/b7ed78/",headers:[{level:2,title:"路由规则体",slug:"路由规则体",normalizedTitle:"路由规则体",charIndex:10},{level:2,title:"执行方法",slug:"执行方法",normalizedTitle:"执行方法",charIndex:399},{level:2,title:"执行指定namespace的决策路由",slug:"执行指定namespace的决策路由",normalizedTitle:"执行指定namespace的决策路由",charIndex:920},{level:2,title:"决策路由对数据库的支持",slug:"决策路由对数据库的支持",normalizedTitle:"决策路由对数据库的支持",charIndex:1815},{level:2,title:"要注意的点",slug:"要注意的点",normalizedTitle:"要注意的点",charIndex:1899}],headersStr:"路由规则体 执行方法 执行指定namespace的决策路由 决策路由对数据库的支持 要注意的点",content:'版本支持：\n\n\n# 路由规则体\n\n在定义规则的时候，新增了一个<route>和<body>标签：\n\n<chain name="chain1">\n    <route>\n        AND(r1, r2, r3)\n    </route>\n    <body>\n        THEN(a, b, c);\n    </body>\n</chain>\n\n<chain name="chain2">\n    <route>\n        AND(OR(r4, r5), NOT(r3))\n    </route>\n    <body>\n        SWITCH(x).TO(d, e, f);\n    </body>\n</chain>\n\n\n其中<route>标签里的就是决策EL，决策EL里只能用与或非表达式，所配置的组件只能是布尔组件。\n\n而<body>里的内容就是原先的规则EL。\n\n\n# 执行方法\n\nLiteFlow在FlowExecutor里新提供了一系列的方法用于执行带决策路由的规则，最基本的方法：\n\nList<LiteflowResponse> responseList = flowExecutor.executeRouteChain(requestData, YourContext.class);\n\n\n可以发现，executeRouteChain其实和execute2Resp差不多，当然execute2Resp支持的，executeRouteChain都支持。比如用初始化好的上下文传入，多上下文的传入。其实和原先都一样，只是不用再传chainId了而已。\n\n当传入之后，LiteFlow会去并行的判断决策路由，符合决策的规则也会被并行的进行执行。\n\n如果你的规则里并没有带有决策路由的规则，又或者是匹配决策路由后，没有可用的规则，LiteFlow会报错进行提示。\n\n值得一说的是方法的返回，返回是一个List<LiteflowResponse>，List里面的就是每一个匹配到的规则执行之后生成的response，在LiteflowResponse中新增了chainId字段，用来识别是哪条规则的结果。\n\n\n# 执行指定namespace的决策路由\n\n决策路由默认会去执行所有带<route>标签的chain。\n\n但是如果你的决策路由很多，想要判断某一组决策路由，这时候可以可以在chain层面加入namespace参数，比如：\n\n<chain name="chain1" namespace="n1">\n    <route>\n        AND(r1, r2, r3)\n    </route>\n    <body>\n        THEN(a, b, c);\n    </body>\n</chain>\n\n<chain name="chain2" namespace="n1">\n    <route>\n        AND(OR(r4, r5), NOT(r3))\n    </route>\n    <body>\n        SWITCH(x).TO(d, e, f);\n    </body>\n</chain>\n\n<chain name="chain3" namespace="n2">\n    <route>\n        r4\n    </route>\n    <body>\n        WHEN(a,b);\n    </body>\n</chain>\n\n<chain name="chain4" namespace="n2">\n    <route>\n        AND(r4,r5)\n    </route>\n    <body>\n        IF(x, m, n);\n    </body>\n</chain>\n\n\nFlowExecutor也提供了一个带指定namespace的执行方法：\n\nList<LiteflowResponse> responseList = flowExecutor.executeRouteChain("n1", requestData, YourContext.class);\n\n\n以上例子只会在n1这个namespace中去进行判断，会依次判断chain1和chain2满不满足决策条件，然后选择满足决策的规则进行执行。\n\n\n# 决策路由对数据库的支持\n\n目前决策路由特性仅对xml文件形式以及数据库方式进行了支持。其他存储均不支持这一特性。\n\n数据库方式的配置请参考SQL数据库配置源。\n\n\n# 要注意的点\n\n1.决策路由体里的节点不能是除了布尔组件之外的任何类型的组件。\n\n2.决策路由体里的表达式不能是除了与或非表达式之外任何其他的主表达式。\n\n3.匹配到的每一个规则的上下文实例都是单独的，并且运行时是并行执行的。互不相干。\n\n4.启动不检查规则特性对决策路由EL是不起作用的，决策体中的EL是启动时一定会检查的，但是决策体中的EL是可以加node关键字的。\n\n5.决策路由体中的EL是可以加tag，data等副表达式的。\n\n6.在JSON和YAML等格式中，也是可以加决策体的，多了一个route的key值，但是没有body，因为在json和yaml中，原先的规则体的key是value，还是会保留的。',normalizedContent:'版本支持：\n\n\n# 路由规则体\n\n在定义规则的时候，新增了一个<route>和<body>标签：\n\n<chain name="chain1">\n    <route>\n        and(r1, r2, r3)\n    </route>\n    <body>\n        then(a, b, c);\n    </body>\n</chain>\n\n<chain name="chain2">\n    <route>\n        and(or(r4, r5), not(r3))\n    </route>\n    <body>\n        switch(x).to(d, e, f);\n    </body>\n</chain>\n\n\n其中<route>标签里的就是决策el，决策el里只能用与或非表达式，所配置的组件只能是布尔组件。\n\n而<body>里的内容就是原先的规则el。\n\n\n# 执行方法\n\nliteflow在flowexecutor里新提供了一系列的方法用于执行带决策路由的规则，最基本的方法：\n\nlist<liteflowresponse> responselist = flowexecutor.executeroutechain(requestdata, yourcontext.class);\n\n\n可以发现，executeroutechain其实和execute2resp差不多，当然execute2resp支持的，executeroutechain都支持。比如用初始化好的上下文传入，多上下文的传入。其实和原先都一样，只是不用再传chainid了而已。\n\n当传入之后，liteflow会去并行的判断决策路由，符合决策的规则也会被并行的进行执行。\n\n如果你的规则里并没有带有决策路由的规则，又或者是匹配决策路由后，没有可用的规则，liteflow会报错进行提示。\n\n值得一说的是方法的返回，返回是一个list<liteflowresponse>，list里面的就是每一个匹配到的规则执行之后生成的response，在liteflowresponse中新增了chainid字段，用来识别是哪条规则的结果。\n\n\n# 执行指定namespace的决策路由\n\n决策路由默认会去执行所有带<route>标签的chain。\n\n但是如果你的决策路由很多，想要判断某一组决策路由，这时候可以可以在chain层面加入namespace参数，比如：\n\n<chain name="chain1" namespace="n1">\n    <route>\n        and(r1, r2, r3)\n    </route>\n    <body>\n        then(a, b, c);\n    </body>\n</chain>\n\n<chain name="chain2" namespace="n1">\n    <route>\n        and(or(r4, r5), not(r3))\n    </route>\n    <body>\n        switch(x).to(d, e, f);\n    </body>\n</chain>\n\n<chain name="chain3" namespace="n2">\n    <route>\n        r4\n    </route>\n    <body>\n        when(a,b);\n    </body>\n</chain>\n\n<chain name="chain4" namespace="n2">\n    <route>\n        and(r4,r5)\n    </route>\n    <body>\n        if(x, m, n);\n    </body>\n</chain>\n\n\nflowexecutor也提供了一个带指定namespace的执行方法：\n\nlist<liteflowresponse> responselist = flowexecutor.executeroutechain("n1", requestdata, yourcontext.class);\n\n\n以上例子只会在n1这个namespace中去进行判断，会依次判断chain1和chain2满不满足决策条件，然后选择满足决策的规则进行执行。\n\n\n# 决策路由对数据库的支持\n\n目前决策路由特性仅对xml文件形式以及数据库方式进行了支持。其他存储均不支持这一特性。\n\n数据库方式的配置请参考sql数据库配置源。\n\n\n# 要注意的点\n\n1.决策路由体里的节点不能是除了布尔组件之外的任何类型的组件。\n\n2.决策路由体里的表达式不能是除了与或非表达式之外任何其他的主表达式。\n\n3.匹配到的每一个规则的上下文实例都是单独的，并且运行时是并行执行的。互不相干。\n\n4.启动不检查规则特性对决策路由el是不起作用的，决策体中的el是启动时一定会检查的，但是决策体中的el是可以加node关键字的。\n\n5.决策路由体中的el是可以加tag，data等副表达式的。\n\n6.在json和yaml等格式中，也是可以加决策体的，多了一个route的key值，但是没有body，因为在json和yaml中，原先的规则体的key是value，还是会保留的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍌本地规则文件监听",frontmatter:{title:"🍌本地规则文件监听",date:"2023-03-16T22:59:58.000Z",permalink:"/pages/f8aa79/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/031.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/031.本地规则文件监听.md",key:"v-11ba52b0",path:"/pages/f8aa79/",headers:[{level:2,title:"单个文件的监听",slug:"单个文件的监听",normalizedTitle:"单个文件的监听",charIndex:2},{level:2,title:"模糊文件路径的监听",slug:"模糊文件路径的监听",normalizedTitle:"模糊文件路径的监听",charIndex:325}],headersStr:"单个文件的监听 模糊文件路径的监听",content:"# 单个文件的监听\n\n首先，在LiteFlow的配置liteflow.rule-source中，不光可以配置项目内的规则文件，其实还可以配置本地磁盘上的文件的，比如：\n\nliteflow.rule-source=/Users/bryan31/liteflow/test/flow.xml\n\n\n但是当你本地规则文件改变了的情况下，你的项目是无法获知的，你只能通过手动刷新规则去实现热刷新(详细请阅读平滑热刷新)。\n\n现在LiteFlow支持对本地文件的监听配置了。\n\n你只需要配置liteflow.enable-monitor-file=true，即可开启自动对文件的监听特性。文件改动，你的项目无需做任何事，立马自动刷新整个规则。非常方便。\n\n\n# 模糊文件路径的监听\n\n如果你用模糊匹配的方式也是可以的，同样也会对匹配的所有文件进行监听。\n\nliteflow.rule-source=/Users/bryan31/liteflow/**/flow*.xml\n\n\n还是只需要配置liteflow.enable-monitor-file=true即可。",normalizedContent:"# 单个文件的监听\n\n首先，在liteflow的配置liteflow.rule-source中，不光可以配置项目内的规则文件，其实还可以配置本地磁盘上的文件的，比如：\n\nliteflow.rule-source=/users/bryan31/liteflow/test/flow.xml\n\n\n但是当你本地规则文件改变了的情况下，你的项目是无法获知的，你只能通过手动刷新规则去实现热刷新(详细请阅读平滑热刷新)。\n\n现在liteflow支持对本地文件的监听配置了。\n\n你只需要配置liteflow.enable-monitor-file=true，即可开启自动对文件的监听特性。文件改动，你的项目无需做任何事，立马自动刷新整个规则。非常方便。\n\n\n# 模糊文件路径的监听\n\n如果你用模糊匹配的方式也是可以的，同样也会对匹配的所有文件进行监听。\n\nliteflow.rule-source=/users/bryan31/liteflow/**/flow*.xml\n\n\n还是只需要配置liteflow.enable-monitor-file=true即可。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥠组件降级",frontmatter:{title:"🥠组件降级",date:"2023-10-08T20:06:00.000Z",permalink:"/pages/79289a/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/035.%E7%BB%84%E4%BB%B6%E9%99%8D%E7%BA%A7.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/035.组件降级.md",key:"v-400c1155",path:"/pages/79289a/",headers:[{level:2,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:247},{level:2,title:"多组件类型的支持",slug:"多组件类型的支持",normalizedTitle:"多组件类型的支持",charIndex:716}],headersStr:"使用方法 多组件类型的支持",content:'版本支持：\n\nLiteFlow支持组件降级功能。\n\n如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了 A，B，C 三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    THEN(A, B, C, D);\n</chain>\n\n\n由于 D 组件不存在，所以启动时会报错。\n\n组件降级的意义是，当你写了一个不存在的组件时，在运行时会自动路由到你指定的降级组件上，由这个降级组件来代替你不存在的组件执行，这样就不会报错了。\n\n\n# 使用方法\n\n首先需要在配置文件开启组件降级功能，默认是关闭的：\n\nliteflow.fallback-cmp-enable=true\n\n\n若想将一个组件声明为降级组件，只需要在组件上添加 @FallbackCmp 注解。 比如可以通过以下方式定义一个普通组件的降级组件 E。\n\n@LiteflowComponent("E")\n@FallbackCmp\npublic class ECmp extends NodeComponent {\n    @Override\n    public void process() {\n        System.out.println("ECmp executed!");\n    }\n}\n\n\n若想使用降级组件，规则文件需要这么写：\n\n<chain name="chain1">\n    THEN(A, B, C, node("D"));\n</chain>\n\n\n当组件 D 不存在时，会降级为组件 E 运行。\n\n提示\n\n如果不加 node 关键字，是不会自动路由到降级组件的，所以一定得加。\n\n\n# 多组件类型的支持\n\nLiteFlow 不仅支持普通组件的降级，对其他组件类型也提供了支持。以下示例分别声明了一个布尔降级组件和次数循环降级组件。\n\n@LiteflowComponent("if1")\n@FallbackCmp\npublic class IfCmp1 extends NodeBooleanComponent {\n    @Override\n    public boolean processBoolean() throws Exception {\n        return false;\n    }\n}\n\n\n@LiteflowComponent("for1")\n@FallbackCmp\npublic class ForCmp extends NodeForComponent {\n    @Override\n    public int processFor() throws Exception {\n        return 3;\n    }\n} \n\n\n对于如下的 EL 表达式：\n\n<chain name="chain2">\n    IF(node("x1"), FOR("x2").DO(node("x3")));\n</chain>\n\n\n当组件 x1、x2 或 x3 不存在时，会分别路由到条件降级组件、次数循环降级组件以及普通降级组件。其他类型的组件也同理。\n\n与或非表达式也可以使用降级组件，如下的 EL 表达式：\n\n<chain name="chain3">\n    IF(AND(node("x"), a), b);\n</chain>\n\n\n当组件 x 不存在时会路由到条件降级组件。\n\n提示\n\n目前每种类型的组件只允许定义一个降级组件。',normalizedContent:'版本支持：\n\nliteflow支持组件降级功能。\n\n如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了 a，b，c 三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n由于 d 组件不存在，所以启动时会报错。\n\n组件降级的意义是，当你写了一个不存在的组件时，在运行时会自动路由到你指定的降级组件上，由这个降级组件来代替你不存在的组件执行，这样就不会报错了。\n\n\n# 使用方法\n\n首先需要在配置文件开启组件降级功能，默认是关闭的：\n\nliteflow.fallback-cmp-enable=true\n\n\n若想将一个组件声明为降级组件，只需要在组件上添加 @fallbackcmp 注解。 比如可以通过以下方式定义一个普通组件的降级组件 e。\n\n@liteflowcomponent("e")\n@fallbackcmp\npublic class ecmp extends nodecomponent {\n    @override\n    public void process() {\n        system.out.println("ecmp executed!");\n    }\n}\n\n\n若想使用降级组件，规则文件需要这么写：\n\n<chain name="chain1">\n    then(a, b, c, node("d"));\n</chain>\n\n\n当组件 d 不存在时，会降级为组件 e 运行。\n\n提示\n\n如果不加 node 关键字，是不会自动路由到降级组件的，所以一定得加。\n\n\n# 多组件类型的支持\n\nliteflow 不仅支持普通组件的降级，对其他组件类型也提供了支持。以下示例分别声明了一个布尔降级组件和次数循环降级组件。\n\n@liteflowcomponent("if1")\n@fallbackcmp\npublic class ifcmp1 extends nodebooleancomponent {\n    @override\n    public boolean processboolean() throws exception {\n        return false;\n    }\n}\n\n\n@liteflowcomponent("for1")\n@fallbackcmp\npublic class forcmp extends nodeforcomponent {\n    @override\n    public int processfor() throws exception {\n        return 3;\n    }\n} \n\n\n对于如下的 el 表达式：\n\n<chain name="chain2">\n    if(node("x1"), for("x2").do(node("x3")));\n</chain>\n\n\n当组件 x1、x2 或 x3 不存在时，会分别路由到条件降级组件、次数循环降级组件以及普通降级组件。其他类型的组件也同理。\n\n与或非表达式也可以使用降级组件，如下的 el 表达式：\n\n<chain name="chain3">\n    if(and(node("x"), a), b);\n</chain>\n\n\n当组件 x 不存在时会路由到条件降级组件。\n\n提示\n\n目前每种类型的组件只允许定义一个降级组件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍉组件参数",frontmatter:{title:"🍉组件参数",date:"2022-10-06T22:55:30.000Z",permalink:"/pages/6e4d15/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/036.%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/036.组件参数.md",key:"v-dc55cd76",path:"/pages/6e4d15/",headersStr:null,content:'版本支持：\n\nLiteFlow支持了组件参数特性，你可以在EL语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是JSON格式：\n\n<flow>\n    <chain name="chain1">\n        cmpData = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        THEN(a, b.data(cmpData), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpData = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        WHEN(c, b.data(cmpData));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过this.getCmpData方法也能拿到相应的参数。\n\n如果上述对象是一个Json的数组，在组件中也可以通过getCmpDataList方法来获取。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tUser user = this.getCmpData(User.class);\n\t\t...\n\t}\n\n}\n',normalizedContent:'版本支持：\n\nliteflow支持了组件参数特性，你可以在el语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是json格式：\n\n<flow>\n    <chain name="chain1">\n        cmpdata = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        then(a, b.data(cmpdata), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpdata = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        when(c, b.data(cmpdata));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过this.getcmpdata方法也能拿到相应的参数。\n\n如果上述对象是一个json的数组，在组件中也可以通过getcmpdatalist方法来获取。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tuser user = this.getcmpdata(user.class);\n\t\t...\n\t}\n\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍍组件标签",frontmatter:{title:"🍍组件标签",date:"2022-07-03T00:32:36.000Z",permalink:"/pages/0f788f/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/050.%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/050.组件标签.md",key:"v-34701b02",path:"/pages/0f788f/",headersStr:null,content:'tag有2种用途：\n\n * 用于SWITCH语法的选择\n * 赋值\n\n关于SWITCH的选择tag标签内容请参考选择编排这一章。\n\n这章主要阐述tag标签的赋值功能。\n\n你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    THEN(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.getTag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        String tag = this.getTag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    THEN(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',normalizedContent:'tag有2种用途：\n\n * 用于switch语法的选择\n * 赋值\n\n关于switch的选择tag标签内容请参考选择编排这一章。\n\n这章主要阐述tag标签的赋值功能。\n\n你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    then(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.gettag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n    @override\n    public void process() {\n        string tag = this.gettag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    then(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍑组件别名",frontmatter:{title:"🍑组件别名",date:"2022-07-03T00:31:22.000Z",permalink:"/pages/92ef89/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/040.%E7%BB%84%E4%BB%B6%E5%88%AB%E5%90%8D.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/040.组件别名.md",key:"v-3877a216",path:"/pages/92ef89/",headers:[{level:2,title:"Springboot & Spring 扫描方式",slug:"springboot-spring-扫描方式",normalizedTitle:"springboot &amp; spring 扫描方式",charIndex:null},{level:2,title:"规则文件方式定义组件",slug:"规则文件方式定义组件",normalizedTitle:"规则文件方式定义组件",charIndex:381},{level:2,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:49}],headersStr:"Springboot & Spring 扫描方式 规则文件方式定义组件 打印",content:'LiteFlow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# Springboot & Spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@Component换成@LiteflowComponent，并做如下定义：\n\n@LiteflowComponent(id = "a", name = "组件A")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件A" class="com.yomahub.liteflow.test.config.cmp.ACmp"/>\n<node id="b" name="组件B" class="com.yomahub.liteflow.test.config.cmp.BCmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',normalizedContent:'liteflow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# springboot & spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@component换成@liteflowcomponent，并做如下定义：\n\n@liteflowcomponent(id = "a", name = "组件a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件a" class="com.yomahub.liteflow.test.config.cmp.acmp"/>\n<node id="b" name="组件b" class="com.yomahub.liteflow.test.config.cmp.bcmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥝组件事件回调",frontmatter:{title:"🥝组件事件回调",date:"2022-07-03T00:41:09.000Z",permalink:"/pages/3ee755/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/060.%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/060.组件事件回调.md",key:"v-030d45c2",path:"/pages/3ee755/",headers:[{level:2,title:"成功事件",slug:"成功事件",normalizedTitle:"成功事件",charIndex:31},{level:2,title:"失败事件",slug:"失败事件",normalizedTitle:"失败事件",charIndex:36},{level:3,title:"注意点1",slug:"注意点1",normalizedTitle:"注意点1",charIndex:842},{level:3,title:"注意点2",slug:"注意点2",normalizedTitle:"注意点2",charIndex:912},{level:3,title:"注意点3",slug:"注意点3",normalizedTitle:"注意点3",charIndex:1393}],headersStr:"成功事件 失败事件 注意点1 注意点2 注意点3",content:'LiteFlow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onSuccess方法，那么组件成功后会回调这个方法。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void onSuccess() throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onError方法，那么组件发生异常后会回调这个方法。\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError(Exception e) throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonError方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onError方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onError方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError(Exception e) throws Exception {\n\t\tthrow new IllegalAccessException("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是NullPointerException而不是IllegalAccessException，但是IllegalAccessException这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonError方法执行后，afterProcess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterProcess方法都会被执行。',normalizedContent:'liteflow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onsuccess方法，那么组件成功后会回调这个方法。\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void onsuccess() throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onerror方法，那么组件发生异常后会回调这个方法。\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror(exception e) throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonerror方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onerror方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onerror方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror(exception e) throws exception {\n\t\tthrow new illegalaccessexception("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是nullpointerexception而不是illegalaccessexception，但是illegalaccessexception这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonerror方法执行后，afterprocess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterprocess方法都会被执行。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐋组件回滚",frontmatter:{title:"🐋组件回滚",date:"2023-08-20T22:35:07.000Z",permalink:"/pages/y172l7/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/061.%E7%BB%84%E4%BB%B6%E5%9B%9E%E6%BB%9A.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/061.组件回滚.md",key:"v-74a1d3c8",path:"/pages/y172l7/",headers:[{level:3,title:"回滚触发前提",slug:"回滚触发前提",normalizedTitle:"回滚触发前提",charIndex:196},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:461},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:782}],headersStr:"回滚触发前提 基本用法 注意事项",content:'版本支持：\n\nLiteFlow支持了组件回滚功能。\n\nLiteFlow中组件对异常的处理方法有以下三种：组件中的continueOnError方法、EL表达式中设置ignoreError以及RL表达式中设置CATCH关键字。如果这三种条件均不满足并且出现了异常，那么流程就会执行失败，触发回滚的逻辑。使用rollback功能的前提需要对LiteFlow的异常处理机制具有一定的了解。\n\n\n# 回滚触发前提\n\n在实际应用场景中，组件的执行流程会因为各种突发情况导致失败，所以组件需要一种能在流程执行失败之后对流程进行处理的机制，因此LiteFlow新增了回滚功能。\n\n在流程执行失败，并且存在异常时会自动触发回滚机制，回滚机制会按照已经执行的组件的逆序执行其中的rollback方法。\n\n对于逆序执行，请参照下面的示例：\n\n图示\n\n如果上述全部组件均重写了rollback方法，在d中出现异常， 并且执行顺序为并且执行顺序为：a -> b -> c -> d的话，回滚顺序将会是：d -> c -> b -> a。\n\n\n# 基本用法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void rollback() throws Exception {\n        DefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n与组件中的其他方法类似，在回滚事件中，随时可以获取自己定义的上下文。\n\n\n# 注意事项\n\n 1. 回滚的过程中只能回滚流程已经执行完的组件，并不可以回滚整个流程的全部组件。\n 2. 回滚流程与正常执行流程相似，用户也可以在LiteflowResponse对象中通过相应的方法获取回滚流程的步骤信息以及执行时间等信息。\n\nLiteflowResponse response = flowExecutor.execute2Resp("yourChainName", "arg");\nString rollbackStepStr = response.getRollbackStepStr(); // 以字符串形式获取回滚流程\nString rollbackStepStrWithTime = response.getRollbackStepStrWithTime();\nQueue<CmpStep> rollbackStepQueue = response.getRollbackStepQueue(); // 获取回滚的组件的步骤信息\nMap<String, List<CmpStep>> rollbackSteps = response.getRollbackSteps(); // 获取回滚组件的步骤信息\n\n\n 3. 回滚过程中如果出现异常，不会打断回滚流程。',normalizedContent:'版本支持：\n\nliteflow支持了组件回滚功能。\n\nliteflow中组件对异常的处理方法有以下三种：组件中的continueonerror方法、el表达式中设置ignoreerror以及rl表达式中设置catch关键字。如果这三种条件均不满足并且出现了异常，那么流程就会执行失败，触发回滚的逻辑。使用rollback功能的前提需要对liteflow的异常处理机制具有一定的了解。\n\n\n# 回滚触发前提\n\n在实际应用场景中，组件的执行流程会因为各种突发情况导致失败，所以组件需要一种能在流程执行失败之后对流程进行处理的机制，因此liteflow新增了回滚功能。\n\n在流程执行失败，并且存在异常时会自动触发回滚机制，回滚机制会按照已经执行的组件的逆序执行其中的rollback方法。\n\n对于逆序执行，请参照下面的示例：\n\n图示\n\n如果上述全部组件均重写了rollback方法，在d中出现异常， 并且执行顺序为并且执行顺序为：a -> b -> c -> d的话，回滚顺序将会是：d -> c -> b -> a。\n\n\n# 基本用法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void rollback() throws exception {\n        defaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n与组件中的其他方法类似，在回滚事件中，随时可以获取自己定义的上下文。\n\n\n# 注意事项\n\n 1. 回滚的过程中只能回滚流程已经执行完的组件，并不可以回滚整个流程的全部组件。\n 2. 回滚流程与正常执行流程相似，用户也可以在liteflowresponse对象中通过相应的方法获取回滚流程的步骤信息以及执行时间等信息。\n\nliteflowresponse response = flowexecutor.execute2resp("yourchainname", "arg");\nstring rollbackstepstr = response.getrollbackstepstr(); // 以字符串形式获取回滚流程\nstring rollbackstepstrwithtime = response.getrollbackstepstrwithtime();\nqueue<cmpstep> rollbackstepqueue = response.getrollbackstepqueue(); // 获取回滚的组件的步骤信息\nmap<string, list<cmpstep>> rollbacksteps = response.getrollbacksteps(); // 获取回滚组件的步骤信息\n\n\n 3. 回滚过程中如果出现异常，不会打断回滚流程。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥑隐式子流程",frontmatter:{title:"🥑隐式子流程",date:"2022-07-03T00:42:38.000Z",permalink:"/pages/80e873/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/070.%E9%9A%90%E5%BC%8F%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/070.隐式子流程.md",key:"v-c5f9b436",path:"/pages/80e873/",headersStr:null,content:'LiteFlow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@Component("h")\npublic class HComponent extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("Hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeInAsync方法。\n\n同样，隐式子流程也支持返回LiteFlowResponse对象，需要调用invoke2Resp方法，关于返回对象为LiteFlowResponse的说明，请参照LiteflowResponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getSubChainReqData()去拿。\n\n如果你是用invokeInAsync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getSubChainReqDataInAsync()去拿。\n\n用this.getRequestData()是拿不到的！',normalizedContent:'liteflow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@component("h")\npublic class hcomponent extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeinasync方法。\n\n同样，隐式子流程也支持返回liteflowresponse对象，需要调用invoke2resp方法，关于返回对象为liteflowresponse的说明，请参照liteflowresponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getsubchainreqdata()去拿。\n\n如果你是用invokeinasync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getsubchainreqdatainasync()去拿。\n\n用this.getrequestdata()是拿不到的！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍕私有投递",frontmatter:{title:"🍕私有投递",date:"2022-07-03T10:59:19.000Z",permalink:"/pages/fbb938/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/080.%E7%A7%81%E6%9C%89%E6%8A%95%E9%80%92.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/080.私有投递.md",key:"v-3ae6687c",path:"/pages/fbb938/",headers:[{level:2,title:"什么叫私有投递",slug:"什么叫私有投递",normalizedTitle:"什么叫私有投递",charIndex:21},{level:2,title:"解决方式",slug:"解决方式",normalizedTitle:"解决方式",charIndex:657}],headersStr:"什么叫私有投递 解决方式",content:'LiteFlow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个LiteFLow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        THEN(\n            a,\n            WHEN(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，LiteFlow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\tcontext.setData("testSet", new HashSet<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendPrivateDeliveryData("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendPrivateDeliveryData方法，指定了b组件\n\n然后我们再来看b组件：\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("BCmp executed!");\n\t\tInteger value = this.getPrivateDeliveryData();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getPrivateDeliveryData()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',normalizedContent:'liteflow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个liteflow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        then(\n            a,\n            when(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，liteflow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\tcontext.setdata("testset", new hashset<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendprivatedeliverydata("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendprivatedeliverydata方法，指定了b组件\n\n然后我们再来看b组件：\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("bcmp executed!");\n\t\tinteger value = this.getprivatedeliverydata();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getprivatedeliverydata()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🫐EL中的重试",frontmatter:{title:"🫐EL中的重试",date:"2024-04-10T17:11:31.000Z",permalink:"/pages/b44233/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/091.EL%E4%B8%AD%E7%9A%84%E9%87%8D%E8%AF%95.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/091.EL中的重试.md",key:"v-3c9903ea",path:"/pages/b44233/",headers:[{level:2,title:"单个组件的重试",slug:"单个组件的重试",normalizedTitle:"单个组件的重试",charIndex:54},{level:2,title:"表达式的重试",slug:"表达式的重试",normalizedTitle:"表达式的重试",charIndex:247},{level:2,title:"整个Chain的重试",slug:"整个chain的重试",normalizedTitle:"整个chain的重试",charIndex:513},{level:2,title:"带指定异常的重试",slug:"带指定异常的重试",normalizedTitle:"带指定异常的重试",charIndex:652},{level:2,title:"特例",slug:"特例",normalizedTitle:"特例",charIndex:1050}],headersStr:"单个组件的重试 表达式的重试 整个Chain的重试 带指定异常的重试 特例",content:'版本支持：\n\nLiteFlow支持在EL层面进行重试次数的设置。用来满足一些失败了需要重试的场景。\n\n\n# 单个组件的重试\n\n<chain id="chain1">\n    THEN(a, b.retry(3));\n</chain>\n\n\n以上EL表示，当b这个组件出现任何异常时，会最多自动重试3次。\n\n3次重试中如果有任意一次成功，则正常往下走。如果3次均不成功，则会中断规则，最后LiteflowResponse结果中的isSuccess为false，并且结果中带有具体异常信息。\n\n\n# 表达式的重试\n\nretry关键字不仅可以作用于组件上，还可以作用于任意表达式上，或者作用于表达式变量上，以下仅为举例：\n\n<chain id="chain1">\n    THEN(a, b).retry(3);\n</chain>\n\n<chain id="chain2">\n    FOR(c).DO(a).retry(3);\n</chain>\n\n<chain id="chain3">\n    exp = SWITCH(x).to(m,n,p);\n    IF(f, exp.retry(3), b);\n</chain>\n\n\n\n# 整个Chain的重试\n\nretry还可以作用于整个chain上：\n\n<chain id="sub">\n    THEN(a, b);\n</chain>\n\n<chain id="main">\n    WHEN(x, y, sub.retry(3));\n</chain>\n\n\n\n# 带指定异常的重试\n\nretry关键字默认情况下，只要碰到任何异常，都会进行重试。\n\n这里我们也可以指定异常，来完成特定情况下的重试：\n\n<chain id="chain1">\n    THEN(a, b).retry(3, "java.lang.NullPointerException");\n</chain>\n\n\n上述表达式表示只有抛出NullPointerException异常的情况下才进行重试，其余的异常都不进行重试，直接中断失败。\n\n异常还可以指定多个：\n\n<chain id="chain1">\n    THEN(a, b).retry(3, "java.lang.NullPointerException", "java.lang.ArrayIndexOutOfBoundsException");\n</chain>\n\n\n那么只有抛出上述两个异常中的任意一个都会进行重试。\n\n\n# 特例\n\n如果你的组件中设置了this.setIsEnd(true)，虽然会抛出一个ChainEndException，但是这个错无论如何不会导致重试。\n\n因为这个Exception就是要强制中止。不应该被重试。',normalizedContent:'版本支持：\n\nliteflow支持在el层面进行重试次数的设置。用来满足一些失败了需要重试的场景。\n\n\n# 单个组件的重试\n\n<chain id="chain1">\n    then(a, b.retry(3));\n</chain>\n\n\n以上el表示，当b这个组件出现任何异常时，会最多自动重试3次。\n\n3次重试中如果有任意一次成功，则正常往下走。如果3次均不成功，则会中断规则，最后liteflowresponse结果中的issuccess为false，并且结果中带有具体异常信息。\n\n\n# 表达式的重试\n\nretry关键字不仅可以作用于组件上，还可以作用于任意表达式上，或者作用于表达式变量上，以下仅为举例：\n\n<chain id="chain1">\n    then(a, b).retry(3);\n</chain>\n\n<chain id="chain2">\n    for(c).do(a).retry(3);\n</chain>\n\n<chain id="chain3">\n    exp = switch(x).to(m,n,p);\n    if(f, exp.retry(3), b);\n</chain>\n\n\n\n# 整个chain的重试\n\nretry还可以作用于整个chain上：\n\n<chain id="sub">\n    then(a, b);\n</chain>\n\n<chain id="main">\n    when(x, y, sub.retry(3));\n</chain>\n\n\n\n# 带指定异常的重试\n\nretry关键字默认情况下，只要碰到任何异常，都会进行重试。\n\n这里我们也可以指定异常，来完成特定情况下的重试：\n\n<chain id="chain1">\n    then(a, b).retry(3, "java.lang.nullpointerexception");\n</chain>\n\n\n上述表达式表示只有抛出nullpointerexception异常的情况下才进行重试，其余的异常都不进行重试，直接中断失败。\n\n异常还可以指定多个：\n\n<chain id="chain1">\n    then(a, b).retry(3, "java.lang.nullpointerexception", "java.lang.arrayindexoutofboundsexception");\n</chain>\n\n\n那么只有抛出上述两个异常中的任意一个都会进行重试。\n\n\n# 特例\n\n如果你的组件中设置了this.setisend(true)，虽然会抛出一个chainendexception，但是这个错无论如何不会导致重试。\n\n因为这个exception就是要强制中止。不应该被重试。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣组件重试",frontmatter:{title:"🍣组件重试",date:"2022-07-03T11:03:09.000Z",permalink:"/pages/7e9da1/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/090.%E7%BB%84%E4%BB%B6%E9%87%8D%E8%AF%95.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/090.组件重试.md",key:"v-795f1111",path:"/pages/7e9da1/",headers:[{level:2,title:"全局重试",slug:"全局重试",normalizedTitle:"全局重试",charIndex:112},{level:2,title:"单个组件重试",slug:"单个组件重试",normalizedTitle:"单个组件重试",charIndex:117},{level:2,title:"全局重试和单个组件重试都定义的情况下",slug:"全局重试和单个组件重试都定义的情况下",normalizedTitle:"全局重试和单个组件重试都定义的情况下",charIndex:1061}],headersStr:"全局重试 单个组件重试 全局重试和单个组件重试都定义的情况下",content:'注意\n\n此功能已经被EL中的重试替代。后者的功能可以替代组件重试的所有特性。\n\n但是此特性依然可以正常工作，之所以没删除这一章节是为了兼容，但是在以后的版本中，这个章节会被删除。\n\nLiteFLow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了isContinueOnError，设为true的话，那流程会继续。\n\n异步流程的话，如果WHEN上配置了ignoreError为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreError的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nLiteFlow还提供了基于单个组件，指定Exception的重试特性，LiteFlow从2.6.0开始提供了@LiteflowRetry标注\n\n你可以在指定的组件上进行标注：\n\n@LiteflowComponent("c")\n@LiteflowRetry(5)\npublic class CCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@LiteflowComponent("e")\n@LiteflowRetry(retry = 5, forExceptions = {NullPointerException.class,IllegalArgumentException.class})\npublic class ECmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是NullPointerException或者IllegalArgumentException（或者是这两个Exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',normalizedContent:'注意\n\n此功能已经被el中的重试替代。后者的功能可以替代组件重试的所有特性。\n\n但是此特性依然可以正常工作，之所以没删除这一章节是为了兼容，但是在以后的版本中，这个章节会被删除。\n\nliteflow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了iscontinueonerror，设为true的话，那流程会继续。\n\n异步流程的话，如果when上配置了ignoreerror为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreerror的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nliteflow还提供了基于单个组件，指定exception的重试特性，liteflow从2.6.0开始提供了@liteflowretry标注\n\n你可以在指定的组件上进行标注：\n\n@liteflowcomponent("c")\n@liteflowretry(5)\npublic class ccmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@liteflowcomponent("e")\n@liteflowretry(retry = 5, forexceptions = {nullpointerexception.class,illegalargumentexception.class})\npublic class ecmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是nullpointerexception或者illegalargumentexception（或者是这两个exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥦异步循环模式",frontmatter:{title:"🥦异步循环模式",date:"2023-08-14T23:36:23.000Z",permalink:"/pages/35cc4a/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/095.%E5%BC%82%E6%AD%A5%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/095.异步循环模式.md",key:"v-5f43eff4",path:"/pages/35cc4a/",headers:[{level:2,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:54},{level:2,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:279},{level:2,title:"使用说明",slug:"使用说明",normalizedTitle:"使用说明",charIndex:693}],headersStr:"使用方法 例子 使用说明",content:'版本支持：\n\nLiteFlow支持循环表达式的异步模式，使得各个循环表达式的循环子项可以异步执行。\n\n\n# 使用方法\n\n对于LiteFlow中的次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式，可以使用parallel子关键字（默认为false）来配置循环子项的执行方式，使其成为异步模式的循环表达式（所谓异步模式，就是各个循环子项之间并行执行）。\n\n如果parallel子关键字设置为true，表示各循环子项之间并行执行，否则各循环子项之间串行执行。\n\n----------------------------------------\n\n\n# 例子\n\n对于次数循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain1">\n   FOR(2).parallel(true).DO(THEN(a,b,c));\n</chain>\n\n\n如果使用上述配置，每个循环子项本身的执行方式保持不变，只是各个循环子项之间的执行方式变为并行执行，也就是chain1会并行执行两次THEN(a,b,c)。\n\n对于条件循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain6">\n   WHILE(x).parallel(true).DO(THEN(a,b,c));\n</chain>\n\n\n对于迭代循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain7">\n   ITERATOR(x).parallel(true).DO(THEN(a,b,c));\n</chain>\n\n\n\n# 使用说明\n\n 1. parallel子关键字只能用于次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式。\n 2. 对于异步模式的条件循环表达式，会不断创建并行执行循环子项，直到条件不满足为止。\n 3. 异步模式依然支持BREAK，当退出循环组件返回为true时，会停止向线程池提交新的任务，但是已经提交的任务会继续执行。循环组件会在所有已提交任务执行完毕后退出。\n 4. 默认情况下，异步模式的下各循环子项会在liteFlow提供的默认异步循环线程池中执行，并且可以通过如下两个参数来控制默认线程池的workers数目和队列长度\n    \n    \x3c!--配置默认线程池的worker数目--\x3e\n    liteflow.parallel-max-workers=16\n    \x3c!--配置默认线程池的队列长度--\x3e\n    liteflow.parallel-queue-limit=512\n    \n    \n    当然，也可以通过自定义线程池来执行异步模式的循环子项，只需要在配置文件中进行如下配置即可，不过此时上述两个参数将不再生效。\n    \n    \x3c!--用户可以直接指定自定义的线程池全类名的方式指定异步循环线程池--\x3e\n    liteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n    ',normalizedContent:'版本支持：\n\nliteflow支持循环表达式的异步模式，使得各个循环表达式的循环子项可以异步执行。\n\n\n# 使用方法\n\n对于liteflow中的次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式，可以使用parallel子关键字（默认为false）来配置循环子项的执行方式，使其成为异步模式的循环表达式（所谓异步模式，就是各个循环子项之间并行执行）。\n\n如果parallel子关键字设置为true，表示各循环子项之间并行执行，否则各循环子项之间串行执行。\n\n----------------------------------------\n\n\n# 例子\n\n对于次数循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain1">\n   for(2).parallel(true).do(then(a,b,c));\n</chain>\n\n\n如果使用上述配置，每个循环子项本身的执行方式保持不变，只是各个循环子项之间的执行方式变为并行执行，也就是chain1会并行执行两次then(a,b,c)。\n\n对于条件循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain6">\n   while(x).parallel(true).do(then(a,b,c));\n</chain>\n\n\n对于迭代循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain7">\n   iterator(x).parallel(true).do(then(a,b,c));\n</chain>\n\n\n\n# 使用说明\n\n 1. parallel子关键字只能用于次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式。\n 2. 对于异步模式的条件循环表达式，会不断创建并行执行循环子项，直到条件不满足为止。\n 3. 异步模式依然支持break，当退出循环组件返回为true时，会停止向线程池提交新的任务，但是已经提交的任务会继续执行。循环组件会在所有已提交任务执行完毕后退出。\n 4. 默认情况下，异步模式的下各循环子项会在liteflow提供的默认异步循环线程池中执行，并且可以通过如下两个参数来控制默认线程池的workers数目和队列长度\n    \n    \x3c!--配置默认线程池的worker数目--\x3e\n    liteflow.parallel-max-workers=16\n    \x3c!--配置默认线程池的队列长度--\x3e\n    liteflow.parallel-queue-limit=512\n    \n    \n    当然，也可以通过自定义线程池来执行异步模式的循环子项，只需要在配置文件中进行如下配置即可，不过此时上述两个参数将不再生效。\n    \n    \x3c!--用户可以直接指定自定义的线程池全类名的方式指定异步循环线程池--\x3e\n    liteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n    ',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⏱️超时控制",frontmatter:{title:"⏱️超时控制",date:"2023-08-06T22:36:38.000Z",permalink:"/pages/fd5984/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/097.%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/097.超时控制.md",key:"v-551685fc",path:"/pages/fd5984/",headers:[{level:2,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:37},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:1238}],headersStr:"使用方法 注意事项",content:'版本支持：\n\nLiteFlow支持使用关键字对流程进行超时控制。\n\n\n# 使用方法\n\n使用 maxWaitSeconds,maxWaitMilliseconds 关键字可对任意的组件、表达式、流程进行超时控制。\n\nmaxWaitSeconds后面传的是秒数，maxWaitMilliseconds后面传的是毫秒数。使用方式都一样。\n\nmaxWaitSeconds和maxWaitMilliseconds 传入一个 int 类型的整数表示最大等待秒数/毫秒数，使用如下方法设置最大超时等待时间。\n\n<flow>\n    \x3c!-- 串行编排超时控制 --\x3e\n    <chain name="then">\n        THEN(a,b).maxWaitSeconds(5);\n    </chain>\n\n    \x3c!-- 并行编排超时控制 --\x3e\n    <chain name="when">\n        WHEN(a,b).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 循环编排超时控制 --\x3e\n    <chain name="for">\n        FOR(2).DO(a).maxWaitSeconds(3);\n    </chain>\n    <chain name="while">\n        WHILE(w).DO(a).maxWaitSeconds(3);\n    </chain>\n    <chain name="iterator">\n        ITERATOR(x).DO(a).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 选择编排超时控制 --\x3e\n    <chain name="switch">\n        SWITCH(s).TO(a, b).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 条件编排超时控制 --\x3e\n    <chain name="if">\n        IF(f, b, c).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 组件超时控制 --\x3e\n    <chain name="component">\n        WHEN(\n            a.maxWaitSeconds(2),\n            b.maxWaitSeconds(3)\n        );\n    </chain>\n\n    \x3c!-- 流程超时控制 --\x3e\n    <chain name="testChain">\n        THEN(b)\n    </chain>\n    <chain name="chain">\n        testChain.maxWaitSeconds(3);\n    </chain>\n</flow>\n\n\n\n# 注意事项\n\n 1. FINALLY 不可使用此关键字。\n    \n    这种写法是不被允许的：\n    \n    THEN(a, FINALLY(b).maxWaitSeconds(3))\n    \n\n 2. 如果 THEN 使用了超时控制，其内部直属的 FINALLY 不受超时控制。\n    \n    例如：\n    \n    THEN(a, FINALLY(b)).maxWaitSeconds(5);\n    \n    \n    组件 b 是不受超时控制的。但如果 FINALLY 不是设置超时的 THEN 所直属的，则仍受超时控制。\n    \n    例如：\n    \n    THEN(a, THEN(b, FINALLY(c))).maxWaitSeconds(5);\n    \n    \n    c 仍会受超时控制。\n\n 3. 除WHEN外，若某个关键字后续存在多个连续操作，则maxWaitSeconds必须放在完整语义的最后。。\n    \n    例如：\n    \n    FOR(5).DO(THEN(e, f)).maxWaitSeconds(5);\n    \n    \n    不可写为：\n    \n    FOR(5).maxWaitSeconds(5).DO(THEN(e, f));\n    \n    \n    必须得到完整语义后再设置超时。但使用 WHEN 关键字时可以不放在最后，以下写法是被允许的：\n    \n    WHEN(a, b).maxWaitSeconds(5).any(true);\n    ',normalizedContent:'版本支持：\n\nliteflow支持使用关键字对流程进行超时控制。\n\n\n# 使用方法\n\n使用 maxwaitseconds,maxwaitmilliseconds 关键字可对任意的组件、表达式、流程进行超时控制。\n\nmaxwaitseconds后面传的是秒数，maxwaitmilliseconds后面传的是毫秒数。使用方式都一样。\n\nmaxwaitseconds和maxwaitmilliseconds 传入一个 int 类型的整数表示最大等待秒数/毫秒数，使用如下方法设置最大超时等待时间。\n\n<flow>\n    \x3c!-- 串行编排超时控制 --\x3e\n    <chain name="then">\n        then(a,b).maxwaitseconds(5);\n    </chain>\n\n    \x3c!-- 并行编排超时控制 --\x3e\n    <chain name="when">\n        when(a,b).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 循环编排超时控制 --\x3e\n    <chain name="for">\n        for(2).do(a).maxwaitseconds(3);\n    </chain>\n    <chain name="while">\n        while(w).do(a).maxwaitseconds(3);\n    </chain>\n    <chain name="iterator">\n        iterator(x).do(a).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 选择编排超时控制 --\x3e\n    <chain name="switch">\n        switch(s).to(a, b).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 条件编排超时控制 --\x3e\n    <chain name="if">\n        if(f, b, c).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 组件超时控制 --\x3e\n    <chain name="component">\n        when(\n            a.maxwaitseconds(2),\n            b.maxwaitseconds(3)\n        );\n    </chain>\n\n    \x3c!-- 流程超时控制 --\x3e\n    <chain name="testchain">\n        then(b)\n    </chain>\n    <chain name="chain">\n        testchain.maxwaitseconds(3);\n    </chain>\n</flow>\n\n\n\n# 注意事项\n\n 1. finally 不可使用此关键字。\n    \n    这种写法是不被允许的：\n    \n    then(a, finally(b).maxwaitseconds(3))\n    \n\n 2. 如果 then 使用了超时控制，其内部直属的 finally 不受超时控制。\n    \n    例如：\n    \n    then(a, finally(b)).maxwaitseconds(5);\n    \n    \n    组件 b 是不受超时控制的。但如果 finally 不是设置超时的 then 所直属的，则仍受超时控制。\n    \n    例如：\n    \n    then(a, then(b, finally(c))).maxwaitseconds(5);\n    \n    \n    c 仍会受超时控制。\n\n 3. 除when外，若某个关键字后续存在多个连续操作，则maxwaitseconds必须放在完整语义的最后。。\n    \n    例如：\n    \n    for(5).do(then(e, f)).maxwaitseconds(5);\n    \n    \n    不可写为：\n    \n    for(5).maxwaitseconds(5).do(then(e, f));\n    \n    \n    必须得到完整语义后再设置超时。但使用 when 关键字时可以不放在最后，以下写法是被允许的：\n    \n    when(a, b).maxwaitseconds(5).any(true);\n    ',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍡步骤信息",frontmatter:{title:"🍡步骤信息",date:"2022-07-03T11:09:40.000Z",permalink:"/pages/e5ed0d/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/120.%E6%AD%A5%E9%AA%A4%E4%BF%A1%E6%81%AF.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/120.步骤信息.md",key:"v-d6b6ac36",path:"/pages/e5ed0d/",headersStr:null,content:'LiteFlow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过LiteflowResponse对象来获取的：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "初始参数", CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得Map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的Map中这个组件id的value是最终的那个步骤信息。\n\n而获得Queue<CmpStep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在CmpStep这个对象里，你可以通过以下方法获得你要的数据：\n\n * isSuccess：此组件是否执行成功\n * getNodeId：获得组件Id\n * getNodeName：获得组件名称\n * getTag：获得组件标签值\n * getTimeSpent：获得组件的耗时，单位为毫秒\n * getStartTime：获取组件开始执行的时间，为Date对象(从v2.11.4开始支持)\n * getEndTime：获取组件结束执行的时间，为Date对象(从v2.11.4开始支持)\n * getException：获取此组件抛出的异常，如果isSuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getCause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',normalizedContent:'liteflow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过liteflowresponse对象来获取的：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "初始参数", customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的map中这个组件id的value是最终的那个步骤信息。\n\n而获得queue<cmpstep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在cmpstep这个对象里，你可以通过以下方法获得你要的数据：\n\n * issuccess：此组件是否执行成功\n * getnodeid：获得组件id\n * getnodename：获得组件名称\n * gettag：获得组件标签值\n * gettimespent：获得组件的耗时，单位为毫秒\n * getstarttime：获取组件开始执行的时间，为date对象(从v2.11.4开始支持)\n * getendtime：获取组件结束执行的时间，为date对象(从v2.11.4开始支持)\n * getexception：获取此组件抛出的异常，如果issuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getcause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥯链路继承",frontmatter:{title:"🥯链路继承",date:"2023-10-10T15:26:41.000Z",permalink:"/pages/524c43/",titleTag:"🧪 Beta"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/105.%E9%93%BE%E8%B7%AF%E7%BB%A7%E6%89%BF.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/105.链路继承.md",key:"v-dad72f28",path:"/pages/524c43/",headers:[{level:2,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:99},{level:2,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:339},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:1180}],headersStr:"使用方法 例子 注意事项",content:'版本支持：\n\nLiteFlow从以上版本起，支持chain之间的继承关系，使得chain之间可以进行继承和扩展。\n\n❗注意: 本特性为Beta实验性功能，不保证后续小版本升级能够向下兼容。\n\n\n# 使用方法\n\n可以在某个chain中使用extends属性来指明该chain继承自哪个chain。在被继承的chain中，需要预留出一个或多个占位符，以便于子chain可以对其进行扩展；而在子chain中，需要对被继承的父chain中的所有占位符进行实现。\n\n子chain中的实现可以是组件，可以是表达式，可以是其他chain的id。但是需要注意的是，最终实现的chain必须是一个合法的EL规则，否则会解析失败。子chain的实现中同样可以包含占位符，从而实现多级继承。\n\n\n# 例子\n\n下面是一个基本的例子:\n\n<chain id="base">\n    THEN(a, b, {{0}}, {{1}});\n</chain>\n\n<chain id="implA" extends="base">\n    {{0}}=IF(c, d, e);\n    {{1}}=SWITCH(f).to(j,k);\n</chain>\n\n\n通过上述定义，实现了一个继承自base的implA,最终实现的implA流程如下\n\n<chain id="implA">\n    THEN(a, b, IF(c, d, e), SWITCH(f).to(j,k));\n</chain>\n\n\n下面是一个多级继承的例子:\n\n    <chain id="base">\n        THEN(a, b, {{0}}, {{1}});\n    </chain>\n\n    <chain id="base2" extends="base">\n        {{0}}=THEN(a,b,{{3}});\n        {{1}}=SWITCH(f).to({{4}},k);\n    </chain>\n\n    <chain id="implB" extends="base2">\n        {{3}}=THEN(a,b);\n        {{4}}=j;\n    </chain>\n\n\n在上面的定义中,implB继承自base2,base2又继承自base,最终实现的implB流程如下：\n\n    <chain id="implB" extends="base2">\n        THEN(\n            a, b,\n            THEN(a, b,\n                THEN(a,b)\n            ),\n            SWITCH(f).to(j,k) \n        );\n    </chain>\n\n\n\n# 注意事项\n\n * 一定是要{{..}}双花括弧的形式提供占位符，用双花括弧是为了避免和用户自己的占位符产生冲突\n * 在继承chain和被继承chain中需要使用形如{{x}}的占位符，其中x可以是以下两种形式之一：\n   * 纯数字构成\n   * 由字母、下划线以及数字构成，但是数字不能作为开头 也就是说，形如{{1}}、{{a}}、{{a1}}、{{a_1}}都是合法的占位符，而{{1a}}、{{1_a}}都是非法的占位符。\n * 请保证被继承chain中至少有一个占位符，且在被继承chain中定义的所有占位符，都必须要在子chain中进行实现，否则会抛出异常。\n * {{a}}=THEN(x,y,z)这种形式得写成一行，如果写成多行，则会报错。\n * 如果一个chain中包含未被实现的占位符，那么执行该chain会抛出异常。例如，尝试执行上文所述的base,base2都会抛出异常，因为它们分别包含未被实现的占位符{{0}},{{1}}和{{3}},{{4}}。\n * 如果在子chain中定义了除占位符实现以外的其他表达式，那么该表达式将被忽略。举个例子,如果implA这样实现：\n   \n   <chain id="implA" extends="base">\n       {{0}}=IF(c, d, e);\n       {{1}}=SWITCH(f).to(j,k);\n       THEN(a,b);\n   </chain>\n   \n   \n   那么其中的THEN(a,b);将会被忽略。',normalizedContent:'版本支持：\n\nliteflow从以上版本起，支持chain之间的继承关系，使得chain之间可以进行继承和扩展。\n\n❗注意: 本特性为beta实验性功能，不保证后续小版本升级能够向下兼容。\n\n\n# 使用方法\n\n可以在某个chain中使用extends属性来指明该chain继承自哪个chain。在被继承的chain中，需要预留出一个或多个占位符，以便于子chain可以对其进行扩展；而在子chain中，需要对被继承的父chain中的所有占位符进行实现。\n\n子chain中的实现可以是组件，可以是表达式，可以是其他chain的id。但是需要注意的是，最终实现的chain必须是一个合法的el规则，否则会解析失败。子chain的实现中同样可以包含占位符，从而实现多级继承。\n\n\n# 例子\n\n下面是一个基本的例子:\n\n<chain id="base">\n    then(a, b, {{0}}, {{1}});\n</chain>\n\n<chain id="impla" extends="base">\n    {{0}}=if(c, d, e);\n    {{1}}=switch(f).to(j,k);\n</chain>\n\n\n通过上述定义，实现了一个继承自base的impla,最终实现的impla流程如下\n\n<chain id="impla">\n    then(a, b, if(c, d, e), switch(f).to(j,k));\n</chain>\n\n\n下面是一个多级继承的例子:\n\n    <chain id="base">\n        then(a, b, {{0}}, {{1}});\n    </chain>\n\n    <chain id="base2" extends="base">\n        {{0}}=then(a,b,{{3}});\n        {{1}}=switch(f).to({{4}},k);\n    </chain>\n\n    <chain id="implb" extends="base2">\n        {{3}}=then(a,b);\n        {{4}}=j;\n    </chain>\n\n\n在上面的定义中,implb继承自base2,base2又继承自base,最终实现的implb流程如下：\n\n    <chain id="implb" extends="base2">\n        then(\n            a, b,\n            then(a, b,\n                then(a,b)\n            ),\n            switch(f).to(j,k) \n        );\n    </chain>\n\n\n\n# 注意事项\n\n * 一定是要{{..}}双花括弧的形式提供占位符，用双花括弧是为了避免和用户自己的占位符产生冲突\n * 在继承chain和被继承chain中需要使用形如{{x}}的占位符，其中x可以是以下两种形式之一：\n   * 纯数字构成\n   * 由字母、下划线以及数字构成，但是数字不能作为开头 也就是说，形如{{1}}、{{a}}、{{a1}}、{{a_1}}都是合法的占位符，而{{1a}}、{{1_a}}都是非法的占位符。\n * 请保证被继承chain中至少有一个占位符，且在被继承chain中定义的所有占位符，都必须要在子chain中进行实现，否则会抛出异常。\n * {{a}}=then(x,y,z)这种形式得写成一行，如果写成多行，则会报错。\n * 如果一个chain中包含未被实现的占位符，那么执行该chain会抛出异常。例如，尝试执行上文所述的base,base2都会抛出异常，因为它们分别包含未被实现的占位符{{0}},{{1}}和{{3}},{{4}}。\n * 如果在子chain中定义了除占位符实现以外的其他表达式，那么该表达式将被忽略。举个例子,如果impla这样实现：\n   \n   <chain id="impla" extends="base">\n       {{0}}=if(c, d, e);\n       {{1}}=switch(f).to(j,k);\n       then(a,b);\n   </chain>\n   \n   \n   那么其中的then(a,b);将会被忽略。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍪组件切面",frontmatter:{title:"🍪组件切面",date:"2022-07-03T11:07:26.000Z",permalink:"/pages/2373f5/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/110.%E7%BB%84%E4%BB%B6%E5%88%87%E9%9D%A2.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/110.组件切面.md",key:"v-4445c84e",path:"/pages/2373f5/",headers:[{level:2,title:"全局切面",slug:"全局切面",normalizedTitle:"全局切面",charIndex:34},{level:2,title:"Aspect的切面",slug:"aspect的切面",normalizedTitle:"aspect的切面",charIndex:672}],headersStr:"全局切面 Aspect的切面",content:'LiteFlow支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@Component\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //before business\n    }\n\n    @Override\n    public void afterProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //after business\n    }\n\n    @Override\n    public void onSuccess(NodeComponent cmp) {\n        //do sth\n    }\n\n    @Override\n    public void onError(NodeComponent cmp, Exception e) {\n        //do sth\n    }\n}\n\n\n\n# Aspect的切面\n\nLiteFlow同时也支持了Spring Aspect的切面，你可以用@Aspect标注对任意包，任意规则内的组件进行切面\n\n@Aspect\npublic class CustomAspect {\n\n    @Pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @Around("cut()")\n    public Object around(ProceedingJoinPoint jp) throws Throwable {\n        //do before business\n        Object returnObj = jp.proceed();\n        //do after business\n        return returnObj;\n    }\n}\n',normalizedContent:'liteflow支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@component\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //before business\n    }\n\n    @override\n    public void afterprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //after business\n    }\n\n    @override\n    public void onsuccess(nodecomponent cmp) {\n        //do sth\n    }\n\n    @override\n    public void onerror(nodecomponent cmp, exception e) {\n        //do sth\n    }\n}\n\n\n\n# aspect的切面\n\nliteflow同时也支持了spring aspect的切面，你可以用@aspect标注对任意包，任意规则内的组件进行切面\n\n@aspect\npublic class customaspect {\n\n    @pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @around("cut()")\n    public object around(proceedingjoinpoint jp) throws throwable {\n        //do before business\n        object returnobj = jp.proceed();\n        //do after business\n        return returnobj;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧊异常",frontmatter:{title:"🧊异常",date:"2022-07-26T23:38:00.000Z",permalink:"/pages/dc9bfe/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/125.%E5%BC%82%E5%B8%B8.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/125.异常.md",key:"v-aa97e0f4",path:"/pages/dc9bfe/",headersStr:null,content:'通常在LiteFlow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreError关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进LiteflowResponse对象中。\n\n你可以在LiteflowResponse对象中通过以下方法来获取异常\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n如果你的业务中有获取异常Code的需求，则你自定义的异常需要实现LiteFlow提供的LiteFlowException接口：\n\npublic class YourException extends LiteFlowException {\n\tpublic YourException(String code, String message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了LiteFlowException接口的异常，你则可以在LiteflowResponse中获得message和code信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n  String code = response.getCode();\n  String message = response.getMessage();\n}\n\n\n提示\n\n如果你的异常没实现LiteFlowException，code和message字段都为null。',normalizedContent:'通常在liteflow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreerror关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进liteflowresponse对象中。\n\n你可以在liteflowresponse对象中通过以下方法来获取异常\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n如果你的业务中有获取异常code的需求，则你自定义的异常需要实现liteflow提供的liteflowexception接口：\n\npublic class yourexception extends liteflowexception {\n\tpublic yourexception(string code, string message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了liteflowexception接口的异常，你则可以在liteflowresponse中获得message和code信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n  string code = response.getcode();\n  string message = response.getmessage();\n}\n\n\n提示\n\n如果你的异常没实现liteflowexception，code和message字段都为null。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧁自定义请求Id",frontmatter:{title:"🧁自定义请求Id",date:"2022-07-03T11:12:53.000Z",permalink:"/pages/47e8f5/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/140.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82Id.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/140.自定义请求Id.md",key:"v-558d1a18",path:"/pages/47e8f5/",headers:[{level:2,title:"按照自己的规则生成",slug:"按照自己的规则生成",normalizedTitle:"按照自己的规则生成",charIndex:1149},{level:2,title:"传入已有的requestId/traceId",slug:"传入已有的requestid-traceid",normalizedTitle:"传入已有的requestid/traceid",charIndex:1594},{level:2,title:"给组件中的日志也加上请求ID前缀",slug:"给组件中的日志也加上请求id前缀",normalizedTitle:"给组件中的日志也加上请求id前缀",charIndex:1896}],headersStr:"按照自己的规则生成 传入已有的requestId/traceId 给组件中的日志也加上请求ID前缀",content:'LiteFlow支持让你自定义你的请求Id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[a] execution\n2022-07-03 11:15:00.204  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[b] execution\n2022-07-03 11:15:00.218  INFO 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[c] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[d] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [           main] com.yomahub.liteflow.slot.Slot           : [067a0baa6d434de3a8ccafa4b1506562]:CHAIN_NAME[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  INFO 71275 --- [           main] com.yomahub.liteflow.slot.DataBus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是RequestId，一个请求中的requestId都是相同的，方便你进行日志查找。\n\n这个requestId的形式也是可以自定义的。你可以按照自己的规则生成，也可以传入本来已有的TraceId来和系统做集成。\n\n\n# 按照自己的规则生成\n\n你只需要要声明一个类，然后实现RequestIdGenerator接口即可：\n\npublic class CustomRequestIdGenerator implements RequestIdGenerator {\n\n    @Override\n    public String generate() {\n        return System.nanoTime();\n    }\n}\n\n\n然后在LiteFlow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestId.config.CustomRequestIdGenerator\n\n\n一般情况下，LiteFlow有自己默认的Id生成规则。所以大多数情况下你并不需要去特别自定义这个Id生成器。\n\n\n# 传入已有的requestId/traceId\n\nLiteFlow在v2.10.5版本中对于这个特性给予了支持。在FlowExecutor进行调用的时候，你可以调用如下方法来传入一个已有的requestId。\n\n如果有小伙伴用了TraceId的框架，可以把TraceId通过以下这种方式进行传入：\n\nLiteflowResponse response = flowExecutor.execute2RespWithRid("chain1", arg, "T001234", YourContext.class);\n\n\n那么，这个链路中所有的框架日志前，都会带有[T001234]这个传入的ID了。\n\n\n# 给组件中的日志也加上请求ID前缀\n\n值得一提的是，LiteFlow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求ID前缀。\n\nprivate final LFLog logger = LFLoggerManager.getLogger(FlowExecutor.class);\n\n\n其中LFLog这个类是继承自slf4j的Logger类的，所以它的使用方式和Logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求ID，那么对于定位问题来说，会很方便。推荐大家使用此特性。',normalizedContent:'liteflow支持让你自定义你的请求id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[a] execution\n2022-07-03 11:15:00.204  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[b] execution\n2022-07-03 11:15:00.218  info 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[c] execution\n2022-07-03 11:15:00.220  info 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[d] execution\n2022-07-03 11:15:00.220  info 71275 --- [           main] com.yomahub.liteflow.slot.slot           : [067a0baa6d434de3a8ccafa4b1506562]:chain_name[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  info 71275 --- [           main] com.yomahub.liteflow.slot.databus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是requestid，一个请求中的requestid都是相同的，方便你进行日志查找。\n\n这个requestid的形式也是可以自定义的。你可以按照自己的规则生成，也可以传入本来已有的traceid来和系统做集成。\n\n\n# 按照自己的规则生成\n\n你只需要要声明一个类，然后实现requestidgenerator接口即可：\n\npublic class customrequestidgenerator implements requestidgenerator {\n\n    @override\n    public string generate() {\n        return system.nanotime();\n    }\n}\n\n\n然后在liteflow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestid.config.customrequestidgenerator\n\n\n一般情况下，liteflow有自己默认的id生成规则。所以大多数情况下你并不需要去特别自定义这个id生成器。\n\n\n# 传入已有的requestid/traceid\n\nliteflow在v2.10.5版本中对于这个特性给予了支持。在flowexecutor进行调用的时候，你可以调用如下方法来传入一个已有的requestid。\n\n如果有小伙伴用了traceid的框架，可以把traceid通过以下这种方式进行传入：\n\nliteflowresponse response = flowexecutor.execute2respwithrid("chain1", arg, "t001234", yourcontext.class);\n\n\n那么，这个链路中所有的框架日志前，都会带有[t001234]这个传入的id了。\n\n\n# 给组件中的日志也加上请求id前缀\n\n值得一提的是，liteflow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求id前缀。\n\nprivate final lflog logger = lfloggermanager.getlogger(flowexecutor.class);\n\n\n其中lflog这个类是继承自slf4j的logger类的，所以它的使用方式和logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求id，那么对于定位问题来说，会很方便。推荐大家使用此特性。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧇打印信息详解",frontmatter:{title:"🧇打印信息详解",date:"2022-07-03T11:12:19.000Z",permalink:"/pages/4d614c/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/130.%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/130.打印信息详解.md",key:"v-4a7ed459",path:"/pages/4d614c/",headers:[{level:2,title:"流程执行中打印",slug:"流程执行中打印",normalizedTitle:"流程执行中打印",charIndex:2},{level:2,title:"打印步骤信息",slug:"打印步骤信息",normalizedTitle:"打印步骤信息",charIndex:558}],headersStr:"流程执行中打印 打印步骤信息",content:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[ACmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[BCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[X]start component[CCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[DCmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求ID，一个请求无论经历了多少个组件，他们的请求ID都是一致的，你可以根据这个ID在日志中进行快速定位进行排查。\n\n在后面会跟着一个[O]或者[X]，[O]代表了执行了这个组件的主要逻辑，[X]代表因为isAccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，LiteFlow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件ID<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件A]<100>==>b[组件B]<0>==>m[组件M]<256>\n\n\n这里的表达形式为：组件ID[组件别名]<耗时毫秒>",normalizedContent:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[acmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[bcmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[x]start component[ccmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[dcmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求id，一个请求无论经历了多少个组件，他们的请求id都是一致的，你可以根据这个id在日志中进行快速定位进行排查。\n\n在后面会跟着一个[o]或者[x]，[o]代表了执行了这个组件的主要逻辑，[x]代表因为isaccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，liteflow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件id<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件a]<100>==>b[组件b]<0>==>m[组件m]<256>\n\n\n这里的表达形式为：组件id[组件别名]<耗时毫秒>",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌭不同格式规则加载",frontmatter:{title:"🌭不同格式规则加载",date:"2022-07-03T11:20:47.000Z",permalink:"/pages/a7e02e/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/150.%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99%E5%8A%A0%E8%BD%BD.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/150.不同格式规则加载.md",key:"v-21bc4e62",path:"/pages/a7e02e/",headersStr:null,content:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipleType/flow.el.xml,multipleType/flow.el.json\n\n\n这种模式在正常下会解析失败，但是LiteFLow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",normalizedContent:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipletype/flow.el.xml,multipletype/flow.el.json\n\n\n这种模式在正常下会解析失败，但是liteflow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🫕快速解析模式",frontmatter:{title:"🫕快速解析模式",date:"2024-01-14T21:16:54.000Z",permalink:"/pages/5fe959/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/145.%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%BC%8F.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/145.快速解析模式.md",key:"v-14193918",path:"/pages/5fe959/",headersStr:null,content:"版本支持：\n\nLiteFlow提供了一个liteflow.fast-load的配置参数：\n\nliteflow.fast-load=false\n\n\n如果把这个设为true，则在拥有超大量的规则的时候，加载性能能提高4倍。\n\n这里超大量规则指的是5000条规则以上。如果几百个规则，还是推荐用默认模式。\n\n我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。\n\n当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。",normalizedContent:"版本支持：\n\nliteflow提供了一个liteflow.fast-load的配置参数：\n\nliteflow.fast-load=false\n\n\n如果把这个设为true，则在拥有超大量的规则的时候，加载性能能提高4倍。\n\n这里超大量规则指的是5000条规则以上。如果几百个规则，还是推荐用默认模式。\n\n我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。\n\n当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥗异步线程池自定义",frontmatter:{title:"🥗异步线程池自定义",date:"2022-07-03T11:21:39.000Z",permalink:"/pages/7280ea/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/160.%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%87%AA%E5%AE%9A%E4%B9%89.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/160.异步线程池自定义.md",key:"v-1232ba9a",path:"/pages/7280ea/",headers:[{level:2,title:"默认全局线程池",slug:"默认全局线程池",normalizedTitle:"默认全局线程池",charIndex:2},{level:2,title:"自定义全局线程池",slug:"自定义全局线程池",normalizedTitle:"自定义全局线程池",charIndex:157},{level:2,title:"WHEN级别的单独线程池",slug:"when级别的单独线程池",normalizedTitle:"when级别的单独线程池",charIndex:1134},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1940}],headersStr:"默认全局线程池 自定义全局线程池 WHEN级别的单独线程池 优先级",content:'# 默认全局线程池\n\nLiteFlow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，LiteFlow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的Builder：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n\n\n然后把你的Builder加入LiteFlow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n\t<property name="ruleSource" value="customThreadPool/flow.el.xml"/>\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n  <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n这样，LiteFlow在启动的时候就会自动通过你声明的Builder加载到自定义的线程池了。\n\n\n# WHEN级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    WHEN(a, b);\n</chain>\n\n<chain name="chain2">\n    WHEN(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class CustomThreadExecutor1 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class CustomThreadExecutor2 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    WHEN(a, b).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor1");\n</chain>\n<chain name="chain2">\n    WHEN(c, d).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和Condition都配置自定义线程池的情况下，优先使用Condition上配置的线程池。',normalizedContent:'# 默认全局线程池\n\nliteflow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，liteflow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的builder：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n\n\n然后把你的builder加入liteflow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n\t<property name="rulesource" value="customthreadpool/flow.el.xml"/>\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.test.customthreadpool.customthreadbuilder"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n  <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n这样，liteflow在启动的时候就会自动通过你声明的builder加载到自定义的线程池了。\n\n\n# when级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    when(a, b);\n</chain>\n\n<chain name="chain2">\n    when(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class customthreadexecutor1 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class customthreadexecutor2 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    when(a, b).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor1");\n</chain>\n<chain name="chain2">\n    when(c, d).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和condition都配置自定义线程池的情况下，优先使用condition上配置的线程池。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍿自定义组件执行器",frontmatter:{title:"🍿自定义组件执行器",date:"2022-07-03T11:24:54.000Z",permalink:"/pages/46bbed/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/170.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/170.自定义组件执行器.md",key:"v-523e15a6",path:"/pages/46bbed/",headers:[{level:2,title:"全局组件执行器",slug:"全局组件执行器",normalizedTitle:"全局组件执行器",charIndex:130},{level:2,title:"单个组件配置特殊的执行器",slug:"单个组件配置特殊的执行器",normalizedTitle:"单个组件配置特殊的执行器",charIndex:755},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1147},{level:2,title:"自定义执行器对于重试功能的影响",slug:"自定义执行器对于重试功能的影响",normalizedTitle:"自定义执行器对于重试功能的影响",charIndex:1196}],headersStr:"全局组件执行器 单个组件配置特殊的执行器 优先级 自定义执行器对于重试功能的影响",content:'LiteFlow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeExecutor.CustomerDefaultNodeExecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.NodeExecutor。\n\npublic class CustomerDefaultNodeExecutor extends NodeExecutor {\n    @Override\n    public void execute(NodeComponent instance) throws Exception {\n        LOG.info("使用customerDefaultNodeExecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getNodeExecutorClass 方法：\n\n@LiteflowComponent("d")\npublic class DCmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        System.out.println("DCmp executed!");\n    }\n\n    @Override\n    public Class<? extends NodeExecutor> getNodeExecutorClass() {\n        return CustomerNodeExecutorAndCustomRetry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@LiteflowRetry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',normalizedContent:'liteflow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeexecutor.customerdefaultnodeexecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.nodeexecutor。\n\npublic class customerdefaultnodeexecutor extends nodeexecutor {\n    @override\n    public void execute(nodecomponent instance) throws exception {\n        log.info("使用customerdefaultnodeexecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getnodeexecutorclass 方法：\n\n@liteflowcomponent("d")\npublic class dcmp extends nodecomponent {\n\n    @override\n    public void process() {\n        system.out.println("dcmp executed!");\n    }\n\n    @override\n    public class<? extends nodeexecutor> getnodeexecutorclass() {\n        return customernodeexecutorandcustomretry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@liteflowretry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪁测试用例",frontmatter:{title:"🪁测试用例",date:"2022-07-03T11:28:26.000Z",permalink:"/pages/81cdce/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/010.%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",relativePath:"07.v2.12.X文档/110.⛱测试用例以及示例/010.测试用例.md",key:"v-3df23b4c",path:"/pages/81cdce/",headersStr:null,content:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有1800多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解LiteFlow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于Groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于QLExpress脚本框架的测试用例\n * liteflow-testcase-el-script-javascript-springboot: 基于JavaScript脚本框架的测试用例\n * liteflow-testcase-el-script-graaljs-springboot: 基于JavaScript脚本(graaljs实现，支持jdk17)框架的测试用例\n * liteflow-testcase-el-script-python-springboot: 基于Python脚本框架的测试用例\n * liteflow-testcase-el-script-lua-springboot: 基于Lua脚本框架的测试用例\n * liteflow-testcase-el-script-aviator-springboot: 基于Aviator脚本框架的测试用例\n * liteflow-testcase-el-script-java-springboot: 基于Java脚本的测试用例\n * liteflow-testcase-el-script-kotlin-springboot: 基于kotlin脚本的测试用例\n * liteflow-testcase-el-script-multi-language-springboot: 多脚本共存的测试用例\n * liteflow-testcase-el-zk-springboot: ZK配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: SQL数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: Nacos配置源场景下的测试用例\n * liteflow-testcase-el-apollo-springboot: Apollo配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: Etcd配置源场景下的测试用例\n * liteflow-testcase-el-redis-springboot: Redis配置源场景下的测试用例\n * liteflow-testcase-el-builder: 动态组装EL的API的测试用例",normalizedContent:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有1800多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解liteflow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于qlexpress脚本框架的测试用例\n * liteflow-testcase-el-script-javascript-springboot: 基于javascript脚本框架的测试用例\n * liteflow-testcase-el-script-graaljs-springboot: 基于javascript脚本(graaljs实现，支持jdk17)框架的测试用例\n * liteflow-testcase-el-script-python-springboot: 基于python脚本框架的测试用例\n * liteflow-testcase-el-script-lua-springboot: 基于lua脚本框架的测试用例\n * liteflow-testcase-el-script-aviator-springboot: 基于aviator脚本框架的测试用例\n * liteflow-testcase-el-script-java-springboot: 基于java脚本的测试用例\n * liteflow-testcase-el-script-kotlin-springboot: 基于kotlin脚本的测试用例\n * liteflow-testcase-el-script-multi-language-springboot: 多脚本共存的测试用例\n * liteflow-testcase-el-zk-springboot: zk配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: sql数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: nacos配置源场景下的测试用例\n * liteflow-testcase-el-apollo-springboot: apollo配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: etcd配置源场景下的测试用例\n * liteflow-testcase-el-redis-springboot: redis配置源场景下的测试用例\n * liteflow-testcase-el-builder: 动态组装el的api的测试用例",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧉XML的DTD",frontmatter:{title:"🧉XML的DTD",date:"2022-10-24T12:50:29.000Z",permalink:"/pages/0066ae/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/190.XML%E7%9A%84DTD.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/190.XML的DTD.md",key:"v-08a52da4",path:"/pages/0066ae/",headersStr:null,content:'版本支持：\n\nLiteFlow对XML增加了DTD，方便在XML里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE flow PUBLIC  "liteflow" "https://liteflow.cc/liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        THEN(a,b,WHEN(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为LiteFlow xml节点非常简单，并没有很多的节点标签需要记忆。',normalizedContent:'版本支持：\n\nliteflow对xml增加了dtd，方便在xml里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype flow public  "liteflow" "https://liteflow.cc/liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        then(a,b,when(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为liteflow xml节点非常简单，并没有很多的节点标签需要记忆。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍥简单监控",frontmatter:{title:"🍥简单监控",date:"2022-07-03T11:25:52.000Z",permalink:"/pages/e59f3a/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/180.%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7.html",relativePath:"07.v2.12.X文档/100.🎨高级特性/180.简单监控.md",key:"v-36b7bba2",path:"/pages/e59f3a/",headersStr:null,content:"LiteFlow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",normalizedContent:"liteflow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪀DEMO案例",frontmatter:{title:"🪀DEMO案例",date:"2022-07-03T11:32:24.000Z",permalink:"/pages/0a8188/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/020.DEMO%E6%A1%88%E4%BE%8B.html",relativePath:"07.v2.12.X文档/110.⛱测试用例以及示例/020.DEMO案例.md",key:"v-412981e5",path:"/pages/0a8188/",headers:[{level:2,title:"DEMO案例1",slug:"demo案例1",normalizedTitle:"demo案例1",charIndex:38},{level:2,title:"DEMO案例2",slug:"demo案例2",normalizedTitle:"demo案例2",charIndex:131},{level:2,title:"外置规则存储案例",slug:"外置规则存储案例",normalizedTitle:"外置规则存储案例",charIndex:217}],headersStr:"DEMO案例1 DEMO案例2 外置规则存储案例",content:"如果你想看一个实际的案例，加深对LiteFlow的理解。可以查看：\n\n\n# DEMO案例1\n\n> DEMO案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的Java业务！\n\n\n# DEMO案例2\n\n> DEMO案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到DB里，或者zk/nacos/etcd里，此案例为一个简单的DEMO，你可以根据此案例的演示来进行接入。",normalizedContent:"如果你想看一个实际的案例，加深对liteflow的理解。可以查看：\n\n\n# demo案例1\n\n> demo案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的java业务！\n\n\n# demo案例2\n\n> demo案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到db里，或者zk/nacos/etcd里，此案例为一个简单的demo，你可以根据此案例的演示来进行接入。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪂性能表现",frontmatter:{title:"🪂性能表现",date:"2022-07-03T11:32:51.000Z",permalink:"/pages/9bf839/"},regularPath:"/07.v2.12.X%E6%96%87%E6%A1%A3/120.%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0.html",relativePath:"07.v2.12.X文档/120.性能表现.md",key:"v-9ed471fa",path:"/pages/9bf839/",headersStr:null,content:"LiteFlow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，LiteFlow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的TPS，集群达到了1W以上的TPS，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然LiteFlow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求IO，或者有bad sql，又或者有大量的rpc同步调用。那实际TPS也不会很高。但是这是业务组件的问题，而不是LiteFlow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的TPS/QPS，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nLiteFlow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库IO。\n\n基于这个Demo业务进行了压测，压测机器为mac m3 pro ，压测工具为apache jmeter 5.6，容器为springboot自带的tomcat，压测结果为：\n\n300线程并发，循环300次\n\n\n\n600并发，循环300次\n\n\n\n900并发，循环300次\n\n",normalizedContent:"liteflow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，liteflow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的tps，集群达到了1w以上的tps，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然liteflow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求io，或者有bad sql，又或者有大量的rpc同步调用。那实际tps也不会很高。但是这是业务组件的问题，而不是liteflow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的tps/qps，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nliteflow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库io。\n\n基于这个demo业务进行了压测，压测机器为mac m3 pro ，压测工具为apache jmeter 5.6，容器为springboot自带的tomcat，压测结果为：\n\n300线程并发，循环300次\n\n\n\n600并发，循环300次\n\n\n\n900并发，循环300次\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"☕️JDK支持度",frontmatter:{title:"☕️JDK支持度",date:"2023-07-21T18:07:20.000Z",permalink:"/pages/v2.11.X/7cf080/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/010.JDK%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"08.v2.11.X文档/021.🧁环境支持/010.JDK支持度.md",key:"v-3cd6d033",path:"/pages/v2.11.X/7cf080/",headersStr:null,content:"LiteFlow要求的最低的JDK版本为8，支持JDK8~JDK17所有的版本。\n\n如果你使用JDK11以上，确保LiteFlow的版本为v2.10.6及其以上版本。\n\n因为LiteFlow从v2.10.6开始，对JDK11和JDK17进行了详细的用例测试，通过了全部的900多个测试用例。而在v2.10.6以下版本，在JDK11以上是未经过测试用例保障的。\n\n特别需要注意的是，如果你使用JDK11及其以上的版本，请确保jvm参数加上以下参数\n\n--add-opens java.base/sun.reflect.annotation=ALL-UNNAMED\n",normalizedContent:"liteflow要求的最低的jdk版本为8，支持jdk8~jdk17所有的版本。\n\n如果你使用jdk11以上，确保liteflow的版本为v2.10.6及其以上版本。\n\n因为liteflow从v2.10.6开始，对jdk11和jdk17进行了详细的用例测试，通过了全部的900多个测试用例。而在v2.10.6以下版本，在jdk11以上是未经过测试用例保障的。\n\n特别需要注意的是，如果你使用jdk11及其以上的版本，请确保jvm参数加上以下参数\n\n--add-opens java.base/sun.reflect.annotation=all-unnamed\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍓项目特性",frontmatter:{title:"🍓项目特性",date:"2022-06-01T21:13:18.000Z",permalink:"/pages/v2.11.X/724bc3/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/020.%E9%A1%B9%E7%9B%AE%E7%89%B9%E6%80%A7.html",relativePath:"08.v2.11.X文档/020.项目特性.md",key:"v-da72d61a",path:"/pages/v2.11.X/724bc3/",headersStr:null,content:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看即懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，Nacos，Etcd，Zookeeper，Apollo，Redis。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * Springboot支持全面： 支持Springboot 2.X到最新的Springboot 3.X。\n * 脚本语言支持： 可以定义脚本语言节点，支持Groovy，Java，Javascript，QLExpress，Python，Lua，Aviator。未来还会支持更多的脚本语言。\n * 脚本和Java全打通： 所有脚本语言均可调用Java方法，甚至于可以引用任意的实例，在脚本中调用RPC也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",normalizedContent:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看即懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用liteflow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，nacos，etcd，zookeeper，apollo，redis。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * springboot支持全面： 支持springboot 2.x到最新的springboot 3.x。\n * 脚本语言支持： 可以定义脚本语言节点，支持groovy，java，javascript，qlexpress，python，lua，aviator。未来还会支持更多的脚本语言。\n * 脚本和java全打通： 所有脚本语言均可调用java方法，甚至于可以引用任意的实例，在脚本中调用rpc也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍤LiteFlow简介",frontmatter:{title:"🍤LiteFlow简介",date:"2022-06-16T17:51:48.000Z",permalink:"/pages/v2.11.X/5816c5/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/010.LiteFlow%E7%AE%80%E4%BB%8B.html",relativePath:"08.v2.11.X文档/010.LiteFlow简介.md",key:"v-09959741",path:"/pages/v2.11.X/5816c5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"LiteFlow框架的优势",slug:"liteflow框架的优势",normalizedTitle:"liteflow框架的优势",charIndex:390},{level:2,title:"LiteFlow的设计原则",slug:"liteflow的设计原则",normalizedTitle:"liteflow的设计原则",charIndex:934},{level:2,title:"LiteFlow不适用于哪些场景",slug:"liteflow不适用于哪些场景",normalizedTitle:"liteflow不适用于哪些场景",charIndex:1524},{level:2,title:"LiteFlow适用于哪些场景",slug:"liteflow适用于哪些场景",normalizedTitle:"liteflow适用于哪些场景",charIndex:1698}],headersStr:"前言 LiteFlow框架的优势 LiteFlow的设计原则 LiteFlow不适用于哪些场景 LiteFlow适用于哪些场景",content:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nLiteFlow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# LiteFlow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用LiteFlow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。LiteFlow拥有开源规则引擎最为简单的DSL语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nLiteFlow的脚本组件，支持众多脚本语言，完全和Java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nLiteFlow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用LiteFlow，轻而易举，你立马唾手可得！\n\n\n# LiteFlow的设计原则\n\nLiteFlow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。\n\n\n# LiteFlow不适用于哪些场景\n\nLiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。\n\n提示\n\n这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# LiteFlow适用于哪些场景\n\nLiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",normalizedContent:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统rpc调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？liteflow为解耦逻辑而生，为编排而生，在使用liteflow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nliteflow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# liteflow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用liteflow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用liteflow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。liteflow拥有开源规则引擎最为简单的dsl语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nliteflow的脚本组件，支持众多脚本语言，完全和java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nliteflow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用liteflow，轻而易举，你立马唾手可得！\n\n\n# liteflow的设计原则\n\nliteflow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到liteflow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以liteflow能做到统一解耦的组件和灵活的装配。\n\n\n# liteflow不适用于哪些场景\n\nliteflow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，a审批完应该是b审批，然后再流转到c角色。\n\n提示\n\n这里申明下，liteflow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# liteflow适用于哪些场景\n\nliteflow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用liteflow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot支持度",frontmatter:{title:"🌿Springboot支持度",date:"2023-07-21T18:20:37.000Z",permalink:"/pages/v2.11.X/891e0f/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/020.Springboot%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"08.v2.11.X文档/021.🧁环境支持/020.Springboot支持度.md",key:"v-2a18f085",path:"/pages/v2.11.X/891e0f/",headersStr:null,content:"LiteFlow要求的Springboot的最低的版本是2.0。\n\n支持的范围是Springboot 2.X ~ Springboot 3.X。\n\n当然如果你使用了最新的Springboot 3.X，相应的JDK版本也要切换为JDK17。\n\n如果你想使用Springboot快速开始学习，请参考Springboot场景安装运行。",normalizedContent:"liteflow要求的springboot的最低的版本是2.0。\n\n支持的范围是springboot 2.x ~ springboot 3.x。\n\n当然如果你使用了最新的springboot 3.x，相应的jdk版本也要切换为jdk17。\n\n如果你想使用springboot快速开始学习，请参考springboot场景安装运行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring的支持度",frontmatter:{title:"🌱Spring的支持度",date:"2023-07-21T18:24:20.000Z",permalink:"/pages/v2.11.X/2d12db/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/030.Spring%E7%9A%84%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"08.v2.11.X文档/021.🧁环境支持/030.Spring的支持度.md",key:"v-21ea24e2",path:"/pages/v2.11.X/2d12db/",headersStr:null,content:"如果你不使用Springboot，只使用Spring。\n\nLiteFlow要求的Spring的最低版本为Spring 5.0。\n\n支持的范围是Spring 5.X ~ Spring 6.X。\n\n当然如果你使用了最新的Spring 6.X，相应的JDK版本也要切换为JDK17。\n\n如果你想使用Spring快速开始学习，请参考Spring场景安装运行。",normalizedContent:"如果你不使用springboot，只使用spring。\n\nliteflow要求的spring的最低版本为spring 5.0。\n\n支持的范围是spring 5.x ~ spring 6.x。\n\n当然如果你使用了最新的spring 6.x，相应的jdk版本也要切换为jdk17。\n\n如果你想使用spring快速开始学习，请参考spring场景安装运行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:49:31.000Z",permalink:"/pages/v2.11.X/631fa1/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/005.%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/005.说明.md",key:"v-da2d04e8",path:"/pages/v2.11.X/631fa1/",headersStr:null,content:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验LiteFlow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的Hello World里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到LiteFlow的优雅之处。",normalizedContent:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验liteflow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的hello world里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到liteflow的优雅之处。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.11.X/df6982/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md",key:"v-c118e040",path:"/pages/v2.11.X/df6982/",headersStr:null,content:"LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring-boot-starter</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"liteflow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring-boot-starter</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.11.X/9f4489/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md",key:"v-e9d43e64",path:"/pages/v2.11.X/9f4489/",headersStr:null,content:'声明启动类：\n\n@SpringBootApplication\n//把你定义的组件扫入Spring上下文中\n@ComponentScan({"com.xxx.xxx.cmp"})\npublic class LiteflowExampleApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(LiteflowExampleApplication.class, args);\n    }\n}\n\n\n然后你就可以在SpringBoot任意被Spring托管的类中拿到flowExecutor，进行执行链路：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以将自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'声明启动类：\n\n@springbootapplication\n//把你定义的组件扫入spring上下文中\n@componentscan({"com.xxx.xxx.cmp"})\npublic class liteflowexampleapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(liteflowexampleapplication.class, args);\n    }\n}\n\n\n然后你就可以在springboot任意被spring托管的类中拿到flowexecutor，进行执行链路：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以将自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.11.X/82ef41/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md",key:"v-7d2fe52a",path:"/pages/v2.11.X/82ef41/",headers:[{level:2,title:"组件的定义",slug:"组件的定义",normalizedTitle:"组件的定义",charIndex:2},{level:2,title:"SpringBoot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:453},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:620}],headersStr:"组件的定义 SpringBoot配置文件 规则文件的定义",content:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文。\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# SpringBoot配置文件\n\n然后，在你的SpringBoot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c);\n    </chain>\n</flow>\n\n\nSpringBoot在启动时会自动装载规则文件。',normalizedContent:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保springboot会扫描到这些组件并注册进上下文。\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# springboot配置文件\n\n然后，在你的springboot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c);\n    </chain>\n</flow>\n\n\nspringboot在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.11.X/0a4573/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md",key:"v-2b9660ca",path:"/pages/v2.11.X/0a4573/",headersStr:null,content:"针对于使用了Spring但没有使用SpringBoot的项目\n\n<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring</artifactId>\n\t<version>2.11.4.2</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"针对于使用了spring但没有使用springboot的项目\n\n<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring</artifactid>\n\t<version>2.11.4.2</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.11.X/495f21/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md",key:"v-0516feb4",path:"/pages/v2.11.X/495f21/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"Spring xml中的配置",slug:"spring-xml中的配置",normalizedTitle:"spring xml中的配置",charIndex:452},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:1155}],headersStr:"定义你的组件 Spring xml中的配置 规则文件的定义",content:'# 定义你的组件\n\n你需要定义并实现一些组件，确保Spring会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# Spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springAware" class="com.yomahub.liteflow.spi.spring.SpringAware"/>\n\n<bean class="com.yomahub.liteflow.spring.ComponentScanner"/>\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\x3c!-- 如果上述enableLog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.MonitorBus">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c)\n    </chain>\n</flow>\n\n\nSpring在启动时会自动装载规则文件。',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件，确保spring会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springaware" class="com.yomahub.liteflow.spi.spring.springaware"/>\n\n<bean class="com.yomahub.liteflow.spring.componentscanner"/>\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\x3c!-- 如果上述enablelog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.monitorbus">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c)\n    </chain>\n</flow>\n\n\nspring在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-02T19:49:57.000Z",permalink:"/pages/v2.11.X/0e0fb5/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md",key:"v-09e49989",path:"/pages/v2.11.X/0e0fb5/",headersStr:null,content:'和SpringBoot的执行方式一样，没有任何区别，你可以在你的任何受Spring托管的类里注入FlowExecutor进行执行：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'和springboot的执行方式一样，没有任何区别，你可以在你的任何受spring托管的类里注入flowexecutor进行执行：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.11.X/522432/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md",key:"v-53af0494",path:"/pages/v2.11.X/522432/",headersStr:null,content:"虽说Springboot/Spring已经成为了Java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合Spring我始终觉得是瑕疵，有点代码洁癖），现在在非Spring体系的环境中也能使用LiteFlow框架带来的便捷和高效。\n\nLiteFlow文档中提到的98%以上的特性功能都能在非Spring体系中生效。其中不生效的特性和功能有：\n\n * ruleSource的模糊路径匹配特性在非Spring体系下不生效\n * LiteflowComponent在非Spring体系下无法使用\n * 监控功能在非Spring体系中无法使用",normalizedContent:"虽说springboot/spring已经成为了java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合spring我始终觉得是瑕疵，有点代码洁癖），现在在非spring体系的环境中也能使用liteflow框架带来的便捷和高效。\n\nliteflow文档中提到的98%以上的特性功能都能在非spring体系中生效。其中不生效的特性和功能有：\n\n * rulesource的模糊路径匹配特性在非spring体系下不生效\n * liteflowcomponent在非spring体系下无法使用\n * 监控功能在非spring体系中无法使用",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.11.X/8760c4/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E4%BE%9D%E8%B5%96.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md",key:"v-ac32a9a4",path:"/pages/v2.11.X/8760c4/",headersStr:null,content:"<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-core</artifactId>\n\t<version>2.11.4.2</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-core</artifactid>\n\t<version>2.11.4.2</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-06T23:15:50.000Z",permalink:"/pages/v2.11.X/151524/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/040.%E6%89%A7%E8%A1%8C.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md",key:"v-575b8a1c",path:"/pages/v2.11.X/151524/",headers:[{level:2,title:"初始化你的FlowExecutor执行器",slug:"初始化你的flowexecutor执行器",normalizedTitle:"初始化你的flowexecutor执行器",charIndex:2},{level:2,title:"用FlowExecutor执行",slug:"用flowexecutor执行",normalizedTitle:"用flowexecutor执行",charIndex:331}],headersStr:"初始化你的FlowExecutor执行器 用FlowExecutor执行",content:'# 初始化你的FlowExecutor执行器\n\n通过以下代码你可以轻易的初始化FlowExecutor处理器：\n\nLiteflowConfig config = new LiteflowConfig();\nconfig.setRuleSource("config/flow.el.xml");\nFlowExecutor flowExecutor = FlowExecutorHolder.loadInstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化FlowExecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用FlowExecutor执行\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'# 初始化你的flowexecutor执行器\n\n通过以下代码你可以轻易的初始化flowexecutor处理器：\n\nliteflowconfig config = new liteflowconfig();\nconfig.setrulesource("config/flow.el.xml");\nflowexecutor flowexecutor = flowexecutorholder.loadinstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化flowexecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用flowexecutor执行\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-06T21:42:12.000Z",permalink:"/pages/v2.11.X/b70ec8/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/010.%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/040.🍢配置项/010.说明.md",key:"v-42670b79",path:"/pages/v2.11.X/b70ec8/",headersStr:null,content:"LiteFlow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",normalizedContent:"liteflow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.11.X/249d17/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E9%85%8D%E7%BD%AE.html",relativePath:"08.v2.11.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md",key:"v-67b601b9",path:"/pages/v2.11.X/249d17/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"规则文件的配置",slug:"规则文件的配置",normalizedTitle:"规则文件的配置",charIndex:381}],headersStr:"定义你的组件 规则文件的配置",content:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.AComponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.BComponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.CComponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tTHEN(a, b, c);\n\t</chain>\n</flow>\n',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.acomponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.bcomponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.ccomponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tthen(a, b, c);\n\t</chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot下的配置项",frontmatter:{title:"🌿Springboot下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.11.X/4594ec/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/020.Springboot%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"08.v2.11.X文档/040.🍢配置项/020.Springboot下的配置项.md",key:"v-0c9eca63",path:"/pages/v2.11.X/4594ec/",headersStr:null,content:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zkNode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#FlowExecutor的execute2Future的线程数，默认为64\nliteflow.main-executor-works=64\n#FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n#自定义请求ID的生成类，LiteFlow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n#并行节点的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n#异步线程最长的等待时间(只用于when)，默认值为15000\nliteflow.when-max-wait-time=15000\n#异步线程最长的等待时间单位(只用于when)，默认值为MILLISECONDS，毫秒\nliteflow.when-max-wait-time-unit=MILLISECONDS\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#并行循环子项线程池最大线程数，默认为16\nliteflow.parallel-max-workers=16\n#并行循环子项线程池等待队列数，默认为512\nliteflow.parallel-queue-limit=512\n#并行循环子项的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#是否开启本地文件监听，默认为false\nliteflow.enable-monitor-file=false\n#是否开启快速解析模式，默认为false\nliteflow.fast-load=false\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #FlowExecutor的execute2Future的线程数，默认为64\n  main-executor-works: 64\n  #FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\n  main-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n  #自定义请求ID的生成类，LiteFlow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n  #并行节点的线程池Builder，LiteFlow提供了默认的Builder\n  thread-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n  #异步线程最长的等待时间(只用于when)，默认值为15000\n  when-max-wait-time: 15000\n  #异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒\n  when-max-wait-time-unit: MILLISECONDS\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #并行循环子项线程池最大线程数，默认为16\n  parallel-max-workers: 16\n  #并行循环子项线程池等待队列数，默认为512\n  parallel-queue-limit: 512\n  #并行循环子项的线程池Builder，LiteFlow提供了默认的Builder\n  parallel-loop-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultParallelLoopExecutorBuilder\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #是否开启本地文件监听，默认为false\n  enable-monitor-file: false\n  #是否开启快速解析模式，默认为false\n  fast-load: false\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",normalizedContent:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zknode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#flowexecutor的execute2future的线程数，默认为64\nliteflow.main-executor-works=64\n#flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n#自定义请求id的生成类，liteflow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n#并行节点的线程池builder，liteflow提供了默认的builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n#异步线程最长的等待时间(只用于when)，默认值为15000\nliteflow.when-max-wait-time=15000\n#异步线程最长的等待时间单位(只用于when)，默认值为milliseconds，毫秒\nliteflow.when-max-wait-time-unit=milliseconds\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#并行循环子项线程池最大线程数，默认为16\nliteflow.parallel-max-workers=16\n#并行循环子项线程池等待队列数，默认为512\nliteflow.parallel-queue-limit=512\n#并行循环子项的线程池builder，liteflow提供了默认的builder\nliteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#是否开启本地文件监听，默认为false\nliteflow.enable-monitor-file=false\n#是否开启快速解析模式，默认为false\nliteflow.fast-load=false\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #flowexecutor的execute2future的线程数，默认为64\n  main-executor-works: 64\n  #flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\n  main-executor-class: com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n  #自定义请求id的生成类，liteflow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n  #并行节点的线程池builder，liteflow提供了默认的builder\n  thread-executor-class: com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n  #异步线程最长的等待时间(只用于when)，默认值为15000\n  when-max-wait-time: 15000\n  #异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒\n  when-max-wait-time-unit: milliseconds\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #并行循环子项线程池最大线程数，默认为16\n  parallel-max-workers: 16\n  #并行循环子项线程池等待队列数，默认为512\n  parallel-queue-limit: 512\n  #并行循环子项的线程池builder，liteflow提供了默认的builder\n  parallel-loop-executor-class: com.yomahub.liteflow.thread.liteflowdefaultparallelloopexecutorbuilder\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #是否开启本地文件监听，默认为false\n  enable-monitor-file: false\n  #是否开启快速解析模式，默认为false\n  fast-load: false\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring下的配置项",frontmatter:{title:"🌱Spring下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.11.X/33833a/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/030.Spring%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"08.v2.11.X文档/040.🍢配置项/030.Spring下的配置项.md",key:"v-0a4f2a01",path:"/pages/v2.11.X/33833a/",headersStr:null,content:'<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printBanner" value="true"/> \n    \x3c!-- zkNode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zkNode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotSize" value="1024"/> \n    \x3c!-- FlowExecutor的execute2Future的线程数，默认为64 --\x3e\n    <property name="mainExecutorWorks" value="64"/> \n    \x3c!-- FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="mainExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder"/>\n    \x3c!-- 自定义请求ID的生成类，LiteFlow提供了默认的生成类 --\x3e\n    <property name="requestIdGeneratorClass" value="com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator"/>\n    \x3c!-- 并行节点的线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder"/> \n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为15000 --\x3e\n    <property name="whenMaxWaitTime" value="15000"/>\n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒 --\x3e\n    <property name="whenMaxWaitTimeUnit" value="MILLISECONDS"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenMaxWorkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenQueueLimit" value="512"/>\n    \x3c!-- 并行循环子项线程池最大线程数，默认为16--\x3e\n    <property name="parallelMaxWorkers" value="16"/>\n    \x3c!-- 并行循环子项线程池等待队列数，默认为512--\x3e\n    <property name="parallelQueueLimit" value="512"/>\n    \x3c!-- 并行循环子项的线程池Builder，LiteFlow提供了默认的Builder--\x3e\n    <property name="parallelLoopExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultParallelLoopExecutorBuilder"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseOnStart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retryCount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportMultipleType" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeExecutorClass" value="com.yomahub.liteflow.flow.executor.DefaultNodeExecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printExecutionLog" value="true"/>\n    \x3c!-- 是否开启本地文件监听，默认为false --\x3e\n    <property name="enableMonitorFile" value="false"/>\n    \x3c!-- 是否开启快速解析模式，默认为false --\x3e\n    <property name="fastLoad" value="false"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enableLog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queueLimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/>\n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printbanner" value="true"/> \n    \x3c!-- zknode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zknode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotsize" value="1024"/> \n    \x3c!-- flowexecutor的execute2future的线程数，默认为64 --\x3e\n    <property name="mainexecutorworks" value="64"/> \n    \x3c!-- flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="mainexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder"/>\n    \x3c!-- 自定义请求id的生成类，liteflow提供了默认的生成类 --\x3e\n    <property name="requestidgeneratorclass" value="com.yomahub.liteflow.flow.id.defaultrequestidgenerator"/>\n    \x3c!-- 并行节点的线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder"/> \n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为15000 --\x3e\n    <property name="whenmaxwaittime" value="15000"/>\n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒 --\x3e\n    <property name="whenmaxwaittimeunit" value="milliseconds"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenmaxworkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenqueuelimit" value="512"/>\n    \x3c!-- 并行循环子项线程池最大线程数，默认为16--\x3e\n    <property name="parallelmaxworkers" value="16"/>\n    \x3c!-- 并行循环子项线程池等待队列数，默认为512--\x3e\n    <property name="parallelqueuelimit" value="512"/>\n    \x3c!-- 并行循环子项的线程池builder，liteflow提供了默认的builder--\x3e\n    <property name="parallelloopexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultparallelloopexecutorbuilder"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseonstart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retrycount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportmultipletype" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeexecutorclass" value="com.yomahub.liteflow.flow.executor.defaultnodeexecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printexecutionlog" value="true"/>\n    \x3c!-- 是否开启本地文件监听，默认为false --\x3e\n    <property name="enablemonitorfile" value="false"/>\n    \x3c!-- 是否开启快速解析模式，默认为false --\x3e\n    <property name="fastload" value="false"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enablelog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queuelimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/>\n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵其他场景代码设置配置项",frontmatter:{title:"🌵其他场景代码设置配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.11.X/b5065a/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/040.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"08.v2.11.X文档/040.🍢配置项/040.其他场景代码设置配置项.md",key:"v-c418353a",path:"/pages/v2.11.X/b5065a/",headersStr:null,content:'LiteflowConfig config = new LiteflowConfig();\n//规则文件路径\nconfig.setRuleSource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setEnable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setPrintBanner(true);\n//zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setZkNode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setSlotSize(1024);\n//FlowExecutor的execute2Future的线程数，默认为64\nconfig.setMainExecutorWorks(64);\n//FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nconfig.setMainExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder");\n//自定义请求ID的生成类，LiteFlow提供了默认的生成类\nconfig.setRequestIdGeneratorClass("com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator");\n//并行节点的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setThreadExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder");\n//异步线程最长的等待时间(只用于when)，默认值为15000\nconfig.setWhenMaxWaitTime(15000);\n//异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒\nconfig.setWhenMaxWaitTimeUnit(TimeUnit.MILLISECONDS);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setWhenMaxWorkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setWhenQueueLimit(512);\n//并行循环子项线程池最大线程数，默认为16\nconfig.setParallelMaxWorkers(16)\n//并行循环子项线程池等待队列数，默认为512\nconfig.setParallelQueueLimit(512)\n//并行循环子项的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setParallelLoopExecutorClass(com.yomahub.liteflow.thread.LiteFlowDefaultParallelLoopExecutorBuilder)\n//是否在启动的时候就解析规则，默认为true\nconfig.setParseOnStart(true);\n//全局重试次数，默认为0\nconfig.setRetryCount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setSupportMultipleType(false);\n//全局默认节点执行器\nconfig.setNodeExecutorClass("com.yomahub.liteflow.flow.executor.DefaultNodeExecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setPrintExecutionLog(true);\n//是否开启本地文件监听，默认为false\nconfig.setEnableMonitorFile(false);\n//是否开启快速解析模式，默认为false\nconfig.setFastLoad(false);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setEnableLog(false);\n//监控队列存储大小，默认值为200\nconfig.setQueueLimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setDelay(300000L);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setPeriod(300000L);\n\n\n\n:::tip\n只要使用了规则，那么`rule-source`必须得有。\n\n但是如果你是用代码动态构造规则，那么`rule-source`配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考[用代码动态构造规则](/pages/v2.11.X/9aa85a/)。\n:::',normalizedContent:'liteflowconfig config = new liteflowconfig();\n//规则文件路径\nconfig.setrulesource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setenable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setprintbanner(true);\n//zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setzknode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setslotsize(1024);\n//flowexecutor的execute2future的线程数，默认为64\nconfig.setmainexecutorworks(64);\n//flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nconfig.setmainexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder");\n//自定义请求id的生成类，liteflow提供了默认的生成类\nconfig.setrequestidgeneratorclass("com.yomahub.liteflow.flow.id.defaultrequestidgenerator");\n//并行节点的线程池builder，liteflow提供了默认的builder\nconfig.setthreadexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder");\n//异步线程最长的等待时间(只用于when)，默认值为15000\nconfig.setwhenmaxwaittime(15000);\n//异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒\nconfig.setwhenmaxwaittimeunit(timeunit.milliseconds);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setwhenmaxworkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setwhenqueuelimit(512);\n//并行循环子项线程池最大线程数，默认为16\nconfig.setparallelmaxworkers(16)\n//并行循环子项线程池等待队列数，默认为512\nconfig.setparallelqueuelimit(512)\n//并行循环子项的线程池builder，liteflow提供了默认的builder\nconfig.setparallelloopexecutorclass(com.yomahub.liteflow.thread.liteflowdefaultparallelloopexecutorbuilder)\n//是否在启动的时候就解析规则，默认为true\nconfig.setparseonstart(true);\n//全局重试次数，默认为0\nconfig.setretrycount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setsupportmultipletype(false);\n//全局默认节点执行器\nconfig.setnodeexecutorclass("com.yomahub.liteflow.flow.executor.defaultnodeexecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setprintexecutionlog(true);\n//是否开启本地文件监听，默认为false\nconfig.setenablemonitorfile(false);\n//是否开启快速解析模式，默认为false\nconfig.setfastload(false);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setenablelog(false);\n//监控队列存储大小，默认值为200\nconfig.setqueuelimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setdelay(300000l);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setperiod(300000l);\n\n\n\n:::tip\n只要使用了规则，那么`rule-source`必须得有。\n\n但是如果你是用代码动态构造规则，那么`rule-source`配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考[用代码动态构造规则](/pages/v2.11.x/9aa85a/)。\n:::',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📔规则文件格式",frontmatter:{title:"📔规则文件格式",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.11.X/6fa87e/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/010.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/010.规则文件格式.md",key:"v-23b79988",path:"/pages/v2.11.X/6fa87e/",headers:[{level:2,title:"规则组成部分",slug:"规则组成部分",normalizedTitle:"规则组成部分",charIndex:147}],headersStr:"规则组成部分",content:'LiteFlow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nLiteFlow的规则文件非常轻量，非常容易上手。主要由Node节点和Chain节点组成。\n\n提示\n\n必须要说明的是，Node节点在Springboot/Spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到Spring上下文中。\n\n在非Spring环境体系中，Node节点是必须的。如果不配置Node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nXML在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.ACmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.BCmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.CCmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.DCmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(\n            a, b, WHEN(c,d)\n        );\n    </chain>\n</flow>\n\n\nJSON在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.TestCustomParser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ACmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.BCmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.CCmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.DCmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "THEN(a, b, WHEN(c, d))"\n      }\n    ]\n  }\n}\n\n\nYAML在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.TestCustomParser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.ACmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.BCmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.CCmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.DCmp\n  chain:\n    - name: chain1\n      value: "THEN(a, b, WHEN(c, d))"\n',normalizedContent:'liteflow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nliteflow的规则文件非常轻量，非常容易上手。主要由node节点和chain节点组成。\n\n提示\n\n必须要说明的是，node节点在springboot/spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到spring上下文中。\n\n在非spring环境体系中，node节点是必须的。如果不配置node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nxml在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.acmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.bcmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.ccmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.dcmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(\n            a, b, when(c,d)\n        );\n    </chain>\n</flow>\n\n\njson在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.testcustomparser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.acmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.bcmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ccmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.dcmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "then(a, b, when(c, d))"\n      }\n    ]\n  }\n}\n\n\nyaml在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.testcustomparser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.acmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.bcmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.ccmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.dcmp\n  chain:\n    - name: chain1\n      value: "then(a, b, when(c, d))"\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📕本地规则文件配置",frontmatter:{title:"📕本地规则文件配置",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.11.X/51ddd5/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/020.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/020.本地规则文件配置.md",key:"v-5d63701c",path:"/pages/v2.11.X/51ddd5/",headers:[{level:2,title:"常规配置",slug:"常规配置",normalizedTitle:"常规配置",charIndex:173},{level:2,title:"工程内指定多个路径",slug:"工程内指定多个路径",normalizedTitle:"工程内指定多个路径",charIndex:300},{level:2,title:"绝对路径指定多个路径",slug:"绝对路径指定多个路径",normalizedTitle:"绝对路径指定多个路径",charIndex:493}],headersStr:"常规配置 工程内指定多个路径 绝对路径指定多个路径",content:"在LiteFlow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是LiteFlow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 工程内指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用Spring EL表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n\n# 绝对路径指定多个路径\n\n绝对路径也可以用,或者;进行分隔：\n\nliteflow.rule-source=/data/lf/flow1.el.xml,/data/lf/flow2.el.xml\n\n\n提示\n\n在LiteFlow v2.11.1版本之前，不支持绝对路径的模糊匹配。而在这个版本之后，对绝对路径的模糊匹配也作了支持\n\n你可以用*和**来进行模糊匹配：\n\nliteflow.rule-source=/data/lf/**/*Rule.xml\n\n\n以上则表示，在/data/lf/ 这个目录下，以及多级子目录下的所有匹配*Rule这个文件命名并且以xml结尾的所有文件。",normalizedContent:"在liteflow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是liteflow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 工程内指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用spring el表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n\n# 绝对路径指定多个路径\n\n绝对路径也可以用,或者;进行分隔：\n\nliteflow.rule-source=/data/lf/flow1.el.xml,/data/lf/flow2.el.xml\n\n\n提示\n\n在liteflow v2.11.1版本之前，不支持绝对路径的模糊匹配。而在这个版本之后，对绝对路径的模糊匹配也作了支持\n\n你可以用*和**来进行模糊匹配：\n\nliteflow.rule-source=/data/lf/**/*rule.xml\n\n\n以上则表示，在/data/lf/ 这个目录下，以及多级子目录下的所有匹配*rule这个文件命名并且以xml结尾的所有文件。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📗ZK规则文件配置源",frontmatter:{title:"📗ZK规则文件配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.11.X/ffc345/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/030.ZK%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/030.ZK规则文件配置源.md",key:"v-2c906cbe",path:"/pages/v2.11.X/ffc345/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:17},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:651},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:787},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1155},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1223}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'# 依赖\n\nLiteFlow支持把配置放在zk集群中，基于zk的通知机制，LiteFlow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-zk</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectStr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainPath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectStr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectStr   zk的连接串，可以是集群\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在ZK中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainId，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手ZK规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'# 依赖\n\nliteflow支持把配置放在zk集群中，基于zk的通知机制，liteflow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-zk</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectstr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainpath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectstr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectstr   zk的连接串，可以是集群\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在zk中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainid，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手zk规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📋Nacos配置源",frontmatter:{title:"📋Nacos配置源",date:"2022-10-06T23:19:04.000Z",permalink:"/pages/v2.11.X/09b776/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/050.Nacos%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/050.Nacos配置源.md",key:"v-2f5f0498",path:"/pages/v2.11.X/09b776/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:40},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:31},{level:2,title:"对阿里云MSE的支持",slug:"对阿里云mse的支持",normalizedTitle:"对阿里云mse的支持",charIndex:696},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:982},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:1216},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1486},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1560}],headersStr:"依赖 配置 对阿里云MSE的支持 配置说明 存储数据说明 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了Nacos的规则配置源。\n\n\n# 依赖\n\n如果使用Nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-nacos</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serverAddr: 127.0.0.1:8848\n    dataId: demo_rule\n    group: DEFAULT_GROUP\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serverAddr":"127.0.0.1:8848",\\\n    "dataId":"demo_rule",\\\n    "group":"DEFAULT_GROUP",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 对阿里云MSE的支持\n\n自从v2.11.4开始，LiteFlow对阿里云的MSE也进行了支持，配置如下:\n\nliteflow.rule-source-ext-data={\\\n    "serverAddr":"127.0.0.1:8848",\\\n    "dataId":"demo_rule",\\\n    "group":"DEFAULT_GROUP",\\\n    "namespace":"your namespace id",\\\n    "accessKey":"xxxxxxxxxx",\\\n    "secretKey":"xxxxxxxxxx"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserverAddr   nacos的连接串\ndataId       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\naccessKey    阿里云的accessKey\nsecretKey    阿里云的secretKey\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用Nacos配置源的时候，Nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      THEN(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此Nacos配置源插件，凡是Nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手Nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了nacos的规则配置源。\n\n\n# 依赖\n\n如果使用nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-nacos</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serveraddr: 127.0.0.1:8848\n    dataid: demo_rule\n    group: default_group\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serveraddr":"127.0.0.1:8848",\\\n    "dataid":"demo_rule",\\\n    "group":"default_group",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 对阿里云mse的支持\n\n自从v2.11.4开始，liteflow对阿里云的mse也进行了支持，配置如下:\n\nliteflow.rule-source-ext-data={\\\n    "serveraddr":"127.0.0.1:8848",\\\n    "dataid":"demo_rule",\\\n    "group":"default_group",\\\n    "namespace":"your namespace id",\\\n    "accesskey":"xxxxxxxxxx",\\\n    "secretkey":"xxxxxxxxxx"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserveraddr   nacos的连接串\ndataid       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\naccesskey    阿里云的accesskey\nsecretkey    阿里云的secretkey\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用nacos配置源的时候，nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      then(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此nacos配置源插件，凡是nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🗄Etcd配置源",frontmatter:{title:"🗄Etcd配置源",date:"2022-10-06T23:19:17.000Z",permalink:"/pages/v2.11.X/4bfac2/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/060.Etcd%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/060.Etcd配置源.md",key:"v-2edf2a5e",path:"/pages/v2.11.X/4bfac2/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:39},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:30},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:578},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:710},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1080},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1152}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了Etcd的规则配置源。\n\n\n# 依赖\n\n如果使用Etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-etcd</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainPath: /liteflow/chain\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在etcd中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainId，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此Etcd配置源插件，凡是Etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手Etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了etcd的规则配置源。\n\n\n# 依赖\n\n如果使用etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-etcd</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainpath: /liteflow/chain\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在etcd中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainid，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此etcd配置源插件，凡是etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📘SQL数据库配置源",frontmatter:{title:"📘SQL数据库配置源",date:"2022-10-06T23:18:42.000Z",permalink:"/pages/v2.11.X/236b4f/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/040.SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/040.SQL数据库配置源.md",key:"v-60631a33",path:"/pages/v2.11.X/236b4f/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:67},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:35},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:1972},{level:2,title:"使用你项目中的dataSource来进行连接",slug:"使用你项目中的datasource来进行连接",normalizedTitle:"使用你项目中的datasource来进行连接",charIndex:4811},{level:2,title:"轮询自动刷新",slug:"轮询自动刷新",normalizedTitle:"轮询自动刷新",charIndex:557},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:5839}],headersStr:"依赖 配置 配置说明 使用你项目中的dataSource来进行连接 轮询自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准SQL语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-sql</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverClassName: com.mysql.cj.jdbc.Driver\n    username: root\n    password: 123456\n    applicationName: demo\n    #是否开启SQL日志\n    sqlLogEnabled: true\n    #是否开启SQL数据轮询自动刷新机制 默认不开启\n    pollingEnabled: true\n    pollingIntervalSeconds: 60\n    pollingStartSeconds: 60\n    #以下是chain表的配置，这个一定得有\n    chainTableName: chain\n    chainApplicationNameField: application_name\n    chainNameField: chain_name\n    elDataField: el_data\n    chainEnableField: enable\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scriptTableName: script\n    scriptApplicationNameField: application_name\n    scriptIdField: script_id\n    scriptNameField: script_name\n    scriptDataField: script_data\n    scriptTypeField: script_type\n    scriptLanguageField: script_language\n    scriptEnableField: enable\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverClassName":"com.mysql.cj.jdbc.Driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationName": "demo",\\\n  "sqlLogEnabled": true,\\\n  "pollingEnabled": true,\\\n  "pollingIntervalSeconds": 60,\\\n  "pollingStartSeconds": 60,\\\n  "chainTableName": "chain",\\\n  "chainApplicationNameField": "application_name",\\\n  "chainNameField": "chain_name",\\\n  "elDataField": "el_data",\\\n  "chainEnableField": "enable",\\\n  "scriptTableName": "script",\\\n  "scriptApplicationNameField": "application_name",\\\n  "scriptIdField": "script_id",\\\n  "scriptNameField": "script_name",\\\n  "scriptDataField": "script_data",\\\n  "scriptTypeField": "script_type",\\\n  "scriptLanguageField": "script_language",\\\n  "scriptEnableField": "enable"\n  }\n\n\n\n# 配置说明\n\nLiteFlow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明\nurl                          jdbc的连接url\ndriverClassName              驱动器类名\nusername                     数据库用户名\npassword                     数据库密码\napplicationName              你的应用名称\nsqlLogEnabled                是否开启SQL日志 默认开启\npollingEnabled               是否开启SQL数据轮询自动刷新机制 默认不开启\npollingIntervalSeconds       SQL数据轮询时间间隔(s) 默认为60s\npollingStartSeconds          规则配置后首次轮询的起始时间(s) 默认为60s\nchainTableName               编排规则表的表名\nchainApplicationNameField    编排规则表中应用名称存储字段名\nchainNameField               规则名称存储的字段名\nelDataField                  EL表达式的字段(只存EL)\nchainEnableField             此chain是否生效，此字段最好在mysql中定义成tinyInt类型\nscriptTableName              你的脚本存储表的表名\nscriptApplicationNameField   脚本表中应用名称存储字段名\nscriptIdField                脚本组件的Id的字段名\nscriptNameField              脚本组件名称的字段名\nscriptDataField              脚本数据的字段名\nscriptTypeField              脚本类型的字段名(类型参照定义脚本组件)\nscriptLanguageField          脚本语言类型（groovy | qlexpress | js | python | lua | aviator |\n                             java）\nscriptEnableField            此脚本是否生效，此字段最好在mysql中定义成tinyInt类型\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nID   APPLICATION_NAME   CHAIN_NAME   CHAIN_DESC   EL_DATA                 CREATE_TIME\n1    demo               chain1       测试流程1        THEN(a, b, c, s1,s2);   2022-09-19 19:31:00\n\n脚本表：liteflow_script\n\nID   APPLICATION_NAME   SCRIPT_ID   SCRIPT_NAME   SCRIPT_DATA                                                  SCRIPT_TYPE   SCRIPT_LANGUAGE   CREATE_TIME\n1    demo               s1          脚本s1          import cn.hutool.core.date.DateUtil                          script        groovy            2022-09-19 19:31:00\n                                                  def date = DateUtil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultContext.setData("demoDate", date)\n                                                  class Student {\n                                                  int studentID\n                                                  String studentName\n                                                  }\n                                                  Student student = new Student() student.studentID = 100301\n                                                  student.studentName = "张三"\n                                                  defaultContext.setData("student",student) def a=3\n                                                  def b=2\n                                                  defaultContext.setData("s1",a*b)\n2    demo               s2          脚本s2          defaultContext.setData("s2","hello")                         script        groovy            2022-09-19 19:31:00\n\n\n# 使用你项目中的dataSource来进行连接\n\nLiteFlow从v2.10.6开始支持了使用项目中已存在的Datasource来进行数据库连接。如果你项目中已有链接配置，比如：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/poseidon\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n那么你在rule-source-ext-data-map中无需再配置以下几项：\n\nurl: jdbc:mysql://localhost:3306/poseidon\ndriverClassName: com.mysql.cj.jdbc.Driver\nusername: root\npassword: 123456\n\n\n提示\n\n需要注意的是，如果你的系统中声明了多个数据源，那么LiteFlow会自动判断该选用哪个数据源。\n\n如果你的系统中使用了动态数据源，那么请确保默认数据源是含有LiteFlow链路数据的表数据的。\n\n\n# 轮询自动刷新\n\nLiteFlow从v2.11.1开始，支持SQL数据源轮询模式的自动刷新机制。你可以在配置项中通过pollingEnabled: true来开启自动刷新：\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    pollingEnabled: true\n    ##以下非必须，默认1分钟\n    pollingIntervalSeconds: 60\n    pollingStartSeconds: 60\n    ...\n\n\nliteflow.rule-source-ext-data={\\\n  ...\\\n  "pollingEnabled": true,\\\n  "pollingIntervalSeconds": 60,\\\n  "pollingStartSeconds": 60,\\\n  ...\n  }\n\n\n轮询模式的自动刷新根据预设的时间间隔定时拉取SQL中的数据，与本地保存的数据SHA值进行对比来判断是否需要更新数据。\n\n定时轮询存在些微的性能消耗；受轮询间隔限制，数据更新有一定延迟性。\n\n\n# 小例子\n\n为了让大家能简单上手SQL规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准sql语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-sql</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverclassname: com.mysql.cj.jdbc.driver\n    username: root\n    password: 123456\n    applicationname: demo\n    #是否开启sql日志\n    sqllogenabled: true\n    #是否开启sql数据轮询自动刷新机制 默认不开启\n    pollingenabled: true\n    pollingintervalseconds: 60\n    pollingstartseconds: 60\n    #以下是chain表的配置，这个一定得有\n    chaintablename: chain\n    chainapplicationnamefield: application_name\n    chainnamefield: chain_name\n    eldatafield: el_data\n    chainenablefield: enable\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scripttablename: script\n    scriptapplicationnamefield: application_name\n    scriptidfield: script_id\n    scriptnamefield: script_name\n    scriptdatafield: script_data\n    scripttypefield: script_type\n    scriptlanguagefield: script_language\n    scriptenablefield: enable\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverclassname":"com.mysql.cj.jdbc.driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationname": "demo",\\\n  "sqllogenabled": true,\\\n  "pollingenabled": true,\\\n  "pollingintervalseconds": 60,\\\n  "pollingstartseconds": 60,\\\n  "chaintablename": "chain",\\\n  "chainapplicationnamefield": "application_name",\\\n  "chainnamefield": "chain_name",\\\n  "eldatafield": "el_data",\\\n  "chainenablefield": "enable",\\\n  "scripttablename": "script",\\\n  "scriptapplicationnamefield": "application_name",\\\n  "scriptidfield": "script_id",\\\n  "scriptnamefield": "script_name",\\\n  "scriptdatafield": "script_data",\\\n  "scripttypefield": "script_type",\\\n  "scriptlanguagefield": "script_language",\\\n  "scriptenablefield": "enable"\n  }\n\n\n\n# 配置说明\n\nliteflow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明\nurl                          jdbc的连接url\ndriverclassname              驱动器类名\nusername                     数据库用户名\npassword                     数据库密码\napplicationname              你的应用名称\nsqllogenabled                是否开启sql日志 默认开启\npollingenabled               是否开启sql数据轮询自动刷新机制 默认不开启\npollingintervalseconds       sql数据轮询时间间隔(s) 默认为60s\npollingstartseconds          规则配置后首次轮询的起始时间(s) 默认为60s\nchaintablename               编排规则表的表名\nchainapplicationnamefield    编排规则表中应用名称存储字段名\nchainnamefield               规则名称存储的字段名\neldatafield                  el表达式的字段(只存el)\nchainenablefield             此chain是否生效，此字段最好在mysql中定义成tinyint类型\nscripttablename              你的脚本存储表的表名\nscriptapplicationnamefield   脚本表中应用名称存储字段名\nscriptidfield                脚本组件的id的字段名\nscriptnamefield              脚本组件名称的字段名\nscriptdatafield              脚本数据的字段名\nscripttypefield              脚本类型的字段名(类型参照定义脚本组件)\nscriptlanguagefield          脚本语言类型（groovy | qlexpress | js | python | lua | aviator |\n                             java）\nscriptenablefield            此脚本是否生效，此字段最好在mysql中定义成tinyint类型\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nid   application_name   chain_name   chain_desc   el_data                 create_time\n1    demo               chain1       测试流程1        then(a, b, c, s1,s2);   2022-09-19 19:31:00\n\n脚本表：liteflow_script\n\nid   application_name   script_id   script_name   script_data                                                  script_type   script_language   create_time\n1    demo               s1          脚本s1          import cn.hutool.core.date.dateutil                          script        groovy            2022-09-19 19:31:00\n                                                  def date = dateutil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultcontext.setdata("demodate", date)\n                                                  class student {\n                                                  int studentid\n                                                  string studentname\n                                                  }\n                                                  student student = new student() student.studentid = 100301\n                                                  student.studentname = "张三"\n                                                  defaultcontext.setdata("student",student) def a=3\n                                                  def b=2\n                                                  defaultcontext.setdata("s1",a*b)\n2    demo               s2          脚本s2          defaultcontext.setdata("s2","hello")                         script        groovy            2022-09-19 19:31:00\n\n\n# 使用你项目中的datasource来进行连接\n\nliteflow从v2.10.6开始支持了使用项目中已存在的datasource来进行数据库连接。如果你项目中已有链接配置，比如：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver\nspring.datasource.url=jdbc:mysql://localhost:3306/poseidon\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n那么你在rule-source-ext-data-map中无需再配置以下几项：\n\nurl: jdbc:mysql://localhost:3306/poseidon\ndriverclassname: com.mysql.cj.jdbc.driver\nusername: root\npassword: 123456\n\n\n提示\n\n需要注意的是，如果你的系统中声明了多个数据源，那么liteflow会自动判断该选用哪个数据源。\n\n如果你的系统中使用了动态数据源，那么请确保默认数据源是含有liteflow链路数据的表数据的。\n\n\n# 轮询自动刷新\n\nliteflow从v2.11.1开始，支持sql数据源轮询模式的自动刷新机制。你可以在配置项中通过pollingenabled: true来开启自动刷新：\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    pollingenabled: true\n    ##以下非必须，默认1分钟\n    pollingintervalseconds: 60\n    pollingstartseconds: 60\n    ...\n\n\nliteflow.rule-source-ext-data={\\\n  ...\\\n  "pollingenabled": true,\\\n  "pollingintervalseconds": 60,\\\n  "pollingstartseconds": 60,\\\n  ...\n  }\n\n\n轮询模式的自动刷新根据预设的时间间隔定时拉取sql中的数据，与本地保存的数据sha值进行对比来判断是否需要更新数据。\n\n定时轮询存在些微的性能消耗；受轮询间隔限制，数据更新有一定延迟性。\n\n\n# 小例子\n\n为了让大家能简单上手sql规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置说明",frontmatter:{title:"配置说明",date:"2023-08-28T00:29:24.000Z",permalink:"/pages/v2.11.X/38dcf8/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/066.%F0%9F%93%91Redis%E9%85%8D%E7%BD%AE%E6%BA%90/010.%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/066.📑Redis配置源/010.配置说明.md",key:"v-34546ad2",path:"/pages/v2.11.X/38dcf8/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:41},{level:2,title:"配置模式",slug:"配置模式",normalizedTitle:"配置模式",charIndex:282},{level:2,title:"配置模式选择",slug:"配置模式选择",normalizedTitle:"配置模式选择",charIndex:502}],headersStr:"依赖 配置模式 配置模式选择",content:"LiteFlow从v2.11.0开始，原生支持了Redis的规则配置源。\n\n\n# 依赖\n\n如果使用Redis作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-redis</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可。\n\n\n# 配置模式\n\nRedis配置源支持平滑热刷新，在刷新机制上实现了【轮询】和【订阅】两种模式，可通过配置自由选择。\n\n> 【轮询模式】：基于Redis的Hash结构，通过定时轮询的方式进行规则刷新，轮询频率可配置，轮询间隔内有一定刷新延迟。\n> \n> 【订阅模式】：基于Redisson客户端的RMapCache存储结构，只支持使用Redisson客户端，可实现规则的实时平滑刷新。\n\n两种模式的插件依赖相同，仅通过配置参数加以区分。 如果没有配置模式选择，默认为轮询模式。\n\n两种模式的工作原理及具体配置方式详见对应子菜单：\n\nRedis配置源-轮询模式\n\nRedis配置源-订阅模式\n\n\n# 配置模式选择\n\n基于两种工作模式的特点，推荐根据实际需要进行选择。\n\n>  * 如果你需要采用其他Redis客户端 (如Jedis等)，且接受轮询间隔内的数据刷新延迟，推荐你配置为【轮询模式】\n> \n>  * 如果你需要确保规则刷新的实时性，不容忍轮询间隔内的延迟，且接受使用Redisson，推荐你配置为【订阅模式】",normalizedContent:"liteflow从v2.11.0开始，原生支持了redis的规则配置源。\n\n\n# 依赖\n\n如果使用redis作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-redis</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可。\n\n\n# 配置模式\n\nredis配置源支持平滑热刷新，在刷新机制上实现了【轮询】和【订阅】两种模式，可通过配置自由选择。\n\n> 【轮询模式】：基于redis的hash结构，通过定时轮询的方式进行规则刷新，轮询频率可配置，轮询间隔内有一定刷新延迟。\n> \n> 【订阅模式】：基于redisson客户端的rmapcache存储结构，只支持使用redisson客户端，可实现规则的实时平滑刷新。\n\n两种模式的插件依赖相同，仅通过配置参数加以区分。 如果没有配置模式选择，默认为轮询模式。\n\n两种模式的工作原理及具体配置方式详见对应子菜单：\n\nredis配置源-轮询模式\n\nredis配置源-订阅模式\n\n\n# 配置模式选择\n\n基于两种工作模式的特点，推荐根据实际需要进行选择。\n\n>  * 如果你需要采用其他redis客户端 (如jedis等)，且接受轮询间隔内的数据刷新延迟，推荐你配置为【轮询模式】\n> \n>  * 如果你需要确保规则刷新的实时性，不容忍轮询间隔内的延迟，且接受使用redisson，推荐你配置为【订阅模式】",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📜Apollo配置源",frontmatter:{title:"📜Apollo配置源",date:"2022-12-12T22:42:40.000Z",permalink:"/pages/v2.11.X/bea809/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/065.Apollo%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/065.Apollo配置源.md",key:"v-44ace19e",path:"/pages/v2.11.X/bea809/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:57},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:28},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:525},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:610},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1209}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新",content:'LiteFlow从2.9.5开始，原生支持了Apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用Apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-apollo</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainNamespace: chainConfig\n    scriptNamespace: scriptConfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainNamespace":"chainConfig",\\\n    "scriptNamespace":"scriptConfig"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainNamespace    规则命名空间名称\nscriptNamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在Apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在LiteFlow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在Apollo中需要为规则单独创建一个Namespace，数据类型选择properties，那么这个Namespace 下的每一对kv都是一个规则，假设你的规则命名空间为:chainConfig，那么配置形式样例如下：\n\nNAMESPACE：CHAINCONFIG   \nchain1                  THEN(a, b, c);\nchain2                  IF(x, b).ELIF(y, c).ELSE(d);\n\n对于脚本命名空间来说，key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，假设你的脚本命名空间为：scriptConfig，那么配置形式样例如下：\n\nNAMESPACE：SCRIPTCONFIG   \ns1:script:脚本组件1          defaultContext.setData("s1","hello")\ns2:if_script:脚本组件2       if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\nApollo支持推送配置数据的变更，凡是在Apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。',normalizedContent:'liteflow从2.9.5开始，原生支持了apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-apollo</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainnamespace: chainconfig\n    scriptnamespace: scriptconfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainnamespace":"chainconfig",\\\n    "scriptnamespace":"scriptconfig"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainnamespace    规则命名空间名称\nscriptnamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在liteflow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在apollo中需要为规则单独创建一个namespace，数据类型选择properties，那么这个namespace 下的每一对kv都是一个规则，假设你的规则命名空间为:chainconfig，那么配置形式样例如下：\n\nnamespace：chainconfig   \nchain1                  then(a, b, c);\nchain2                  if(x, b).elif(y, c).else(d);\n\n对于脚本命名空间来说，key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，假设你的脚本命名空间为：scriptconfig，那么配置形式样例如下：\n\nnamespace：scriptconfig   \ns1:script:脚本组件1          defaultcontext.setdata("s1","hello")\ns2:if_script:脚本组件2       if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\napollo支持推送配置数据的变更，凡是在apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📙自定义配置源",frontmatter:{title:"📙自定义配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.11.X/25f2c0/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/070.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/070.自定义配置源.md",key:"v-728de3bf",path:"/pages/v2.11.X/25f2c0/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:616}],headersStr:"说明 配置路径",content:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。LiteFlow支持自定义的配置源的扩展点。\n\nXML形式的规则文件请继承ClassXmlFlowELParser\n\nJSON形式的规则文件请继承ClassJsonFlowELParser\n\nYML形式的规则文件请继承ClassYmlFlowELParser\n\n以下以XML形式的自定义源配置类举例：\n\npublic class TestCustomParser extends ClassXmlFlowELParser {\n\n\t@Override\n\tpublic String parseCustom() {\n\t\tSystem.out.println("进入自定义parser");\n\t\tString xmlContent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlContent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@Autowired和@Resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n\n关于el_xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以EL的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',normalizedContent:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。liteflow支持自定义的配置源的扩展点。\n\nxml形式的规则文件请继承classxmlflowelparser\n\njson形式的规则文件请继承classjsonflowelparser\n\nyml形式的规则文件请继承classymlflowelparser\n\n以下以xml形式的自定义源配置类举例：\n\npublic class testcustomparser extends classxmlflowelparser {\n\n\t@override\n\tpublic string parsecustom() {\n\t\tsystem.out.println("进入自定义parser");\n\t\tstring xmlcontent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlcontent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@autowired和@resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n\n关于el_xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以el的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📎普通组件",frontmatter:{title:"📎普通组件",date:"2022-06-29T17:53:36.000Z",permalink:"/pages/v2.11.X/8486fb/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/010.%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/055.🔗常规组件/010.普通组件.md",key:"v-d15e277e",path:"/pages/v2.11.X/8486fb/",headers:[{level:2,title:"可以覆盖的方法",slug:"可以覆盖的方法",normalizedTitle:"可以覆盖的方法",charIndex:335},{level:3,title:"isAccess",slug:"isaccess",normalizedTitle:"isaccess",charIndex:369},{level:3,title:"isContinueOnError",slug:"iscontinueonerror",normalizedTitle:"iscontinueonerror",charIndex:422},{level:3,title:"isEnd",slug:"isend",normalizedTitle:"isend",charIndex:472},{level:3,title:"beforeProcess和afterProcess",slug:"beforeprocess和afterprocess",normalizedTitle:"beforeprocess和afterprocess",charIndex:667},{level:3,title:"onSuccess和onError",slug:"onsuccess和onerror",normalizedTitle:"onsuccess和onerror",charIndex:797},{level:3,title:"rollback",slug:"rollback",normalizedTitle:"rollback",charIndex:845},{level:2,title:"This关键字可以调用的方法",slug:"this关键字可以调用的方法",normalizedTitle:"this关键字可以调用的方法",charIndex:881},{level:3,title:"获取上下文",slug:"获取上下文",normalizedTitle:"获取上下文",charIndex:900},{level:3,title:"getNodeId",slug:"getnodeid",normalizedTitle:"getnodeid",charIndex:978},{level:3,title:"getName",slug:"getname",normalizedTitle:"getname",charIndex:1001},{level:3,title:"getChainName",slug:"getchainname",normalizedTitle:"getchainname",charIndex:1022},{level:3,title:"getRequestData",slug:"getrequestdata",normalizedTitle:"getrequestdata",charIndex:1053},{level:3,title:"setIsEnd",slug:"setisend",normalizedTitle:"setisend",charIndex:613},{level:3,title:"getTag",slug:"gettag",normalizedTitle:"gettag",charIndex:1284},{level:3,title:"invoke和invoke2Response",slug:"invoke和invoke2response",normalizedTitle:"invoke和invoke2response",charIndex:1328},{level:2,title:"@LiteflowComponent",slug:"liteflowcomponent",normalizedTitle:"@liteflowcomponent",charIndex:58}],headersStr:"可以覆盖的方法 isAccess isContinueOnError isEnd beforeProcess和afterProcess onSuccess和onError rollback This关键字可以调用的方法 获取上下文 getNodeId getName getChainName getRequestData setIsEnd getTag invoke和invoke2Response @LiteflowComponent",content:'普通组件节点需要继承NodeComponent，可用于THEN和WHEN关键字中。\n\n需要实现process方法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n提示\n\n@LiteflowComponent继承自@Component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@LiteflowComponent的参数a，就是你在写EL规则时需要用到组件ID。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isAccess\n\n推荐实现isAccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# isContinueOnError\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isEnd\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# beforeProcess和afterProcess\n\n流程的前置和后置处理器，其中前置处理器，在isAccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onSuccess和onError\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# rollback\n\n流程失败后的回滚方法，详情请参考组件回滚。\n\n\n# This关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getContextBean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getNodeId\n\n获取组件ID。\n\n\n# getName\n\n获取组件别名。\n\n\n# getChainName\n\n获取当前执行的流程名称。\n\n\n# getRequestData\n\n获取流程的初始参数。\n\n\n# setIsEnd\n\n表示是否立即结束整个流程 ，用法为this.setIsEnd(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# getTag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2Response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @LiteflowComponent\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'普通组件节点需要继承nodecomponent，可用于then和when关键字中。\n\n需要实现process方法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n提示\n\n@liteflowcomponent继承自@component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@liteflowcomponent的参数a，就是你在写el规则时需要用到组件id。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isaccess\n\n推荐实现isaccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# iscontinueonerror\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isend\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# beforeprocess和afterprocess\n\n流程的前置和后置处理器，其中前置处理器，在isaccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onsuccess和onerror\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# rollback\n\n流程失败后的回滚方法，详情请参考组件回滚。\n\n\n# this关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getcontextbean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getnodeid\n\n获取组件id。\n\n\n# getname\n\n获取组件别名。\n\n\n# getchainname\n\n获取当前执行的流程名称。\n\n\n# getrequestdata\n\n获取流程的初始参数。\n\n\n# setisend\n\n表示是否立即结束整个流程 ，用法为this.setisend(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# gettag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @liteflowcomponent\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"轮询模式配置",frontmatter:{title:"轮询模式配置",date:"2023-08-23T19:55:26.000Z",permalink:"/pages/v2.11.X/186747/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/066.%F0%9F%93%91Redis%E9%85%8D%E7%BD%AE%E6%BA%90/020.%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/066.📑Redis配置源/020.轮询模式配置.md",key:"v-170e5d3c",path:"/pages/v2.11.X/186747/",headers:[{level:2,title:"工作原理",slug:"工作原理",normalizedTitle:"工作原理",charIndex:28},{level:2,title:"配置参数",slug:"配置参数",normalizedTitle:"配置参数",charIndex:485},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:1482},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:2043},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:2817},{level:2,title:"模式优缺点",slug:"模式优缺点",normalizedTitle:"模式优缺点",charIndex:2896},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:3165}],headersStr:"工作原理 配置参数 配置说明 存储数据说明 自动刷新 模式优缺点 小例子",content:'Redis配置源的规则刷新机制默认为轮询模式。\n\n\n# 工作原理\n\n轮询模式以 定时拉取 的方式进行规则数据刷新。\n\n在拉取方式的具体设计上主要考虑到两个因素。其一，若每次去Redis中拉取规则数据，需要再次解析和编译，会对框架性能造成很大影响； 其二，大部分时间拉取的数据并无变化，无用功较多。\n\n考虑到如上两个问题，轮询模式数据拉取的工作方式设定为：\n\n> 1、首次在Redis中获取数据后，将数据以KV结构缓存到本地，key为chainId/scriptId (以下简称数据Id)，value为数据的指纹值 (SHA-1值)。相较于原始数据，指纹值数据量小，缓存占用空间可忽略不计。\n> \n> \n> 2、此后的每次轮询中，无需拉取全部数据，而是在Redis端调用脚本计算当前数据的指纹值，仅传输数据Id及对应指纹值。\n> \n> \n> 3、将拉取获得的最新指纹值与本地缓存的指纹值对比，对于发生变化的数据，针对性地根据数据Id从Redis中获取最新数据值，更新规则元数据，同时更新本地缓存指纹值。\n\n以上设定中，首次轮询起始时间、轮询时间间隔均可自由配置。\n\n\n# 配置参数\n\nRedis配置源支持单点和哨兵两种模式。轮询模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redisMode: sentinel\n    masterName: mymaster\n    sentinelAddress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    mode: poll\n    pollingInterval: 60\n    pollingStartTime: 60\n    chainDataBase: 1\n    chainKey: chainKey\n    #如果你没有脚本组件，以下可以不配置\n    scriptDataBase: 1\n    scriptKey: scriptKey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redisMode":"sentinel",\\\n      "masterName":"mymaster",\\\n      "sentinelAddress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"poll",\\\n      "pollingInterval":60,\\\n      "pollingStartTime":60,\\\n      "chainDataBase":1,\\\n      "chainKey":"chainKey",\\\n      "scriptDataBase":1,\\\n      "scriptKey":"scriptKey"\\\n}\n\n\n\n# 配置说明\n\n配置项                说明\nredisMode          Redis模式，single为单点，sentinel为哨兵，默认为单点\nhost               单点模式Redis连接IP地址\nport               单点模式Redis连接端口号\nmasterName         哨兵模式主节点名\nsentinelAddress    哨兵模式哨兵节点连接地址 ip:port\nusername           Redis的用户名 (Redis 6.0及以上)\npassword           Redis的密码\nmode               规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchainDataBase      规则数据的数据库号\nchainKey           规则数据的Redis key名\nscriptDataBase     脚本组件的数据库号\nscriptKey          脚本组件的Redis key名\npollingInterval    轮询时间间隔(s)，默认为60s\npollingStartTime   规则配置后首次轮询的起始时间(s)，默认为60s\n\n\n# 存储数据说明\n\n提示\n\n在轮询模式中，规则和脚本数据均以Redis Hash结构存储，配置项chainKey和scriptKey即为该Hash的名字。\n\n你可以在redis UI客户端直接存入数据，如果使用redis client框架以代码的方式存入时，一定要注意编码，比如以Redisson存储规则时，一定要设置Codec为StringCodec。\n\n对于规则来说，你在Redis中需要为规则单独创建一个Hash类型的数据，这个Hash内的每个键值对就是一个规则，Hash内的field为chainId，value为单纯的EL（THEN(a,b,c)）。\n\n假设你的规则Hash数据键名为:chains，那么配置形式样例如下：\n\nREDIS HASHKEY：CHAINS   \nchain1                 THEN(a, b, c);\nchain2                 IF(x, b).ELIF(y, c).ELSE(d);\n\n对于脚本来说，Hash中的field有固定格式：脚本组件ID:脚本类型:脚本名称[:脚本语言]，value为脚本数据。\n\n假设你的脚本Hash数据键名为:scripts，那么配置形式样例如下：\n\nREDIS HASHKEY：SCRIPTS   \ns1:script:脚本组件1         defaultContext.setData("s1","hello")\ns2:script:脚本组件2:js      defaultContext.setData("s2","hello")\ns3:if_script:脚本组件3      if(a > 100){return true;}else{return false;}\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n\n# 自动刷新\n\n使用了此Redis配置源插件的轮询模式，凡是在配置的Redis键内的数据改动，会依据设定的轮询参数定期拉取并更新数据，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，轮询模式在性能方面做出了权衡：\n\n> 【优势】\n> \n>  * 能做到按需拉取真实数据，缓存占用空间小；\n>  * 计算脚本预先缓存到服务端，不影响Redis服务端性能；\n>  * 基于Redis原生Hash结构存储，可通过任意客户端或命令行操作数据。\n> \n> 【劣势】\n> \n>  * 受轮询间隔限制，数据更新不实时；\n>  * 客户端定时轮询存在性能消耗，但仅做指纹值对比，传输数据量小，实际性能影响很小。\n\n如果对数据数据延迟容忍度高，且希望Redis客户端不受限的情况下，推荐采用轮询模式。\n\n\n# 小例子\n\n为了让大家能简单上手Redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'redis配置源的规则刷新机制默认为轮询模式。\n\n\n# 工作原理\n\n轮询模式以 定时拉取 的方式进行规则数据刷新。\n\n在拉取方式的具体设计上主要考虑到两个因素。其一，若每次去redis中拉取规则数据，需要再次解析和编译，会对框架性能造成很大影响； 其二，大部分时间拉取的数据并无变化，无用功较多。\n\n考虑到如上两个问题，轮询模式数据拉取的工作方式设定为：\n\n> 1、首次在redis中获取数据后，将数据以kv结构缓存到本地，key为chainid/scriptid (以下简称数据id)，value为数据的指纹值 (sha-1值)。相较于原始数据，指纹值数据量小，缓存占用空间可忽略不计。\n> \n> \n> 2、此后的每次轮询中，无需拉取全部数据，而是在redis端调用脚本计算当前数据的指纹值，仅传输数据id及对应指纹值。\n> \n> \n> 3、将拉取获得的最新指纹值与本地缓存的指纹值对比，对于发生变化的数据，针对性地根据数据id从redis中获取最新数据值，更新规则元数据，同时更新本地缓存指纹值。\n\n以上设定中，首次轮询起始时间、轮询时间间隔均可自由配置。\n\n\n# 配置参数\n\nredis配置源支持单点和哨兵两种模式。轮询模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redismode: sentinel\n    mastername: mymaster\n    sentineladdress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    mode: poll\n    pollinginterval: 60\n    pollingstarttime: 60\n    chaindatabase: 1\n    chainkey: chainkey\n    #如果你没有脚本组件，以下可以不配置\n    scriptdatabase: 1\n    scriptkey: scriptkey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redismode":"sentinel",\\\n      "mastername":"mymaster",\\\n      "sentineladdress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"poll",\\\n      "pollinginterval":60,\\\n      "pollingstarttime":60,\\\n      "chaindatabase":1,\\\n      "chainkey":"chainkey",\\\n      "scriptdatabase":1,\\\n      "scriptkey":"scriptkey"\\\n}\n\n\n\n# 配置说明\n\n配置项                说明\nredismode          redis模式，single为单点，sentinel为哨兵，默认为单点\nhost               单点模式redis连接ip地址\nport               单点模式redis连接端口号\nmastername         哨兵模式主节点名\nsentineladdress    哨兵模式哨兵节点连接地址 ip:port\nusername           redis的用户名 (redis 6.0及以上)\npassword           redis的密码\nmode               规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchaindatabase      规则数据的数据库号\nchainkey           规则数据的redis key名\nscriptdatabase     脚本组件的数据库号\nscriptkey          脚本组件的redis key名\npollinginterval    轮询时间间隔(s)，默认为60s\npollingstarttime   规则配置后首次轮询的起始时间(s)，默认为60s\n\n\n# 存储数据说明\n\n提示\n\n在轮询模式中，规则和脚本数据均以redis hash结构存储，配置项chainkey和scriptkey即为该hash的名字。\n\n你可以在redis ui客户端直接存入数据，如果使用redis client框架以代码的方式存入时，一定要注意编码，比如以redisson存储规则时，一定要设置codec为stringcodec。\n\n对于规则来说，你在redis中需要为规则单独创建一个hash类型的数据，这个hash内的每个键值对就是一个规则，hash内的field为chainid，value为单纯的el（then(a,b,c)）。\n\n假设你的规则hash数据键名为:chains，那么配置形式样例如下：\n\nredis hashkey：chains   \nchain1                 then(a, b, c);\nchain2                 if(x, b).elif(y, c).else(d);\n\n对于脚本来说，hash中的field有固定格式：脚本组件id:脚本类型:脚本名称[:脚本语言]，value为脚本数据。\n\n假设你的脚本hash数据键名为:scripts，那么配置形式样例如下：\n\nredis hashkey：scripts   \ns1:script:脚本组件1         defaultcontext.setdata("s1","hello")\ns2:script:脚本组件2:js      defaultcontext.setdata("s2","hello")\ns3:if_script:脚本组件3      if(a > 100){return true;}else{return false;}\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n\n# 自动刷新\n\n使用了此redis配置源插件的轮询模式，凡是在配置的redis键内的数据改动，会依据设定的轮询参数定期拉取并更新数据，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，轮询模式在性能方面做出了权衡：\n\n> 【优势】\n> \n>  * 能做到按需拉取真实数据，缓存占用空间小；\n>  * 计算脚本预先缓存到服务端，不影响redis服务端性能；\n>  * 基于redis原生hash结构存储，可通过任意客户端或命令行操作数据。\n> \n> 【劣势】\n> \n>  * 受轮询间隔限制，数据更新不实时；\n>  * 客户端定时轮询存在性能消耗，但仅做指纹值对比，传输数据量小，实际性能影响很小。\n\n如果对数据数据延迟容忍度高，且希望redis客户端不受限的情况下，推荐采用轮询模式。\n\n\n# 小例子\n\n为了让大家能简单上手redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"订阅模式配置",frontmatter:{title:"订阅模式配置",date:"2023-08-28T00:31:38.000Z",permalink:"/pages/v2.11.X/3f553f/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/066.%F0%9F%93%91Redis%E9%85%8D%E7%BD%AE%E6%BA%90/030.%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE.html",relativePath:"08.v2.11.X文档/050.🗂规则文件/066.📑Redis配置源/030.订阅模式配置.md",key:"v-129c0d43",path:"/pages/v2.11.X/3f553f/",headers:[{level:2,title:"工作原理",slug:"工作原理",normalizedTitle:"工作原理",charIndex:37},{level:2,title:"配置参数",slug:"配置参数",normalizedTitle:"配置参数",charIndex:1},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:1329},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:1797},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:2610},{level:2,title:"模式优缺点",slug:"模式优缺点",normalizedTitle:"模式优缺点",charIndex:2696},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:2890}],headersStr:"工作原理 配置参数 配置说明 存储数据说明 自动刷新 模式优缺点 小例子",content:'在配置参数中添加mode:sub，可将规则刷新机制选为订阅模式。\n\n\n# 工作原理\n\n订阅模式基于Pub/Sub机制，依赖于Redisson中RMapCache结构的监听功能。\n\n考虑到轮询模式无法保证规则刷新的实时性，因此提供订阅模式的刷新机制，即客户端修改数据后发送一个事件，LiteFlow订阅到该事件后进行数据刷新。\n\n> 基于Pub/Sub机制，若采用Redis原生Hash结构，则修改数据方需要增加额外的开发成本来发送事件。 为降低用户修改规则的开发成本，Redis配置源的订阅模式选择采用Redisson的RMapCache结构。\n> \n> \n> RMapCache可看作自带监听功能的Redis Hash结构，其底层通过创建额外的Key和Lua脚本，自动使用Pub/Sub来实现监听机制。\n\n需要注意的是，由于Redisson对RMapCache结构中的field和value进行了改动，并非纯文本。故对数据的读取和修改均只能使用Redisson客户端进行。\n\n\n# 配置参数\n\nRedis配置源支持单点和哨兵两种模式。订阅模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redisMode: sentinel\n    masterName: mymaster\n    sentinelAddress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    mode: sub\n    chainDataBase: 1\n    chainKey: chainKey\n    #如果你没有脚本组件，以下可以不配置\n    scriptDataBase: 1\n    scriptKey: scriptKey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redisMode":"sentinel",\\\n      "masterName":"mymaster",\\\n      "sentinelAddress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"sub",\\\n      "chainDataBase":1,\\\n      "chainKey":"chainKey",\\\n      "scriptDataBase":1,\\\n      "scriptKey":"scriptKey"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nredisMode         Redis模式，single为单点，sentinel为哨兵，默认为单点\nhost              单点模式Redis连接IP地址\nport              单点模式Redis连接端口号\nmasterName        哨兵模式主节点名\nsentinelAddress   哨兵模式哨兵节点连接地址 ip:port\nusername          Redis的用户名 (Redis 6.0及以上)\npassword          Redis的密码\nmode              规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchainDataBase     规则数据的数据库号\nchainKey          规则数据的Redis key名\nscriptDataBase    脚本组件的数据库号\nscriptKey         脚本组件的Redis key名\n\n\n# 存储数据说明\n\n提示\n\n在订阅模式中，规则和脚本数据均以Redisson RMapCache结构存储，配置项chainKey和scriptKey即为该RMapCache的名字。\n\n对于规则来说，你需要使用Redisson客户端，为规则单独创建一个RMapCache类型的数据，这个结构内的每个键值对就是一个规则，RMapCache内的key为chainId，value为单纯的EL（THEN(a,b,c)）。\n\n假设你的规则RMapCache数据键名为:chains，那么利用Redisson客户端的数据操作如下：\n\nRMapCache<String, String> chains = redissonClient.getMapCache("chains");\nchains.put("chain1", "THEN(a, b, c);");\nchains.put("chain2", "IF(x, b).ELIF(y, c).ELSE(d);");\n\n\n对于脚本来说，RMapCache中的key有固定格式：脚本组件ID:脚本类型:脚本名称[:脚本语言]，value为脚本数据。\n\n假设你的脚本RMapCache数据键名为:scripts，那么利用Redisson客户端的数据操作如下：\n\nRMapCache<String, String> scripts = redissonClient.getMapCache("scripts");\nscripts.put("s1:script:脚本组件1", "defaultContext.setData(\\"test1\\",\\"hello\\");");\nscripts.put("s2:script:脚本组件2:js", "defaultContext.setData(\\"test2\\",\\"hello\\");");\n\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此Redis配置源插件的订阅模式，凡是在配置的RMapCache对象内的数据改动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，订阅模式有如下优势和局限性：\n\n> 【优势】\n> \n>  * 数据刷新实时性高；\n>  * 能够做到按需刷新，不产生额外的通知成本；\n>  * 监听性能较高。\n> \n> 【劣势】\n> \n>  * 基于独有数据结构，Redis客户端只能使用Redisson。\n\n如果对数据数据延迟容忍度低，希望保证实时性，且接受使用Redisson，推荐采用订阅模式。\n\n\n# 小例子\n\n为了让大家能简单上手Redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'在配置参数中添加mode:sub，可将规则刷新机制选为订阅模式。\n\n\n# 工作原理\n\n订阅模式基于pub/sub机制，依赖于redisson中rmapcache结构的监听功能。\n\n考虑到轮询模式无法保证规则刷新的实时性，因此提供订阅模式的刷新机制，即客户端修改数据后发送一个事件，liteflow订阅到该事件后进行数据刷新。\n\n> 基于pub/sub机制，若采用redis原生hash结构，则修改数据方需要增加额外的开发成本来发送事件。 为降低用户修改规则的开发成本，redis配置源的订阅模式选择采用redisson的rmapcache结构。\n> \n> \n> rmapcache可看作自带监听功能的redis hash结构，其底层通过创建额外的key和lua脚本，自动使用pub/sub来实现监听机制。\n\n需要注意的是，由于redisson对rmapcache结构中的field和value进行了改动，并非纯文本。故对数据的读取和修改均只能使用redisson客户端进行。\n\n\n# 配置参数\n\nredis配置源支持单点和哨兵两种模式。订阅模式下配置参数如下：\n\nliteflow:\n  rule-source-ext-data-map:\n    #单点模式配置如下两项\n    host: 127.0.0.1\n    port: 6379\n    #哨兵模式配置如下三项\n    redismode: sentinel\n    mastername: mymaster\n    sentineladdress: [127.0.0.1:26389, 127.0.0.1:26379]\n    #如果你没有用户名或密码可以不配置\n    username: root\n    password: 123456\n    mode: sub\n    chaindatabase: 1\n    chainkey: chainkey\n    #如果你没有脚本组件，以下可以不配置\n    scriptdatabase: 1\n    scriptkey: scriptkey\n\n\nliteflow.rule-source-ext-data={\\\n      \\# 单点模式配置如下两项\\\n      "host":"127.0.0.1",\\\n      "port":6379,\\\n      \\# 哨兵模式配置如下三项\\\n      "redismode":"sentinel",\\\n      "mastername":"mymaster",\\\n      "sentineladdress":["127.0.0.1:26389","127.0.0.1:26379"],\\\n      "username":"root",\\\n      "password":"123456",\\\n      "mode":"sub",\\\n      "chaindatabase":1,\\\n      "chainkey":"chainkey",\\\n      "scriptdatabase":1,\\\n      "scriptkey":"scriptkey"\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nredismode         redis模式，single为单点，sentinel为哨兵，默认为单点\nhost              单点模式redis连接ip地址\nport              单点模式redis连接端口号\nmastername        哨兵模式主节点名\nsentineladdress   哨兵模式哨兵节点连接地址 ip:port\nusername          redis的用户名 (redis 6.0及以上)\npassword          redis的密码\nmode              规则刷新模式，poll为轮询，sub/subscribe为订阅，默认为轮询\nchaindatabase     规则数据的数据库号\nchainkey          规则数据的redis key名\nscriptdatabase    脚本组件的数据库号\nscriptkey         脚本组件的redis key名\n\n\n# 存储数据说明\n\n提示\n\n在订阅模式中，规则和脚本数据均以redisson rmapcache结构存储，配置项chainkey和scriptkey即为该rmapcache的名字。\n\n对于规则来说，你需要使用redisson客户端，为规则单独创建一个rmapcache类型的数据，这个结构内的每个键值对就是一个规则，rmapcache内的key为chainid，value为单纯的el（then(a,b,c)）。\n\n假设你的规则rmapcache数据键名为:chains，那么利用redisson客户端的数据操作如下：\n\nrmapcache<string, string> chains = redissonclient.getmapcache("chains");\nchains.put("chain1", "then(a, b, c);");\nchains.put("chain2", "if(x, b).elif(y, c).else(d);");\n\n\n对于脚本来说，rmapcache中的key有固定格式：脚本组件id:脚本类型:脚本名称[:脚本语言]，value为脚本数据。\n\n假设你的脚本rmapcache数据键名为:scripts，那么利用redisson客户端的数据操作如下：\n\nrmapcache<string, string> scripts = redissonclient.getmapcache("scripts");\nscripts.put("s1:script:脚本组件1", "defaultcontext.setdata(\\"test1\\",\\"hello\\");");\nscripts.put("s2:script:脚本组件2:js", "defaultcontext.setdata(\\"test2\\",\\"hello\\");");\n\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此redis配置源插件的订阅模式，凡是在配置的rmapcache对象内的数据改动，会自动推送到业务系统，进行实时的平滑热刷新，你无需做任何事情。\n\n\n# 模式优缺点\n\n根据工作原理，订阅模式有如下优势和局限性：\n\n> 【优势】\n> \n>  * 数据刷新实时性高；\n>  * 能够做到按需刷新，不产生额外的通知成本；\n>  * 监听性能较高。\n> \n> 【劣势】\n> \n>  * 基于独有数据结构，redis客户端只能使用redisson。\n\n如果对数据数据延迟容忍度低，希望保证实时性，且接受使用redisson，推荐采用订阅模式。\n\n\n# 小例子\n\n为了让大家能简单上手redis规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换redis的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"✂️选择组件",frontmatter:{title:"✂️选择组件",date:"2022-06-29T17:58:54.000Z",permalink:"/pages/v2.11.X/c0f5d7/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/020.%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/055.🔗常规组件/020.选择组件.md",key:"v-06e77438",path:"/pages/v2.11.X/c0f5d7/",headers:[{level:2,title:"根据nodeId进行选择",slug:"根据nodeid进行选择",normalizedTitle:"根据nodeid进行选择",charIndex:153},{level:2,title:"根据表达式的id进行选择",slug:"根据表达式的id进行选择",normalizedTitle:"根据表达式的id进行选择",charIndex:496},{level:2,title:"根据tag进行选择",slug:"根据tag进行选择",normalizedTitle:"根据tag进行选择",charIndex:882},{level:2,title:"表达式tag的选择",slug:"表达式tag的选择",normalizedTitle:"表达式tag的选择",charIndex:2367},{level:2,title:"链路tag的选择",slug:"链路tag的选择",normalizedTitle:"链路tag的选择",charIndex:2522}],headersStr:"根据nodeId进行选择 根据表达式的id进行选择 根据tag进行选择 表达式tag的选择 链路tag的选择",content:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于SWITCH关键字中。\n\n关于SWITCH表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承NodeSwitchComponent。\n\n需要实现方法processSwitch方法。\n\n\n# 根据nodeId进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c);\n</chain>\n\n\n这个方法需要返回String类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, WHEN(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nLiteFlow从v2.9.0开始支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    THEN(\n        a,\n        SWITCH(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class GSwitchCmp extends NodeSwitchComponent {\n\n\t@Override\n\tpublic String processSwitch() throws Exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetId是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetId是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetId是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetId是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetId是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetId是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetId是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetId是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 表达式tag的选择\n\nLiteFlow从v2.10.2开始，支持了表达式的tag选择，比如：\n\n<chain name="chain1">\n    SWITCH(a).to(b, WHEN(c,d).tag("w1"));\n</chain>\n\n\na中返回tag:w1或者:w1就能选择到后面的表达式。\n\n\n# 链路tag的选择\n\nLiteFlow从v2.10.3开始，支持了链路tag的选择，比如：\n\n<chain name="chain1">\n    SWITCH(a).to(b, sub.tag("w1"));\n</chain>\n\n<chain name="sub">\n    THEN(c,d);\n</chain>\n\n\n事实上，a无论返回sub还是tag:w1都能选择到后面的链路。',normalizedContent:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于switch关键字中。\n\n关于switch表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承nodeswitchcomponent。\n\n需要实现方法processswitch方法。\n\n\n# 根据nodeid进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, c);\n</chain>\n\n\n这个方法需要返回string类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, when(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nliteflow从v2.9.0开始支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    then(\n        a,\n        switch(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class gswitchcmp extends nodeswitchcomponent {\n\n\t@override\n\tpublic string processswitch() throws exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetid是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetid是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetid是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetid是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetid是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetid是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetid是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetid是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 表达式tag的选择\n\nliteflow从v2.10.2开始，支持了表达式的tag选择，比如：\n\n<chain name="chain1">\n    switch(a).to(b, when(c,d).tag("w1"));\n</chain>\n\n\na中返回tag:w1或者:w1就能选择到后面的表达式。\n\n\n# 链路tag的选择\n\nliteflow从v2.10.3开始，支持了链路tag的选择，比如：\n\n<chain name="chain1">\n    switch(a).to(b, sub.tag("w1"));\n</chain>\n\n<chain name="sub">\n    then(c,d);\n</chain>\n\n\n事实上，a无论返回sub还是tag:w1都能选择到后面的链路。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬次数循环组件",frontmatter:{title:"🧬次数循环组件",date:"2022-10-06T15:04:44.000Z",permalink:"/pages/v2.11.X/5f971f/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/040.%E6%AC%A1%E6%95%B0%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/055.🔗常规组件/040.次数循环组件.md",key:"v-11d57881",path:"/pages/v2.11.X/5f971f/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"循环下标获取",slug:"循环下标获取",normalizedTitle:"循环下标获取",charIndex:446}],headersStr:"用法 循环下标获取",content:'# 用法\n\nLiteFlow从v2.9.0开始，提供了次数循环组件。返回的是一个int值的循环次数。 主要用于FOR...DO...表达式。\n\n关于FOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\nf节点的定义，需要继承NodeForComponent，需要实现processFor方法：\n\n@LiteflowComponent("f")\npublic class FCmp extends NodeForComponent {\n    @Override\n    public int processFor() throws Exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字FOR...DO...中DO里面的任意java组件都可以通过this.getLoopIndex()来获得下标。\n\n在脚本中通过_meta.loopIndex来获取。',normalizedContent:'# 用法\n\nliteflow从v2.9.0开始，提供了次数循环组件。返回的是一个int值的循环次数。 主要用于for...do...表达式。\n\n关于for...do...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\nf节点的定义，需要继承nodeforcomponent，需要实现processfor方法：\n\n@liteflowcomponent("f")\npublic class fcmp extends nodeforcomponent {\n    @override\n    public int processfor() throws exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字for...do...中do里面的任意java组件都可以通过this.getloopindex()来获得下标。\n\n在脚本中通过_meta.loopindex来获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⛓条件循环组件",frontmatter:{title:"⛓条件循环组件",date:"2022-10-06T17:11:06.000Z",permalink:"/pages/v2.11.X/e6995e/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/050.%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/055.🔗常规组件/050.条件循环组件.md",key:"v-034193f0",path:"/pages/v2.11.X/e6995e/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"循环下标获取",slug:"循环下标获取",normalizedTitle:"循环下标获取",charIndex:446}],headersStr:"用法 循环下标获取",content:'# 用法\n\nLiteFlow从v2.9.0开始，支持了条件循环组件，主要用于WHILE...DO...表达式。\n\n关于WHILE...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行条件循环操作，可以如下定义：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b));\n</chain>\n\n\nw节点的定义，需要继承NodeWhileComponent，需要实现processWhile方法：\n\n@LiteflowComponent("w")\npublic class WCmp extends NodeWhileComponent {\n    @Override\n    public boolean processWhile() throws Exception {\n        //这里根据业务去返回while的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字WHILE...DO...中DO里面的任意节点都可以通过this.getLoopIndex()来获得下标。\n\n在脚本中通过_meta.loopIndex来获取。',normalizedContent:'# 用法\n\nliteflow从v2.9.0开始，支持了条件循环组件，主要用于while...do...表达式。\n\n关于while...do...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行条件循环操作，可以如下定义：\n\n<chain name="chain1">\n    while(w).do(then(a, b));\n</chain>\n\n\nw节点的定义，需要继承nodewhilecomponent，需要实现processwhile方法：\n\n@liteflowcomponent("w")\npublic class wcmp extends nodewhilecomponent {\n    @override\n    public boolean processwhile() throws exception {\n        //这里根据业务去返回while的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字while...do...中do里面的任意节点都可以通过this.getloopindex()来获得下标。\n\n在脚本中通过_meta.loopindex来获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📌条件组件",frontmatter:{title:"📌条件组件",date:"2022-08-26T12:25:04.000Z",permalink:"/pages/v2.11.X/cb0b59/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/030.%E6%9D%A1%E4%BB%B6%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/055.🔗常规组件/030.条件组件.md",key:"v-1a462536",path:"/pages/v2.11.X/cb0b59/",headersStr:null,content:'LiteFlow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为IF组件，返回是一个true/false。可用于IF...ELIF...ELSE等关键字。\n\n关于IF...ELIF...ELSE表达式的用法，可以参考条件编排这一章。\n\n比如一个IF三元表达式，如下所示，x就是IF组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承NodeIfComponent：\n\n@Component("x")\npublic class XCmp extends NodeIfComponent {\n\t@Override\n\tpublic boolean processIf() throws Exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为if组件，返回是一个true/false。可用于if...elif...else等关键字。\n\n关于if...elif...else表达式的用法，可以参考条件编排这一章。\n\n比如一个if三元表达式，如下所示，x就是if组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承nodeifcomponent：\n\n@component("x")\npublic class xcmp extends nodeifcomponent {\n\t@override\n\tpublic boolean processif() throws exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧿退出循环组件",frontmatter:{title:"🧿退出循环组件",date:"2022-10-06T17:11:27.000Z",permalink:"/pages/v2.11.X/c078cd/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/060.%E9%80%80%E5%87%BA%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/055.🔗常规组件/060.退出循环组件.md",key:"v-6b3ab58c",path:"/pages/v2.11.X/c078cd/",headersStr:null,content:'LiteFlow从v2.9.0开始，提供了退出循环组件。返回的是一个布尔值的循环次数。 主要用于FOR...DO...BREAK,WHILE...DO...BREAK,ITERATOR...DO...BREAK表达式。\n\n关于这两种表达式的用法，可以参考循环编排这一章。\n\n比如要对某一个循环操作进行退出的编排，可以如此定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n或者\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\nc节点的定义，需要继承NodeBreakComponent，需要实现processBreak方法：\n\n@LiteflowComponent("c")\npublic class CCmp extends NodeBreakComponent {\n    @Override\n    public boolean processBreak() throws Exception {\n        //这里根据业务去返回break的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'liteflow从v2.9.0开始，提供了退出循环组件。返回的是一个布尔值的循环次数。 主要用于for...do...break,while...do...break,iterator...do...break表达式。\n\n关于这两种表达式的用法，可以参考循环编排这一章。\n\n比如要对某一个循环操作进行退出的编排，可以如此定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b)).break(c);\n</chain>\n\n\n或者\n\n<chain name="chain1">\n    while(w).do(then(a, b)).break(c);\n</chain>\n\n\nc节点的定义，需要继承nodebreakcomponent，需要实现processbreak方法：\n\n@liteflowcomponent("c")\npublic class ccmp extends nodebreakcomponent {\n    @override\n    public boolean processbreak() throws exception {\n        //这里根据业务去返回break的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⌛️迭代循环组件",frontmatter:{title:"⌛️迭代循环组件",date:"2023-02-09T10:40:52.000Z",permalink:"/pages/v2.11.X/64262b/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/055.%E8%BF%AD%E4%BB%A3%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/055.🔗常规组件/055.迭代循环组件.md",key:"v-0cd16e12",path:"/pages/v2.11.X/64262b/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"迭代对象的获取",slug:"迭代对象的获取",normalizedTitle:"迭代对象的获取",charIndex:559}],headersStr:"用法 迭代对象的获取",content:'# 用法\n\nLiteFlow从v2.9.7开始，支持了迭代循环组件，相当于Java语言的Iterator关键字，主要用于ITERATOR...DO...表达式。\n\n关于ITERATOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\nx节点的定义，需要继承NodeIteratorComponent，需要实现processIterator方法：\n\n@LiteflowComponent("x")\npublic class XCmp extends NodeIteratorComponent {\n    @Override\n    public Iterator<?> processIterator() throws Exception {\n        List<String> list = ListUtil.toList("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 迭代对象的获取\n\n关键字ITERATOR...DO...中DO里面所有的节点都可以通过this.getCurrLoopObj()获得迭代循环的当前对象。\n\n在脚本中通过_meta.loopObject来获取。',normalizedContent:'# 用法\n\nliteflow从v2.9.7开始，支持了迭代循环组件，相当于java语言的iterator关键字，主要用于iterator...do...表达式。\n\n关于iterator...do...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\nx节点的定义，需要继承nodeiteratorcomponent，需要实现processiterator方法：\n\n@liteflowcomponent("x")\npublic class xcmp extends nodeiteratorcomponent {\n    @override\n    public iterator<?> processiterator() throws exception {\n        list<string> list = listutil.tolist("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 迭代对象的获取\n\n关键字iterator...do...中do里面所有的节点都可以通过this.getcurrloopobj()获得迭代循环的当前对象。\n\n在脚本中通过_meta.loopobject来获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-29T15:30:16.000Z",permalink:"/pages/v2.11.X/16eca9/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/010.%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/010.说明.md",key:"v-03922cfd",path:"/pages/v2.11.X/16eca9/",headersStr:null,content:"在本章，将说明如何撰写规则表达式。\n\nLiteFlow在2.8.X版本中设计了非常强大的规则表达式。一切复杂的流程在LiteFlow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",normalizedContent:"在本章，将说明如何撰写规则表达式。\n\nliteflow在2.8.x版本中设计了非常强大的规则表达式。一切复杂的流程在liteflow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎋并行编排",frontmatter:{title:"🎋并行编排",date:"2022-06-29T16:46:16.000Z",permalink:"/pages/v2.11.X/b3446a/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/030.%E5%B9%B6%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/030.并行编排.md",key:"v-4e239d24",path:"/pages/v2.11.X/b3446a/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:2},{level:2,title:"和串行嵌套起来(一)",slug:"和串行嵌套起来-一",normalizedTitle:"和串行嵌套起来(一)",charIndex:152},{level:2,title:"和串行嵌套起来(二)",slug:"和串行嵌套起来-二",normalizedTitle:"和串行嵌套起来(二)",charIndex:327},{level:2,title:"忽略错误",slug:"忽略错误",normalizedTitle:"忽略错误",charIndex:470},{level:2,title:"任一节点先执行完则忽略其他",slug:"任一节点先执行完则忽略其他",normalizedTitle:"任一节点先执行完则忽略其他",charIndex:684},{level:2,title:"指定任意节点先执行完则忽略其他",slug:"指定任意节点先执行完则忽略其他",normalizedTitle:"指定任意节点先执行完则忽略其他",charIndex:930},{level:2,title:"开启WHEN线程池隔离",slug:"开启when线程池隔离",normalizedTitle:"开启when线程池隔离",charIndex:1507},{level:2,title:"关于组的概念",slug:"关于组的概念",normalizedTitle:"关于组的概念",charIndex:1802}],headersStr:"最基本的例子 和串行嵌套起来(一) 和串行嵌套起来(二) 忽略错误 任一节点先执行完则忽略其他 指定任意节点先执行完则忽略其他 开启WHEN线程池隔离 关于组的概念",content:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用WHEN关键字，需要注意的是，WHEN必须大写。\n\n提示\n\n从v2.11.4开始，你也可以用PAR关键字，和WHEN是等价的。\n\n<chain name="chain1">\n    WHEN(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把THEN和WHEN结合起来用，看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nWHEN关键字提供了一个子关键字ignoreError(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).ignoreError(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nWHEN关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 指定任意节点先执行完则忽略其他\n\nLiteFlow从v2.11.1开始，支持了并行编排中指定节点的执行则忽略其他，WHEN 关键字新增子关键字 must (不可为空)，可用于指定需等待执行的任意节点，可以为 1 个或者多个，若指定的所有节点率先完成，则继续往下执行，忽略同级别的其他任务，用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).must(b, c),\n        f\n    );\n</chain>\n\n\n以上流程中，must指定了b,c，则b，c是一定会被执行完毕了，如果b，c执行完毕了后d还未执行完，则忽略，直接执行下一个组件f。\n\n以上是单节点的用法，must还可以指定一个或多个表达式。比如\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d).id("t1"), e).must(b, "t1"),\n        f\n    );\n</chain>\n\n\n在这个表达式中WHEN里有一个嵌套的THEN，如果需要指定这个表达式，则需要给这个表达式设置一个id，must里需要指定这个id，需要注意的是，must里指定id，需要用引号括起来。\n\n\n# 开启WHEN线程池隔离\n\n目前liteflow设计里when线程池，如果你不单独设置自定义线程池，那么就会用默认的线程池。而这个线程池，是所有的when共同一个。\n\nLiteFlow从2.11.1开始，提供一个liteflow.when-thread-pool-isolate参数，默认为false，如果设为true，则会开启WHEN的线程池隔离机制，这意味着每一个when都会有单独的线程池。这个特性对于运行复杂的嵌套when时是可以提升运行速度的且规避掉一些锁的问题。\n\n你可以如下配置来开启：\n\nliteflow.when-thread-pool-isolate=true\n\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.X版本中，我们去除了组的概念。\n\n用EL表达式，其实你写2个不同的WHEN就是2个组。比如：\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b),\n        WHEN(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',normalizedContent:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用when关键字，需要注意的是，when必须大写。\n\n提示\n\n从v2.11.4开始，你也可以用par关键字，和when是等价的。\n\n<chain name="chain1">\n    when(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把then和when结合起来用，看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nwhen关键字提供了一个子关键字ignoreerror(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).ignoreerror(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nwhen关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 指定任意节点先执行完则忽略其他\n\nliteflow从v2.11.1开始，支持了并行编排中指定节点的执行则忽略其他，when 关键字新增子关键字 must (不可为空)，可用于指定需等待执行的任意节点，可以为 1 个或者多个，若指定的所有节点率先完成，则继续往下执行，忽略同级别的其他任务，用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).must(b, c),\n        f\n    );\n</chain>\n\n\n以上流程中，must指定了b,c，则b，c是一定会被执行完毕了，如果b，c执行完毕了后d还未执行完，则忽略，直接执行下一个组件f。\n\n以上是单节点的用法，must还可以指定一个或多个表达式。比如\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d).id("t1"), e).must(b, "t1"),\n        f\n    );\n</chain>\n\n\n在这个表达式中when里有一个嵌套的then，如果需要指定这个表达式，则需要给这个表达式设置一个id，must里需要指定这个id，需要注意的是，must里指定id，需要用引号括起来。\n\n\n# 开启when线程池隔离\n\n目前liteflow设计里when线程池，如果你不单独设置自定义线程池，那么就会用默认的线程池。而这个线程池，是所有的when共同一个。\n\nliteflow从2.11.1开始，提供一个liteflow.when-thread-pool-isolate参数，默认为false，如果设为true，则会开启when的线程池隔离机制，这意味着每一个when都会有单独的线程池。这个特性对于运行复杂的嵌套when时是可以提升运行速度的且规避掉一些锁的问题。\n\n你可以如下配置来开启：\n\nliteflow.when-thread-pool-isolate=true\n\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.x版本中，我们去除了组的概念。\n\n用el表达式，其实你写2个不同的when就是2个组。比如：\n\n<chain name="chain1">\n    then(\n        when(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    then(\n        when(a, b),\n        when(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌴串行编排",frontmatter:{title:"🌴串行编排",date:"2022-06-29T15:28:24.000Z",permalink:"/pages/v2.11.X/a590ee/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/020.%E4%B8%B2%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/020.串行编排.md",key:"v-95142338",path:"/pages/v2.11.X/a590ee/",headersStr:null,content:'如果你要依次执行a,b,c,d四个组件，你可以用THEN关键字，需要注意的是，THEN必须大写。\n\n提示\n\n从v2.11.4开始，你也可以用SER关键字，和THEN是等价的。\n\n<chain name="chain1">\n    THEN(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    THEN(a, b, THEN(c, d));\n</chain>\n\n\n图示',normalizedContent:'如果你要依次执行a,b,c,d四个组件，你可以用then关键字，需要注意的是，then必须大写。\n\n提示\n\n从v2.11.4开始，你也可以用ser关键字，和then是等价的。\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    then(a, b, then(c, d));\n</chain>\n\n\n图示',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌾选择编排",frontmatter:{title:"🌾选择编排",date:"2022-06-29T17:15:38.000Z",permalink:"/pages/v2.11.X/d90483/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/040.%E9%80%89%E6%8B%A9%E7%BC%96%E6%8E%92.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/040.选择编排.md",key:"v-164de06d",path:"/pages/v2.11.X/d90483/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:164},{level:2,title:"DEFAULT关键字",slug:"default关键字",normalizedTitle:"default关键字",charIndex:273},{level:2,title:"和THEN,WHEN嵌套起来",slug:"和then-when嵌套起来",normalizedTitle:"和then,when嵌套起来",charIndex:487},{level:2,title:"选择编排中的id语法",slug:"选择编排中的id语法",normalizedTitle:"选择编排中的id语法",charIndex:677},{level:2,title:"选择编排中的tag语法",slug:"选择编排中的tag语法",normalizedTitle:"选择编排中的tag语法",charIndex:1271}],headersStr:"最基本的例子 DEFAULT关键字 和THEN,WHEN嵌套起来 选择编排中的id语法 选择编排中的tag语法",content:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入A流程，如果返回结果2，则进入B流程，如果返回结果3，则进入C流程。在有些流程定义中也被定义为排他网关。\n\n这个通过LiteFLow的表达式也非常容易实现，你可以用SWITCH...TO的组合关键字，注意的是SWITCH必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# DEFAULT关键字\n\nLiteFlow从2.9.5开始，对选择编排新增了一个DEFAULT关键字。用法为SWITCH...TO...DEFAULT。\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(x).TO(a, b, c).DEFAULT(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然DEFAULT里面也可以是一个表达式。\n\n\n# 和THEN,WHEN嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(\n            b,\n            SWITCH(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个SWITCH中套THEN和WHEN的例子。\n\n如果你阅读过选择组件这一章，就应该知道，LiteFlow通过选择组件的返回来确定该选择什么。\n\n那么如果SWITCH中套一个THEN，那么选择组件如果要选择这个THEN应该返回什么呢？\n\nLiteFlow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回t1:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        //do your biz\n        return "t1";\n    }\n}\n\n\n\n# 选择编排中的tag语法\n\n事实上，除了给表达式赋值id属性之外，你还可以给表达式赋值tag属性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).tag("t1")\n        ),\n        f\n    );\n</chain>\n\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        return "tag:t1";\n        //以下这种也是可以的\n        return ":t1";\n    }\n}\n\n\n选择组件还有其他返回形式，详情请见选择组件这一章。',normalizedContent:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入a流程，如果返回结果2，则进入b流程，如果返回结果3，则进入c流程。在有些流程定义中也被定义为排他网关。\n\n这个通过liteflow的表达式也非常容易实现，你可以用switch...to的组合关键字，注意的是switch必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    switch(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# default关键字\n\nliteflow从2.9.5开始，对选择编排新增了一个default关键字。用法为switch...to...default。\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(x).to(a, b, c).default(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然default里面也可以是一个表达式。\n\n\n# 和then,when嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            b,\n            switch(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个switch中套then和when的例子。\n\n如果你阅读过选择组件这一章，就应该知道，liteflow通过选择组件的返回来确定该选择什么。\n\n那么如果switch中套一个then，那么选择组件如果要选择这个then应该返回什么呢？\n\nliteflow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回t1:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        //do your biz\n        return "t1";\n    }\n}\n\n\n\n# 选择编排中的tag语法\n\n事实上，除了给表达式赋值id属性之外，你还可以给表达式赋值tag属性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).tag("t1")\n        ),\n        f\n    );\n</chain>\n\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        return "tag:t1";\n        //以下这种也是可以的\n        return ":t1";\n    }\n}\n\n\n选择组件还有其他返回形式，详情请见选择组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵条件编排",frontmatter:{title:"🌵条件编排",date:"2022-08-26T14:13:55.000Z",permalink:"/pages/v2.11.X/e76999/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/045.%E6%9D%A1%E4%BB%B6%E7%BC%96%E6%8E%92.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/045.条件编排.md",key:"v-6203c652",path:"/pages/v2.11.X/e76999/",headers:[{level:2,title:"IF的二元表达式",slug:"if的二元表达式",normalizedTitle:"if的二元表达式",charIndex:206},{level:2,title:"IF的三元表达式",slug:"if的三元表达式",normalizedTitle:"if的三元表达式",charIndex:363},{level:2,title:"ELSE表达式",slug:"else表达式",normalizedTitle:"else表达式",charIndex:529},{level:2,title:"ELIF表达式",slug:"elif表达式",normalizedTitle:"elif表达式",charIndex:707}],headersStr:"IF的二元表达式 IF的三元表达式 ELSE表达式 ELIF表达式",content:'LiteFlow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在LiteFlow EL语法中有一些不一样的用法。\n\n以下IF和ELIF的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# IF的二元表达式\n\n我们先来看IF关键字的二元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# IF的三元表达式\n\n我们接下来再来看IF关键字的三元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# ELSE表达式\n\nLiteFlow也提供了ELSE表达式，IF的二元表达式+ELSE表达式等同于IF三元表达式，比如：\n\n<chain name="chain1">\n    IF(x, a).ELSE(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n\n# ELIF表达式\n\nELIF关键字的用法其实和java语言的else if类似，可以跟多个，和IF二元表达式参数一样，一般最后还会跟个ELSE，用于多重条件的判断：\n\n<chain name="chain1">\n    IF(x1, a).ELIF(x2, b).ELIF(x3, c).ELIF(x4, d).ELSE(THEN(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有IF的二元表达式后面才能跟ELIF，如果IF三元表达式后面跟ELIF，最后一个表达式会被ELIF的表达式覆盖，就比如：\n\n<chain name="chain1">\n    IF(x1, a, b).ELIF(x2, c).ELSE(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实IF三元表达式已经能表达一切的可能了，有多重条件也可以不用ELIF，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    IF(\n        x1,\n        a, \n        IF(\n            x2,\n            b,\n            IF(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用ELIF来代替。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在liteflow el语法中有一些不一样的用法。\n\n以下if和elif的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# if的二元表达式\n\n我们先来看if关键字的二元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# if的三元表达式\n\n我们接下来再来看if关键字的三元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# else表达式\n\nliteflow也提供了else表达式，if的二元表达式+else表达式等同于if三元表达式，比如：\n\n<chain name="chain1">\n    if(x, a).else(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n\n# elif表达式\n\nelif关键字的用法其实和java语言的else if类似，可以跟多个，和if二元表达式参数一样，一般最后还会跟个else，用于多重条件的判断：\n\n<chain name="chain1">\n    if(x1, a).elif(x2, b).elif(x3, c).elif(x4, d).else(then(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有if的二元表达式后面才能跟elif，如果if三元表达式后面跟elif，最后一个表达式会被elif的表达式覆盖，就比如：\n\n<chain name="chain1">\n    if(x1, a, b).elif(x2, c).else(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实if三元表达式已经能表达一切的可能了，有多重条件也可以不用elif，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    if(\n        x1,\n        a, \n        if(\n            x2,\n            b,\n            if(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用elif来代替。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎃捕获异常表达式",frontmatter:{title:"🎃捕获异常表达式",date:"2023-03-16T22:27:28.000Z",permalink:"/pages/v2.11.X/f53b51/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/047.%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/047.捕获异常表达式.md",key:"v-5c3dc76f",path:"/pages/v2.11.X/f53b51/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:42},{level:2,title:"搭配循环使用",slug:"搭配循环使用",normalizedTitle:"搭配循环使用",charIndex:559}],headersStr:"基本用法 搭配循环使用",content:'LiteFlow从2.10.0开始，EL表达式语法中新增了捕获异常的表达式\n\n\n# 基本用法\n\n具体用法为CATCH...DO:\n\n<chain name="chain1">\n    CATCH(\n        THEN(a,b)\n    ).DO(c)\n</chain>\n\n\n上述语法表示，如果a组件出现异常并抛出，则不会执行b组件，会直接执行c组件。\n\n在c组件中，可以通过this.getSlot().getException()来获取异常。\n\n同时，当用了CATCH表达式之后，即便在CATCH包裹的组件有异常抛出，整个流程返回的LiteflowResponse中的isSuccess方法仍然为true，getCause中也没有任何的Exception。如果你写过java程序，应该会对这样的机制很容易理解。因为异常已经被你自己处理掉了。\n\n同时CATCH也可以不加DO，比如：\n\n<chain name="chain1">\n    THEN(\n        CATCH(\n            THEN(a,b)\n        ),\n        c\n    )\n</chain>\n\n\n上面这段表达式不管a,b有没有抛出异常，最终总会执行c。如果a抛出异常，那么最终执行链路就为a==>c\n\n\n# 搭配循环使用\n\nCATCH表达式和循环表达式搭配起来使用，还能做出java中continue的效果，比如：\n\n<chain name="chain1">\n    FOR(x).DO(\n        CATCH(\n            THEN(a,b,c)\n        )\n    )\n</chain>\n\n\n如果你希望在b组件中达成某一个条件就不执行c，继续循环，那么你可以借助CATCH语法，只要在b组件中往外抛一个异常即可。\n\n我相信这种用法对于写程序的同学来说，应该不用过多解释。',normalizedContent:'liteflow从2.10.0开始，el表达式语法中新增了捕获异常的表达式\n\n\n# 基本用法\n\n具体用法为catch...do:\n\n<chain name="chain1">\n    catch(\n        then(a,b)\n    ).do(c)\n</chain>\n\n\n上述语法表示，如果a组件出现异常并抛出，则不会执行b组件，会直接执行c组件。\n\n在c组件中，可以通过this.getslot().getexception()来获取异常。\n\n同时，当用了catch表达式之后，即便在catch包裹的组件有异常抛出，整个流程返回的liteflowresponse中的issuccess方法仍然为true，getcause中也没有任何的exception。如果你写过java程序，应该会对这样的机制很容易理解。因为异常已经被你自己处理掉了。\n\n同时catch也可以不加do，比如：\n\n<chain name="chain1">\n    then(\n        catch(\n            then(a,b)\n        ),\n        c\n    )\n</chain>\n\n\n上面这段表达式不管a,b有没有抛出异常，最终总会执行c。如果a抛出异常，那么最终执行链路就为a==>c\n\n\n# 搭配循环使用\n\ncatch表达式和循环表达式搭配起来使用，还能做出java中continue的效果，比如：\n\n<chain name="chain1">\n    for(x).do(\n        catch(\n            then(a,b,c)\n        )\n    )\n</chain>\n\n\n如果你希望在b组件中达成某一个条件就不执行c，继续循环，那么你可以借助catch语法，只要在b组件中往外抛一个异常即可。\n\n我相信这种用法对于写程序的同学来说，应该不用过多解释。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌳循环编排",frontmatter:{title:"🌳循环编排",date:"2022-10-06T15:13:06.000Z",permalink:"/pages/v2.11.X/fbf715/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/046.%E5%BE%AA%E7%8E%AF%E7%BC%96%E6%8E%92.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/046.循环编排.md",key:"v-8d64f6d2",path:"/pages/v2.11.X/fbf715/",headers:[{level:2,title:"FOR循环",slug:"for循环",normalizedTitle:"for循环",charIndex:36},{level:2,title:"WHILE循环",slug:"while循环",normalizedTitle:"while循环",charIndex:310},{level:2,title:"ITERATOR迭代循环",slug:"iterator迭代循环",normalizedTitle:"iterator迭代循环",charIndex:463},{level:2,title:"BREAK",slug:"break",normalizedTitle:"break",charIndex:653},{level:2,title:"异步循环",slug:"异步循环",normalizedTitle:"异步循环",charIndex:946}],headersStr:"FOR循环 WHILE循环 ITERATOR迭代循环 BREAK 异步循环",content:'LiteFlow从v2.9.0开始，提供了循环编排表达式组合。\n\n\n# FOR循环\n\nFOR循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    FOR(5).DO(THEN(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# WHILE循环\n\nWHILE循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b));\n</chain>\n\n\n其中w这个节点需要为条件循环组件，返回一个布尔值，为true则继续循环，如何定义请参照条件循环组件。\n\n\n# ITERATOR迭代循环\n\nITERATOR迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# BREAK\n\nLiteFlow同样也支持BREAK语法，代表退出循环。\n\nBREAK关键字可以跟在FOR和WHILE后面，通常用法为：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n其中c这个节点需要为退出循环组件，返回一个布尔值，为true则退出循环。如何定义请参考退出循环组件。\n\n提示\n\nBREAK关键字是在每次循环的末尾进行判断的。\n\n\n# 异步循环\n\nLiteFlow从v2.11.0支持了异步循环特性，关于异步循环请参考高级特性中的异步循环模式。',normalizedContent:'liteflow从v2.9.0开始，提供了循环编排表达式组合。\n\n\n# for循环\n\nfor循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    for(5).do(then(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# while循环\n\nwhile循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    while(w).do(then(a, b));\n</chain>\n\n\n其中w这个节点需要为条件循环组件，返回一个布尔值，为true则继续循环，如何定义请参照条件循环组件。\n\n\n# iterator迭代循环\n\niterator迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# break\n\nliteflow同样也支持break语法，代表退出循环。\n\nbreak关键字可以跟在for和while后面，通常用法为：\n\n<chain name="chain1">\n    for(f).do(then(a, b)).break(c);\n</chain>\n\n\n<chain name="chain1">\n    while(w).do(then(a, b)).break(c);\n</chain>\n\n\n其中c这个节点需要为退出循环组件，返回一个布尔值，为true则退出循环。如何定义请参考退出循环组件。\n\n提示\n\nbreak关键字是在每次循环的末尾进行判断的。\n\n\n# 异步循环\n\nliteflow从v2.11.0支持了异步循环特性，关于异步循环请参考高级特性中的异步循环模式。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄与或非表达式",frontmatter:{title:"🍄与或非表达式",date:"2023-04-11T21:28:38.000Z",permalink:"/pages/v2.11.X/a8b344/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/048.%E4%B8%8E%E6%88%96%E9%9D%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/048.与或非表达式.md",key:"v-6ce21664",path:"/pages/v2.11.X/a8b344/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:2},{level:2,title:"可以用的地方",slug:"可以用的地方",normalizedTitle:"可以用的地方",charIndex:669},{level:2,title:"复杂嵌套",slug:"复杂嵌套",normalizedTitle:"复杂嵌套",charIndex:799}],headersStr:"基本用法 可以用的地方 复杂嵌套",content:'# 基本用法\n\nLiteFlow在v2.10.2版本带来了与或非表达式，就是AND，OR，NOT表达式。\n\n通过之前的几小章，应该可以知道，有些编排需要返回一个布尔值，比如条件编排：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n其中x组件应该为条件组件，返回的是一个布尔值。\n\n但是如果这个布尔值并不是由一个组件决定的，而是由多个组件决定的呢。这里就可以用与或非表达式了。\n\n假设这里的条件是要由x和y共同决定，利用与或非表达式中的AND:\n\n<chain name="chain1">\n    IF(AND(x,y), a, b);\n</chain>\n\n\n上述AND的意思是，如果x和y都为true，则为真，会执行组件a，如果x和y有一个为false，则执行b。\n\nAND里面可以有多个布尔组件或者与或非表达式。\n\n同理，这里也可以用OR来表示：\n\n<chain name="chain1">\n    IF(OR(x,y), a, b);\n</chain>\n\n\n上述OR的意思是，只要x和y中的一个为true，则为真，否则为假。\n\nOR里面可以有多个组件或者与或非表达式。\n\nNOT就是非的意思，比如：\n\n<chain name="chain1">\n    IF(NOT(x), a, b);\n</chain>\n\n\n如果x返回true，则经过非运算后，为假，执行b，如果x返回false，则经过非运算后，为真，执行a。\n\nNOT里面只能有一个布尔组件或者与或非表达式。\n\n\n# 可以用的地方\n\n在LiteFlow所有EL表达式中，返回布尔值的地方都可以用与或非表达式，除了上述的IF外，还可以用在WHILE，BREAK表达式中。\n\n提示\n\n如果你在THEN表达式中用与或非表达式，会报错的，因为普通组件并非是一个布尔值的的返回。\n\n\n# 复杂嵌套\n\n与或非表达式也可以进行多级嵌套，比如：\n\n<chain name="chain1">\n    IF(\n        OR(\n            AND(x1, x3), NOT(OR(x3, x4))\n        ),\n        a, b\n    );\n</chain>\n\n\n类似于这种，其实概念和java的与或非都一样，无非就是换了种写法。',normalizedContent:'# 基本用法\n\nliteflow在v2.10.2版本带来了与或非表达式，就是and，or，not表达式。\n\n通过之前的几小章，应该可以知道，有些编排需要返回一个布尔值，比如条件编排：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n其中x组件应该为条件组件，返回的是一个布尔值。\n\n但是如果这个布尔值并不是由一个组件决定的，而是由多个组件决定的呢。这里就可以用与或非表达式了。\n\n假设这里的条件是要由x和y共同决定，利用与或非表达式中的and:\n\n<chain name="chain1">\n    if(and(x,y), a, b);\n</chain>\n\n\n上述and的意思是，如果x和y都为true，则为真，会执行组件a，如果x和y有一个为false，则执行b。\n\nand里面可以有多个布尔组件或者与或非表达式。\n\n同理，这里也可以用or来表示：\n\n<chain name="chain1">\n    if(or(x,y), a, b);\n</chain>\n\n\n上述or的意思是，只要x和y中的一个为true，则为真，否则为假。\n\nor里面可以有多个组件或者与或非表达式。\n\nnot就是非的意思，比如：\n\n<chain name="chain1">\n    if(not(x), a, b);\n</chain>\n\n\n如果x返回true，则经过非运算后，为假，执行b，如果x返回false，则经过非运算后，为真，执行a。\n\nnot里面只能有一个布尔组件或者与或非表达式。\n\n\n# 可以用的地方\n\n在liteflow所有el表达式中，返回布尔值的地方都可以用与或非表达式，除了上述的if外，还可以用在while，break表达式中。\n\n提示\n\n如果你在then表达式中用与或非表达式，会报错的，因为普通组件并非是一个布尔值的的返回。\n\n\n# 复杂嵌套\n\n与或非表达式也可以进行多级嵌套，比如：\n\n<chain name="chain1">\n    if(\n        or(\n            and(x1, x3), not(or(x3, x4))\n        ),\n        a, b\n    );\n</chain>\n\n\n类似于这种，其实概念和java的与或非都一样，无非就是换了种写法。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍁使用子流程",frontmatter:{title:"🍁使用子流程",date:"2022-07-01T19:00:46.000Z",permalink:"/pages/v2.11.X/dc5df7/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/050.%E4%BD%BF%E7%94%A8%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/050.使用子流程.md",key:"v-21994c86",path:"/pages/v2.11.X/dc5df7/",headersStr:null,content:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    THEN(\n        A, B,\n        WHEN(\n            THEN(C, WHEN(J, K)),\n            D,\n            THEN(H, I)\n        ),\n        SWITCH(X).to(\n            M,\n            N,\n            WHEN(Q, THEN(P, R)).id("w01")\n        ),\n        Z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nLiteFlow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainChain">\n    THEN(\n    \tA, B,\n    \tWHEN(chain1, D, chain2),\n    \tSWITCH(X).to(M, N, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tTHEN(C, WHEN(J, K));\n</chain>\n\n<chain name="chain2">\n  \tTHEN(H, I);\n</chain>\n\n<chain name="chain3">\n  \tWHEN(Q, THEN(P, R)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',normalizedContent:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    then(\n        a, b,\n        when(\n            then(c, when(j, k)),\n            d,\n            then(h, i)\n        ),\n        switch(x).to(\n            m,\n            n,\n            when(q, then(p, r)).id("w01")\n        ),\n        z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nliteflow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainchain">\n    then(\n    \ta, b,\n    \twhen(chain1, d, chain2),\n    \tswitch(x).to(m, n, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tthen(c, when(j, k));\n</chain>\n\n<chain name="chain2">\n  \tthen(h, i);\n</chain>\n\n<chain name="chain3">\n  \twhen(q, then(p, r)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"💐复杂编排例子",frontmatter:{title:"💐复杂编排例子",date:"2022-06-29T21:29:06.000Z",permalink:"/pages/v2.11.X/5156b3/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/070.%E5%A4%8D%E6%9D%82%E7%BC%96%E6%8E%92%E4%BE%8B%E5%AD%90.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/070.复杂编排例子.md",key:"v-2df23e04",path:"/pages/v2.11.X/5156b3/",headers:[{level:2,title:"复杂例子一",slug:"复杂例子一",normalizedTitle:"复杂例子一",charIndex:85},{level:2,title:"复杂例子二",slug:"复杂例子二",normalizedTitle:"复杂例子二",charIndex:840},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1905}],headersStr:"复杂例子一 复杂例子二 总结",content:'经过上面几小章，你是不是已经大致了解了LiteFlow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        WHEN(\n            THEN(B, C),\n            THEN(D, E, F),\n            THEN(\n                SWITCH(G).to(\n                    THEN(H, I, WHEN(J, K)).id("t1"),\n                    THEN(L, M).id("t2")\n                ),\n                N\n            )\n        ),\n        Z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = THEN(B, C);\n    item2 = THEN(D, E, F);\n    item3_1 = THEN(H, I, WHEN(J, K)).id("t1");\n    item3_2 = THEN(L, M).id("t2");\n    item3 = THEN(SWITCH(G).to(item3_1, item3_2), N);\n    \n    THEN(\n        A,\n        WHEN(item1, item2, item3),\n        Z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        SWITCH(B).to(\n            THEN(D, E, F).id("t1"),\n            THEN(\n                C,\n                WHEN(\n                    THEN(\n                        SWITCH(G).to(THEN(H, I).id("t2"), J),\n                        K\n                    ),\n                    THEN(L, M)\n                )\n            ).id("t3")\n        ),\n        Z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = THEN(D, E, F).id("t1");\n    \n    item2_1 = THEN(\n        SWITCH(G).to(\n            THEN(H, I).id("t2"),\n            J\n        ),\n        K\n    );\n    \n    item2_2 = THEN(L, M);\n    \n    item2 = THEN(C, WHEN(item2_1, item2_2)).id("t3");\n    \n    THEN(\n        A,\n        SWITCH(B).to(item1, item2),\n        Z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest2\n\n\n# 总结\n\nLiteFlow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',normalizedContent:'经过上面几小章，你是不是已经大致了解了liteflow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            then(b, c),\n            then(d, e, f),\n            then(\n                switch(g).to(\n                    then(h, i, when(j, k)).id("t1"),\n                    then(l, m).id("t2")\n                ),\n                n\n            )\n        ),\n        z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = then(b, c);\n    item2 = then(d, e, f);\n    item3_1 = then(h, i, when(j, k)).id("t1");\n    item3_2 = then(l, m).id("t2");\n    item3 = then(switch(g).to(item3_1, item3_2), n);\n    \n    then(\n        a,\n        when(item1, item2, item3),\n        z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            then(d, e, f).id("t1"),\n            then(\n                c,\n                when(\n                    then(\n                        switch(g).to(then(h, i).id("t2"), j),\n                        k\n                    ),\n                    then(l, m)\n                )\n            ).id("t3")\n        ),\n        z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = then(d, e, f).id("t1");\n    \n    item2_1 = then(\n        switch(g).to(\n            then(h, i).id("t2"),\n            j\n        ),\n        k\n    );\n    \n    item2_2 = then(l, m);\n    \n    item2 = then(c, when(item2_1, item2_2)).id("t3");\n    \n    then(\n        a,\n        switch(b).to(item1, item2),\n        z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.complexelspringboottest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.complexelspringboottest2\n\n\n# 总结\n\nliteflow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍂使用子变量",frontmatter:{title:"🍂使用子变量",date:"2022-07-01T19:01:33.000Z",permalink:"/pages/v2.11.X/71ff49/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/060.%E4%BD%BF%E7%94%A8%E5%AD%90%E5%8F%98%E9%87%8F.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/060.使用子变量.md",key:"v-1e7a979e",path:"/pages/v2.11.X/71ff49/",headersStr:null,content:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为LiteFlow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = THEN(C, WHEN(J, K));\n    w1 = WHEN(Q, THEN(P, R)).id("w01");\n    t2 = THEN(H, I);\n    \n    THEN(\n        A, B,\n        WHEN(t1, D, t2),\n        SWITCH(X).to(M, N, w1),\n        Z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',normalizedContent:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为liteflow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = then(c, when(j, k));\n    w1 = when(q, then(p, r)).id("w01");\n    t2 = then(h, i);\n    \n    then(\n        a, b,\n        when(t1, d, t2),\n        switch(x).to(m, n, w1),\n        z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌻关于分号",frontmatter:{title:"🌻关于分号",date:"2022-07-10T10:58:25.000Z",permalink:"/pages/v2.11.X/af44a6/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/080.%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/080.关于分号.md",key:"v-3bad0d8c",path:"/pages/v2.11.X/af44a6/",headersStr:null,content:'大家可能注意到了，在EL规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nLiteFlow的EL规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    THEN(\n        a, \n        b, \n        WHEN(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = THEN(a, b);\n    w1 = WHEN(c, d);\n    \n    THEN(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为LiteFlow的IDEA插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',normalizedContent:'大家可能注意到了，在el规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nliteflow的el规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    then(a, b, when(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    then(\n        a, \n        b, \n        when(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = then(a, b);\n    w1 = when(c, d);\n    \n    then(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为liteflow的idea插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐚组件名包装",frontmatter:{title:"🐚组件名包装",date:"2022-07-26T23:58:18.000Z",permalink:"/pages/v2.11.X/2df3d9/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/100.%E7%BB%84%E4%BB%B6%E5%90%8D%E5%8C%85%E8%A3%85.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/100.组件名包装.md",key:"v-78c1c150",path:"/pages/v2.11.X/2df3d9/",headersStr:null,content:'LiteFlow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88Cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    THEN(a, b, 88Cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nLiteFlow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    THEN(a, b, node("88Cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',normalizedContent:'liteflow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    then(a, b, 88cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nliteflow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    then(a, b, node("88cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌰关于注释",frontmatter:{title:"🌰关于注释",date:"2022-07-19T10:34:21.000Z",permalink:"/pages/v2.11.X/f3dc09/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/090.%E5%85%B3%E4%BA%8E%E6%B3%A8%E9%87%8A.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/090.关于注释.md",key:"v-64c1cc82",path:"/pages/v2.11.X/f3dc09/",headersStr:null,content:'在LiteFlow的EL规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    THEN(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        WHEN(c, d)\n    )\n</chain>\n',normalizedContent:'在liteflow的el规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    then(a, b, when(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    then(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        when(c, d)\n    )\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🔆验证规则",frontmatter:{title:"🔆验证规则",date:"2022-12-01T00:10:24.000Z",permalink:"/pages/v2.11.X/395fd0/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/110.%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99.html",relativePath:"08.v2.11.X文档/060.🧩EL规则的写法/110.验证规则.md",key:"v-620f21cd",path:"/pages/v2.11.X/395fd0/",headersStr:null,content:'LiteFlow从v2.9.4版本开始，为规则EL提供了一个验证的方法接口，用于验证EL是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourMethod() {\n    boolean isValid = LiteFlowChainELBuilder.validate("THEN(a, b, h)");\n    ...\n}\n',normalizedContent:'liteflow从v2.9.4版本开始，为规则el提供了一个验证的方法接口，用于验证el是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourmethod() {\n    boolean isvalid = liteflowchainelbuilder.validate("then(a, b, h)");\n    ...\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T23:35:36.000Z",permalink:"/pages/v2.11.X/74b4bf/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/010.%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/070.🌮数据上下文/010.说明.md",key:"v-2391217a",path:"/pages/v2.11.X/74b4bf/",headersStr:null,content:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在LiteFlow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nLiteFlow对此有独特的设计理念，平时我们写瀑布流的程序时，A调用B，那A一定要把B所需要的参数传递给B，而在LiteFlow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在LiteFlow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",normalizedContent:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在liteflow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nliteflow对此有独特的设计理念，平时我们写瀑布流的程序时，a调用b，那a一定要把b所需要的参数传递给b，而在liteflow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在liteflow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯数据上下文的定义和使用",frontmatter:{title:"🌯数据上下文的定义和使用",date:"2022-07-01T23:49:40.000Z",permalink:"/pages/v2.11.X/501abf/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/020.%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8.html",relativePath:"08.v2.11.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.md",key:"v-78db2895",path:"/pages/v2.11.X/501abf/",headers:[{level:2,title:"默认上下文",slug:"默认上下文",normalizedTitle:"默认上下文",charIndex:2},{level:2,title:"自定义上下文",slug:"自定义上下文",normalizedTitle:"自定义上下文",charIndex:224},{level:2,title:"多上下文",slug:"多上下文",normalizedTitle:"多上下文",charIndex:816}],headersStr:"默认上下文 自定义上下文 多上下文",content:'# 默认上下文\n\nLiteFlow提供了一个默认的数据上下文的实现：DefaultContext。这个默认的实现其实里面主要存储数据的容器就是一个Map。\n\n你可以通过DefaultContext中的setData方法放入数据，通过getData方法获得数据。\n\n建议\n\nDefaultContext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的Bean当做上下文进行传入。LiteFlow对上下文的Bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, CustomContext.class);\n\n\n传入之后， LiteFlow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tCustomContext context = this.getContextBean(CustomContext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//CustomContext context = this.getFirstContextBean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nLiteFlow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, OrderContext.class, UserContext.class, SignContext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tOrderContext orderContext = this.getContextBean(OrderContext.class);\n\t\tUserContext userContext = this.getContextBean(UserContext.class);\n\t\tSignContext signContext = this.getContextBean(SignContext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是OrderContext，那么也可以用这个方法\n\t\t//OrderContext orderContext = this.getFirstContextBean();\n\t\t...\n\t}\n}\n',normalizedContent:'# 默认上下文\n\nliteflow提供了一个默认的数据上下文的实现：defaultcontext。这个默认的实现其实里面主要存储数据的容器就是一个map。\n\n你可以通过defaultcontext中的setdata方法放入数据，通过getdata方法获得数据。\n\n建议\n\ndefaultcontext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的bean当做上下文进行传入。liteflow对上下文的bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, customcontext.class);\n\n\n传入之后， liteflow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tcustomcontext context = this.getcontextbean(customcontext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//customcontext context = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nliteflow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, ordercontext.class, usercontext.class, signcontext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tordercontext ordercontext = this.getcontextbean(ordercontext.class);\n\t\tusercontext usercontext = this.getcontextbean(usercontext.class);\n\t\tsigncontext signcontext = this.getcontextbean(signcontext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是ordercontext，那么也可以用这个方法\n\t\t//ordercontext ordercontext = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T22:30:36.000Z",permalink:"/pages/v2.11.X/90b2a5/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/010.%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/080.🛩执行器/010.说明.md",key:"v-59824782",path:"/pages/v2.11.X/90b2a5/",headersStr:null,content:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合Hello World章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",normalizedContent:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合hello world章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪶用初始化好的上下文传入",frontmatter:{title:"🪶用初始化好的上下文传入",date:"2022-08-17T23:30:42.000Z",permalink:"/pages/v2.11.X/f05ed6/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/030.%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A5%BD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%A0%E5%85%A5.html",relativePath:"08.v2.11.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.md",key:"v-088c6cd4",path:"/pages/v2.11.X/f05ed6/",headersStr:null,content:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getRequestData()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nLiteFlow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到FlowExecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nOrderContext orderContext = new OrderContext();\norderContext.setOrderNo("SO11223344");\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", null, orderContext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',normalizedContent:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getrequestdata()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nliteflow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到flowexecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nordercontext ordercontext = new ordercontext();\nordercontext.setorderno("so11223344");\nliteflowresponse response = flowexecutor.execute2resp("chain1", null, ordercontext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎡执行方法",frontmatter:{title:"🎡执行方法",date:"2022-07-01T23:03:12.000Z",permalink:"/pages/v2.11.X/20072e/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/020.%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.html",relativePath:"08.v2.11.X文档/080.🛩执行器/020.执行方法.md",key:"v-67575d0c",path:"/pages/v2.11.X/20072e/",headers:[{level:2,title:"返回类型为LiteflowResponse",slug:"返回类型为liteflowresponse",normalizedTitle:"返回类型为liteflowresponse",charIndex:86},{level:2,title:"返回类型为Future",slug:"返回类型为future",normalizedTitle:"返回类型为future",charIndex:667}],headersStr:"返回类型为LiteflowResponse 返回类型为Future",content:"你可以在Springboot/Spring体系中的任何被Spring上下文管理的类中进行注入FlowExecutor。\n\nFlowExecutor有多个重载方法。\n\n\n# 返回类型为LiteflowResponse\n\n//参数为流程ID，无初始流程入参，上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId)\n//第一个参数为流程ID，第二个参数为流程入参。上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId, Object param);\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文class\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文的Bean\npublic LiteflowResponse execute2Resp(String chainId, Object param, Object... contextBeanArray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为Future\n\npublic Future<LiteflowResponse> execute2Future(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，LiteFlow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现ExecutorBuilder接口：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n",normalizedContent:"你可以在springboot/spring体系中的任何被spring上下文管理的类中进行注入flowexecutor。\n\nflowexecutor有多个重载方法。\n\n\n# 返回类型为liteflowresponse\n\n//参数为流程id，无初始流程入参，上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid)\n//第一个参数为流程id，第二个参数为流程入参。上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid, object param);\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文class\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文的bean\npublic liteflowresponse execute2resp(string chainid, object param, object... contextbeanarray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为future\n\npublic future<liteflowresponse> execute2future(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，liteflow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现executorbuilder接口：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎢流程入参",frontmatter:{title:"🎢流程入参",date:"2022-07-02T00:38:44.000Z",permalink:"/pages/v2.11.X/563b67/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/030.%E6%B5%81%E7%A8%8B%E5%85%A5%E5%8F%82.html",relativePath:"08.v2.11.X文档/080.🛩执行器/030.流程入参.md",key:"v-878a8230",path:"/pages/v2.11.X/563b67/",headersStr:null,content:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户Id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的Bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tYourBean requestBean = this.getRequestData();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getRequestData()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',normalizedContent:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tyourbean requestbean = this.getrequestdata();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getrequestdata()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎈LiteflowResponse对象",frontmatter:{title:"🎈LiteflowResponse对象",date:"2022-07-02T00:52:14.000Z",permalink:"/pages/v2.11.X/9f653d/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/040.LiteflowResponse%E5%AF%B9%E8%B1%A1.html",relativePath:"08.v2.11.X文档/080.🛩执行器/040.LiteflowResponse对象.md",key:"v-340ada9a",path:"/pages/v2.11.X/9f653d/",headers:[{level:2,title:"流程执行是否成功",slug:"流程执行是否成功",normalizedTitle:"流程执行是否成功",charIndex:66},{level:2,title:"获取异常信息",slug:"获取异常信息",normalizedTitle:"获取异常信息",charIndex:240},{level:2,title:"获得执行步骤详细信息",slug:"获得执行步骤详细信息",normalizedTitle:"获得执行步骤详细信息",charIndex:481},{level:2,title:"上下文数据",slug:"上下文数据",normalizedTitle:"上下文数据",charIndex:890},{level:2,title:"获得步骤字符串信息",slug:"获得步骤字符串信息",normalizedTitle:"获得步骤字符串信息",charIndex:1516}],headersStr:"流程执行是否成功 获取异常信息 获得执行步骤详细信息 上下文数据 获得步骤字符串信息",content:'在执行器返回中，用的最多的就是返回一个LiteFlowResponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nboolean isSuccess = response.isSuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程isSuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了LiteFlowResponse对象之后，可以这样获得上下文Bean：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nCustomContext context = response.getContextBean(CustomContext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//CustomContext context = response.getFirstContextBean();\n\n\n对于多上下文来说，也是一样的用法：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, OrderContext.class, UserContext.class);\nOrderContext orderContext = response.getContextBean(OrderContext.class);\nUserContext userContext = response.getContextBean(UserContext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nString stepStr = response.getExecuteStepStrWithTime();\n\n\n这个字符串打印出来结果如下：\n\na[组件A]<201>==>b[组件B]<300>==>m[组件M]<1205>\n\n\n这里的表达形式为组件ID[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getExecuteStepStrWithoutTime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',normalizedContent:'在执行器返回中，用的最多的就是返回一个liteflowresponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nboolean issuccess = response.issuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程issuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了liteflowresponse对象之后，可以这样获得上下文bean：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\ncustomcontext context = response.getcontextbean(customcontext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//customcontext context = response.getfirstcontextbean();\n\n\n对于多上下文来说，也是一样的用法：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, ordercontext.class, usercontext.class);\nordercontext ordercontext = response.getcontextbean(ordercontext.class);\nusercontext usercontext = response.getcontextbean(usercontext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nstring stepstr = response.getexecutestepstrwithtime();\n\n\n这个字符串打印出来结果如下：\n\na[组件a]<201>==>b[组件b]<300>==>m[组件m]<1205>\n\n\n这里的表达形式为组件id[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getexecutestepstrwithouttime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌭脚本语言介绍",frontmatter:{title:"🌭脚本语言介绍",date:"2023-08-27T22:54:15.000Z",permalink:"/pages/v2.11.X/38c781/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/005.%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/005.脚本语言介绍.md",key:"v-e23af09a",path:"/pages/v2.11.X/38c781/",headersStr:null,content:"在前面几个章节中，我们介绍了LiteFlow是用EL表达式来驱动组件执行顺序的。\n\n可见组件是LiteFlow的最小逻辑执行单元。\n\n而组件在前面几章的介绍中，都是需要你自己去定义类的。而定义类通常用于相对固定的逻辑，EL表达式能够即时调整，但是定义成类的组件中的逻辑还是要重启系统才能调整。\n\n但是在实际业务场景中，有的场景需要实时的去调整小部分逻辑，那怎么办呢。\n\n这就需要LiteFlow提供的脚本组件特性了。\n\n脚本组件，顾名思义就是不再需要你去用类去定义组件了，而是用脚本来定义组件。而脚本也是可以被即时调整的。\n\n脚本组件也是LiteFlow框架中非常重要且极具有特色的一个特性，利用EL+脚本组件，你可以做出一套极其灵活的系统。无论是执行顺序，还是关键逻辑，均可进行热刷新。\n\nLiteFlow在启动时就对脚本进行了预编译，虽然脚本的执行性能肯定比不过原生java，但是性能不会差太多，因为脚本方便且灵活可以热刷，这是java类所做不到的。\n\nLiteFlow中目前支持的脚本语言多达7种。下面一小章会大致说下每一种脚本语言该如何运用。\n\n提示\n\n虽然脚本组件拥有可热刷新的特性，但是依旧不推荐把一个系统里所有的逻辑都写成脚本组件，因为并不是所有的逻辑都需要热修改。\n\n推荐把需要灵活经常变的逻辑写成脚本组件，固定不变的逻辑还是用java类来写。java类+脚本组件+EL的组合是官方最为推荐的方式。",normalizedContent:"在前面几个章节中，我们介绍了liteflow是用el表达式来驱动组件执行顺序的。\n\n可见组件是liteflow的最小逻辑执行单元。\n\n而组件在前面几章的介绍中，都是需要你自己去定义类的。而定义类通常用于相对固定的逻辑，el表达式能够即时调整，但是定义成类的组件中的逻辑还是要重启系统才能调整。\n\n但是在实际业务场景中，有的场景需要实时的去调整小部分逻辑，那怎么办呢。\n\n这就需要liteflow提供的脚本组件特性了。\n\n脚本组件，顾名思义就是不再需要你去用类去定义组件了，而是用脚本来定义组件。而脚本也是可以被即时调整的。\n\n脚本组件也是liteflow框架中非常重要且极具有特色的一个特性，利用el+脚本组件，你可以做出一套极其灵活的系统。无论是执行顺序，还是关键逻辑，均可进行热刷新。\n\nliteflow在启动时就对脚本进行了预编译，虽然脚本的执行性能肯定比不过原生java，但是性能不会差太多，因为脚本方便且灵活可以热刷，这是java类所做不到的。\n\nliteflow中目前支持的脚本语言多达7种。下面一小章会大致说下每一种脚本语言该如何运用。\n\n提示\n\n虽然脚本组件拥有可热刷新的特性，但是依旧不推荐把一个系统里所有的逻辑都写成脚本组件，因为并不是所有的逻辑都需要热修改。\n\n推荐把需要灵活经常变的逻辑写成脚本组件，固定不变的逻辑还是用java类来写。java类+脚本组件+el的组合是官方最为推荐的方式。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧀Javascript脚本引擎",frontmatter:{title:"🧀Javascript脚本引擎",date:"2023-08-28T00:05:24.000Z",permalink:"/pages/v2.11.X/07f433/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/020.Javascript%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/020.Javascript脚本引擎.md",key:"v-2b553a7c",path:"/pages/v2.11.X/07f433/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:84},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:1031},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:1298}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n对于Javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持ES5。另一种是基于GraalJs引擎实现，支持ES6。\n\n如果你使用jdk8，你可以选用下面任意一种脚本引擎，而jdk11和jdk17，你只能选用graaljs引擎，因为jdk8之后的jdk已经移除了jdk自带的Nashorn JavaScript引擎。\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-javascript</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-graaljs</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例\n\n<node id="s1" name="普通脚本1" type="script" language="js">\n    <![CDATA[\n        var a=3;\n        var b=2;\n        var c=1;\n        var d=5;\n\n        function addByArray(values) {\n            var sum = 0;\n            for (var i = 0; i < values.length; i++) {\n                sum += values[i];\n            }\n            return sum;\n        }\n\n        var result = addByArray([a,b,c,d]);\n\n        defaultContext.setData("s1",parseInt(result));\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，你可以用js的绝大部分语法特性，甚至还可以在脚本里定义Function。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n对于javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持es5。另一种是基于graaljs引擎实现，支持es6。\n\n如果你使用jdk8，你可以选用下面任意一种脚本引擎，而jdk11和jdk17，你只能选用graaljs引擎，因为jdk8之后的jdk已经移除了jdk自带的nashorn javascript引擎。\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-javascript</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-graaljs</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例\n\n<node id="s1" name="普通脚本1" type="script" language="js">\n    <![cdata[\n        var a=3;\n        var b=2;\n        var c=1;\n        var d=5;\n\n        function addbyarray(values) {\n            var sum = 0;\n            for (var i = 0; i < values.length; i++) {\n                sum += values[i];\n            }\n            return sum;\n        }\n\n        var result = addbyarray([a,b,c,d]);\n\n        defaultcontext.setdata("s1",parseint(result));\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，你可以用js的绝大部分语法特性，甚至还可以在脚本里定义function。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥏Groovy脚本引擎",frontmatter:{title:"🥏Groovy脚本引擎",date:"2023-08-27T22:56:01.000Z",permalink:"/pages/v2.11.X/36877b/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/010.Groovy%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/010.Groovy脚本引擎.md",key:"v-d328377c",path:"/pages/v2.11.X/36877b/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:1202},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:1469}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用groovy脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-groovy</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="groovy">\n    <![CDATA[\n    import cn.hutool.core.collection.ListUtil\n    import cn.hutool.core.date.DateUtil\n\n    import java.util.function.Consumer\n    import java.util.function.Function\n    import java.util.stream.Collectors\n\n    def date = DateUtil.parse("2022-10-17 13:31:43")\n    println(date)\n    defaultContext.setData("demoDate", date)\n\n    List<String> list = ListUtil.toList("a", "b", "c")\n\n    List<String> resultList = list.stream().map(s -> "hello," + s).collect(Collectors.toList())\n\n    defaultContext.setData("resultList", resultList)\n\n    class Student {\n        int studentID\n        String studentName\n    }\n\n    Student student = new Student()\n    student.studentID = 100301\n    student.studentName = "张三"\n    defaultContext.setData("student", student)\n\n    def a = 3\n    def b = 2\n    defaultContext.setData("s1", a * b)\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，可以看到，groovy的脚本语言还是非常类似于java的。甚至还可以在脚本里定义类。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用groovy脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-groovy</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="groovy">\n    <![cdata[\n    import cn.hutool.core.collection.listutil\n    import cn.hutool.core.date.dateutil\n\n    import java.util.function.consumer\n    import java.util.function.function\n    import java.util.stream.collectors\n\n    def date = dateutil.parse("2022-10-17 13:31:43")\n    println(date)\n    defaultcontext.setdata("demodate", date)\n\n    list<string> list = listutil.tolist("a", "b", "c")\n\n    list<string> resultlist = list.stream().map(s -> "hello," + s).collect(collectors.tolist())\n\n    defaultcontext.setdata("resultlist", resultlist)\n\n    class student {\n        int studentid\n        string studentname\n    }\n\n    student student = new student()\n    student.studentid = 100301\n    student.studentname = "张三"\n    defaultcontext.setdata("student", student)\n\n    def a = 3\n    def b = 2\n    defaultcontext.setdata("s1", a * b)\n    ]]>\n</node>\n\n\n以上是一个普通脚本组件的示例，可以看到，groovy的脚本语言还是非常类似于java的。甚至还可以在脚本里定义类。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"☕️Java脚本引擎",frontmatter:{title:"☕️Java脚本引擎",date:"2023-08-28T00:13:47.000Z",permalink:"/pages/v2.11.X/2b8afb/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/030.Java%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/030.Java脚本引擎.md",key:"v-7a115242",path:"/pages/v2.11.X/2b8afb/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:105},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:109},{level:2,title:"和Java类进行交互",slug:"和java类进行交互",normalizedTitle:"和java类进行交互",charIndex:2135},{level:2,title:"如何取Spring上下文中的数据",slug:"如何取spring上下文中的数据",normalizedTitle:"如何取spring上下文中的数据",charIndex:2296},{level:2,title:"必须要注意的点",slug:"必须要注意的点",normalizedTitle:"必须要注意的点",charIndex:2564}],headersStr:"介绍 依赖 使用 和Java类进行交互 如何取Spring上下文中的数据 必须要注意的点",content:'# 介绍\n\nLiteFlow在v2.11.0版本中支持了用Java本身作为脚本语言的特性。\n\n也就是说，在写组件脚本时，你可以完全用Java自身的语法来写脚本。同样这部分的脚本，也是可以进行热刷新的。\n\n\n# 依赖\n\n使用Java脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-java</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\nJava作为脚本语言，不同于其他脚本语言，它有自己的一套方式。总体来说，用java来写脚本语言，会更加方便。\n\n先看一个例子：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![CDATA[\n    import com.yomahub.liteflow.slot.DefaultContext;\n    import com.yomahub.liteflow.spi.holder.ContextAwareHolder;\n    import com.yomahub.liteflow.test.script.java.common.cmp.TestDomain;\n    import com.yomahub.liteflow.script.body.JaninoCommonScriptBody;\n    import com.yomahub.liteflow.script.ScriptExecuteWrap;\n\n    public class Demo implements JaninoCommonScriptBody{\n        public Void body(ScriptExecuteWrap wrap){\n            int v1 = 2;\n            int v2 = 3;\n            DefaultContext ctx = (DefaultContext)wrap.cmp.getFirstContextBean();\n            ctx.setData("s1", v1 * v2);\n\n            TestDomain domain = (TestDomain)ContextAwareHolder.loadContextAware().getBean(TestDomain.class);\n\n            String str = domain.sayHello("jack");\n            ctx.setData("hi", str);\n\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\n最明显的区别在于，java脚本在书写时，是需要去定义一个类的，并且去继承一个接口。此接口在不同的脚本类型时，也有变化。\n\nscript：普通脚本节点，需要实现JaninoCommonScriptBody接口，脚本里返回null即可。\n\nswitch_script：选择脚本节点，需要实现JaninoSwitchScriptBody接口，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，需要实现JaninoIfScriptBody接口，脚本里需要返回true/false。\n\nfor_script：数量循环节点，需要实现JaninoForScriptBody接口，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，需要实现JaninoWhileScriptBody接口，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，需要实现JaninoBreakScriptBody，脚本里需要返回true/false，表示什么时候退出循环。\n\n以下是一个FOR循环脚本例子：\n\n<node id="s2" name="循环脚本1" type="for_script" language="java">\n    <![CDATA[\n    import com.yomahub.liteflow.script.body.JaninoForScriptBody;\n    import com.yomahub.liteflow.script.ScriptExecuteWrap;\n\n    public class Demo implements JaninoForScriptBody{\n        public Integer body(ScriptExecuteWrap wrap){\n            return 2;\n        }\n    }\n    ]]>\n</node>\n\n\n\n# 和Java类进行交互\n\n由于Java作为脚本，是需要定义一个类的。并且实现其接口所定义的方法。\n\n方法里有ScriptExecuteWrap这个参数。而warp.cmp就是当前的NodeComponent，等同于this，所以你可以用warp.cmp来调取上下文，或者是元数据。使用方式和Java类组件是一致的。\n\n\n# 如何取Spring上下文中的数据\n\n值得注意的是，虽然脚本组件完全是Java的语法，但是你无法用@Resource或者@Autowired来进行注入spring的bean。\n\nLiteFlow提供一个方法，用来获取Spring中的bean数据，如下示例：\n\nUserDomain domain = (UserDomain)ContextAwareHolder.loadContextAware().getBean(UserDomain.class);\n\n\n这样就可以获得在spring上下文中注入的UserDomain对象了。\n\n\n# 必须要注意的点\n\n也许你注意到了，以上示例很多地方都是有强制转型的：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![CDATA[\n    ...\n\n    public class Demo implements JaninoCommonScriptBody{\n        public Void body(ScriptExecuteWrap wrap){\n            ...\n            DefaultContext ctx = (DefaultContext)wrap.cmp.getFirstContextBean();\n            ...\n            TestDomain domain = (TestDomain)ContextAwareHolder.loadContextAware().getBean(TestDomain.class);\n            ...\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\n但你查看其代码会发现，这些方法均定义的是泛型返回，如果是正常的Java，应该会自动转型才对。为何这里要多此一举？\n\n提示\n\n这里一定要注意下，Java脚本不支持泛型，凡是调用的方法出现泛型返回，必须得强制转型！这是唯一的限制。',normalizedContent:'# 介绍\n\nliteflow在v2.11.0版本中支持了用java本身作为脚本语言的特性。\n\n也就是说，在写组件脚本时，你可以完全用java自身的语法来写脚本。同样这部分的脚本，也是可以进行热刷新的。\n\n\n# 依赖\n\n使用java脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-java</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\njava作为脚本语言，不同于其他脚本语言，它有自己的一套方式。总体来说，用java来写脚本语言，会更加方便。\n\n先看一个例子：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![cdata[\n    import com.yomahub.liteflow.slot.defaultcontext;\n    import com.yomahub.liteflow.spi.holder.contextawareholder;\n    import com.yomahub.liteflow.test.script.java.common.cmp.testdomain;\n    import com.yomahub.liteflow.script.body.janinocommonscriptbody;\n    import com.yomahub.liteflow.script.scriptexecutewrap;\n\n    public class demo implements janinocommonscriptbody{\n        public void body(scriptexecutewrap wrap){\n            int v1 = 2;\n            int v2 = 3;\n            defaultcontext ctx = (defaultcontext)wrap.cmp.getfirstcontextbean();\n            ctx.setdata("s1", v1 * v2);\n\n            testdomain domain = (testdomain)contextawareholder.loadcontextaware().getbean(testdomain.class);\n\n            string str = domain.sayhello("jack");\n            ctx.setdata("hi", str);\n\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\n最明显的区别在于，java脚本在书写时，是需要去定义一个类的，并且去继承一个接口。此接口在不同的脚本类型时，也有变化。\n\nscript：普通脚本节点，需要实现janinocommonscriptbody接口，脚本里返回null即可。\n\nswitch_script：选择脚本节点，需要实现janinoswitchscriptbody接口，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，需要实现janinoifscriptbody接口，脚本里需要返回true/false。\n\nfor_script：数量循环节点，需要实现janinoforscriptbody接口，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，需要实现janinowhilescriptbody接口，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，需要实现janinobreakscriptbody，脚本里需要返回true/false，表示什么时候退出循环。\n\n以下是一个for循环脚本例子：\n\n<node id="s2" name="循环脚本1" type="for_script" language="java">\n    <![cdata[\n    import com.yomahub.liteflow.script.body.janinoforscriptbody;\n    import com.yomahub.liteflow.script.scriptexecutewrap;\n\n    public class demo implements janinoforscriptbody{\n        public integer body(scriptexecutewrap wrap){\n            return 2;\n        }\n    }\n    ]]>\n</node>\n\n\n\n# 和java类进行交互\n\n由于java作为脚本，是需要定义一个类的。并且实现其接口所定义的方法。\n\n方法里有scriptexecutewrap这个参数。而warp.cmp就是当前的nodecomponent，等同于this，所以你可以用warp.cmp来调取上下文，或者是元数据。使用方式和java类组件是一致的。\n\n\n# 如何取spring上下文中的数据\n\n值得注意的是，虽然脚本组件完全是java的语法，但是你无法用@resource或者@autowired来进行注入spring的bean。\n\nliteflow提供一个方法，用来获取spring中的bean数据，如下示例：\n\nuserdomain domain = (userdomain)contextawareholder.loadcontextaware().getbean(userdomain.class);\n\n\n这样就可以获得在spring上下文中注入的userdomain对象了。\n\n\n# 必须要注意的点\n\n也许你注意到了，以上示例很多地方都是有强制转型的：\n\n<node id="s1" name="普通脚本1" type="script" language="java">\n    <![cdata[\n    ...\n\n    public class demo implements janinocommonscriptbody{\n        public void body(scriptexecutewrap wrap){\n            ...\n            defaultcontext ctx = (defaultcontext)wrap.cmp.getfirstcontextbean();\n            ...\n            testdomain domain = (testdomain)contextawareholder.loadcontextaware().getbean(testdomain.class);\n            ...\n            return null;\n        }\n    }\n    ]]>\n</node>\n\n\n但你查看其代码会发现，这些方法均定义的是泛型返回，如果是正常的java，应该会自动转型才对。为何这里要多此一举？\n\n提示\n\n这里一定要注意下，java脚本不支持泛型，凡是调用的方法出现泛型返回，必须得强制转型！这是唯一的限制。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥐Aviator脚本引擎",frontmatter:{title:"🥐Aviator脚本引擎",date:"2023-08-28T00:49:08.000Z",permalink:"/pages/v2.11.X/bad4b0/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/070.Aviator%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/070.Aviator脚本引擎.md",key:"v-bed8d4b8",path:"/pages/v2.11.X/bad4b0/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:772},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:1039}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用aviator脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-aviator</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="aviator">\n    <![CDATA[\n        use java.util.Date;\n        use cn.hutool.core.date.DateUtil;\n        let d = DateUtil.formatDateTime(new Date());\n        println(d);\n\n        a = 2;\n        b = 3;\n\n        setData(defaultContext, "s1", a*b);\n    ]]>\n</node>\n\n\n在aviator中，你同样可以导入java的包名，直接调用java的方法。\n\n在aviator中，调用java方式和其他不一样，比如我们上下文是UserContext，在其他脚本语言中调用是用userContext.setName("jack")，而在aviator脚本中，调用方式是setName(userContext, "jack")，也就是method(bean, args)这种形式，有点类似java反射的invoke形式。这点要注意下。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用aviator脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-aviator</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="aviator">\n    <![cdata[\n        use java.util.date;\n        use cn.hutool.core.date.dateutil;\n        let d = dateutil.formatdatetime(new date());\n        println(d);\n\n        a = 2;\n        b = 3;\n\n        setdata(defaultcontext, "s1", a*b);\n    ]]>\n</node>\n\n\n在aviator中，你同样可以导入java的包名，直接调用java的方法。\n\n在aviator中，调用java方式和其他不一样，比如我们上下文是usercontext，在其他脚本语言中调用是用usercontext.setname("jack")，而在aviator脚本中，调用方式是setname(usercontext, "jack")，也就是method(bean, args)这种形式，有点类似java反射的invoke形式。这点要注意下。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥞QLExpress脚本引擎",frontmatter:{title:"🥞QLExpress脚本引擎",date:"2023-08-28T00:47:19.000Z",permalink:"/pages/v2.11.X/19db6d/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/040.QLExpress%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/040.QLExpress脚本引擎.md",key:"v-625a0ef0",path:"/pages/v2.11.X/19db6d/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:182},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:586},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:853}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\nQLExpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-qlexpress</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本" type="script">\n    <![CDATA[\n        a=3;\n        b=2;\n        defaultContext.setData("s1",a*b);\n    ]]>\n</node>\n\n<node id="s2" name="条件脚本" type="switch_script">\n    <![CDATA[\n        count = defaultContext.getData("count");\n        if(count > 100){\n            return "a";\n        }else{\n            return "b";\n        }\n    ]]>\n</node>\n\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\nqlexpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-qlexpress</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本" type="script">\n    <![cdata[\n        a=3;\n        b=2;\n        defaultcontext.setdata("s1",a*b);\n    ]]>\n</node>\n\n<node id="s2" name="条件脚本" type="switch_script">\n    <![cdata[\n        count = defaultcontext.getdata("count");\n        if(count > 100){\n            return "a";\n        }else{\n            return "b";\n        }\n    ]]>\n</node>\n\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍧Python脚本引擎",frontmatter:{title:"🍧Python脚本引擎",date:"2023-08-28T00:48:36.000Z",permalink:"/pages/v2.11.X/114982/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/050.Python%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/050.Python脚本引擎.md",key:"v-7005a8fc",path:"/pages/v2.11.X/114982/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:1154},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:1421}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用python脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-python</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n提示\n\npython解析执行依赖Jython环境，不安装部署启动会报错（IDEA里不会报错），环境安装说明如下\n\n一、下载安装Jython Installer\n\nhttps://www.jython.org/download\n\n二、Springboot启动类添加代码\n\nProperties props = new Properties();\nProperties preprops = System.getProperties();\nprops.put("python.home", jython安装目录);\nPythonInterpreter.initialize (preprops, props, new String[]{});\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="python">\n    <![CDATA[\n        import json\n\n        x=\'{"name": "杰克", "age": 25, "nationality": "China"}\'\n        jsonData=json.loads(x)\n        name=jsonData[\'name\']\n        defaultContext.setData("name", name.decode(\'utf-8\'))\n\n\n        a=6\n        b=10\n        if a>5:\n            b=5\n            print \'hello\'\n        else:\n            print \'hi\'\n        defaultContext.setData("s1",a*b)\n    ]]>\n</node>\n\n\n上面的例子为python语法，你甚至可以引入一些python的原有的包来做逻辑。对于复杂的逻辑，推荐直接调用java类，关于如何和java互动请看下面。\n\n提示\n\n如果遇到中文乱码的现象，请使用decode函数，比如：\n\nprint \'你好\'.decode(\'UTF-8\')\n\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用python脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-python</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n提示\n\npython解析执行依赖jython环境，不安装部署启动会报错（idea里不会报错），环境安装说明如下\n\n一、下载安装jython installer\n\nhttps://www.jython.org/download\n\n二、springboot启动类添加代码\n\nproperties props = new properties();\nproperties preprops = system.getproperties();\nprops.put("python.home", jython安装目录);\npythoninterpreter.initialize (preprops, props, new string[]{});\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script" language="python">\n    <![cdata[\n        import json\n\n        x=\'{"name": "杰克", "age": 25, "nationality": "china"}\'\n        jsondata=json.loads(x)\n        name=jsondata[\'name\']\n        defaultcontext.setdata("name", name.decode(\'utf-8\'))\n\n\n        a=6\n        b=10\n        if a>5:\n            b=5\n            print \'hello\'\n        else:\n            print \'hi\'\n        defaultcontext.setdata("s1",a*b)\n    ]]>\n</node>\n\n\n上面的例子为python语法，你甚至可以引入一些python的原有的包来做逻辑。对于复杂的逻辑，推荐直接调用java类，关于如何和java互动请看下面。\n\n提示\n\n如果遇到中文乱码的现象，请使用decode函数，比如：\n\nprint \'你好\'.decode(\'utf-8\')\n\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍝Lua脚本引擎",frontmatter:{title:"🍝Lua脚本引擎",date:"2023-08-28T00:48:55.000Z",permalink:"/pages/v2.11.X/5f0cc7/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%F0%9F%8D%AB%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/060.Lua%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/010.🍫脚本语言种类/060.Lua脚本引擎.md",key:"v-cc8680f4",path:"/pages/v2.11.X/5f0cc7/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:6},{level:2,title:"脚本类型",slug:"脚本类型",normalizedTitle:"脚本类型",charIndex:577},{level:2,title:"如何取到上下文以及和Java类进行交互",slug:"如何取到上下文以及和java类进行交互",normalizedTitle:"如何取到上下文以及和java类进行交互",charIndex:844}],headersStr:"依赖 使用 脚本类型 如何取到上下文以及和Java类进行交互",content:'# 依赖\n\n使用lua脚本语言，你需要额外依赖LiteFlow提供的脚本插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-lua</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script">\n    <![CDATA[\n        local a=6\n        local b=10\n        if(a>5) then\n            b=5\n        else\n            b=2\n        end\n        defaultContext:setData("s1",a*b)\n        defaultContext:setData("s2",_meta:get("nodeId"))\n    ]]>\n</node>\n\n\n在lua中，调用java方法是用:来调用的，并不是.，比如defaultContext:setData("s1",a*b)。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和Java类进行交互\n\n关于这部分，请详细参考脚本与Java进行交互这一章节。',normalizedContent:'# 依赖\n\n使用lua脚本语言，你需要额外依赖liteflow提供的脚本插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-lua</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 使用\n\n你需要在你的xml中去定义node节点，以下是一个示例：\n\n<node id="s1" name="普通脚本1" type="script">\n    <![cdata[\n        local a=6\n        local b=10\n        if(a>5) then\n            b=5\n        else\n            b=2\n        end\n        defaultcontext:setdata("s1",a*b)\n        defaultcontext:setdata("s2",_meta:get("nodeid"))\n    ]]>\n</node>\n\n\n在lua中，调用java方法是用:来调用的，并不是.，比如defaultcontext:setdata("s1",a*b)。\n\n\n# 脚本类型\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值类型，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n\n# 如何取到上下文以及和java类进行交互\n\n关于这部分，请详细参考脚本与java进行交互这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣脚本与Java进行交互",frontmatter:{title:"🍣脚本与Java进行交互",date:"2022-10-05T14:18:24.000Z",permalink:"/pages/v2.11.X/d861c8/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/015.%E8%84%9A%E6%9C%AC%E4%B8%8EJava%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/015.脚本与Java进行交互.md",key:"v-d457f70c",path:"/pages/v2.11.X/d861c8/",headers:[{level:2,title:"和上下文进行交互",slug:"和上下文进行交互",normalizedTitle:"和上下文进行交互",charIndex:110},{level:2,title:"自定义上下文引用名称",slug:"自定义上下文引用名称",normalizedTitle:"自定义上下文引用名称",charIndex:649},{level:2,title:"元数据",slug:"元数据",normalizedTitle:"元数据",charIndex:949},{level:2,title:"和自定义的JavaBean进行交互",slug:"和自定义的javabean进行交互",normalizedTitle:"和自定义的javabean进行交互",charIndex:1319},{level:2,title:"直接注入方法",slug:"直接注入方法",normalizedTitle:"直接注入方法",charIndex:2669}],headersStr:"和上下文进行交互 自定义上下文引用名称 元数据 和自定义的JavaBean进行交互 直接注入方法",content:'提示\n\n这章只适用于groovy,js,python,qlexpress,lua,aviator这6种脚本语言。\n\nv2.11.0新增的Java脚本语言和Java类的交互方式在Java脚本引擎中已做了详细说明。\n\n\n# 和上下文进行交互\n\n因为LiteFlow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的className的驼峰形式来获取数据。\n\n比如你的上下文类叫OrderContext，那么脚本中的就用orderContext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取UserContext中的userName对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![CDATA[\n        //你可以这样定义\n        def name = userContext.userName;\n        //也可以这样定义，如果你对userName有getter方法的话\n        def name = userContext.getUserName();\n        //同理，你可以调用数据上下文中的任意方法\n        userContext.doYourMethod();\n    ]]>\n</node>\n\n\n\n# 自定义上下文引用名称\n\n上文提到，在脚本中默认的上下文引用规则为上下文类的simpleClassName，比如你的上下文为UserContext，那么脚本就用userContext去引用。\n\n那么可不可以自定义这个上下文的名称呢？\n\n可以。LiteFlow从2.10.0版本开始支持这个功能，如果你不想用userContext来引用，那么只需加一个@ContextBean的注解即可完成：\n\n@ContextBean("userCxt")\npublic class UserContext {\n    ...\n}\n\n\n这样定义后，那么脚本中，你就可以用userCtxt关键字去引用上下文了。\n\n\n# 元数据\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotIndex: slot下标，可以通过FlowBus.getSlot(slotIndex)来获得slot数据\n * currChainId: 当前执行chain的名称\n * nodeId: 当前执行node的Id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpData: 组件规则参数，关于cmpData的说明请查看组件参数\n * loopIndex: 在循环中的循环下标\n * loopObject: 在迭代循环中的循环对象\n * requestData: 流程初始参数\n * subRequestData: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 和自定义的JavaBean进行交互\n\nLiteFlow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@ScriptBean标注，即可完成注入。\n\n@Component\n@ScriptBean("demo")\npublic class DemoBean1 {\n\n    @Resource\n    private DemoBean2 demoBean2;\n\n    public String getDemoStr1(){\n        return "hello";\n    }\n\n    public String getDemoStr2(String name){\n        return demoBean2.getDemoStr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getDemoStr1()和getDemoStr2()方法了。\n\n我们在LiteFlow 2.9.5版本支持了@ScriptBean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", includeMethodName = {"test1","test2"})\npublic class DemoBean3 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", excludeMethodName = {"test2","test3"})\npublic class DemoBean4 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@ScriptBean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nScriptBeanManager.addScriptBean("demo", new DemoBean());\n\n\n\n# 直接注入方法\n\n如果你有一个java类，里面有100个方法，而我只想暴露其1个给脚本使用，用@ScriptBean可能会把整个bean都暴露出去，有没有方法呢？\n\n有。LiteFlow从2.9.5开始加入了@ScriptMethod注解，在方法上进行标注：\n\n@Component\npublic class DemoBean1 {\n\n    @ScriptMethod("demo")\n    public String getDemoStr1() {\n        return "hello";\n    }\n\n    public String method2() {\n       ...\n    }\n       \n    public String method3() {\n       ...\n    }\n    \n    ...\n}\n\n\n这样，你就可以在脚本中用demo.getDemoStr1()来调用到相应的java方法了。\n\n提示\n\n当然这里的前提同样是：java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@ScriptMethod注解也是没用的。',normalizedContent:'提示\n\n这章只适用于groovy,js,python,qlexpress,lua,aviator这6种脚本语言。\n\nv2.11.0新增的java脚本语言和java类的交互方式在java脚本引擎中已做了详细说明。\n\n\n# 和上下文进行交互\n\n因为liteflow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的classname的驼峰形式来获取数据。\n\n比如你的上下文类叫ordercontext，那么脚本中的就用ordercontext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取usercontext中的username对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![cdata[\n        //你可以这样定义\n        def name = usercontext.username;\n        //也可以这样定义，如果你对username有getter方法的话\n        def name = usercontext.getusername();\n        //同理，你可以调用数据上下文中的任意方法\n        usercontext.doyourmethod();\n    ]]>\n</node>\n\n\n\n# 自定义上下文引用名称\n\n上文提到，在脚本中默认的上下文引用规则为上下文类的simpleclassname，比如你的上下文为usercontext，那么脚本就用usercontext去引用。\n\n那么可不可以自定义这个上下文的名称呢？\n\n可以。liteflow从2.10.0版本开始支持这个功能，如果你不想用usercontext来引用，那么只需加一个@contextbean的注解即可完成：\n\n@contextbean("usercxt")\npublic class usercontext {\n    ...\n}\n\n\n这样定义后，那么脚本中，你就可以用userctxt关键字去引用上下文了。\n\n\n# 元数据\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotindex: slot下标，可以通过flowbus.getslot(slotindex)来获得slot数据\n * currchainid: 当前执行chain的名称\n * nodeid: 当前执行node的id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpdata: 组件规则参数，关于cmpdata的说明请查看组件参数\n * loopindex: 在循环中的循环下标\n * loopobject: 在迭代循环中的循环对象\n * requestdata: 流程初始参数\n * subrequestdata: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 和自定义的javabean进行交互\n\nliteflow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@scriptbean标注，即可完成注入。\n\n@component\n@scriptbean("demo")\npublic class demobean1 {\n\n    @resource\n    private demobean2 demobean2;\n\n    public string getdemostr1(){\n        return "hello";\n    }\n\n    public string getdemostr2(string name){\n        return demobean2.getdemostr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getdemostr1()和getdemostr2()方法了。\n\n我们在liteflow 2.9.5版本支持了@scriptbean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", includemethodname = {"test1","test2"})\npublic class demobean3 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", excludemethodname = {"test2","test3"})\npublic class demobean4 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@scriptbean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nscriptbeanmanager.addscriptbean("demo", new demobean());\n\n\n\n# 直接注入方法\n\n如果你有一个java类，里面有100个方法，而我只想暴露其1个给脚本使用，用@scriptbean可能会把整个bean都暴露出去，有没有方法呢？\n\n有。liteflow从2.9.5开始加入了@scriptmethod注解，在方法上进行标注：\n\n@component\npublic class demobean1 {\n\n    @scriptmethod("demo")\n    public string getdemostr1() {\n        return "hello";\n    }\n\n    public string method2() {\n       ...\n    }\n       \n    public string method3() {\n       ...\n    }\n    \n    ...\n}\n\n\n这样，你就可以在脚本中用demo.getdemostr1()来调用到相应的java方法了。\n\n提示\n\n当然这里的前提同样是：java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@scriptmethod注解也是没用的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍱多脚本语言混合共存",frontmatter:{title:"🍱多脚本语言混合共存",date:"2023-03-16T22:49:23.000Z",permalink:"/pages/v2.11.X/acba2c/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/020.%E5%A4%9A%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E5%85%B1%E5%AD%98.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/020.多脚本语言混合共存.md",key:"v-6e38866a",path:"/pages/v2.11.X/acba2c/",headersStr:null,content:'LiteFlow从2.10.0开始，支持了多脚本语言混合共存的特性。你完全可以在规则文件内用不同的脚本语言书写不同的逻辑。\n\n当然有个前提：你使用了多个脚本，必须引入多个脚本对应的依赖，依赖选项在脚本语言种类有说过。\n\n比如你可以这样定义多个脚本：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="groovy脚本" type="script" language="groovy">\n            <![CDATA[\n                class Student {\n                    int studentID\n                    String studentName\n                }\n\n                Student student = new Student()\n                student.studentID = 100301\n                student.studentName = "张三"\n                defaultContext.setData("student", student)\n\n                def a = 3\n                def b = 2\n                defaultContext.setData("s1", a * b)\n            ]]>\n        </node>\n\n        <node id="s2" name="js脚本" type="script" language="js">\n            <![CDATA[\n                var student = defaultContext.getData("student");\n                student.studentID = 10032;\n            ]]>\n        </node>\n\n        <node id="s3" name="python脚本" type="script" language="python">\n            <![CDATA[\n                a = 3\n                s1 = defaultContext.getData("s1")\n                defaultContext.setData("s1",s1*a)\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, s1, b, s2, c, s3);\n    </chain>\n</flow>\n\n\n以上规则中，其中a,b,c为java组件，s1是groovy组件，s2是javascript组件，s3是python组件。\n\nLiteFlow能非常方便的能进行混合编排，并且实现参数互通。',normalizedContent:'liteflow从2.10.0开始，支持了多脚本语言混合共存的特性。你完全可以在规则文件内用不同的脚本语言书写不同的逻辑。\n\n当然有个前提：你使用了多个脚本，必须引入多个脚本对应的依赖，依赖选项在脚本语言种类有说过。\n\n比如你可以这样定义多个脚本：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="groovy脚本" type="script" language="groovy">\n            <![cdata[\n                class student {\n                    int studentid\n                    string studentname\n                }\n\n                student student = new student()\n                student.studentid = 100301\n                student.studentname = "张三"\n                defaultcontext.setdata("student", student)\n\n                def a = 3\n                def b = 2\n                defaultcontext.setdata("s1", a * b)\n            ]]>\n        </node>\n\n        <node id="s2" name="js脚本" type="script" language="js">\n            <![cdata[\n                var student = defaultcontext.getdata("student");\n                student.studentid = 10032;\n            ]]>\n        </node>\n\n        <node id="s3" name="python脚本" type="script" language="python">\n            <![cdata[\n                a = 3\n                s1 = defaultcontext.getdata("s1")\n                defaultcontext.setdata("s1",s1*a)\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, s1, b, s2, c, s3);\n    </chain>\n</flow>\n\n\n以上规则中，其中a,b,c为java组件，s1是groovy组件，s2是javascript组件，s3是python组件。\n\nliteflow能非常方便的能进行混合编排，并且实现参数互通。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯文件脚本的定义",frontmatter:{title:"🌯文件脚本的定义",date:"2022-10-05T14:16:29.000Z",permalink:"/pages/v2.11.X/f7acfd/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/030.%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9A%E4%B9%89.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/030.文件脚本的定义.md",key:"v-608c3a58",path:"/pages/v2.11.X/f7acfd/",headersStr:null,content:'LiteFlow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟IDE对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前LiteFlow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n从2.9.7开始，LiteFlow已经支持脚本文件的绝对路径。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, IF(s3, b, c));\n    </chain>\n</flow>\n',normalizedContent:'liteflow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟ide对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前liteflow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n从2.9.7开始，liteflow已经支持脚本文件的绝对路径。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        then(d, if(s3, b, c));\n    </chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍘动态刷新脚本",frontmatter:{title:"🍘动态刷新脚本",date:"2022-10-05T22:47:47.000Z",permalink:"/pages/v2.11.X/cbcb14/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/050.%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E8%84%9A%E6%9C%AC.html",relativePath:"08.v2.11.X文档/085.🍋脚本组件/050.动态刷新脚本.md",key:"v-789e0ef9",path:"/pages/v2.11.X/cbcb14/",headersStr:null,content:'其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n但是如果你要仅仅热刷新脚本的话，这里也提供了单独的方式，你可以调用如下的代码进行脚本的热刷新：\n\nScriptExecutorFactory.loadInstance().getScriptExecutor("groovy").load(nodeId, script);\n',normalizedContent:'其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n但是如果你要仅仅热刷新脚本的话，这里也提供了单独的方式，你可以调用如下的代码进行脚本的热刷新：\n\nscriptexecutorfactory.loadinstance().getscriptexecutor("groovy").load(nodeid, script);\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥭什么叫声明式组件",frontmatter:{title:"🥭什么叫声明式组件",date:"2022-10-05T23:19:02.000Z",permalink:"/pages/v2.11.X/46f0fa/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/010.%E4%BB%80%E4%B9%88%E5%8F%AB%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/086.🍇声明式组件/010.什么叫声明式组件.md",key:"v-7c5f3212",path:"/pages/v2.11.X/46f0fa/",headersStr:null,content:"何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承NodeComponent或者NodeSwitchComponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成LiteFlow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。\n\n提示\n\n目前声明式组件只能在springboot环境中使用.",normalizedContent:"何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承nodecomponent或者nodeswitchcomponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成liteflow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。\n\n提示\n\n目前声明式组件只能在springboot环境中使用.",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:56:32.000Z",permalink:"/pages/v2.11.X/9aa85a/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/010.%E8%AF%B4%E6%98%8E.html",relativePath:"08.v2.11.X文档/090.🎲用代码动态构造规则/010.说明.md",key:"v-02709772",path:"/pages/v2.11.X/9aa85a/",headersStr:null,content:"之前的章节讲述的是通过规则文件去构造流程。\n\nLiteFlow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，ruleSource不用去定义。完全用代码去构建。\n\n事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的API意义在于：\n\n有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n\nLiteFlow设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",normalizedContent:"之前的章节讲述的是通过规则文件去构造流程。\n\nliteflow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，rulesource不用去定义。完全用代码去构建。\n\n事实上，liteflow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的api意义在于：\n\n有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n\nliteflow设计了非常简单的构造方法链式api，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥥方法级别式声明",frontmatter:{title:"🥥方法级别式声明",date:"2022-10-05T23:40:08.000Z",permalink:"/pages/v2.11.X/797830/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/030.%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"08.v2.11.X文档/086.🍇声明式组件/030.方法级别式声明.md",key:"v-16638950",path:"/pages/v2.11.X/797830/",headersStr:null,content:'LiteFlow从v2.9.0版开始推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    //普通组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeName = "A组件")\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    //SWITCH组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeId = "b", nodeName = "B组件", nodeType = NodeTypeEnum.SWITCH)\n    public String processB(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //IF组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_IF, nodeId = "c", nodeName = "C组件", nodeType = NodeTypeEnum.IF)\n    public boolean processC(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //FOR组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeId = "d", nodeName = "D组件", nodeType = NodeTypeEnum.FOR)\n    public int processD(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //WHILE组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_WHILE, nodeId = "e", nodeName = "E组件", nodeType = NodeTypeEnum.WHILE)\n    public int processE(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //BREAK组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BREAK, nodeId = "f", nodeName = "F组件", nodeType = NodeTypeEnum.BREAK)\n    public int processF(NodeComponent bindCmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@LiteflowMethod注解上的nodeId一定要写。\n\nLiteFlow从v2.10.6开始，新增了nodeName的属性。方便对声明式的组件进行命名。这个属性是可选的。\n\n普通组件上的nodeType因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodeType = NodeTypeEnum.COMMON。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如IF组件的processIf方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public boolean isAccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void onSuccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_IF, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public boolean processF(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public boolean isAccessF(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public void onSuccessF(NodeComponent bindCmp){\n        ...\n    }\n}\n',normalizedContent:'liteflow从v2.9.0版开始推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    //普通组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodename = "a组件")\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    //switch组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodeid = "b", nodename = "b组件", nodetype = nodetypeenum.switch)\n    public string processb(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //if组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_if, nodeid = "c", nodename = "c组件", nodetype = nodetypeenum.if)\n    public boolean processc(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //for组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_for, nodeid = "d", nodename = "d组件", nodetype = nodetypeenum.for)\n    public int processd(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //while组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_while, nodeid = "e", nodename = "e组件", nodetype = nodetypeenum.while)\n    public int processe(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //break组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_break, nodeid = "f", nodename = "f组件", nodetype = nodetypeenum.break)\n    public int processf(nodecomponent bindcmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@liteflowmethod注解上的nodeid一定要写。\n\nliteflow从v2.10.6开始，新增了nodename的属性。方便对声明式的组件进行命名。这个属性是可选的。\n\n普通组件上的nodetype因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodetype = nodetypeenum.common。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如if组件的processif方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodetype = nodetypeenum.common)\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "a", nodetype = nodetypeenum.common)\n    public boolean isaccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "a", nodetype = nodetypeenum.common)\n    public void onsuccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.process_if, nodeid = "f", nodetype = nodetypeenum.if)\n    public boolean processf(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "f", nodetype = nodetypeenum.if)\n    public boolean isaccessf(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "f", nodetype = nodetypeenum.if)\n    public void onsuccessf(nodecomponent bindcmp){\n        ...\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧅类级别式声明",frontmatter:{title:"🧅类级别式声明",date:"2022-10-05T23:22:17.000Z",permalink:"/pages/v2.11.X/18f548/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/020.%E7%B1%BB%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"08.v2.11.X文档/086.🍇声明式组件/020.类级别式声明.md",key:"v-479d7cf0",path:"/pages/v2.11.X/18f548/",headers:[{level:2,title:"普通组件的声明",slug:"普通组件的声明",normalizedTitle:"普通组件的声明",charIndex:147},{level:2,title:"选择组件的声明",slug:"选择组件的声明",normalizedTitle:"选择组件的声明",charIndex:2e3},{level:2,title:"条件组件的声明",slug:"条件组件的声明",normalizedTitle:"条件组件的声明",charIndex:2375},{level:2,title:"数值循环组件的声明",slug:"数值循环组件的声明",normalizedTitle:"数值循环组件的声明",charIndex:2678},{level:2,title:"条件循环组件的声明",slug:"条件循环组件的声明",normalizedTitle:"条件循环组件的声明",charIndex:2990},{level:2,title:"退出循环组件的声明",slug:"退出循环组件的声明",normalizedTitle:"退出循环组件的声明",charIndex:3351},{level:2,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:1537}],headersStr:"普通组件的声明 选择组件的声明 条件组件的声明 数值循环组件的声明 条件循环组件的声明 退出循环组件的声明 注意点",content:'类级别式声明主要用处就是通过注解形式让普通的java bean变成LiteFlow的组件。无需通过继承类或者实现接口的方式。\n\n由于LiteFlow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@LiteflowComponent("a")\n@LiteflowCmpDefine\npublic class ACmp{\n  \n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS)\n\tpublic void processAcmp(NodeComponent bindCmp) {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)\n\tpublic boolean isAcmpAccess(NodeComponent bindCmp){\n\t\treturn true;\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.BEFORE_PROCESS)\n\tpublic void beforeAcmp(NodeComponent bindCmp){\n\t\tSystem.out.println("before A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.AFTER_PROCESS)\n\tpublic void afterAcmp(NodeComponent bindCmp){\n\t\tSystem.out.println("after A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_SUCCESS)\n\tpublic void onAcmpSuccess(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp success");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_ERROR)\n\tpublic void onAcmpError(NodeComponent bindCmp, Exception e){\n\t\tSystem.out.println("Acmp error");\n\t}\n\t\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_END)\n\tpublic boolean isAcmpEnd(NodeComponent bindCmp) {\n\t\treturn false;\n\t}\n    \n    @LiteflowMethod(value = LiteFlowMethodEnum.ROLLBACK)\n    public void rollbackA(NodeComponent bindCmp) throws Exception {\n        System.out.println("ACmp rollback!");\n    }\n}\n\n\n使用者无需继承NodeComponent了，在你定义的类上，只要类上加上LiteflowCmpDefine注解，相应的方法上加上LiteflowMethod注解，即可完成对任意自定义类的组件化工作。\n\n其中LiteFlowMethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n关于参数的参数，这里需要注意的是，方法上参数必须传入NodeComponent bindCmp这个参数，而且必须是第一个参数。\n\n比如原先的process()，那么在声明式里就是yourMethodName(NodeComponent bindCmp)。\n\n如果是原先的onError(Exception e)，那么在声明式里就是yourMethodName(NodeComponent bindCmp, Exception e)。\n\n规律很明显，就是原先的参数保留，在第一个位置插入NodeComponent对象，代替原先的this。\n\n以前获取上下文Bean是用this关键字，现在只需从bindCmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如IF组件的processIf方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.SWITCH参数。\n\n@Component("e")\n@LiteflowCmpDefine(NodeTypeEnum.SWITCH)\npublic class ECmp{\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeType = NodeTypeEnum.SWITCH)\n    public String processSwitch(NodeComponent bindCmp) throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.IF参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.IF)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.IF, nodeType = NodeTypeEnum.IF)\n\tpublic boolean processIf(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.FOR参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.FOR)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeType = NodeTypeEnum.FOR)\n\tpublic int processFor(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 条件循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.WHILE参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.WHILE)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_WHILE, nodeType = NodeTypeEnum.WHILE)\n\tpublic boolean processWhile(NodeComponent bindCmp) throws Exception {\n\t\t//get your while flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 退出循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.BREAK参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.BREAK)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BREAK, nodeType = NodeTypeEnum.BREAK)\n\tpublic boolean processBreak(NodeComponent bindCmp) throws Exception {\n\t\t//get your break flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processXxx一样的方式去声明。',normalizedContent:'类级别式声明主要用处就是通过注解形式让普通的java bean变成liteflow的组件。无需通过继承类或者实现接口的方式。\n\n由于liteflow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@liteflowcomponent("a")\n@liteflowcmpdefine\npublic class acmp{\n  \n\t@liteflowmethod(liteflowmethodenum.process)\n\tpublic void processacmp(nodecomponent bindcmp) {\n\t\tsystem.out.println("acmp executed!");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.is_access)\n\tpublic boolean isacmpaccess(nodecomponent bindcmp){\n\t\treturn true;\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.before_process)\n\tpublic void beforeacmp(nodecomponent bindcmp){\n\t\tsystem.out.println("before a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.after_process)\n\tpublic void afteracmp(nodecomponent bindcmp){\n\t\tsystem.out.println("after a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_success)\n\tpublic void onacmpsuccess(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp success");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_error)\n\tpublic void onacmperror(nodecomponent bindcmp, exception e){\n\t\tsystem.out.println("acmp error");\n\t}\n\t\n\t@liteflowmethod(liteflowmethodenum.is_end)\n\tpublic boolean isacmpend(nodecomponent bindcmp) {\n\t\treturn false;\n\t}\n    \n    @liteflowmethod(value = liteflowmethodenum.rollback)\n    public void rollbacka(nodecomponent bindcmp) throws exception {\n        system.out.println("acmp rollback!");\n    }\n}\n\n\n使用者无需继承nodecomponent了，在你定义的类上，只要类上加上liteflowcmpdefine注解，相应的方法上加上liteflowmethod注解，即可完成对任意自定义类的组件化工作。\n\n其中liteflowmethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n关于参数的参数，这里需要注意的是，方法上参数必须传入nodecomponent bindcmp这个参数，而且必须是第一个参数。\n\n比如原先的process()，那么在声明式里就是yourmethodname(nodecomponent bindcmp)。\n\n如果是原先的onerror(exception e)，那么在声明式里就是yourmethodname(nodecomponent bindcmp, exception e)。\n\n规律很明显，就是原先的参数保留，在第一个位置插入nodecomponent对象，代替原先的this。\n\n以前获取上下文bean是用this关键字，现在只需从bindcmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如if组件的processif方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.switch参数。\n\n@component("e")\n@liteflowcmpdefine(nodetypeenum.switch)\npublic class ecmp{\n\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodetype = nodetypeenum.switch)\n    public string processswitch(nodecomponent bindcmp) throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.if参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.if)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.if, nodetype = nodetypeenum.if)\n\tpublic boolean processif(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.for参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.for)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_for, nodetype = nodetypeenum.for)\n\tpublic int processfor(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 条件循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.while参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.while)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_while, nodetype = nodetypeenum.while)\n\tpublic boolean processwhile(nodecomponent bindcmp) throws exception {\n\t\t//get your while flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 退出循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.break参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.break)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_break, nodetype = nodetypeenum.break)\n\tpublic boolean processbreak(nodecomponent bindcmp) throws exception {\n\t\t//get your break flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processxxx一样的方式去声明。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥜构造Node",frontmatter:{title:"🥜构造Node",date:"2023-10-12T10:46:15.000Z",permalink:"/pages/v2.11.X/5bbee3/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/020.%E6%9E%84%E9%80%A0Node.html",relativePath:"08.v2.11.X文档/090.🎲用代码动态构造规则/020.构造Node.md",key:"v-5b00a83e",path:"/pages/v2.11.X/5bbee3/",headers:[{level:2,title:"什么时候构造",slug:"什么时候构造",normalizedTitle:"什么时候构造",charIndex:93},{level:2,title:"构造Node",slug:"构造node",normalizedTitle:"构造node",charIndex:145}],headersStr:"什么时候构造 构造Node",content:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造Node\n\n提示\n\n你可以像以下那样构造一个普通的Node，当然在spring/springboot环境，大多数情况你无需去构建一个Node，因为只要你的组件上标有@Component/@LiteflowComponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看定义脚本组件\n\n//构建一个普通组件\nLiteFlowNodeBuilder.createCommonNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个普通条件组件\nLiteFlowNodeBuilder.createSwitchNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个脚本组件\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nLiteFlowNodeBuilder.createScriptSwitchNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setFile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@LiteflowComponent或者@Component，如果项目是spring体系的话，LiteFlow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@Autowired和@Resource等等之类的spring任何注解。',normalizedContent:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造node\n\n提示\n\n你可以像以下那样构造一个普通的node，当然在spring/springboot环境，大多数情况你无需去构建一个node，因为只要你的组件上标有@component/@liteflowcomponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看定义脚本组件\n\n//构建一个普通组件\nliteflownodebuilder.createcommonnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个普通条件组件\nliteflownodebuilder.createswitchnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个脚本组件\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nliteflownodebuilder.createscriptswitchnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setfile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@liteflowcomponent或者@component，如果项目是spring体系的话，liteflow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@autowired和@resource等等之类的spring任何注解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌰构造EL",frontmatter:{title:"🌰构造EL",date:"2023-10-11T21:54:09.000Z",permalink:"/pages/v2.11.X/a3cb4b/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/030.%E6%9E%84%E9%80%A0EL.html",relativePath:"08.v2.11.X文档/090.🎲用代码动态构造规则/030.构造EL.md",key:"v-6ebc757e",path:"/pages/v2.11.X/a3cb4b/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"构建一个EL表达式",slug:"构建一个el表达式",normalizedTitle:"构建一个el表达式",charIndex:232},{level:2,title:"格式化输出EL表达式",slug:"格式化输出el表达式",normalizedTitle:"格式化输出el表达式",charIndex:1309},{level:2,title:"目前支持的表达式和关键字",slug:"目前支持的表达式和关键字",normalizedTitle:"目前支持的表达式和关键字",charIndex:1628},{level:2,title:"EL表达式参数校验",slug:"el表达式参数校验",normalizedTitle:"el表达式参数校验",charIndex:5543}],headersStr:"依赖 构建一个EL表达式 格式化输出EL表达式 目前支持的表达式和关键字 EL表达式参数校验",content:'# 依赖\n\n从2.11.1版本开始，你可以在代码中动态组装EL表达式，包括创建、修改、输出EL表达式。\n\n如果需要在代码中动态构建EL表达式，需要添加以下额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-el-builder</artifactId>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 构建一个EL表达式\n\n你可以通过工厂类ELBus创建任何一个EL表达式。比如对于这样一个EL表达式：\n\n图示\n\n可以调用如下方法组装该表达式：\n\n// 组装EL表达式\nThenELWrapper el = ELBus.then("a",\n\t\tELBus.when("b").when(ELBus.then("c", "d")),\n\t\t"e");\n\n\n可以调用toEL()方法输出EL表达式：\n\nTHEN(node("a"),WHEN(node("b"),THEN(node("c"),node("d"))),node("e"))\n\n\n提示\n\n为了避免可能的冲突，node("")将组件名进行了包装，以确保Node的名称与LiteFlow组件名规范不发生冲突。更详细的内容请查看组件名包装。\n\n除了构建表达式之外，你也可以在表达式中调用表达式的关键字，比如为选择组件的子组件设置id、tag，设置并行组件的any关键字等等。如下例所示：\n\n\x3c!-- 目标EL表达式 --\x3e\n<chain name="chain1">\nwhenData = \'{"name":"zhangsan","age":18}\';\n\nWHEN(\n\tnode("a"),\n\tWHEN(\n\t\tnode("b").data(whenData),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n</chain>\n\n\n可以通过以下方法组装出该EL表达式，调用对应的关键字，并输出对应的表达式。\n\n// EL表达式组装\nWhenELWrapper el = ELBus.when("a",\n\t\tELBus.when(ELBus.node("b").data("whenData", "{\\"name\\":\\"zhangsan\\",\\"age\\":18}"))\n\t\t     .when("c")\n\t\t\t .id("this is a id"),\n\t\t"d").tag("this is a tag").any(true);\n\n\n该EL表达式输出如下：\n\nwhenData = \'{"name":"zhangsan","age":18}\';\nWHEN(node("a"),WHEN(node("b").data(whenData),node("c")).id("this is a id"),node("d")).any(true).tag("this is a tag")\n\n\n\n# 格式化输出EL表达式\n\n容易能发现toEL()方法输出的EL表达式是一行字符串，不方便查看以及校验EL表达式是否正确。可以使用 toEL(true) 方法以树形结构输出EL表达式。对于上一个例子中的EL表达式，调用el.toEL(true)方法，得到树型结构表达式输出如下：\n\nwhenData = \'{"name":"zhangsan","age":18}\';\nWHEN(\n\tnode("a"),\n\tWHEN(\n\t\tnode("b").data(whenData),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n\n\n\n# 目前支持的表达式和关键字\n\n目前支持到2.11.1版本的所有EL表达式，包括其中的关键字和高级特性。当前支持的详细内容如下表：\n\nEL表达式     创建方法                    支持调用方法                                          支持关键字\n串行编排      ELBus.then              then(Object ... objects)                        pre\n                                                                                  finally\n                                                                                  tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n并行编排      ELBus.when              when(Object ... objects)                        any\n                                                                                  ignoreError\n                                                                                  customThreadExecutor\n                                                                                  must\n                                                                                  tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n选择编排      ELBus.switch            to(Object... objects)                           tag\n                                  defaultOpt(Object object)                       id\n                                                                                  maxWaitSeconds\n条件编排      ELBus.ifOpt             elseOpt(Object falseObject)                     tag\n                                  elIfOpt(Object ifObject, Object trueObject)     id\n                                                                                  maxWaitSeconds\n循环编排      ELBus.forOpt            doOpt(Object object)                            parallel\n          ELBus.whileOpt          breakOpt(Object object) (ITERATOR迭代器循环表达式不支持)   tag\n          ELBus.iteratorOpt                                                       id\n                                                                                  maxWaitSeconds\n捕获异常表达式   ELBus.catchException    doOpt(Object object)                            tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n与表达式      ELBus.and               and(Object ... object)                          tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n或表达式      ELBus.or                or(Object ... object)                           tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n非表达式      ELBus.not                                                               tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n单节点表达式    ELBus.node                                                              tag\n                                                                                  data\n                                                                                  maxWaitSeconds\n前置组件      通过then组件的pre关键字创建                                                       tag\n                                                                                  id\n                                                                                  maxWaitSeconds\n后置组件      通过then组件的finally关键字创建                                                   tag\n                                                                                  id\n\n\n# EL表达式参数校验\n\n组装表达式时会对表达式的参数类型进行校验。包括是否为单节点组件、是否允许为与或非表达式等。比如，WHILE表达式WHILE(w).DO(THEN(a, b)); 中，w需要是返回布尔值的节点或与或非表达式。\n\n更多测试样例请在 liteflow-testcase-el/liteflow-testcase-el-builder 模块中查看。',normalizedContent:'# 依赖\n\n从2.11.1版本开始，你可以在代码中动态组装el表达式，包括创建、修改、输出el表达式。\n\n如果需要在代码中动态构建el表达式，需要添加以下额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-el-builder</artifactid>\n    <version>2.11.4.2</version>\n</dependency>\n\n\n\n# 构建一个el表达式\n\n你可以通过工厂类elbus创建任何一个el表达式。比如对于这样一个el表达式：\n\n图示\n\n可以调用如下方法组装该表达式：\n\n// 组装el表达式\nthenelwrapper el = elbus.then("a",\n\t\telbus.when("b").when(elbus.then("c", "d")),\n\t\t"e");\n\n\n可以调用toel()方法输出el表达式：\n\nthen(node("a"),when(node("b"),then(node("c"),node("d"))),node("e"))\n\n\n提示\n\n为了避免可能的冲突，node("")将组件名进行了包装，以确保node的名称与liteflow组件名规范不发生冲突。更详细的内容请查看组件名包装。\n\n除了构建表达式之外，你也可以在表达式中调用表达式的关键字，比如为选择组件的子组件设置id、tag，设置并行组件的any关键字等等。如下例所示：\n\n\x3c!-- 目标el表达式 --\x3e\n<chain name="chain1">\nwhendata = \'{"name":"zhangsan","age":18}\';\n\nwhen(\n\tnode("a"),\n\twhen(\n\t\tnode("b").data(whendata),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n</chain>\n\n\n可以通过以下方法组装出该el表达式，调用对应的关键字，并输出对应的表达式。\n\n// el表达式组装\nwhenelwrapper el = elbus.when("a",\n\t\telbus.when(elbus.node("b").data("whendata", "{\\"name\\":\\"zhangsan\\",\\"age\\":18}"))\n\t\t     .when("c")\n\t\t\t .id("this is a id"),\n\t\t"d").tag("this is a tag").any(true);\n\n\n该el表达式输出如下：\n\nwhendata = \'{"name":"zhangsan","age":18}\';\nwhen(node("a"),when(node("b").data(whendata),node("c")).id("this is a id"),node("d")).any(true).tag("this is a tag")\n\n\n\n# 格式化输出el表达式\n\n容易能发现toel()方法输出的el表达式是一行字符串，不方便查看以及校验el表达式是否正确。可以使用 toel(true) 方法以树形结构输出el表达式。对于上一个例子中的el表达式，调用el.toel(true)方法，得到树型结构表达式输出如下：\n\nwhendata = \'{"name":"zhangsan","age":18}\';\nwhen(\n\tnode("a"),\n\twhen(\n\t\tnode("b").data(whendata),\n\t\tnode("c")\n\t).id("this is a id"),\n\tnode("d")\n).any(true).tag("this is a tag")\n\n\n\n# 目前支持的表达式和关键字\n\n目前支持到2.11.1版本的所有el表达式，包括其中的关键字和高级特性。当前支持的详细内容如下表：\n\nel表达式     创建方法                    支持调用方法                                          支持关键字\n串行编排      elbus.then              then(object ... objects)                        pre\n                                                                                  finally\n                                                                                  tag\n                                                                                  id\n                                                                                  maxwaitseconds\n并行编排      elbus.when              when(object ... objects)                        any\n                                                                                  ignoreerror\n                                                                                  customthreadexecutor\n                                                                                  must\n                                                                                  tag\n                                                                                  id\n                                                                                  maxwaitseconds\n选择编排      elbus.switch            to(object... objects)                           tag\n                                  defaultopt(object object)                       id\n                                                                                  maxwaitseconds\n条件编排      elbus.ifopt             elseopt(object falseobject)                     tag\n                                  elifopt(object ifobject, object trueobject)     id\n                                                                                  maxwaitseconds\n循环编排      elbus.foropt            doopt(object object)                            parallel\n          elbus.whileopt          breakopt(object object) (iterator迭代器循环表达式不支持)   tag\n          elbus.iteratoropt                                                       id\n                                                                                  maxwaitseconds\n捕获异常表达式   elbus.catchexception    doopt(object object)                            tag\n                                                                                  id\n                                                                                  maxwaitseconds\n与表达式      elbus.and               and(object ... object)                          tag\n                                                                                  id\n                                                                                  maxwaitseconds\n或表达式      elbus.or                or(object ... object)                           tag\n                                                                                  id\n                                                                                  maxwaitseconds\n非表达式      elbus.not                                                               tag\n                                                                                  id\n                                                                                  maxwaitseconds\n单节点表达式    elbus.node                                                              tag\n                                                                                  data\n                                                                                  maxwaitseconds\n前置组件      通过then组件的pre关键字创建                                                       tag\n                                                                                  id\n                                                                                  maxwaitseconds\n后置组件      通过then组件的finally关键字创建                                                   tag\n                                                                                  id\n\n\n# el表达式参数校验\n\n组装表达式时会对表达式的参数类型进行校验。包括是否为单节点组件、是否允许为与或非表达式等。比如，while表达式while(w).do(then(a, b)); 中，w需要是返回布尔值的节点或与或非表达式。\n\n更多测试样例请在 liteflow-testcase-el/liteflow-testcase-el-builder 模块中查看。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍞构造Chain",frontmatter:{title:"🍞构造Chain",date:"2023-10-12T10:46:15.000Z",permalink:"/pages/v2.11.X/cd0445/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/040.%E6%9E%84%E9%80%A0Chain.html",relativePath:"08.v2.11.X文档/090.🎲用代码动态构造规则/040.构造Chain.md",key:"v-6ac251e4",path:"/pages/v2.11.X/cd0445/",headers:[{level:2,title:"构建一个Chain",slug:"构建一个chain",normalizedTitle:"构建一个chain",charIndex:2},{level:2,title:"使用动态组装EL表达式构建Chain",slug:"使用动态组装el表达式构建chain",normalizedTitle:"使用动态组装el表达式构建chain",charIndex:324},{level:2,title:"销毁一个Chain",slug:"销毁一个chain",normalizedTitle:"销毁一个chain",charIndex:681}],headersStr:"构建一个Chain 使用动态组装EL表达式构建Chain 销毁一个Chain",content:'# 构建一个Chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个EL表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 使用动态组装EL表达式构建Chain\n\n从2.11.1版本开始，您可以根据实际需求动态地构建EL表达式，而不仅仅限于使用固定的字符串。如下例所示：\n\n// 动态组装el表达式\nELWrapper el = ELBus.then("a", "b", ELBus.when("c", "d"));\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n\t// 输出el表达式\n    el.toEL()\n).build();\n\n\n请注意，上述示例仅用于演示目的，实际使用时，您需要根据具体的业务逻辑和数据结构来组装EL表达式，并将其应用于相应的Chain。\n\n如果使用动态组装的EL表达式，需要引入额外依赖。具体请参考构造EL。\n\n\n# 销毁一个Chain\n\nLiteFlow中允许你手动运行以下代码来销毁一个流程：\n\nFlowBus.removeChain("你的流程ID")\n',normalizedContent:'# 构建一个chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个el表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 使用动态组装el表达式构建chain\n\n从2.11.1版本开始，您可以根据实际需求动态地构建el表达式，而不仅仅限于使用固定的字符串。如下例所示：\n\n// 动态组装el表达式\nelwrapper el = elbus.then("a", "b", elbus.when("c", "d"));\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n\t// 输出el表达式\n    el.toel()\n).build();\n\n\n请注意，上述示例仅用于演示目的，实际使用时，您需要根据具体的业务逻辑和数据结构来组装el表达式，并将其应用于相应的chain。\n\n如果使用动态组装的el表达式，需要引入额外依赖。具体请参考构造el。\n\n\n# 销毁一个chain\n\nliteflow中允许你手动运行以下代码来销毁一个流程：\n\nflowbus.removechain("你的流程id")\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥠组件降级",frontmatter:{title:"🥠组件降级",date:"2023-10-08T20:06:00.000Z",permalink:"/pages/v2.11.X/79289a/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/035.%E7%BB%84%E4%BB%B6%E9%99%8D%E7%BA%A7.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/035.组件降级.md",key:"v-4790ead5",path:"/pages/v2.11.X/79289a/",headers:[{level:2,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:254},{level:2,title:"多组件类型的支持",slug:"多组件类型的支持",normalizedTitle:"多组件类型的支持",charIndex:723}],headersStr:"使用方法 多组件类型的支持",content:'LiteFlow 从 2.11.1 版本开始支持组件降级功能。\n\n如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了 A，B，C 三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    THEN(A, B, C, D);\n</chain>\n\n\n由于 D 组件不存在，所以启动时会报错。\n\n组件降级的意义是，当你写了一个不存在的组件时，在运行时会自动路由到你指定的降级组件上，由这个降级组件来代替你不存在的组件执行，这样就不会报错了。\n\n\n# 使用方法\n\n首先需要在配置文件开启组件降级功能，默认是关闭的：\n\nliteflow.fallback-cmp-enable=true\n\n\n若想将一个组件声明为降级组件，只需要在组件上添加 @FallbackCmp 注解。 比如可以通过以下方式定义一个普通组件的降级组件 E。\n\n@LiteflowComponent("E")\n@FallbackCmp\npublic class ECmp extends NodeComponent {\n    @Override\n    public void process() {\n        System.out.println("ECmp executed!");\n    }\n}\n\n\n若想使用降级组件，规则文件需要这么写：\n\n<chain name="chain1">\n    THEN(A, B, C, node("D"));\n</chain>\n\n\n当组件 D 不存在时，会降级为组件 E 运行。\n\n提示\n\n如果不加 node 关键字，是不会自动路由到降级组件的，所以一定得加。\n\n\n# 多组件类型的支持\n\nLiteFlow 不仅支持普通组件的降级，对其他组件类型也提供了支持。以下示例分别声明了一个条件降级组件和次数循环降级组件。\n\n@LiteflowComponent("if1")\n@FallbackCmp\npublic class IfCmp1 extends NodeIfComponent {\n    @Override\n    public boolean processIf() throws Exception {\n        return false;\n    }\n}\n\n\n@LiteflowComponent("for1")\n@FallbackCmp\npublic class ForCmp extends NodeForComponent {\n    @Override\n    public int processFor() throws Exception {\n        return 3;\n    }\n} \n\n\n对于如下的 EL 表达式：\n\n<chain name="chain2">\n    IF(node("x1"), FOR(node("x2")).DO(node("x3")));\n</chain>\n\n\n当组件 x1、x2 或 x3 不存在时，会分别路由到条件降级组件、次数循环降级组件以及普通降级组件。其他类型的组件也同理。\n\n与或非表达式也可以使用降级组件，如下的 EL 表达式：\n\n<chain name="chain3">\n    IF(AND(node("x"), a), b);\n</chain>\n\n\n当组件 x 不存在时会路由到条件降级组件。\n\n提示\n\n目前每种类型的组件只允许定义一个降级组件。',normalizedContent:'liteflow 从 2.11.1 版本开始支持组件降级功能。\n\n如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了 a，b，c 三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n由于 d 组件不存在，所以启动时会报错。\n\n组件降级的意义是，当你写了一个不存在的组件时，在运行时会自动路由到你指定的降级组件上，由这个降级组件来代替你不存在的组件执行，这样就不会报错了。\n\n\n# 使用方法\n\n首先需要在配置文件开启组件降级功能，默认是关闭的：\n\nliteflow.fallback-cmp-enable=true\n\n\n若想将一个组件声明为降级组件，只需要在组件上添加 @fallbackcmp 注解。 比如可以通过以下方式定义一个普通组件的降级组件 e。\n\n@liteflowcomponent("e")\n@fallbackcmp\npublic class ecmp extends nodecomponent {\n    @override\n    public void process() {\n        system.out.println("ecmp executed!");\n    }\n}\n\n\n若想使用降级组件，规则文件需要这么写：\n\n<chain name="chain1">\n    then(a, b, c, node("d"));\n</chain>\n\n\n当组件 d 不存在时，会降级为组件 e 运行。\n\n提示\n\n如果不加 node 关键字，是不会自动路由到降级组件的，所以一定得加。\n\n\n# 多组件类型的支持\n\nliteflow 不仅支持普通组件的降级，对其他组件类型也提供了支持。以下示例分别声明了一个条件降级组件和次数循环降级组件。\n\n@liteflowcomponent("if1")\n@fallbackcmp\npublic class ifcmp1 extends nodeifcomponent {\n    @override\n    public boolean processif() throws exception {\n        return false;\n    }\n}\n\n\n@liteflowcomponent("for1")\n@fallbackcmp\npublic class forcmp extends nodeforcomponent {\n    @override\n    public int processfor() throws exception {\n        return 3;\n    }\n} \n\n\n对于如下的 el 表达式：\n\n<chain name="chain2">\n    if(node("x1"), for(node("x2")).do(node("x3")));\n</chain>\n\n\n当组件 x1、x2 或 x3 不存在时，会分别路由到条件降级组件、次数循环降级组件以及普通降级组件。其他类型的组件也同理。\n\n与或非表达式也可以使用降级组件，如下的 el 表达式：\n\n<chain name="chain3">\n    if(and(node("x"), a), b);\n</chain>\n\n\n当组件 x 不存在时会路由到条件降级组件。\n\n提示\n\n目前每种类型的组件只允许定义一个降级组件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍒前置和后置组件",frontmatter:{title:"🍒前置和后置组件",date:"2022-07-02T22:51:41.000Z",permalink:"/pages/v2.11.X/9f93be/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/030.%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E7%BB%84%E4%BB%B6.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/030.前置和后置组件.md",key:"v-0c1bcada",path:"/pages/v2.11.X/9f93be/",headers:[{level:2,title:"前置组件",slug:"前置组件",normalizedTitle:"前置组件",charIndex:11},{level:2,title:"后置节点",slug:"后置节点",normalizedTitle:"后置节点",charIndex:259},{level:2,title:"顺序问题",slug:"顺序问题",normalizedTitle:"顺序问题",charIndex:446},{level:2,title:"层级和范围",slug:"层级和范围",normalizedTitle:"层级和范围",charIndex:732}],headersStr:"前置组件 后置节点 顺序问题 层级和范围",content:'LiteFlow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用PRE关键字(必须大写)来表示:\n\n<chain name="chain1">\n    THEN(\n        PRE(p1, p2), \n        a, b, c, \n        WHEN(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受Exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用FINALLY关键字(必须大写)表示：\n\n<chain name="chain1">\n    THEN(\n        a, b, c, \n        FINALLY(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，PRE和FINALLY可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    THEN(\n        PRE(a), c, d, FINALLY(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    THEN(\n        FINALLY(f1, f2), c, PRE(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nLiteFlow 2.9.5中能支持PRE和FINALLY写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\nPRE和FINALLY只能写在THEN表达式中，如果你写在WHEN表达式中或者其他诸如SWITCH,IF的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = THEN(PRE(p1, p2), THEN(a, b, c), FINALLY(f1, f2));\n    THEN(PRE(p1, p2), c1, FINALLY(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',normalizedContent:'liteflow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用pre关键字(必须大写)来表示:\n\n<chain name="chain1">\n    then(\n        pre(p1, p2), \n        a, b, c, \n        when(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用finally关键字(必须大写)表示：\n\n<chain name="chain1">\n    then(\n        a, b, c, \n        finally(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，pre和finally可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    then(\n        pre(a), c, d, finally(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    then(\n        finally(f1, f2), c, pre(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nliteflow 2.9.5中能支持pre和finally写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\npre和finally只能写在then表达式中，如果你写在when表达式中或者其他诸如switch,if的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = then(pre(p1, p2), then(a, b, c), finally(f1, f2));\n    then(pre(p1, p2), c1, finally(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍌本地规则文件监听",frontmatter:{title:"🍌本地规则文件监听",date:"2023-03-16T22:59:58.000Z",permalink:"/pages/v2.11.X/f8aa79/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/031.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/031.本地规则文件监听.md",key:"v-e746dfb0",path:"/pages/v2.11.X/f8aa79/",headersStr:null,content:"首先，在LiteFlow的配置liteflow.rule-source中，不光可以配置项目内的规则文件，其实还可以配置本地磁盘上的文件的，比如：\n\nliteflow.rule-source=/Users/bryan31/liteflow/test/flow.xml\n\n\n但是当你本地规则文件改变了的情况下，你的项目是无法获知的，你只能通过手动刷新规则去实现热刷新(详细请阅读平滑热刷新)。\n\nLiteFlow从2.10.0开始，增加了对本地规则文件监听的特性。\n\nLiteFlow从2.11.1开始，增加了对本地规则文件的模糊匹配以及监听。\n\n如果你用模糊匹配的方式也是可以的，同样也会对匹配的所有文件进行监听。\n\nliteflow.rule-source=/Users/bryan31/liteflow/**/flow*.xml\n\n\n你只需要配置liteflow.enable-monitor-file=true，即可开启自动对文件的监听特性。文件改动，你的项目无需做任何事，立马自动刷新整个规则。非常方便。\n\n在各个环境中如何配置，前面的章节也提到过，详情请阅读配置项这一大章节。",normalizedContent:"首先，在liteflow的配置liteflow.rule-source中，不光可以配置项目内的规则文件，其实还可以配置本地磁盘上的文件的，比如：\n\nliteflow.rule-source=/users/bryan31/liteflow/test/flow.xml\n\n\n但是当你本地规则文件改变了的情况下，你的项目是无法获知的，你只能通过手动刷新规则去实现热刷新(详细请阅读平滑热刷新)。\n\nliteflow从2.10.0开始，增加了对本地规则文件监听的特性。\n\nliteflow从2.11.1开始，增加了对本地规则文件的模糊匹配以及监听。\n\n如果你用模糊匹配的方式也是可以的，同样也会对匹配的所有文件进行监听。\n\nliteflow.rule-source=/users/bryan31/liteflow/**/flow*.xml\n\n\n你只需要配置liteflow.enable-monitor-file=true，即可开启自动对文件的监听特性。文件改动，你的项目无需做任何事，立马自动刷新整个规则。非常方便。\n\n在各个环境中如何配置，前面的章节也提到过，详情请阅读配置项这一大章节。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍉组件参数",frontmatter:{title:"🍉组件参数",date:"2022-10-06T22:55:30.000Z",permalink:"/pages/v2.11.X/6e4d15/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/036.%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/036.组件参数.md",key:"v-cd4c1a76",path:"/pages/v2.11.X/6e4d15/",headersStr:null,content:'LiteFlow从v2.9.0开始支持了组件参数特性，你可以在EL语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是JSON格式：\n\n<flow>\n    <chain name="chain1">\n        cmpData = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        THEN(a, b.data(cmpData), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpData = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        WHEN(c, b.data(cmpData));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过getCmpData方法也能拿到相应的参数。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tUser user = this.getCmpData(User.class);\n\t\t...\n\t}\n\n}\n',normalizedContent:'liteflow从v2.9.0开始支持了组件参数特性，你可以在el语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是json格式：\n\n<flow>\n    <chain name="chain1">\n        cmpdata = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        then(a, b.data(cmpdata), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpdata = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        when(c, b.data(cmpdata));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过getcmpdata方法也能拿到相应的参数。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tuser user = this.getcmpdata(user.class);\n\t\t...\n\t}\n\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍑组件别名",frontmatter:{title:"🍑组件别名",date:"2022-07-03T00:31:22.000Z",permalink:"/pages/v2.11.X/92ef89/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/040.%E7%BB%84%E4%BB%B6%E5%88%AB%E5%90%8D.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/040.组件别名.md",key:"v-3ffc7b96",path:"/pages/v2.11.X/92ef89/",headers:[{level:2,title:"Springboot & Spring 扫描方式",slug:"springboot-spring-扫描方式",normalizedTitle:"springboot &amp; spring 扫描方式",charIndex:null},{level:2,title:"规则文件方式定义组件",slug:"规则文件方式定义组件",normalizedTitle:"规则文件方式定义组件",charIndex:381},{level:2,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:49}],headersStr:"Springboot & Spring 扫描方式 规则文件方式定义组件 打印",content:'LiteFlow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# Springboot & Spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@Component换成@LiteflowComponent，并做如下定义：\n\n@LiteflowComponent(id = "a", name = "组件A")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件A" class="com.yomahub.liteflow.test.config.cmp.ACmp"/>\n<node id="b" name="组件B" class="com.yomahub.liteflow.test.config.cmp.BCmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',normalizedContent:'liteflow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# springboot & spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@component换成@liteflowcomponent，并做如下定义：\n\n@liteflowcomponent(id = "a", name = "组件a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件a" class="com.yomahub.liteflow.test.config.cmp.acmp"/>\n<node id="b" name="组件b" class="com.yomahub.liteflow.test.config.cmp.bcmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍍组件标签",frontmatter:{title:"🍍组件标签",date:"2022-07-03T00:32:36.000Z",permalink:"/pages/v2.11.X/0f788f/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/050.%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/050.组件标签.md",key:"v-3bf4f482",path:"/pages/v2.11.X/0f788f/",headersStr:null,content:'tag有2种用途：\n\n * 用于SWITCH语法的选择\n * 赋值\n\n关于SWITCH的选择tag标签内容请参考选择编排这一章。\n\n这章主要阐述tag标签的赋值功能。\n\n你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    THEN(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.getTag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        String tag = this.getTag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    THEN(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',normalizedContent:'tag有2种用途：\n\n * 用于switch语法的选择\n * 赋值\n\n关于switch的选择tag标签内容请参考选择编排这一章。\n\n这章主要阐述tag标签的赋值功能。\n\n你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    then(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.gettag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n    @override\n    public void process() {\n        string tag = this.gettag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    then(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐋组件回滚",frontmatter:{title:"🐋组件回滚",date:"2023-08-20T22:35:07.000Z",permalink:"/pages/v2.11.X/y172l7/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/061.%E7%BB%84%E4%BB%B6%E5%9B%9E%E6%BB%9A.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/061.组件回滚.md",key:"v-7c26ad48",path:"/pages/v2.11.X/y172l7/",headers:[{level:3,title:"回滚触发前提",slug:"回滚触发前提",normalizedTitle:"回滚触发前提",charIndex:199},{level:3,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:464},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:785}],headersStr:"回滚触发前提 基本用法 注意事项",content:'LiteFlow从v2.11.0开始支持了组件回滚功能。\n\nLiteFlow中组件对异常的处理方法有以下三种：组件中的continueOnError方法、EL表达式中设置ignoreError以及RL表达式中设置CATCH关键字。如果这三种条件均不满足并且出现了异常，那么流程就会执行失败，触发回滚的逻辑。使用rollback功能的前提需要对LiteFlow的异常处理机制具有一定的了解。\n\n\n# 回滚触发前提\n\n在实际应用场景中，组件的执行流程会因为各种突发情况导致失败，所以组件需要一种能在流程执行失败之后对流程进行处理的机制，因此LiteFlow新增了回滚功能。\n\n在流程执行失败，并且存在异常时会自动触发回滚机制，回滚机制会按照已经执行的组件的逆序执行其中的rollback方法。\n\n对于逆序执行，请参照下面的示例：\n\n图示\n\n如果上述全部组件均重写了rollback方法，在d中出现异常， 并且执行顺序为并且执行顺序为：a -> b -> c -> d的话，回滚顺序将会是：d -> c -> b -> a。\n\n\n# 基本用法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void rollback() throws Exception {\n        DefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n与组件中的其他方法类似，在回滚事件中，随时可以获取自己定义的上下文。\n\n\n# 注意事项\n\n 1. 回滚的过程中只能回滚流程已经执行完的组件，并不可以回滚整个流程的全部组件。\n 2. 回滚流程与正常执行流程相似，用户也可以在LiteflowResponse对象中通过相应的方法获取回滚流程的步骤信息以及执行时间等信息。\n\nLiteflowResponse response = flowExecutor.execute2Resp("yourChainName", "arg");\nString rollbackStepStr = response.getRollbackStepStr(); // 以字符串形式获取回滚流程\nString rollbackStepStrWithTime = response.getRollbackStepStrWithTime();\nQueue<CmpStep> rollbackStepQueue = response.getRollbackStepQueue(); // 获取回滚的组件的步骤信息\nMap<String, List<CmpStep>> rollbackSteps = response.getRollbackSteps(); // 获取回滚组件的步骤信息\n\n\n 3. 回滚过程中如果出现异常，不会打断回滚流程。',normalizedContent:'liteflow从v2.11.0开始支持了组件回滚功能。\n\nliteflow中组件对异常的处理方法有以下三种：组件中的continueonerror方法、el表达式中设置ignoreerror以及rl表达式中设置catch关键字。如果这三种条件均不满足并且出现了异常，那么流程就会执行失败，触发回滚的逻辑。使用rollback功能的前提需要对liteflow的异常处理机制具有一定的了解。\n\n\n# 回滚触发前提\n\n在实际应用场景中，组件的执行流程会因为各种突发情况导致失败，所以组件需要一种能在流程执行失败之后对流程进行处理的机制，因此liteflow新增了回滚功能。\n\n在流程执行失败，并且存在异常时会自动触发回滚机制，回滚机制会按照已经执行的组件的逆序执行其中的rollback方法。\n\n对于逆序执行，请参照下面的示例：\n\n图示\n\n如果上述全部组件均重写了rollback方法，在d中出现异常， 并且执行顺序为并且执行顺序为：a -> b -> c -> d的话，回滚顺序将会是：d -> c -> b -> a。\n\n\n# 基本用法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void rollback() throws exception {\n        defaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n与组件中的其他方法类似，在回滚事件中，随时可以获取自己定义的上下文。\n\n\n# 注意事项\n\n 1. 回滚的过程中只能回滚流程已经执行完的组件，并不可以回滚整个流程的全部组件。\n 2. 回滚流程与正常执行流程相似，用户也可以在liteflowresponse对象中通过相应的方法获取回滚流程的步骤信息以及执行时间等信息。\n\nliteflowresponse response = flowexecutor.execute2resp("yourchainname", "arg");\nstring rollbackstepstr = response.getrollbackstepstr(); // 以字符串形式获取回滚流程\nstring rollbackstepstrwithtime = response.getrollbackstepstrwithtime();\nqueue<cmpstep> rollbackstepqueue = response.getrollbackstepqueue(); // 获取回滚的组件的步骤信息\nmap<string, list<cmpstep>> rollbacksteps = response.getrollbacksteps(); // 获取回滚组件的步骤信息\n\n\n 3. 回滚过程中如果出现异常，不会打断回滚流程。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥝组件事件回调",frontmatter:{title:"🥝组件事件回调",date:"2022-07-03T00:41:09.000Z",permalink:"/pages/v2.11.X/3ee755/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/060.%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/060.组件事件回调.md",key:"v-dae2e17c",path:"/pages/v2.11.X/3ee755/",headers:[{level:2,title:"成功事件",slug:"成功事件",normalizedTitle:"成功事件",charIndex:31},{level:2,title:"失败事件",slug:"失败事件",normalizedTitle:"失败事件",charIndex:36},{level:3,title:"注意点1",slug:"注意点1",normalizedTitle:"注意点1",charIndex:842},{level:3,title:"注意点2",slug:"注意点2",normalizedTitle:"注意点2",charIndex:912},{level:3,title:"注意点3",slug:"注意点3",normalizedTitle:"注意点3",charIndex:1393}],headersStr:"成功事件 失败事件 注意点1 注意点2 注意点3",content:'LiteFlow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onSuccess方法，那么组件成功后会回调这个方法。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void onSuccess() throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onError方法，那么组件发生异常后会回调这个方法。\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError(Exception e) throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonError方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onError方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onError方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError(Exception e) throws Exception {\n\t\tthrow new IllegalAccessException("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是NullPointerException而不是IllegalAccessException，但是IllegalAccessException这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonError方法执行后，afterProcess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterProcess方法都会被执行。',normalizedContent:'liteflow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onsuccess方法，那么组件成功后会回调这个方法。\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void onsuccess() throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onerror方法，那么组件发生异常后会回调这个方法。\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror(exception e) throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonerror方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onerror方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onerror方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror(exception e) throws exception {\n\t\tthrow new illegalaccessexception("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是nullpointerexception而不是illegalaccessexception，但是illegalaccessexception这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonerror方法执行后，afterprocess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterprocess方法都会被执行。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍕私有投递",frontmatter:{title:"🍕私有投递",date:"2022-07-03T10:59:19.000Z",permalink:"/pages/v2.11.X/fbb938/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/080.%E7%A7%81%E6%9C%89%E6%8A%95%E9%80%92.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/080.私有投递.md",key:"v-2bdcb57c",path:"/pages/v2.11.X/fbb938/",headers:[{level:2,title:"什么叫私有投递",slug:"什么叫私有投递",normalizedTitle:"什么叫私有投递",charIndex:21},{level:2,title:"解决方式",slug:"解决方式",normalizedTitle:"解决方式",charIndex:657}],headersStr:"什么叫私有投递 解决方式",content:'LiteFlow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个LiteFLow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        THEN(\n            a,\n            WHEN(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，LiteFlow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\tcontext.setData("testSet", new HashSet<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendPrivateDeliveryData("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendPrivateDeliveryData方法，指定了b组件\n\n然后我们再来看b组件：\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("BCmp executed!");\n\t\tInteger value = this.getPrivateDeliveryData();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getPrivateDeliveryData()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',normalizedContent:'liteflow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个liteflow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        then(\n            a,\n            when(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，liteflow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\tcontext.setdata("testset", new hashset<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendprivatedeliverydata("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendprivatedeliverydata方法，指定了b组件\n\n然后我们再来看b组件：\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("bcmp executed!");\n\t\tinteger value = this.getprivatedeliverydata();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getprivatedeliverydata()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣组件重试",frontmatter:{title:"🍣组件重试",date:"2022-07-03T11:03:09.000Z",permalink:"/pages/v2.11.X/7e9da1/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/090.%E7%BB%84%E4%BB%B6%E9%87%8D%E8%AF%95.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/090.组件重试.md",key:"v-fe382ade",path:"/pages/v2.11.X/7e9da1/",headers:[{level:2,title:"全局重试",slug:"全局重试",normalizedTitle:"全局重试",charIndex:21},{level:2,title:"单个组件重试",slug:"单个组件重试",normalizedTitle:"单个组件重试",charIndex:26},{level:2,title:"全局重试和单个组件重试都定义的情况下",slug:"全局重试和单个组件重试都定义的情况下",normalizedTitle:"全局重试和单个组件重试都定义的情况下",charIndex:970}],headersStr:"全局重试 单个组件重试 全局重试和单个组件重试都定义的情况下",content:'LiteFLow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了isContinueOnError，设为true的话，那流程会继续。\n\n异步流程的话，如果WHEN上配置了ignoreError为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreError的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nLiteFlow还提供了基于单个组件，指定Exception的重试特性，LiteFlow从2.6.0开始提供了@LiteflowRetry标注\n\n你可以在指定的组件上进行标注：\n\n@LiteflowComponent("c")\n@LiteflowRetry(5)\npublic class CCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@LiteflowComponent("e")\n@LiteflowRetry(retry = 5, forExceptions = {NullPointerException.class,IllegalArgumentException.class})\npublic class ECmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是NullPointerException或者IllegalArgumentException（或者是这两个Exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',normalizedContent:'liteflow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了iscontinueonerror，设为true的话，那流程会继续。\n\n异步流程的话，如果when上配置了ignoreerror为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreerror的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nliteflow还提供了基于单个组件，指定exception的重试特性，liteflow从2.6.0开始提供了@liteflowretry标注\n\n你可以在指定的组件上进行标注：\n\n@liteflowcomponent("c")\n@liteflowretry(5)\npublic class ccmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@liteflowcomponent("e")\n@liteflowretry(retry = 5, forexceptions = {nullpointerexception.class,illegalargumentexception.class})\npublic class ecmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是nullpointerexception或者illegalargumentexception（或者是这两个exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥑隐式子流程",frontmatter:{title:"🥑隐式子流程",date:"2022-07-03T00:42:38.000Z",permalink:"/pages/v2.11.X/80e873/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/070.%E9%9A%90%E5%BC%8F%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/070.隐式子流程.md",key:"v-2b032de5",path:"/pages/v2.11.X/80e873/",headersStr:null,content:'LiteFlow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@Component("h")\npublic class HComponent extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("Hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeInAsync方法。\n\n同样，隐式子流程也支持返回LiteFlowResponse对象，需要调用invoke2Resp方法，关于返回对象为LiteFlowResponse的说明，请参照LiteflowResponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getSubChainReqData()去拿。\n\n如果你是用invokeInAsync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getSubChainReqDataInAsync()去拿。\n\n用this.getRequestData()是拿不到的！',normalizedContent:'liteflow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@component("h")\npublic class hcomponent extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeinasync方法。\n\n同样，隐式子流程也支持返回liteflowresponse对象，需要调用invoke2resp方法，关于返回对象为liteflowresponse的说明，请参照liteflowresponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getsubchainreqdata()去拿。\n\n如果你是用invokeinasync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getsubchainreqdatainasync()去拿。\n\n用this.getrequestdata()是拿不到的！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍖平滑热刷新",frontmatter:{title:"🍖平滑热刷新",date:"2022-07-03T11:04:48.000Z",permalink:"/pages/v2.11.X/204d71/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/100.%E5%B9%B3%E6%BB%91%E7%83%AD%E5%88%B7%E6%96%B0.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/100.平滑热刷新.md",key:"v-dce50a5c",path:"/pages/v2.11.X/204d71/",headers:[{level:2,title:"自动刷新的场景",slug:"自动刷新的场景",normalizedTitle:"自动刷新的场景",charIndex:147},{level:2,title:"主动调用代码刷新",slug:"主动调用代码刷新",normalizedTitle:"主动调用代码刷新",charIndex:333},{level:2,title:"单独刷新某一个规则",slug:"单独刷新某一个规则",normalizedTitle:"单独刷新某一个规则",charIndex:793}],headersStr:"自动刷新的场景 主动调用代码刷新 单独刷新某一个规则",content:'LiteFlow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\n\n\n# 自动刷新的场景\n\n如果你使用LiteFlow原生支持的zookeeper，etcd，nacos，apollo等插件（关于如何集成插件，请参考规则文件这一大章节），不需要你做任何事，只要规则更改之后，会自动热平滑刷新。\n\n\n如果你是基于本地磁盘规则文件的，并且开启了自动监听设置，那么更改流程后也会自动平滑刷新。关于如何开启自动监听，请参考本地规则文件监听这一章。\n\n\n# 主动调用代码刷新\n\n如果你使用了数据库作为规则文件的存储方式，或是你自己实现了自定义配置源，那么LiteFlow还提供了一种基于代码刷新的方式。\n\n\n你可以在spring容器中拿到FlowExecutor对象后，调用以下接口：\n\nflowExecutor.reloadRule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n这样调用有以下2点注意事项：\n\n提示\n\n1.这样刷新是全量刷新，不过各位同学不用担心其性能，经测试，LiteFlow框架一秒可以刷新1000条规则左右，这都是一些cpu级别的操作，如果你规则没有上大几千，几w条，那么推荐这种方式。\n\n2.如果你的应用是多节点部署的，必须在每个节点上都要刷新，因为规则是存储在jvm内存里的。这就意味着，如果你把刷新规则做成一个rpc接口（诸如dubbo接口之类的），那么rpc接口只会调用到其中一个节点，也就是说，只会有一个节点的规则会刷新。\n\n正确的做法是：利用mq发一个消息，让各个节点去监听到，进行刷新。\n\n\n\n# 单独刷新某一个规则\n\n如果你的规则比较多，成千上万条，又或者你就是不想全量刷新。希望单独刷新某个改动的规则。\n\n那么LiteFlow也提供了相应的方式。\n\n你可以利用以下api来进行刷新：\n\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n提示\n\n既然是指定刷新，那么必须你要获取到改动的EL内容，然后再利用动态代码构建重新build下就可以了，这种方式会自动替换缓存中已有的规则。这种方式不用在build之前销毁流程。\n\n如果是多服务节点部署的情况下，还是要遵循每个节点要都刷新，上面已经说明具体建议的方式。这里不再赘述。',normalizedContent:'liteflow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\n\n\n# 自动刷新的场景\n\n如果你使用liteflow原生支持的zookeeper，etcd，nacos，apollo等插件（关于如何集成插件，请参考规则文件这一大章节），不需要你做任何事，只要规则更改之后，会自动热平滑刷新。\n\n\n如果你是基于本地磁盘规则文件的，并且开启了自动监听设置，那么更改流程后也会自动平滑刷新。关于如何开启自动监听，请参考本地规则文件监听这一章。\n\n\n# 主动调用代码刷新\n\n如果你使用了数据库作为规则文件的存储方式，或是你自己实现了自定义配置源，那么liteflow还提供了一种基于代码刷新的方式。\n\n\n你可以在spring容器中拿到flowexecutor对象后，调用以下接口：\n\nflowexecutor.reloadrule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n这样调用有以下2点注意事项：\n\n提示\n\n1.这样刷新是全量刷新，不过各位同学不用担心其性能，经测试，liteflow框架一秒可以刷新1000条规则左右，这都是一些cpu级别的操作，如果你规则没有上大几千，几w条，那么推荐这种方式。\n\n2.如果你的应用是多节点部署的，必须在每个节点上都要刷新，因为规则是存储在jvm内存里的。这就意味着，如果你把刷新规则做成一个rpc接口（诸如dubbo接口之类的），那么rpc接口只会调用到其中一个节点，也就是说，只会有一个节点的规则会刷新。\n\n正确的做法是：利用mq发一个消息，让各个节点去监听到，进行刷新。\n\n\n\n# 单独刷新某一个规则\n\n如果你的规则比较多，成千上万条，又或者你就是不想全量刷新。希望单独刷新某个改动的规则。\n\n那么liteflow也提供了相应的方式。\n\n你可以利用以下api来进行刷新：\n\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n提示\n\n既然是指定刷新，那么必须你要获取到改动的el内容，然后再利用动态代码构建重新build下就可以了，这种方式会自动替换缓存中已有的规则。这种方式不用在build之前销毁流程。\n\n如果是多服务节点部署的情况下，还是要遵循每个节点要都刷新，上面已经说明具体建议的方式。这里不再赘述。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥦异步循环模式",frontmatter:{title:"🥦异步循环模式",date:"2023-08-14T23:36:23.000Z",permalink:"/pages/v2.11.X/35cc4a/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/091.%E5%BC%82%E6%AD%A5%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/091.异步循环模式.md",key:"v-48593528",path:"/pages/v2.11.X/35cc4a/",headers:[{level:2,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:59},{level:2,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:284},{level:2,title:"使用说明",slug:"使用说明",normalizedTitle:"使用说明",charIndex:698}],headersStr:"使用方法 例子 使用说明",content:'LiteFlow从2.11.0版本起，支持了循环表达式的异步模式，使得各个循环表达式的循环子项可以异步执行。\n\n\n# 使用方法\n\n对于LiteFlow中的次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式，可以使用parallel子关键字（默认为false）来配置循环子项的执行方式，使其成为异步模式的循环表达式（所谓异步模式，就是各个循环子项之间并行执行）。\n\n如果parallel子关键字设置为true，表示各循环子项之间并行执行，否则各循环子项之间串行执行。\n\n----------------------------------------\n\n\n# 例子\n\n对于次数循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain1">\n   FOR(2).parallel(true).DO(THEN(a,b,c));\n</chain>\n\n\n如果使用上述配置，每个循环子项本身的执行方式保持不变，只是各个循环子项之间的执行方式变为并行执行，也就是chain1会并行执行两次THEN(a,b,c)。\n\n对于条件循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain6">\n   WHILE(x).parallel(true).DO(THEN(a,b,c));\n</chain>\n\n\n对于迭代循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain7">\n   ITERATOR(x).parallel(true).DO(THEN(a,b,c));\n</chain>\n\n\n\n# 使用说明\n\n 1. parallel子关键字只能用于次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式。\n 2. 对于异步模式的条件循环表达式，会不断创建并行执行循环子项，直到条件不满足为止。\n 3. 异步模式依然支持BREAK，当退出循环组件返回为true时，会停止向线程池提交新的任务，但是已经提交的任务会继续执行。循环组件会在所有已提交任务执行完毕后退出。\n 4. 默认情况下，异步模式的下各循环子项会在liteFlow提供的默认异步循环线程池中执行，并且可以通过如下两个参数来控制默认线程池的workers数目和队列长度\n    \n    \x3c!--配置默认线程池的worker数目--\x3e\n    liteflow.parallel-max-workers=16\n    \x3c!--配置默认线程池的队列长度--\x3e\n    liteflow.parallel-queue-limit=512\n    \n    \n    当然，也可以通过自定义线程池来执行异步模式的循环子项，只需要在配置文件中进行如下配置即可，不过此时上述两个参数将不再生效。\n    \n    \x3c!--用户可以直接指定自定义的线程池全类名的方式指定异步循环线程池--\x3e\n    liteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n    ',normalizedContent:'liteflow从2.11.0版本起，支持了循环表达式的异步模式，使得各个循环表达式的循环子项可以异步执行。\n\n\n# 使用方法\n\n对于liteflow中的次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式，可以使用parallel子关键字（默认为false）来配置循环子项的执行方式，使其成为异步模式的循环表达式（所谓异步模式，就是各个循环子项之间并行执行）。\n\n如果parallel子关键字设置为true，表示各循环子项之间并行执行，否则各循环子项之间串行执行。\n\n----------------------------------------\n\n\n# 例子\n\n对于次数循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain1">\n   for(2).parallel(true).do(then(a,b,c));\n</chain>\n\n\n如果使用上述配置，每个循环子项本身的执行方式保持不变，只是各个循环子项之间的执行方式变为并行执行，也就是chain1会并行执行两次then(a,b,c)。\n\n对于条件循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain6">\n   while(x).parallel(true).do(then(a,b,c));\n</chain>\n\n\n对于迭代循环表达式，可以这样配置，使其各个循环子项并行执行：\n\n<chain name="chain7">\n   iterator(x).parallel(true).do(then(a,b,c));\n</chain>\n\n\n\n# 使用说明\n\n 1. parallel子关键字只能用于次数循环表达式、条件循环表达式以及迭代循环表达式等循环表达式。\n 2. 对于异步模式的条件循环表达式，会不断创建并行执行循环子项，直到条件不满足为止。\n 3. 异步模式依然支持break，当退出循环组件返回为true时，会停止向线程池提交新的任务，但是已经提交的任务会继续执行。循环组件会在所有已提交任务执行完毕后退出。\n 4. 默认情况下，异步模式的下各循环子项会在liteflow提供的默认异步循环线程池中执行，并且可以通过如下两个参数来控制默认线程池的workers数目和队列长度\n    \n    \x3c!--配置默认线程池的worker数目--\x3e\n    liteflow.parallel-max-workers=16\n    \x3c!--配置默认线程池的队列长度--\x3e\n    liteflow.parallel-queue-limit=512\n    \n    \n    当然，也可以通过自定义线程池来执行异步模式的循环子项，只需要在配置文件中进行如下配置即可，不过此时上述两个参数将不再生效。\n    \n    \x3c!--用户可以直接指定自定义的线程池全类名的方式指定异步循环线程池--\x3e\n    liteflow.parallel-loop-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n    ',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⏱️超时控制",frontmatter:{title:"⏱️超时控制",date:"2023-08-06T22:36:38.000Z",permalink:"/pages/v2.11.X/fd5984/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/092.%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/092.超时控制.md",key:"v-585191b8",path:"/pages/v2.11.X/fd5984/",headers:[{level:2,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:43},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:1244}],headersStr:"使用方法 注意事项",content:'LiteFlow 从 2.11.0 开始，支持使用关键字对流程进行超时控制。\n\n\n# 使用方法\n\n使用 maxWaitSeconds,maxWaitMilliseconds 关键字可对任意的组件、表达式、流程进行超时控制。\n\nmaxWaitSeconds后面传的是秒数，maxWaitMilliseconds后面传的是毫秒数。使用方式都一样。\n\nmaxWaitSeconds和maxWaitMilliseconds 传入一个 int 类型的整数表示最大等待秒数/毫秒数，使用如下方法设置最大超时等待时间。\n\n<flow>\n    \x3c!-- 串行编排超时控制 --\x3e\n    <chain name="then">\n        THEN(a,b).maxWaitSeconds(5);\n    </chain>\n\n    \x3c!-- 并行编排超时控制 --\x3e\n    <chain name="when">\n        WHEN(a,b).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 循环编排超时控制 --\x3e\n    <chain name="for">\n        FOR(2).DO(a).maxWaitSeconds(3);\n    </chain>\n    <chain name="while">\n        WHILE(w).DO(a).maxWaitSeconds(3);\n    </chain>\n    <chain name="iterator">\n        ITERATOR(x).DO(a).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 选择编排超时控制 --\x3e\n    <chain name="switch">\n        SWITCH(s).TO(a, b).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 条件编排超时控制 --\x3e\n    <chain name="if">\n        IF(f, b, c).maxWaitSeconds(3);\n    </chain>\n\n    \x3c!-- 组件超时控制 --\x3e\n    <chain name="component">\n        WHEN(\n            a.maxWaitSeconds(2),\n            b.maxWaitSeconds(3)\n        );\n    </chain>\n\n    \x3c!-- 流程超时控制 --\x3e\n    <chain name="testChain">\n        THEN(b)\n    </chain>\n    <chain name="chain">\n        testChain.maxWaitSeconds(3);\n    </chain>\n</flow>\n\n\n\n# 注意事项\n\n 1. FINALLY 不可使用此关键字。\n    \n    这种写法是不被允许的：\n    \n    THEN(a, FINALLY(b).maxWaitSeconds(3))\n    \n\n 2. 如果 THEN 使用了超时控制，其内部直属的 FINALLY 不受超时控制。\n    \n    例如：\n    \n    THEN(a, FINALLY(b)).maxWaitSeconds(5);\n    \n    \n    组件 b 是不受超时控制的。但如果 FINALLY 不是设置超时的 THEN 所直属的，则仍受超时控制。\n    \n    例如：\n    \n    THEN(a, THEN(b, FINALLY(c))).maxWaitSeconds(5);\n    \n    \n    c 仍会受超时控制。\n\n 3. 除WHEN外，若某个关键字后续存在多个连续操作，则maxWaitSeconds必须放在完整语义的最后。。\n    \n    例如：\n    \n    FOR(5).DO(THEN(e, f)).maxWaitSeconds(5);\n    \n    \n    不可写为：\n    \n    FOR(5).maxWaitSeconds(5).DO(THEN(e, f));\n    \n    \n    必须得到完整语义后再设置超时。但使用 WHEN 关键字时可以不放在最后，以下写法是被允许的：\n    \n    WHEN(a, b).maxWaitSeconds(5).any(true);\n    ',normalizedContent:'liteflow 从 2.11.0 开始，支持使用关键字对流程进行超时控制。\n\n\n# 使用方法\n\n使用 maxwaitseconds,maxwaitmilliseconds 关键字可对任意的组件、表达式、流程进行超时控制。\n\nmaxwaitseconds后面传的是秒数，maxwaitmilliseconds后面传的是毫秒数。使用方式都一样。\n\nmaxwaitseconds和maxwaitmilliseconds 传入一个 int 类型的整数表示最大等待秒数/毫秒数，使用如下方法设置最大超时等待时间。\n\n<flow>\n    \x3c!-- 串行编排超时控制 --\x3e\n    <chain name="then">\n        then(a,b).maxwaitseconds(5);\n    </chain>\n\n    \x3c!-- 并行编排超时控制 --\x3e\n    <chain name="when">\n        when(a,b).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 循环编排超时控制 --\x3e\n    <chain name="for">\n        for(2).do(a).maxwaitseconds(3);\n    </chain>\n    <chain name="while">\n        while(w).do(a).maxwaitseconds(3);\n    </chain>\n    <chain name="iterator">\n        iterator(x).do(a).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 选择编排超时控制 --\x3e\n    <chain name="switch">\n        switch(s).to(a, b).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 条件编排超时控制 --\x3e\n    <chain name="if">\n        if(f, b, c).maxwaitseconds(3);\n    </chain>\n\n    \x3c!-- 组件超时控制 --\x3e\n    <chain name="component">\n        when(\n            a.maxwaitseconds(2),\n            b.maxwaitseconds(3)\n        );\n    </chain>\n\n    \x3c!-- 流程超时控制 --\x3e\n    <chain name="testchain">\n        then(b)\n    </chain>\n    <chain name="chain">\n        testchain.maxwaitseconds(3);\n    </chain>\n</flow>\n\n\n\n# 注意事项\n\n 1. finally 不可使用此关键字。\n    \n    这种写法是不被允许的：\n    \n    then(a, finally(b).maxwaitseconds(3))\n    \n\n 2. 如果 then 使用了超时控制，其内部直属的 finally 不受超时控制。\n    \n    例如：\n    \n    then(a, finally(b)).maxwaitseconds(5);\n    \n    \n    组件 b 是不受超时控制的。但如果 finally 不是设置超时的 then 所直属的，则仍受超时控制。\n    \n    例如：\n    \n    then(a, then(b, finally(c))).maxwaitseconds(5);\n    \n    \n    c 仍会受超时控制。\n\n 3. 除when外，若某个关键字后续存在多个连续操作，则maxwaitseconds必须放在完整语义的最后。。\n    \n    例如：\n    \n    for(5).do(then(e, f)).maxwaitseconds(5);\n    \n    \n    不可写为：\n    \n    for(5).maxwaitseconds(5).do(then(e, f));\n    \n    \n    必须得到完整语义后再设置超时。但使用 when 关键字时可以不放在最后，以下写法是被允许的：\n    \n    when(a, b).maxwaitseconds(5).any(true);\n    ',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥯链路继承",frontmatter:{title:"🥯链路继承",date:"2023-10-10T15:26:41.000Z",permalink:"/pages/v2.11.X/524c43/",titleTag:"🧪 Beta"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/105.%E9%93%BE%E8%B7%AF%E7%BB%A7%E6%89%BF.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/105.链路继承.md",key:"v-cbcd7c28",path:"/pages/v2.11.X/524c43/",headers:[{level:3,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:96},{level:3,title:"例子",slug:"例子",normalizedTitle:"例子",charIndex:336},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:1153}],headersStr:"使用方法 例子 注意事项",content:'LiteFlow从2.11.1版本起，支持chain之间的继承关系，使得chain之间可以进行继承和扩展。\n\n❗注意: 本特性为Beta实验性功能，不保证后续小版本升级能够向下兼容。\n\n\n# 使用方法\n\n可以在某个chain中使用extends属性来指明该chain继承自哪个chain。在被继承的chain中，需要预留出一个或多个占位符，以便于子chain可以对其进行扩展；而在子chain中，需要对被继承的父chain中的所有占位符进行实现。\n\n子chain中的实现可以是组件，可以是表达式，可以是其他chain的id。但是需要注意的是，最终实现的chain必须是一个合法的EL规则，否则会解析失败。子chain的实现中同样可以包含占位符，从而实现多级继承。\n\n\n# 例子\n\n下面是一个基本的例子:\n\n<chain id="base">\n    THEN(a, b, {0}, {1});\n</chain>\n\n<chain id="implA" extends="base">\n    {0}=IF(c, d, e);\n    {1}=SWITCH(f).to(j,k);\n</chain>\n\n\n通过上述定义，实现了一个继承自base的implA,最终实现的implA流程如下\n\n<chain id="implA">\n    THEN(a, b, IF(c, d, e), SWITCH(f).to(j,k));\n</chain>\n\n\n下面是一个多级继承的例子:\n\n    <chain id="base">\n        THEN(a, b, {0}, {1});\n    </chain>\n\n    <chain id="base2" extends="base">\n        {0}=THEN(a,b,{3});\n        {1}=SWITCH(f).to({4},k);\n    </chain>\n\n    <chain id="implB" extends="base2">\n        {3}=THEN(a,b);\n        {4}=j;\n    </chain>\n\n\n在上面的定义中,implB继承自base2,base2又继承自base,最终实现的implB流程如下：\n\n    <chain id="implB" extends="base2">\n        THEN(\n            a, b,\n            THEN(a, b,\n                THEN(a,b)\n            ),\n            SWITCH(f).to(j,k) \n        );\n    </chain>\n\n\n\n# 注意事项\n\n 1. 在继承chain和被继承chain中需要使用形如{x}的占位符，其中x可以是以下两种形式之一：\n    \n    * 纯数字构成\n    * 由字母、下划线以及数字构成，但是数字不能作为开头\n    \n    也就是说，形如{1}、{a}、{a1}、{a_1}都是合法的占位符，而{1a}、{1_a}都是非法的占位符。\n\n 2. 请保证被继承chain中至少有一个占位符，且在被继承chain中定义的所有占位符，都必须要在子chain中进行实现，否则会抛出异常。\n\n 3. 如果一个chain中包含未被实现的占位符，那么执行该chain会抛出异常。例如，尝试执行上文所述的base,base2都会抛出异常，因为它们分别包含未被实现的占位符{0},{1}和{3},{4}。\n\n 4. 如果在子chain中定义了除占位符实现以外的其他表达式，那么该表达式将被忽略。举个例子,如果implA这样实现：\n    \n    <chain id="implA" extends="base">\n        {0}=IF(c, d, e);\n        {1}=SWITCH(f).to(j,k);\n        THEN(a,b);\n    </chain>\n    \n    \n    那么其中的THEN(a,b);将会被忽略。',normalizedContent:'liteflow从2.11.1版本起，支持chain之间的继承关系，使得chain之间可以进行继承和扩展。\n\n❗注意: 本特性为beta实验性功能，不保证后续小版本升级能够向下兼容。\n\n\n# 使用方法\n\n可以在某个chain中使用extends属性来指明该chain继承自哪个chain。在被继承的chain中，需要预留出一个或多个占位符，以便于子chain可以对其进行扩展；而在子chain中，需要对被继承的父chain中的所有占位符进行实现。\n\n子chain中的实现可以是组件，可以是表达式，可以是其他chain的id。但是需要注意的是，最终实现的chain必须是一个合法的el规则，否则会解析失败。子chain的实现中同样可以包含占位符，从而实现多级继承。\n\n\n# 例子\n\n下面是一个基本的例子:\n\n<chain id="base">\n    then(a, b, {0}, {1});\n</chain>\n\n<chain id="impla" extends="base">\n    {0}=if(c, d, e);\n    {1}=switch(f).to(j,k);\n</chain>\n\n\n通过上述定义，实现了一个继承自base的impla,最终实现的impla流程如下\n\n<chain id="impla">\n    then(a, b, if(c, d, e), switch(f).to(j,k));\n</chain>\n\n\n下面是一个多级继承的例子:\n\n    <chain id="base">\n        then(a, b, {0}, {1});\n    </chain>\n\n    <chain id="base2" extends="base">\n        {0}=then(a,b,{3});\n        {1}=switch(f).to({4},k);\n    </chain>\n\n    <chain id="implb" extends="base2">\n        {3}=then(a,b);\n        {4}=j;\n    </chain>\n\n\n在上面的定义中,implb继承自base2,base2又继承自base,最终实现的implb流程如下：\n\n    <chain id="implb" extends="base2">\n        then(\n            a, b,\n            then(a, b,\n                then(a,b)\n            ),\n            switch(f).to(j,k) \n        );\n    </chain>\n\n\n\n# 注意事项\n\n 1. 在继承chain和被继承chain中需要使用形如{x}的占位符，其中x可以是以下两种形式之一：\n    \n    * 纯数字构成\n    * 由字母、下划线以及数字构成，但是数字不能作为开头\n    \n    也就是说，形如{1}、{a}、{a1}、{a_1}都是合法的占位符，而{1a}、{1_a}都是非法的占位符。\n\n 2. 请保证被继承chain中至少有一个占位符，且在被继承chain中定义的所有占位符，都必须要在子chain中进行实现，否则会抛出异常。\n\n 3. 如果一个chain中包含未被实现的占位符，那么执行该chain会抛出异常。例如，尝试执行上文所述的base,base2都会抛出异常，因为它们分别包含未被实现的占位符{0},{1}和{3},{4}。\n\n 4. 如果在子chain中定义了除占位符实现以外的其他表达式，那么该表达式将被忽略。举个例子,如果impla这样实现：\n    \n    <chain id="impla" extends="base">\n        {0}=if(c, d, e);\n        {1}=switch(f).to(j,k);\n        then(a,b);\n    </chain>\n    \n    \n    那么其中的then(a,b);将会被忽略。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍪组件切面",frontmatter:{title:"🍪组件切面",date:"2022-07-03T11:07:26.000Z",permalink:"/pages/v2.11.X/2373f5/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/110.%E7%BB%84%E4%BB%B6%E5%88%87%E9%9D%A2.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/110.组件切面.md",key:"v-4bcaa1ce",path:"/pages/v2.11.X/2373f5/",headers:[{level:2,title:"全局切面",slug:"全局切面",normalizedTitle:"全局切面",charIndex:47},{level:2,title:"Aspect的切面",slug:"aspect的切面",normalizedTitle:"aspect的切面",charIndex:685}],headersStr:"全局切面 Aspect的切面",content:'LiteFlow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@Component\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //before business\n    }\n\n    @Override\n    public void afterProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //after business\n    }\n\n    @Override\n    public void onSuccess(NodeComponent cmp) {\n        //do sth\n    }\n\n    @Override\n    public void onError(NodeComponent cmp, Exception e) {\n        //do sth\n    }\n}\n\n\n\n# Aspect的切面\n\nLiteFlow同时也支持了Spring Aspect的切面，你可以用@Aspect标注对任意包，任意规则内的组件进行切面\n\n@Aspect\npublic class CustomAspect {\n\n    @Pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @Around("cut()")\n    public Object around(ProceedingJoinPoint jp) throws Throwable {\n        //do before business\n        Object returnObj = jp.proceed();\n        //do after business\n        return returnObj;\n    }\n}\n',normalizedContent:'liteflow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@component\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //before business\n    }\n\n    @override\n    public void afterprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //after business\n    }\n\n    @override\n    public void onsuccess(nodecomponent cmp) {\n        //do sth\n    }\n\n    @override\n    public void onerror(nodecomponent cmp, exception e) {\n        //do sth\n    }\n}\n\n\n\n# aspect的切面\n\nliteflow同时也支持了spring aspect的切面，你可以用@aspect标注对任意包，任意规则内的组件进行切面\n\n@aspect\npublic class customaspect {\n\n    @pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @around("cut()")\n    public object around(proceedingjoinpoint jp) throws throwable {\n        //do before business\n        object returnobj = jp.proceed();\n        //do after business\n        return returnobj;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧊异常",frontmatter:{title:"🧊异常",date:"2022-07-26T23:38:00.000Z",permalink:"/pages/v2.11.X/dc9bfe/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/125.%E5%BC%82%E5%B8%B8.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/125.异常.md",key:"v-ea0f0df4",path:"/pages/v2.11.X/dc9bfe/",headersStr:null,content:'通常在LiteFlow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreError关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进LiteflowResponse对象中。\n\n你可以在LiteflowResponse对象中通过以下方法来获取异常\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n如果你的业务中有获取异常Code的需求，则你自定义的异常需要实现LiteFlow提供的LiteFlowException接口：\n\npublic class YourException extends LiteFlowException {\n\tpublic YourException(String code, String message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了LiteFlowException接口的异常，你则可以在LiteflowResponse中获得message和code信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n  String code = response.getCode();\n  String message = response.getMessage();\n}\n\n\n提示\n\n如果你的异常没实现LiteFlowException，code和message字段都为null。',normalizedContent:'通常在liteflow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreerror关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进liteflowresponse对象中。\n\n你可以在liteflowresponse对象中通过以下方法来获取异常\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n如果你的业务中有获取异常code的需求，则你自定义的异常需要实现liteflow提供的liteflowexception接口：\n\npublic class yourexception extends liteflowexception {\n\tpublic yourexception(string code, string message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了liteflowexception接口的异常，你则可以在liteflowresponse中获得message和code信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n  string code = response.getcode();\n  string message = response.getmessage();\n}\n\n\n提示\n\n如果你的异常没实现liteflowexception，code和message字段都为null。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧇打印信息详解",frontmatter:{title:"🧇打印信息详解",date:"2022-07-03T11:12:19.000Z",permalink:"/pages/v2.11.X/4d614c/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/130.%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/130.打印信息详解.md",key:"v-4bffc44e",path:"/pages/v2.11.X/4d614c/",headers:[{level:2,title:"流程执行中打印",slug:"流程执行中打印",normalizedTitle:"流程执行中打印",charIndex:2},{level:2,title:"打印步骤信息",slug:"打印步骤信息",normalizedTitle:"打印步骤信息",charIndex:558}],headersStr:"流程执行中打印 打印步骤信息",content:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[ACmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[BCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[X]start component[CCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[DCmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求ID，一个请求无论经历了多少个组件，他们的请求ID都是一致的，你可以根据这个ID在日志中进行快速定位进行排查。\n\n在后面会跟着一个[O]或者[X]，[O]代表了执行了这个组件的主要逻辑，[X]代表因为isAccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，LiteFlow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件ID<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件A]<100>==>b[组件B]<0>==>m[组件M]<256>\n\n\n这里的表达形式为：组件ID[组件别名]<耗时毫秒>",normalizedContent:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[acmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[bcmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[x]start component[ccmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[dcmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求id，一个请求无论经历了多少个组件，他们的请求id都是一致的，你可以根据这个id在日志中进行快速定位进行排查。\n\n在后面会跟着一个[o]或者[x]，[o]代表了执行了这个组件的主要逻辑，[x]代表因为isaccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，liteflow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件id<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件a]<100>==>b[组件b]<0>==>m[组件m]<256>\n\n\n这里的表达形式为：组件id[组件别名]<耗时毫秒>",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍡步骤信息",frontmatter:{title:"🍡步骤信息",date:"2022-07-03T11:09:40.000Z",permalink:"/pages/v2.11.X/e5ed0d/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/120.%E6%AD%A5%E9%AA%A4%E4%BF%A1%E6%81%AF.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/120.步骤信息.md",key:"v-c7acf936",path:"/pages/v2.11.X/e5ed0d/",headersStr:null,content:'LiteFlow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过LiteflowResponse对象来获取的：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "初始参数", CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得Map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的Map中这个组件id的value是最终的那个步骤信息。\n\n而获得Queue<CmpStep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在CmpStep这个对象里，你可以通过以下方法获得你要的数据：\n\n * isSuccess：此组件是否执行成功\n * getNodeId：获得组件Id\n * getNodeName：获得组件名称\n * getTag：获得组件标签值\n * getTimeSpent：获得组件的耗时，单位为毫秒\n * getStartTime：获取组件开始执行的时间，为Date对象(从v2.11.4开始支持)\n * getEndTime：获取组件结束执行的时间，为Date对象(从v2.11.4开始支持)\n * getException：获取此组件抛出的异常，如果isSuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getCause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',normalizedContent:'liteflow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过liteflowresponse对象来获取的：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "初始参数", customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的map中这个组件id的value是最终的那个步骤信息。\n\n而获得queue<cmpstep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在cmpstep这个对象里，你可以通过以下方法获得你要的数据：\n\n * issuccess：此组件是否执行成功\n * getnodeid：获得组件id\n * getnodename：获得组件名称\n * gettag：获得组件标签值\n * gettimespent：获得组件的耗时，单位为毫秒\n * getstarttime：获取组件开始执行的时间，为date对象(从v2.11.4开始支持)\n * getendtime：获取组件结束执行的时间，为date对象(从v2.11.4开始支持)\n * getexception：获取此组件抛出的异常，如果issuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getcause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🫕快速解析模式",frontmatter:{title:"🫕快速解析模式",date:"2024-01-14T21:16:54.000Z",permalink:"/pages/v2.11.X/5fe959/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/145.%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%BC%8F.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/145.快速解析模式.md",key:"v-f516a618",path:"/pages/v2.11.X/5fe959/",headersStr:null,content:"从v2.11.4正式版中开始新增了一个liteflow.fast-load的配置参数：\n\nliteflow.fast-load=false\n\n\n如果把这个设为true，则在拥有超大量的规则的时候，加载性能能提高4倍。\n\n这里超大量规则指的是5000条规则以上。如果几百个规则，还是推荐用默认模式。\n\n我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。\n\n当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。",normalizedContent:"从v2.11.4正式版中开始新增了一个liteflow.fast-load的配置参数：\n\nliteflow.fast-load=false\n\n\n如果把这个设为true，则在拥有超大量的规则的时候，加载性能能提高4倍。\n\n这里超大量规则指的是5000条规则以上。如果几百个规则，还是推荐用默认模式。\n\n我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。\n\n当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧁自定义请求Id",frontmatter:{title:"🧁自定义请求Id",date:"2022-07-03T11:12:53.000Z",permalink:"/pages/v2.11.X/47e8f5/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/140.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82Id.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/140.自定义请求Id.md",key:"v-26634af4",path:"/pages/v2.11.X/47e8f5/",headers:[{level:2,title:"按照自己的规则生成",slug:"按照自己的规则生成",normalizedTitle:"按照自己的规则生成",charIndex:1149},{level:2,title:"传入已有的requestId/traceId",slug:"传入已有的requestid-traceid",normalizedTitle:"传入已有的requestid/traceid",charIndex:1594},{level:2,title:"给组件中的日志也加上请求ID前缀",slug:"给组件中的日志也加上请求id前缀",normalizedTitle:"给组件中的日志也加上请求id前缀",charIndex:1896}],headersStr:"按照自己的规则生成 传入已有的requestId/traceId 给组件中的日志也加上请求ID前缀",content:'LiteFlow支持让你自定义你的请求Id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[a] execution\n2022-07-03 11:15:00.204  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[b] execution\n2022-07-03 11:15:00.218  INFO 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[c] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[d] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [           main] com.yomahub.liteflow.slot.Slot           : [067a0baa6d434de3a8ccafa4b1506562]:CHAIN_NAME[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  INFO 71275 --- [           main] com.yomahub.liteflow.slot.DataBus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是RequestId，一个请求中的requestId都是相同的，方便你进行日志查找。\n\n这个requestId的形式也是可以自定义的。你可以按照自己的规则生成，也可以传入本来已有的TraceId来和系统做集成。\n\n\n# 按照自己的规则生成\n\n你只需要要声明一个类，然后实现RequestIdGenerator接口即可：\n\npublic class CustomRequestIdGenerator implements RequestIdGenerator {\n\n    @Override\n    public String generate() {\n        return System.nanoTime();\n    }\n}\n\n\n然后在LiteFlow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestId.config.CustomRequestIdGenerator\n\n\n一般情况下，LiteFlow有自己默认的Id生成规则。所以大多数情况下你并不需要去特别自定义这个Id生成器。\n\n\n# 传入已有的requestId/traceId\n\nLiteFlow在v2.10.5版本中对于这个特性给予了支持。在FlowExecutor进行调用的时候，你可以调用如下方法来传入一个已有的requestId。\n\n如果有小伙伴用了TraceId的框架，可以把TraceId通过以下这种方式进行传入：\n\nLiteflowResponse response = flowExecutor.execute2RespWithRid("chain1", arg, "T001234", YourContext.class);\n\n\n那么，这个链路中所有的框架日志前，都会带有[T001234]这个传入的ID了。\n\n\n# 给组件中的日志也加上请求ID前缀\n\n值得一提的是，LiteFlow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求ID前缀。\n\nprivate final LFLog logger = LFLoggerManager.getLogger(FlowExecutor.class);\n\n\n其中LFLog这个类是继承自slf4j的Logger类的，所以它的使用方式和Logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求ID，那么对于定位问题来说，会很方便。推荐大家使用此特性。',normalizedContent:'liteflow支持让你自定义你的请求id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[a] execution\n2022-07-03 11:15:00.204  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[b] execution\n2022-07-03 11:15:00.218  info 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[c] execution\n2022-07-03 11:15:00.220  info 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[d] execution\n2022-07-03 11:15:00.220  info 71275 --- [           main] com.yomahub.liteflow.slot.slot           : [067a0baa6d434de3a8ccafa4b1506562]:chain_name[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  info 71275 --- [           main] com.yomahub.liteflow.slot.databus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是requestid，一个请求中的requestid都是相同的，方便你进行日志查找。\n\n这个requestid的形式也是可以自定义的。你可以按照自己的规则生成，也可以传入本来已有的traceid来和系统做集成。\n\n\n# 按照自己的规则生成\n\n你只需要要声明一个类，然后实现requestidgenerator接口即可：\n\npublic class customrequestidgenerator implements requestidgenerator {\n\n    @override\n    public string generate() {\n        return system.nanotime();\n    }\n}\n\n\n然后在liteflow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestid.config.customrequestidgenerator\n\n\n一般情况下，liteflow有自己默认的id生成规则。所以大多数情况下你并不需要去特别自定义这个id生成器。\n\n\n# 传入已有的requestid/traceid\n\nliteflow在v2.10.5版本中对于这个特性给予了支持。在flowexecutor进行调用的时候，你可以调用如下方法来传入一个已有的requestid。\n\n如果有小伙伴用了traceid的框架，可以把traceid通过以下这种方式进行传入：\n\nliteflowresponse response = flowexecutor.execute2respwithrid("chain1", arg, "t001234", yourcontext.class);\n\n\n那么，这个链路中所有的框架日志前，都会带有[t001234]这个传入的id了。\n\n\n# 给组件中的日志也加上请求id前缀\n\n值得一提的是，liteflow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求id前缀。\n\nprivate final lflog logger = lfloggermanager.getlogger(flowexecutor.class);\n\n\n其中lflog这个类是继承自slf4j的logger类的，所以它的使用方式和logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求id，那么对于定位问题来说，会很方便。推荐大家使用此特性。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌭不同格式规则加载",frontmatter:{title:"🌭不同格式规则加载",date:"2022-07-03T11:20:47.000Z",permalink:"/pages/v2.11.X/a7e02e/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/150.%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99%E5%8A%A0%E8%BD%BD.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/150.不同格式规则加载.md",key:"v-9213f03c",path:"/pages/v2.11.X/a7e02e/",headersStr:null,content:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipleType/flow.el.xml,multipleType/flow.el.json\n\n\n这种模式在正常下会解析失败，但是LiteFLow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",normalizedContent:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipletype/flow.el.xml,multipletype/flow.el.json\n\n\n这种模式在正常下会解析失败，但是liteflow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍿自定义组件执行器",frontmatter:{title:"🍿自定义组件执行器",date:"2022-07-03T11:24:54.000Z",permalink:"/pages/v2.11.X/46bbed/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/170.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/170.自定义组件执行器.md",key:"v-311061b4",path:"/pages/v2.11.X/46bbed/",headers:[{level:2,title:"全局组件执行器",slug:"全局组件执行器",normalizedTitle:"全局组件执行器",charIndex:130},{level:2,title:"单个组件配置特殊的执行器",slug:"单个组件配置特殊的执行器",normalizedTitle:"单个组件配置特殊的执行器",charIndex:755},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1147},{level:2,title:"自定义执行器对于重试功能的影响",slug:"自定义执行器对于重试功能的影响",normalizedTitle:"自定义执行器对于重试功能的影响",charIndex:1196}],headersStr:"全局组件执行器 单个组件配置特殊的执行器 优先级 自定义执行器对于重试功能的影响",content:'LiteFlow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeExecutor.CustomerDefaultNodeExecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.NodeExecutor。\n\npublic class CustomerDefaultNodeExecutor extends NodeExecutor {\n    @Override\n    public void execute(NodeComponent instance) throws Exception {\n        LOG.info("使用customerDefaultNodeExecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getNodeExecutorClass 方法：\n\n@LiteflowComponent("d")\npublic class DCmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        System.out.println("DCmp executed!");\n    }\n\n    @Override\n    public Class<? extends NodeExecutor> getNodeExecutorClass() {\n        return CustomerNodeExecutorAndCustomRetry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@LiteflowRetry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',normalizedContent:'liteflow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeexecutor.customerdefaultnodeexecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.nodeexecutor。\n\npublic class customerdefaultnodeexecutor extends nodeexecutor {\n    @override\n    public void execute(nodecomponent instance) throws exception {\n        log.info("使用customerdefaultnodeexecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getnodeexecutorclass 方法：\n\n@liteflowcomponent("d")\npublic class dcmp extends nodecomponent {\n\n    @override\n    public void process() {\n        system.out.println("dcmp executed!");\n    }\n\n    @override\n    public class<? extends nodeexecutor> getnodeexecutorclass() {\n        return customernodeexecutorandcustomretry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@liteflowretry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥗异步线程池自定义",frontmatter:{title:"🥗异步线程池自定义",date:"2022-07-03T11:21:39.000Z",permalink:"/pages/v2.11.X/7280ea/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/160.%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%87%AA%E5%AE%9A%E4%B9%89.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/160.异步线程池自定义.md",key:"v-b12717cc",path:"/pages/v2.11.X/7280ea/",headers:[{level:2,title:"默认全局线程池",slug:"默认全局线程池",normalizedTitle:"默认全局线程池",charIndex:2},{level:2,title:"自定义全局线程池",slug:"自定义全局线程池",normalizedTitle:"自定义全局线程池",charIndex:157},{level:2,title:"WHEN级别的单独线程池",slug:"when级别的单独线程池",normalizedTitle:"when级别的单独线程池",charIndex:1134},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1940}],headersStr:"默认全局线程池 自定义全局线程池 WHEN级别的单独线程池 优先级",content:'# 默认全局线程池\n\nLiteFlow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，LiteFlow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的Builder：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n\n\n然后把你的Builder加入LiteFlow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n\t<property name="ruleSource" value="customThreadPool/flow.el.xml"/>\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n  <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n这样，LiteFlow在启动的时候就会自动通过你声明的Builder加载到自定义的线程池了。\n\n\n# WHEN级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    WHEN(a, b);\n</chain>\n\n<chain name="chain2">\n    WHEN(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class CustomThreadExecutor1 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class CustomThreadExecutor2 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    WHEN(a, b).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor1");\n</chain>\n<chain name="chain2">\n    WHEN(c, d).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和Condition都配置自定义线程池的情况下，优先使用Condition上配置的线程池。',normalizedContent:'# 默认全局线程池\n\nliteflow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，liteflow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的builder：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n\n\n然后把你的builder加入liteflow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n\t<property name="rulesource" value="customthreadpool/flow.el.xml"/>\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.test.customthreadpool.customthreadbuilder"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n  <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n这样，liteflow在启动的时候就会自动通过你声明的builder加载到自定义的线程池了。\n\n\n# when级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    when(a, b);\n</chain>\n\n<chain name="chain2">\n    when(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class customthreadexecutor1 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class customthreadexecutor2 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    when(a, b).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor1");\n</chain>\n<chain name="chain2">\n    when(c, d).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和condition都配置自定义线程池的情况下，优先使用condition上配置的线程池。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪁测试用例",frontmatter:{title:"🪁测试用例",date:"2022-07-03T11:28:26.000Z",permalink:"/pages/v2.11.X/81cdce/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/010.%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",relativePath:"08.v2.11.X文档/110.⛱测试用例以及示例/010.测试用例.md",key:"v-52828b4c",path:"/pages/v2.11.X/81cdce/",headersStr:null,content:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有1500多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解LiteFlow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于Groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于QLExpress脚本框架的测试用例\n * liteflow-testcase-el-script-javascript-springboot: 基于JavaScript脚本框架的测试用例\n * liteflow-testcase-el-script-graaljs-springboot: 基于JavaScript脚本(graaljs实现，支持jdk17)框架的测试用例\n * liteflow-testcase-el-script-python-springboot: 基于Python脚本框架的测试用例\n * liteflow-testcase-el-script-lua-springboot: 基于Lua脚本框架的测试用例\n * liteflow-testcase-el-script-aviator-springboot: 基于Aviator脚本框架的测试用例\n * liteflow-testcase-el-script-java-springboot: 基于Java脚本的测试用例\n * liteflow-testcase-el-script-multi-language-springboot: 多脚本共存的测试用例\n * liteflow-testcase-el-zk-springboot: ZK配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: SQL数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: Nacos配置源场景下的测试用例\n * liteflow-testcase-el-apollo-springboot: Apollo配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: Etcd配置源场景下的测试用例\n * liteflow-testcase-el-redis-springboot: Redis配置源场景下的测试用例\n * liteflow-testcase-el-builder: 动态组装EL的API的测试用例",normalizedContent:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有1500多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解liteflow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于qlexpress脚本框架的测试用例\n * liteflow-testcase-el-script-javascript-springboot: 基于javascript脚本框架的测试用例\n * liteflow-testcase-el-script-graaljs-springboot: 基于javascript脚本(graaljs实现，支持jdk17)框架的测试用例\n * liteflow-testcase-el-script-python-springboot: 基于python脚本框架的测试用例\n * liteflow-testcase-el-script-lua-springboot: 基于lua脚本框架的测试用例\n * liteflow-testcase-el-script-aviator-springboot: 基于aviator脚本框架的测试用例\n * liteflow-testcase-el-script-java-springboot: 基于java脚本的测试用例\n * liteflow-testcase-el-script-multi-language-springboot: 多脚本共存的测试用例\n * liteflow-testcase-el-zk-springboot: zk配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: sql数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: nacos配置源场景下的测试用例\n * liteflow-testcase-el-apollo-springboot: apollo配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: etcd配置源场景下的测试用例\n * liteflow-testcase-el-redis-springboot: redis配置源场景下的测试用例\n * liteflow-testcase-el-builder: 动态组装el的api的测试用例",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍥简单监控",frontmatter:{title:"🍥简单监控",date:"2022-07-03T11:25:52.000Z",permalink:"/pages/v2.11.X/e59f3a/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/180.%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/180.简单监控.md",key:"v-27ae08a2",path:"/pages/v2.11.X/e59f3a/",headersStr:null,content:"LiteFlow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",normalizedContent:"liteflow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧉XML的DTD",frontmatter:{title:"🧉XML的DTD",date:"2022-10-24T12:50:29.000Z",permalink:"/pages/v2.11.X/0066ae/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/190.XML%E7%9A%84DTD.html",relativePath:"08.v2.11.X文档/100.🎨高级特性/190.XML的DTD.md",key:"v-ab917da4",path:"/pages/v2.11.X/0066ae/",headersStr:null,content:'LiteFlow从2.9.1版本起，对XML增加了DTD，方便在XML里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE flow PUBLIC  "liteflow" "liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        THEN(a,b,WHEN(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为LiteFlow xml节点非常简单，并没有很多的节点标签需要记忆。',normalizedContent:'liteflow从2.9.1版本起，对xml增加了dtd，方便在xml里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype flow public  "liteflow" "liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        then(a,b,when(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为liteflow xml节点非常简单，并没有很多的节点标签需要记忆。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪀DEMO案例",frontmatter:{title:"🪀DEMO案例",date:"2022-07-03T11:32:24.000Z",permalink:"/pages/v2.11.X/0a8188/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/020.DEMO%E6%A1%88%E4%BE%8B.html",relativePath:"08.v2.11.X文档/110.⛱测试用例以及示例/020.DEMO案例.md",key:"v-198329e5",path:"/pages/v2.11.X/0a8188/",headers:[{level:2,title:"DEMO案例1",slug:"demo案例1",normalizedTitle:"demo案例1",charIndex:38},{level:2,title:"DEMO案例2",slug:"demo案例2",normalizedTitle:"demo案例2",charIndex:131},{level:2,title:"外置规则存储案例",slug:"外置规则存储案例",normalizedTitle:"外置规则存储案例",charIndex:217}],headersStr:"DEMO案例1 DEMO案例2 外置规则存储案例",content:"如果你想看一个实际的案例，加深对LiteFlow的理解。可以查看：\n\n\n# DEMO案例1\n\n> DEMO案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的Java业务！\n\n\n# DEMO案例2\n\n> DEMO案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到DB里，或者zk/nacos/etcd里，此案例为一个简单的DEMO，你可以根据此案例的演示来进行接入。",normalizedContent:"如果你想看一个实际的案例，加深对liteflow的理解。可以查看：\n\n\n# demo案例1\n\n> demo案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的java业务！\n\n\n# demo案例2\n\n> demo案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到db里，或者zk/nacos/etcd里，此案例为一个简单的demo，你可以根据此案例的演示来进行接入。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪂性能表现",frontmatter:{title:"🪂性能表现",date:"2022-07-03T11:32:51.000Z",permalink:"/pages/v2.11.X/9bf839/"},regularPath:"/08.v2.11.X%E6%96%87%E6%A1%A3/120.%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0.html",relativePath:"08.v2.11.X文档/120.性能表现.md",key:"v-63e8ef03",path:"/pages/v2.11.X/9bf839/",headersStr:null,content:"LiteFlow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，LiteFlow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的TPS，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然LiteFlow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求IO，或者有bad sql，又或者有大量的rpc同步调用。那实际TPS也不会很高。但是这是业务组件的的问题，而不是LiteFlow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的TPS/QPS，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nLiteFlow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库IO。\n\n基于这个Demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",normalizedContent:"liteflow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，liteflow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的tps，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然liteflow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求io，或者有bad sql，又或者有大量的rpc同步调用。那实际tps也不会很高。但是这是业务组件的的问题，而不是liteflow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的tps/qps，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nliteflow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库io。\n\n基于这个demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍤LiteFlow简介",frontmatter:{title:"🍤LiteFlow简介",date:"2022-06-16T17:51:48.000Z",permalink:"/pages/v2.10.X/5816c5/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/010.LiteFlow%E7%AE%80%E4%BB%8B.html",relativePath:"09.v2.10.X文档/010.LiteFlow简介.md",key:"v-44f62f41",path:"/pages/v2.10.X/5816c5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"LiteFlow框架的优势",slug:"liteflow框架的优势",normalizedTitle:"liteflow框架的优势",charIndex:390},{level:2,title:"LiteFlow的设计原则",slug:"liteflow的设计原则",normalizedTitle:"liteflow的设计原则",charIndex:934},{level:2,title:"LiteFlow不适用于哪些场景",slug:"liteflow不适用于哪些场景",normalizedTitle:"liteflow不适用于哪些场景",charIndex:1524},{level:2,title:"LiteFlow适用于哪些场景",slug:"liteflow适用于哪些场景",normalizedTitle:"liteflow适用于哪些场景",charIndex:1698}],headersStr:"前言 LiteFlow框架的优势 LiteFlow的设计原则 LiteFlow不适用于哪些场景 LiteFlow适用于哪些场景",content:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nLiteFlow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# LiteFlow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用LiteFlow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。LiteFlow拥有开源规则引擎最为简单的DSL语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nLiteFlow的脚本组件，支持众多脚本语言，完全和Java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nLiteFlow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用LiteFlow，轻而易举，你立马唾手可得！\n\n\n# LiteFlow的设计原则\n\nLiteFlow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。\n\n\n# LiteFlow不适用于哪些场景\n\nLiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。\n\n提示\n\n这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# LiteFlow适用于哪些场景\n\nLiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",normalizedContent:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统rpc调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？liteflow为解耦逻辑而生，为编排而生，在使用liteflow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nliteflow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# liteflow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用liteflow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用liteflow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。liteflow拥有开源规则引擎最为简单的dsl语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nliteflow的脚本组件，支持众多脚本语言，完全和java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nliteflow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用liteflow，轻而易举，你立马唾手可得！\n\n\n# liteflow的设计原则\n\nliteflow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到liteflow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以liteflow能做到统一解耦的组件和灵活的装配。\n\n\n# liteflow不适用于哪些场景\n\nliteflow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，a审批完应该是b审批，然后再流转到c角色。\n\n提示\n\n这里申明下，liteflow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# liteflow适用于哪些场景\n\nliteflow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用liteflow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"☕️JDK支持度",frontmatter:{title:"☕️JDK支持度",date:"2023-07-21T18:07:20.000Z",permalink:"/pages/v2.10.X/7cf080/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/010.JDK%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"09.v2.10.X文档/021.🧁环境支持/010.JDK支持度.md",key:"v-3286cc9a",path:"/pages/v2.10.X/7cf080/",headersStr:null,content:"LiteFlow要求的最低的JDK版本为8，支持JDK8~JDK17所有的版本。\n\n如果你使用JDK11以上，确保LiteFlow的版本为v2.10.6及其以上版本。\n\n因为LiteFlow从v2.10.6开始，对JDK11和JDK17进行了详细的用例测试，通过了全部的900多个测试用例。而在v2.10.6以下版本，在JDK11以上是未经过测试用例保障的。\n\n特别需要注意的是，如果你使用JDK11及其以上的版本，请确保jvm参数加上以下参数\n\n--add-opens java.base/sun.reflect.annotation=ALL-UNNAMED\n",normalizedContent:"liteflow要求的最低的jdk版本为8，支持jdk8~jdk17所有的版本。\n\n如果你使用jdk11以上，确保liteflow的版本为v2.10.6及其以上版本。\n\n因为liteflow从v2.10.6开始，对jdk11和jdk17进行了详细的用例测试，通过了全部的900多个测试用例。而在v2.10.6以下版本，在jdk11以上是未经过测试用例保障的。\n\n特别需要注意的是，如果你使用jdk11及其以上的版本，请确保jvm参数加上以下参数\n\n--add-opens java.base/sun.reflect.annotation=all-unnamed\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot支持度",frontmatter:{title:"🌿Springboot支持度",date:"2023-07-21T18:20:37.000Z",permalink:"/pages/v2.10.X/891e0f/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/020.Springboot%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"09.v2.10.X文档/021.🧁环境支持/020.Springboot支持度.md",key:"v-52af8ef6",path:"/pages/v2.10.X/891e0f/",headersStr:null,content:"LiteFlow要求的Springboot的最低的版本是2.0。\n\n支持的范围是Springboot 2.X ~ Springboot 3.X。\n\n当然如果你使用了最新的Springboot 3.X，相应的JDK版本也要切换为JDK17。\n\n如果你想使用Springboot快速开始学习，请参考Springboot场景安装运行。",normalizedContent:"liteflow要求的springboot的最低的版本是2.0。\n\n支持的范围是springboot 2.x ~ springboot 3.x。\n\n当然如果你使用了最新的springboot 3.x，相应的jdk版本也要切换为jdk17。\n\n如果你想使用springboot快速开始学习，请参考springboot场景安装运行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍓项目特性",frontmatter:{title:"🍓项目特性",date:"2022-06-01T21:13:18.000Z",permalink:"/pages/v2.10.X/724bc3/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/020.%E9%A1%B9%E7%9B%AE%E7%89%B9%E6%80%A7.html",relativePath:"09.v2.10.X文档/020.项目特性.md",key:"v-4619bcf3",path:"/pages/v2.10.X/724bc3/",headersStr:null,content:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看即懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，Nacos，Etcd，Zookeeper，Apollo。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * Springboot支持全面： 支持Springboot 2.X到最新的Springboot 3.X。\n * 脚本语言支持： 可以定义脚本语言节点，支持Groovy，Javascript，QLExpress，Python，Lua，Aviator。未来还会支持更多的脚本语言。\n * 脚本和Java全打通： 所有脚本语言均可调用Java方法，甚至于可以引用任意的实例，在脚本中调用RPC也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",normalizedContent:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看即懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用liteflow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，nacos，etcd，zookeeper，apollo。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * springboot支持全面： 支持springboot 2.x到最新的springboot 3.x。\n * 脚本语言支持： 可以定义脚本语言节点，支持groovy，javascript，qlexpress，python，lua，aviator。未来还会支持更多的脚本语言。\n * 脚本和java全打通： 所有脚本语言均可调用java方法，甚至于可以引用任意的实例，在脚本中调用rpc也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.10.X/df6982/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md",key:"v-4a32cd40",path:"/pages/v2.10.X/df6982/",headersStr:null,content:"LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring-boot-starter</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"liteflow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring-boot-starter</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:49:31.000Z",permalink:"/pages/v2.10.X/631fa1/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/005.%E8%AF%B4%E6%98%8E.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/005.说明.md",key:"v-6684958c",path:"/pages/v2.10.X/631fa1/",headersStr:null,content:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验LiteFlow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的Hello World里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到LiteFlow的优雅之处。",normalizedContent:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验liteflow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的hello world里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到liteflow的优雅之处。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring的支持度",frontmatter:{title:"🌱Spring的支持度",date:"2023-07-21T18:24:20.000Z",permalink:"/pages/v2.10.X/2d12db/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/021.%F0%9F%A7%81%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81/030.Spring%E7%9A%84%E6%94%AF%E6%8C%81%E5%BA%A6.html",relativePath:"09.v2.10.X文档/021.🧁环境支持/030.Spring的支持度.md",key:"v-33214e62",path:"/pages/v2.10.X/2d12db/",headersStr:null,content:"如果你不使用Springboot，只使用Spring。\n\nLiteFlow要求的Spring的最低版本为Spring 5.0。\n\n支持的范围是Spring 5.X ~ Spring 6.X。\n\n当然如果你使用了最新的Spring 6.X，相应的JDK版本也要切换为JDK17。\n\n如果你想使用Spring快速开始学习，请参考Spring场景安装运行。",normalizedContent:"如果你不使用springboot，只使用spring。\n\nliteflow要求的spring的最低版本为spring 5.0。\n\n支持的范围是spring 5.x ~ spring 6.x。\n\n当然如果你使用了最新的spring 6.x，相应的jdk版本也要切换为jdk17。\n\n如果你想使用spring快速开始学习，请参考spring场景安装运行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.10.X/495f21/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md",key:"v-4134aa26",path:"/pages/v2.10.X/495f21/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"Spring xml中的配置",slug:"spring-xml中的配置",normalizedTitle:"spring xml中的配置",charIndex:452},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:1155}],headersStr:"定义你的组件 Spring xml中的配置 规则文件的定义",content:'# 定义你的组件\n\n你需要定义并实现一些组件，确保Spring会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# Spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springAware" class="com.yomahub.liteflow.spi.spring.SpringAware"/>\n\n<bean class="com.yomahub.liteflow.spring.ComponentScanner"/>\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\x3c!-- 如果上述enableLog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.MonitorBus">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c)\n    </chain>\n</flow>\n\n\nSpring在启动时会自动装载规则文件。',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件，确保spring会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springaware" class="com.yomahub.liteflow.spi.spring.springaware"/>\n\n<bean class="com.yomahub.liteflow.spring.componentscanner"/>\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\x3c!-- 如果上述enablelog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.monitorbus">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c)\n    </chain>\n</flow>\n\n\nspring在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.10.X/522432/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E8%AF%B4%E6%98%8E.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md",key:"v-f93a7194",path:"/pages/v2.10.X/522432/",headersStr:null,content:"虽说Springboot/Spring已经成为了Java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合Spring我始终觉得是瑕疵，有点代码洁癖），现在在非Spring体系的环境中也能使用LiteFlow框架带来的便捷和高效。\n\nLiteFlow文档中提到的98%以上的特性功能都能在非Spring体系中生效。其中不生效的特性和功能有：\n\n * ruleSource的模糊路径匹配特性在非Spring体系下不生效\n * LiteflowComponent在非Spring体系下无法使用\n * 监控功能在非Spring体系中无法使用",normalizedContent:"虽说springboot/spring已经成为了java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合spring我始终觉得是瑕疵，有点代码洁癖），现在在非spring体系的环境中也能使用liteflow框架带来的便捷和高效。\n\nliteflow文档中提到的98%以上的特性功能都能在非spring体系中生效。其中不生效的特性和功能有：\n\n * rulesource的模糊路径匹配特性在非spring体系下不生效\n * liteflowcomponent在非spring体系下无法使用\n * 监控功能在非spring体系中无法使用",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.10.X/0a4573/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md",key:"v-2df4f91b",path:"/pages/v2.10.X/0a4573/",headersStr:null,content:"针对于使用了Spring但没有使用SpringBoot的项目\n\n<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring</artifactId>\n\t<version>2.10.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"针对于使用了spring但没有使用springboot的项目\n\n<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring</artifactid>\n\t<version>2.10.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-02T19:49:57.000Z",permalink:"/pages/v2.10.X/0e0fb5/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md",key:"v-4da4c309",path:"/pages/v2.10.X/0e0fb5/",headersStr:null,content:'和SpringBoot的执行方式一样，没有任何区别，你可以在你的任何受Spring托管的类里注入FlowExecutor进行执行：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'和springboot的执行方式一样，没有任何区别，你可以在你的任何受spring托管的类里注入flowexecutor进行执行：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.10.X/8760c4/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E4%BE%9D%E8%B5%96.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md",key:"v-5720f4ae",path:"/pages/v2.10.X/8760c4/",headersStr:null,content:"<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-core</artifactId>\n\t<version>2.10.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-core</artifactid>\n\t<version>2.10.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.10.X/9f4489/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md",key:"v-72ee2b64",path:"/pages/v2.10.X/9f4489/",headersStr:null,content:'声明启动类：\n\n@SpringBootApplication\n//把你定义的组件扫入Spring上下文中\n@ComponentScan({"com.xxx.xxx.cmp"})\npublic class LiteflowExampleApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(LiteflowExampleApplication.class, args);\n    }\n}\n\n\n然后你就可以在Springboot任意被Spring托管的类中拿到flowExecutor，进行执行链路：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'声明启动类：\n\n@springbootapplication\n//把你定义的组件扫入spring上下文中\n@componentscan({"com.xxx.xxx.cmp"})\npublic class liteflowexampleapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(liteflowexampleapplication.class, args);\n    }\n}\n\n\n然后你就可以在springboot任意被spring托管的类中拿到flowexecutor，进行执行链路：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.10.X/249d17/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E9%85%8D%E7%BD%AE.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md",key:"v-14f04b39",path:"/pages/v2.10.X/249d17/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"规则文件的配置",slug:"规则文件的配置",normalizedTitle:"规则文件的配置",charIndex:381}],headersStr:"定义你的组件 规则文件的配置",content:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.AComponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.BComponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.CComponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tTHEN(a, b, c);\n\t</chain>\n</flow>\n',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.acomponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.bcomponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.ccomponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tthen(a, b, c);\n\t</chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-06T23:15:50.000Z",permalink:"/pages/v2.10.X/151524/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/040.%E6%89%A7%E8%A1%8C.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md",key:"v-0495d39c",path:"/pages/v2.10.X/151524/",headers:[{level:2,title:"初始化你的FlowExecutor执行器",slug:"初始化你的flowexecutor执行器",normalizedTitle:"初始化你的flowexecutor执行器",charIndex:2},{level:2,title:"用FlowExecutor执行",slug:"用flowexecutor执行",normalizedTitle:"用flowexecutor执行",charIndex:331}],headersStr:"初始化你的FlowExecutor执行器 用FlowExecutor执行",content:'# 初始化你的FlowExecutor执行器\n\n通过以下代码你可以轻易的初始化FlowExecutor处理器：\n\nLiteflowConfig config = new LiteflowConfig();\nconfig.setRuleSource("config/flow.el.xml");\nFlowExecutor flowExecutor = FlowExecutorHolder.loadInstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化FlowExecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用FlowExecutor执行\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'# 初始化你的flowexecutor执行器\n\n通过以下代码你可以轻易的初始化flowexecutor处理器：\n\nliteflowconfig config = new liteflowconfig();\nconfig.setrulesource("config/flow.el.xml");\nflowexecutor flowexecutor = flowexecutorholder.loadinstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化flowexecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用flowexecutor执行\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot下的配置项",frontmatter:{title:"🌿Springboot下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.10.X/4594ec/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/020.Springboot%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"09.v2.10.X文档/040.🍢配置项/020.Springboot下的配置项.md",key:"v-6a8e583a",path:"/pages/v2.10.X/4594ec/",headersStr:null,content:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zkNode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#FlowExecutor的execute2Future的线程数，默认为64\nliteflow.main-executor-works=64\n#FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n#自定义请求ID的生成类，LiteFlow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n#并行节点的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n#异步线程最长的等待时间(只用于when)，默认值为15000\nliteflow.when-max-wait-time=15000\n#异步线程最长的等待时间单位(只用于when)，默认值为MILLISECONDS，毫秒\nliteflow.when-max-wait-time-unit=MILLISECONDS\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#是否开启本地文件监听，默认为false\nliteflow.enable-monitor-file=false\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #FlowExecutor的execute2Future的线程数，默认为64\n  main-executor-works: 64\n  #FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\n  main-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n  #自定义请求ID的生成类，LiteFlow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n  #并行节点的线程池Builder，LiteFlow提供了默认的Builder\n  thread-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n  #异步线程最长的等待时间(只用于when)，默认值为15000\n  when-max-wait-time: 15000\n  #异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒\n  when-max-wait-time-unit: MILLISECONDS\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #是否开启本地文件监听，默认为false\n  enable-monitor-file: false\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",normalizedContent:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zknode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#flowexecutor的execute2future的线程数，默认为64\nliteflow.main-executor-works=64\n#flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n#自定义请求id的生成类，liteflow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n#并行节点的线程池builder，liteflow提供了默认的builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n#异步线程最长的等待时间(只用于when)，默认值为15000\nliteflow.when-max-wait-time=15000\n#异步线程最长的等待时间单位(只用于when)，默认值为milliseconds，毫秒\nliteflow.when-max-wait-time-unit=milliseconds\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#是否开启本地文件监听，默认为false\nliteflow.enable-monitor-file=false\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #flowexecutor的execute2future的线程数，默认为64\n  main-executor-works: 64\n  #flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\n  main-executor-class: com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n  #自定义请求id的生成类，liteflow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n  #并行节点的线程池builder，liteflow提供了默认的builder\n  thread-executor-class: com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n  #异步线程最长的等待时间(只用于when)，默认值为15000\n  when-max-wait-time: 15000\n  #异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒\n  when-max-wait-time-unit: milliseconds\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #是否开启本地文件监听，默认为false\n  enable-monitor-file: false\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.10.X/82ef41/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"09.v2.10.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md",key:"v-0649d22a",path:"/pages/v2.10.X/82ef41/",headers:[{level:2,title:"组件的定义",slug:"组件的定义",normalizedTitle:"组件的定义",charIndex:2},{level:2,title:"SpringBoot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:453},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:620}],headersStr:"组件的定义 SpringBoot配置文件 规则文件的定义",content:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文。\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# SpringBoot配置文件\n\n然后，在你的SpringBoot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c);\n    </chain>\n</flow>\n\n\nSpringBoot在启动时会自动装载规则文件。',normalizedContent:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保springboot会扫描到这些组件并注册进上下文。\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# springboot配置文件\n\n然后，在你的springboot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c);\n    </chain>\n</flow>\n\n\nspringboot在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring下的配置项",frontmatter:{title:"🌱Spring下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.10.X/33833a/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/030.Spring%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"09.v2.10.X文档/040.🍢配置项/030.Spring下的配置项.md",key:"v-1b865381",path:"/pages/v2.10.X/33833a/",headersStr:null,content:'<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printBanner" value="true"/> \n    \x3c!-- zkNode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zkNode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotSize" value="1024"/> \n    \x3c!-- FlowExecutor的execute2Future的线程数，默认为64 --\x3e\n    <property name="mainExecutorWorks" value="64"/> \n    \x3c!-- FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="mainExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder"/>\n    \x3c!-- 自定义请求ID的生成类，LiteFlow提供了默认的生成类 --\x3e\n    <property name="requestIdGeneratorClass" value="com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator"/>\n    \x3c!-- 并行节点的线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder"/> \n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为15000 --\x3e\n    <property name="whenMaxWaitTime" value="15000"/>\n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒 --\x3e\n    <property name="whenMaxWaitTimeUnit" value="MILLISECONDS"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenMaxWorkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenQueueLimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseOnStart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retryCount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportMultipleType" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeExecutorClass" value="com.yomahub.liteflow.flow.executor.DefaultNodeExecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printExecutionLog" value="true"/>\n    \x3c!-- 是否开启本地文件监听，默认为false --\x3e\n    <property name="enableMonitorFile" value="false"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enableLog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queueLimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printbanner" value="true"/> \n    \x3c!-- zknode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zknode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotsize" value="1024"/> \n    \x3c!-- flowexecutor的execute2future的线程数，默认为64 --\x3e\n    <property name="mainexecutorworks" value="64"/> \n    \x3c!-- flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="mainexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder"/>\n    \x3c!-- 自定义请求id的生成类，liteflow提供了默认的生成类 --\x3e\n    <property name="requestidgeneratorclass" value="com.yomahub.liteflow.flow.id.defaultrequestidgenerator"/>\n    \x3c!-- 并行节点的线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder"/> \n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为15000 --\x3e\n    <property name="whenmaxwaittime" value="15000"/>\n    \x3c!-- 异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒 --\x3e\n    <property name="whenmaxwaittimeunit" value="milliseconds"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenmaxworkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenqueuelimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseonstart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retrycount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportmultipletype" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeexecutorclass" value="com.yomahub.liteflow.flow.executor.defaultnodeexecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printexecutionlog" value="true"/>\n    \x3c!-- 是否开启本地文件监听，默认为false --\x3e\n    <property name="enablemonitorfile" value="false"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enablelog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queuelimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-06T21:42:12.000Z",permalink:"/pages/v2.10.X/b70ec8/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/010.%E8%AF%B4%E6%98%8E.html",relativePath:"09.v2.10.X文档/040.🍢配置项/010.说明.md",key:"v-de41190e",path:"/pages/v2.10.X/b70ec8/",headersStr:null,content:"LiteFlow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",normalizedContent:"liteflow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📔规则文件格式",frontmatter:{title:"📔规则文件格式",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.10.X/6fa87e/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/010.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/010.规则文件格式.md",key:"v-998e39f0",path:"/pages/v2.10.X/6fa87e/",headers:[{level:2,title:"规则组成部分",slug:"规则组成部分",normalizedTitle:"规则组成部分",charIndex:147}],headersStr:"规则组成部分",content:'LiteFlow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nLiteFlow的规则文件非常轻量，非常容易上手。主要由Node节点和Chain节点组成。\n\n提示\n\n必须要说明的是，Node节点在Springboot/Spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到Spring上下文中。\n\n在非Spring环境体系中，Node节点是必须的。如果不配置Node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nXML在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.ACmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.BCmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.CCmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.DCmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(\n            a, b, WHEN(c,d)\n        );\n    </chain>\n</flow>\n\n\nJSON在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.TestCustomParser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ACmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.BCmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.CCmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.DCmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "THEN(a, b, WHEN(c, d))"\n      }\n    ]\n  }\n}\n\n\nYAML在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.TestCustomParser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.ACmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.BCmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.CCmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.DCmp\n  chain:\n    - name: chain1\n      value: "THEN(a, b, WHEN(c, d))"\n',normalizedContent:'liteflow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nliteflow的规则文件非常轻量，非常容易上手。主要由node节点和chain节点组成。\n\n提示\n\n必须要说明的是，node节点在springboot/spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到spring上下文中。\n\n在非spring环境体系中，node节点是必须的。如果不配置node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nxml在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.acmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.bcmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.ccmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.dcmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(\n            a, b, when(c,d)\n        );\n    </chain>\n</flow>\n\n\njson在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.testcustomparser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.acmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.bcmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ccmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.dcmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "then(a, b, when(c, d))"\n      }\n    ]\n  }\n}\n\n\nyaml在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.testcustomparser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.acmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.bcmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.ccmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.dcmp\n  chain:\n    - name: chain1\n      value: "then(a, b, when(c, d))"\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵其他场景代码设置配置项",frontmatter:{title:"🌵其他场景代码设置配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.10.X/b5065a/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/040.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"09.v2.10.X文档/040.🍢配置项/040.其他场景代码设置配置项.md",key:"v-d8bbe23a",path:"/pages/v2.10.X/b5065a/",headersStr:null,content:'LiteflowConfig config = new LiteflowConfig();\n//规则文件路径\nconfig.setRuleSource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setEnable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setPrintBanner(true);\n//zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setZkNode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setSlotSize(1024);\n//FlowExecutor的execute2Future的线程数，默认为64\nconfig.setMainExecutorWorks(64);\n//FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nconfig.setMainExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder");\n//自定义请求ID的生成类，LiteFlow提供了默认的生成类\nconfig.setRequestIdGeneratorClass("com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator");\n//并行节点的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setThreadExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder");\n//异步线程最长的等待时间(只用于when)，默认值为15000\nconfig.setWhenMaxWaitTime(15000);\n//异步线程最长的等待时间(只用于when)，默认值为MILLISECONDS，毫秒\nconfig.setWhenMaxWaitTimeUnit(TimeUnit.MILLISECONDS);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setWhenMaxWorkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setWhenQueueLimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setParseOnStart(true);\n//全局重试次数，默认为0\nconfig.setRetryCount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setSupportMultipleType(false);\n//全局默认节点执行器\nconfig.setNodeExecutorClass("com.yomahub.liteflow.flow.executor.DefaultNodeExecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setPrintExecutionLog(true);\n//是否开启本地文件监听，默认为false\nconfig.setEnableMonitorFile(false);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setEnableLog(false);\n//监控队列存储大小，默认值为200\nconfig.setQueueLimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setDelay(300000L);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setPeriod(300000L);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'liteflowconfig config = new liteflowconfig();\n//规则文件路径\nconfig.setrulesource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setenable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setprintbanner(true);\n//zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setzknode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setslotsize(1024);\n//flowexecutor的execute2future的线程数，默认为64\nconfig.setmainexecutorworks(64);\n//flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nconfig.setmainexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder");\n//自定义请求id的生成类，liteflow提供了默认的生成类\nconfig.setrequestidgeneratorclass("com.yomahub.liteflow.flow.id.defaultrequestidgenerator");\n//并行节点的线程池builder，liteflow提供了默认的builder\nconfig.setthreadexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder");\n//异步线程最长的等待时间(只用于when)，默认值为15000\nconfig.setwhenmaxwaittime(15000);\n//异步线程最长的等待时间(只用于when)，默认值为milliseconds，毫秒\nconfig.setwhenmaxwaittimeunit(timeunit.milliseconds);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setwhenmaxworkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setwhenqueuelimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setparseonstart(true);\n//全局重试次数，默认为0\nconfig.setretrycount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setsupportmultipletype(false);\n//全局默认节点执行器\nconfig.setnodeexecutorclass("com.yomahub.liteflow.flow.executor.defaultnodeexecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setprintexecutionlog(true);\n//是否开启本地文件监听，默认为false\nconfig.setenablemonitorfile(false);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setenablelog(false);\n//监控队列存储大小，默认值为200\nconfig.setqueuelimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setdelay(300000l);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setperiod(300000l);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📕本地规则文件配置",frontmatter:{title:"📕本地规则文件配置",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.10.X/51ddd5/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/020.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/020.本地规则文件配置.md",key:"v-66880172",path:"/pages/v2.10.X/51ddd5/",headers:[{level:2,title:"常规配置",slug:"常规配置",normalizedTitle:"常规配置",charIndex:173},{level:2,title:"指定多个路径",slug:"指定多个路径",normalizedTitle:"指定多个路径",charIndex:300}],headersStr:"常规配置 指定多个路径",content:"在LiteFlow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是LiteFlow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用Spring EL表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n提示\n\n模糊匹配只限于Springboot/Spring体系中，非Spring环境，模糊匹配不生效",normalizedContent:"在liteflow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是liteflow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用spring el表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n提示\n\n模糊匹配只限于springboot/spring体系中，非spring环境，模糊匹配不生效",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📗ZK规则文件配置源",frontmatter:{title:"📗ZK规则文件配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.10.X/ffc345/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/030.ZK%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/030.ZK规则文件配置源.md",key:"v-07c11cbe",path:"/pages/v2.10.X/ffc345/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:17},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:649},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:785},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1153},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1221}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'# 依赖\n\nLiteFlow支持把配置放在zk集群中，基于zk的通知机制，LiteFlow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-zk</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectStr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainPath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectStr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectStr   zk的连接串，可以是集群\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在ZK中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainId，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手ZK规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'# 依赖\n\nliteflow支持把配置放在zk集群中，基于zk的通知机制，liteflow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-zk</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectstr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainpath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectstr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectstr   zk的连接串，可以是集群\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在zk中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainid，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手zk规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📘SQL数据库配置源",frontmatter:{title:"📘SQL数据库配置源",date:"2022-10-06T23:18:42.000Z",permalink:"/pages/v2.10.X/236b4f/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/040.SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/040.SQL数据库配置源.md",key:"v-ee1a7b9a",path:"/pages/v2.10.X/236b4f/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:67},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:35},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:1576},{level:2,title:"使用你项目中的dataSource来进行连接",slug:"使用你项目中的datasource来进行连接",normalizedTitle:"使用你项目中的datasource来进行连接",charIndex:4050},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:4593},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:4764}],headersStr:"依赖 配置 配置说明 使用你项目中的dataSource来进行连接 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准SQL语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-sql</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverClassName: com.mysql.cj.jdbc.Driver\n    username: root\n    password: 123456\n    applicationName: demo\n    #以下是chain表的配置，这个一定得有\n    chainTableName: chain\n    chainApplicationNameField: application_name\n    chainNameField: chain_name\n    elDataField: el_data\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scriptTableName: script\n    scriptApplicationNameField: application_name\n    scriptIdField: script_id\n    scriptNameField: script_name\n    scriptDataField: script_data\n    scriptTypeField: script_type\n    scriptLanguageField: script_language\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverClassName":"com.mysql.cj.jdbc.Driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationName": "demo",\\\n  "chainTableName": "chain",\\\n  "chainApplicationNameField": "application_name",\\\n  "chainNameField": "chain_name",\\\n  "elDataField": "el_data",\\\n  "scriptTableName": "script",\\\n  "scriptApplicationNameField": "application_name",\\\n  "scriptIdField": "script_id",\\\n  "scriptNameField": "script_name",\\\n  "scriptDataField": "script_data",\\\n  "scriptTypeField": "script_type",\\\n  "scriptLanguageField": "script_language"\n  }\n\n\n\n# 配置说明\n\nLiteFlow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明\nurl                          jdbc的连接url\ndriverClassName              驱动器类名\nusername                     数据库用户名\npassword                     数据库密码\napplicationName              你的应用名称\nchainTableName               编排规则表的表名\nchainApplicationNameField    编排规则表中应用名称存储字段名\nchainNameField               规则名称存储的字段名\nelDataField                  EL表达式的字段(只存EL)\nscriptTableName              你的脚本存储表的表名\nscriptApplicationNameField   脚本表中应用名称存储字段名\nscriptIdField                脚本组件的Id的字段名\nscriptNameField              脚本组件名称的字段名\nscriptDataField              脚本数据的字段名\nscriptTypeField              脚本类型的字段名(类型参照定义脚本组件)\nscriptLanguageField          脚本语言类型（groovy | qlexpress | js | python | lua | aviator）\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nID   APPLICATION_NAME   CHAIN_NAME   CHAIN_DESC   EL_DATA                 CREATE_TIME\n1    demo               chain1       测试流程1        THEN(a, b, c, s1,s2);   2022-09-19 19:31:00\n\n脚本表：liteflow_script\n\nID   APPLICATION_NAME   SCRIPT_ID   SCRIPT_NAME   SCRIPT_DATA                                                  SCRIPT_TYPE   SCRIPT_LANGUAGE   CREATE_TIME\n1    demo               s1          脚本s1          import cn.hutool.core.date.DateUtil                          script        groovy            2022-09-19 19:31:00\n                                                  def date = DateUtil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultContext.setData("demoDate", date)\n                                                  class Student {\n                                                  int studentID\n                                                  String studentName\n                                                  }\n                                                  Student student = new Student() student.studentID = 100301\n                                                  student.studentName = "张三"\n                                                  defaultContext.setData("student",student) def a=3\n                                                  def b=2\n                                                  defaultContext.setData("s1",a*b)\n2    demo               s2          脚本s2          defaultContext.setData("s2","hello")                         script        groovy            2022-09-19 19:31:00\n\n\n# 使用你项目中的dataSource来进行连接\n\nLiteFlow从v2.10.6开始支持了使用项目中已存在的Datasource来进行数据库连接。如果你项目中已有链接配置，比如：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/poseidon\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n那么你在rule-source-ext-data-map中无需再配置以下几项：\n\nurl: jdbc:mysql://localhost:3306/poseidon\ndriverClassName: com.mysql.cj.jdbc.Driver\nusername: root\npassword: 123456\n\n\n提示\n\n需要注意的是，如果你的系统中声明了多个数据源，那么LiteFlow会自动判断该选用哪个数据源。\n\n如果你的系统中使用了动态数据源，那么请确保默认数据源是含有LiteFlow链路数据的表数据的。\n\n\n# 自动刷新\n\n由于结构化数据库并不提供监听机制，所以当你的规则在数据库中发生变化，LiteFlow是感知不到变化的。不会自动刷新规则。\n\n你需要手动调用LiteFlow提供的相关API来完成规则刷新。在实际应用中，你可以把这个刷新做成页面上的一个按钮或者一个http链接来进行操作。\n\n具体如何调用API进行规则刷新请参照平滑热刷新。\n\n\n# 小例子\n\n为了让大家能简单上手SQL规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准sql语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-sql</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverclassname: com.mysql.cj.jdbc.driver\n    username: root\n    password: 123456\n    applicationname: demo\n    #以下是chain表的配置，这个一定得有\n    chaintablename: chain\n    chainapplicationnamefield: application_name\n    chainnamefield: chain_name\n    eldatafield: el_data\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scripttablename: script\n    scriptapplicationnamefield: application_name\n    scriptidfield: script_id\n    scriptnamefield: script_name\n    scriptdatafield: script_data\n    scripttypefield: script_type\n    scriptlanguagefield: script_language\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverclassname":"com.mysql.cj.jdbc.driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationname": "demo",\\\n  "chaintablename": "chain",\\\n  "chainapplicationnamefield": "application_name",\\\n  "chainnamefield": "chain_name",\\\n  "eldatafield": "el_data",\\\n  "scripttablename": "script",\\\n  "scriptapplicationnamefield": "application_name",\\\n  "scriptidfield": "script_id",\\\n  "scriptnamefield": "script_name",\\\n  "scriptdatafield": "script_data",\\\n  "scripttypefield": "script_type",\\\n  "scriptlanguagefield": "script_language"\n  }\n\n\n\n# 配置说明\n\nliteflow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明\nurl                          jdbc的连接url\ndriverclassname              驱动器类名\nusername                     数据库用户名\npassword                     数据库密码\napplicationname              你的应用名称\nchaintablename               编排规则表的表名\nchainapplicationnamefield    编排规则表中应用名称存储字段名\nchainnamefield               规则名称存储的字段名\neldatafield                  el表达式的字段(只存el)\nscripttablename              你的脚本存储表的表名\nscriptapplicationnamefield   脚本表中应用名称存储字段名\nscriptidfield                脚本组件的id的字段名\nscriptnamefield              脚本组件名称的字段名\nscriptdatafield              脚本数据的字段名\nscripttypefield              脚本类型的字段名(类型参照定义脚本组件)\nscriptlanguagefield          脚本语言类型（groovy | qlexpress | js | python | lua | aviator）\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nid   application_name   chain_name   chain_desc   el_data                 create_time\n1    demo               chain1       测试流程1        then(a, b, c, s1,s2);   2022-09-19 19:31:00\n\n脚本表：liteflow_script\n\nid   application_name   script_id   script_name   script_data                                                  script_type   script_language   create_time\n1    demo               s1          脚本s1          import cn.hutool.core.date.dateutil                          script        groovy            2022-09-19 19:31:00\n                                                  def date = dateutil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultcontext.setdata("demodate", date)\n                                                  class student {\n                                                  int studentid\n                                                  string studentname\n                                                  }\n                                                  student student = new student() student.studentid = 100301\n                                                  student.studentname = "张三"\n                                                  defaultcontext.setdata("student",student) def a=3\n                                                  def b=2\n                                                  defaultcontext.setdata("s1",a*b)\n2    demo               s2          脚本s2          defaultcontext.setdata("s2","hello")                         script        groovy            2022-09-19 19:31:00\n\n\n# 使用你项目中的datasource来进行连接\n\nliteflow从v2.10.6开始支持了使用项目中已存在的datasource来进行数据库连接。如果你项目中已有链接配置，比如：\n\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.driver\nspring.datasource.url=jdbc:mysql://localhost:3306/poseidon\nspring.datasource.username=root\nspring.datasource.password=123456\n\n\n那么你在rule-source-ext-data-map中无需再配置以下几项：\n\nurl: jdbc:mysql://localhost:3306/poseidon\ndriverclassname: com.mysql.cj.jdbc.driver\nusername: root\npassword: 123456\n\n\n提示\n\n需要注意的是，如果你的系统中声明了多个数据源，那么liteflow会自动判断该选用哪个数据源。\n\n如果你的系统中使用了动态数据源，那么请确保默认数据源是含有liteflow链路数据的表数据的。\n\n\n# 自动刷新\n\n由于结构化数据库并不提供监听机制，所以当你的规则在数据库中发生变化，liteflow是感知不到变化的。不会自动刷新规则。\n\n你需要手动调用liteflow提供的相关api来完成规则刷新。在实际应用中，你可以把这个刷新做成页面上的一个按钮或者一个http链接来进行操作。\n\n具体如何调用api进行规则刷新请参照平滑热刷新。\n\n\n# 小例子\n\n为了让大家能简单上手sql规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📋Nacos配置源",frontmatter:{title:"📋Nacos配置源",date:"2022-10-06T23:19:04.000Z",permalink:"/pages/v2.10.X/09b776/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/050.Nacos%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/050.Nacos配置源.md",key:"v-28e1b734",path:"/pages/v2.10.X/09b776/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:40},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:31},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:694},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:874},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1144},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1218}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了Nacos的规则配置源。\n\n\n# 依赖\n\n如果使用Nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-nacos</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serverAddr: 127.0.0.1:8848\n    dataId: demo_rule\n    group: DEFAULT_GROUP\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serverAddr":"127.0.0.1:8848",\\\n    "dataId":"demo_rule",\\\n    "group":"DEFAULT_GROUP",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserverAddr   nacos的连接串\ndataId       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用Nacos配置源的时候，Nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      THEN(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此Nacos配置源插件，凡是Nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手Nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了nacos的规则配置源。\n\n\n# 依赖\n\n如果使用nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-nacos</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serveraddr: 127.0.0.1:8848\n    dataid: demo_rule\n    group: default_group\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serveraddr":"127.0.0.1:8848",\\\n    "dataid":"demo_rule",\\\n    "group":"default_group",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserveraddr   nacos的连接串\ndataid       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用nacos配置源的时候，nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      then(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此nacos配置源插件，凡是nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🗄Etcd配置源",frontmatter:{title:"🗄Etcd配置源",date:"2022-10-06T23:19:17.000Z",permalink:"/pages/v2.10.X/4bfac2/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/060.Etcd%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/060.Etcd配置源.md",key:"v-028dfb44",path:"/pages/v2.10.X/4bfac2/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:39},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:30},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:576},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:708},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1078},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1150}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了Etcd的规则配置源。\n\n\n# 依赖\n\n如果使用Etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-etcd</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainPath: /liteflow/chain\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在etcd中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainId，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此Etcd配置源插件，凡是Etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手Etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了etcd的规则配置源。\n\n\n# 依赖\n\n如果使用etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-etcd</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainpath: /liteflow/chain\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在etcd中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainid，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此etcd配置源插件，凡是etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📜Apollo配置源",frontmatter:{title:"📜Apollo配置源",date:"2022-12-12T22:42:40.000Z",permalink:"/pages/v2.10.X/bea809/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/065.Apollo%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/065.Apollo配置源.md",key:"v-c096ecc4",path:"/pages/v2.10.X/bea809/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:57},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:28},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:524},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:609},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1208}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新",content:'LiteFlow从2.9.5开始，原生支持了Apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用Apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-apollo</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainNamespace: chainConfig\n    scriptNamespace: scriptConfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainNamespace":"chainConfig",\\\n    "scriptNamespace":"scriptConfig",\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainNamespace    规则命名空间名称\nscriptNamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在Apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在LiteFlow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在Apollo中需要为规则单独创建一个Namespace，数据类型选择properties，那么这个Namespace 下的每一对kv都是一个规则，假设你的规则命名空间为:chainConfig，那么配置形式样例如下：\n\nNAMESPACE：CHAINCONFIG   \nchain1                  THEN(a, b, c);\nchain2                  IF(x, b).ELIF(y, c).ELSE(d);\n\n对于脚本命名空间来说，key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，假设你的脚本命名空间为：scriptConfig，那么配置形式样例如下：\n\nNAMESPACE：SCRIPTCONFIG   \ns1:script:脚本组件1          defaultContext.setData("s1","hello")\ns2:if_script:脚本组件2       if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\nApollo支持推送配置数据的变更，凡是在Apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你需做任何事情。',normalizedContent:'liteflow从2.9.5开始，原生支持了apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-apollo</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainnamespace: chainconfig\n    scriptnamespace: scriptconfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainnamespace":"chainconfig",\\\n    "scriptnamespace":"scriptconfig",\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainnamespace    规则命名空间名称\nscriptnamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在liteflow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在apollo中需要为规则单独创建一个namespace，数据类型选择properties，那么这个namespace 下的每一对kv都是一个规则，假设你的规则命名空间为:chainconfig，那么配置形式样例如下：\n\nnamespace：chainconfig   \nchain1                  then(a, b, c);\nchain2                  if(x, b).elif(y, c).else(d);\n\n对于脚本命名空间来说，key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，假设你的脚本命名空间为：scriptconfig，那么配置形式样例如下：\n\nnamespace：scriptconfig   \ns1:script:脚本组件1          defaultcontext.setdata("s1","hello")\ns2:if_script:脚本组件2       if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\napollo支持推送配置数据的变更，凡是在apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你需做任何事情。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"✂️选择组件",frontmatter:{title:"✂️选择组件",date:"2022-06-29T17:58:54.000Z",permalink:"/pages/v2.10.X/c0f5d7/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/020.%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/055.🔗常规组件/020.选择组件.md",key:"v-0e6c4db8",path:"/pages/v2.10.X/c0f5d7/",headers:[{level:2,title:"根据nodeId进行选择",slug:"根据nodeid进行选择",normalizedTitle:"根据nodeid进行选择",charIndex:153},{level:2,title:"根据表达式的id进行选择",slug:"根据表达式的id进行选择",normalizedTitle:"根据表达式的id进行选择",charIndex:496},{level:2,title:"根据tag进行选择",slug:"根据tag进行选择",normalizedTitle:"根据tag进行选择",charIndex:882},{level:2,title:"表达式tag的选择",slug:"表达式tag的选择",normalizedTitle:"表达式tag的选择",charIndex:2367},{level:2,title:"链路tag的选择",slug:"链路tag的选择",normalizedTitle:"链路tag的选择",charIndex:2522}],headersStr:"根据nodeId进行选择 根据表达式的id进行选择 根据tag进行选择 表达式tag的选择 链路tag的选择",content:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于SWITCH关键字中。\n\n关于SWITCH表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承NodeSwitchComponent。\n\n需要实现方法processSwitch方法。\n\n\n# 根据nodeId进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c);\n</chain>\n\n\n这个方法需要返回String类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, WHEN(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nLiteFlow从v2.9.0开始支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    THEN(\n        a,\n        SWITCH(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class GSwitchCmp extends NodeSwitchComponent {\n\n\t@Override\n\tpublic String processSwitch() throws Exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetId是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetId是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetId是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetId是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetId是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetId是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetId是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetId是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 表达式tag的选择\n\nLiteFlow从v2.10.2开始，支持了表达式的tag选择，比如：\n\n<chain name="chain1">\n    SWITCH(a).to(b, WHEN(c,d).tag("w1"));\n</chain>\n\n\na中返回tag:w1或者:w1就能选择到后面的表达式。\n\n\n# 链路tag的选择\n\nLiteFlow从v2.10.3开始，支持了链路tag的选择，比如：\n\n<chain name="chain1">\n    SWITCH(a).to(b, sub.tag("w1"));\n</chain>\n\n<chain name="sub">\n    THEN(c,d);\n</chain>\n\n\n事实上，a无论返回sub还是tag:w1都能选择到后面的链路。',normalizedContent:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于switch关键字中。\n\n关于switch表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承nodeswitchcomponent。\n\n需要实现方法processswitch方法。\n\n\n# 根据nodeid进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, c);\n</chain>\n\n\n这个方法需要返回string类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, when(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nliteflow从v2.9.0开始支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    then(\n        a,\n        switch(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class gswitchcmp extends nodeswitchcomponent {\n\n\t@override\n\tpublic string processswitch() throws exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetid是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetid是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetid是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetid是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetid是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetid是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetid是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetid是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 表达式tag的选择\n\nliteflow从v2.10.2开始，支持了表达式的tag选择，比如：\n\n<chain name="chain1">\n    switch(a).to(b, when(c,d).tag("w1"));\n</chain>\n\n\na中返回tag:w1或者:w1就能选择到后面的表达式。\n\n\n# 链路tag的选择\n\nliteflow从v2.10.3开始，支持了链路tag的选择，比如：\n\n<chain name="chain1">\n    switch(a).to(b, sub.tag("w1"));\n</chain>\n\n<chain name="sub">\n    then(c,d);\n</chain>\n\n\n事实上，a无论返回sub还是tag:w1都能选择到后面的链路。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📎普通组件",frontmatter:{title:"📎普通组件",date:"2022-06-29T17:53:36.000Z",permalink:"/pages/v2.10.X/8486fb/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/010.%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/055.🔗常规组件/010.普通组件.md",key:"v-c254747e",path:"/pages/v2.10.X/8486fb/",headers:[{level:2,title:"可以覆盖的方法",slug:"可以覆盖的方法",normalizedTitle:"可以覆盖的方法",charIndex:335},{level:3,title:"isAccess",slug:"isaccess",normalizedTitle:"isaccess",charIndex:369},{level:3,title:"isContinueOnError",slug:"iscontinueonerror",normalizedTitle:"iscontinueonerror",charIndex:422},{level:3,title:"isEnd",slug:"isend",normalizedTitle:"isend",charIndex:472},{level:3,title:"beforeProcess和afterProcess",slug:"beforeprocess和afterprocess",normalizedTitle:"beforeprocess和afterprocess",charIndex:667},{level:3,title:"onSuccess和onError",slug:"onsuccess和onerror",normalizedTitle:"onsuccess和onerror",charIndex:797},{level:2,title:"This关键字可以调用的方法",slug:"this关键字可以调用的方法",normalizedTitle:"this关键字可以调用的方法",charIndex:845},{level:3,title:"获取上下文",slug:"获取上下文",normalizedTitle:"获取上下文",charIndex:864},{level:3,title:"getNodeId",slug:"getnodeid",normalizedTitle:"getnodeid",charIndex:942},{level:3,title:"getName",slug:"getname",normalizedTitle:"getname",charIndex:965},{level:3,title:"getChainName",slug:"getchainname",normalizedTitle:"getchainname",charIndex:986},{level:3,title:"getRequestData",slug:"getrequestdata",normalizedTitle:"getrequestdata",charIndex:1017},{level:3,title:"setIsEnd",slug:"setisend",normalizedTitle:"setisend",charIndex:613},{level:3,title:"getTag",slug:"gettag",normalizedTitle:"gettag",charIndex:1248},{level:3,title:"invoke和invoke2Response",slug:"invoke和invoke2response",normalizedTitle:"invoke和invoke2response",charIndex:1292},{level:2,title:"@LiteflowComponent",slug:"liteflowcomponent",normalizedTitle:"@liteflowcomponent",charIndex:58}],headersStr:"可以覆盖的方法 isAccess isContinueOnError isEnd beforeProcess和afterProcess onSuccess和onError This关键字可以调用的方法 获取上下文 getNodeId getName getChainName getRequestData setIsEnd getTag invoke和invoke2Response @LiteflowComponent",content:'普通组件节点需要继承NodeComponent，可用于THEN和WHEN关键字中。\n\n需要实现process方法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n提示\n\n@LiteflowComponent继承自@Component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@LiteflowComponent的参数a，就是你在写EL规则时需要用到组件ID。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isAccess\n\n推荐实现isAccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# isContinueOnError\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isEnd\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# beforeProcess和afterProcess\n\n流程的前置和后置处理器，其中前置处理器，在isAccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onSuccess和onError\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# This关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getContextBean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getNodeId\n\n获取组件ID。\n\n\n# getName\n\n获取组件别名。\n\n\n# getChainName\n\n获取当前执行的流程名称。\n\n\n# getRequestData\n\n获取流程的初始参数。\n\n\n# setIsEnd\n\n表示是否立即结束整个流程 ，用法为this.setIsEnd(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# getTag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2Response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @LiteflowComponent\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'普通组件节点需要继承nodecomponent，可用于then和when关键字中。\n\n需要实现process方法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n提示\n\n@liteflowcomponent继承自@component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@liteflowcomponent的参数a，就是你在写el规则时需要用到组件id。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isaccess\n\n推荐实现isaccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# iscontinueonerror\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isend\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# beforeprocess和afterprocess\n\n流程的前置和后置处理器，其中前置处理器，在isaccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onsuccess和onerror\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# this关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getcontextbean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getnodeid\n\n获取组件id。\n\n\n# getname\n\n获取组件别名。\n\n\n# getchainname\n\n获取当前执行的流程名称。\n\n\n# getrequestdata\n\n获取流程的初始参数。\n\n\n# setisend\n\n表示是否立即结束整个流程 ，用法为this.setisend(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# gettag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @liteflowcomponent\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📙自定义配置源",frontmatter:{title:"📙自定义配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.10.X/25f2c0/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/070.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"09.v2.10.X文档/050.🗂规则文件/070.自定义配置源.md",key:"v-020f2d3f",path:"/pages/v2.10.X/25f2c0/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:616}],headersStr:"说明 配置路径",content:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。LiteFlow支持自定义的配置源的扩展点。\n\nXML形式的规则文件请继承ClassXmlFlowELParser\n\nJSON形式的规则文件请继承ClassJsonFlowELParser\n\nYML形式的规则文件请继承ClassYmlFlowELParser\n\n以下以XML形式的自定义源配置类举例：\n\npublic class TestCustomParser extends ClassXmlFlowELParser {\n\n\t@Override\n\tpublic String parseCustom() {\n\t\tSystem.out.println("进入自定义parser");\n\t\tString xmlContent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlContent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@Autowired和@Resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n\n关于el_xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以EL的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',normalizedContent:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。liteflow支持自定义的配置源的扩展点。\n\nxml形式的规则文件请继承classxmlflowelparser\n\njson形式的规则文件请继承classjsonflowelparser\n\nyml形式的规则文件请继承classymlflowelparser\n\n以下以xml形式的自定义源配置类举例：\n\npublic class testcustomparser extends classxmlflowelparser {\n\n\t@override\n\tpublic string parsecustom() {\n\t\tsystem.out.println("进入自定义parser");\n\t\tstring xmlcontent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlcontent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@autowired和@resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n\n关于el_xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以el的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📌条件组件",frontmatter:{title:"📌条件组件",date:"2022-08-26T12:25:04.000Z",permalink:"/pages/v2.10.X/cb0b59/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/030.%E6%9D%A1%E4%BB%B6%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/055.🔗常规组件/030.条件组件.md",key:"v-21cafeb6",path:"/pages/v2.10.X/cb0b59/",headersStr:null,content:'LiteFlow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为IF组件，返回是一个true/false。可用于IF...ELIF...ELSE等关键字。\n\n关于IF...ELIF...ELSE表达式的用法，可以参考条件编排这一章。\n\n比如一个IF三元表达式，如下所示，x就是IF组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承NodeIfComponent：\n\n@Component("x")\npublic class XCmp extends NodeIfComponent {\n\t@Override\n\tpublic boolean processIf() throws Exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为if组件，返回是一个true/false。可用于if...elif...else等关键字。\n\n关于if...elif...else表达式的用法，可以参考条件编排这一章。\n\n比如一个if三元表达式，如下所示，x就是if组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承nodeifcomponent：\n\n@component("x")\npublic class xcmp extends nodeifcomponent {\n\t@override\n\tpublic boolean processif() throws exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬次数循环组件",frontmatter:{title:"🧬次数循环组件",date:"2022-10-06T15:04:44.000Z",permalink:"/pages/v2.10.X/5f971f/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/040.%E6%AC%A1%E6%95%B0%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/055.🔗常规组件/040.次数循环组件.md",key:"v-bd527bfe",path:"/pages/v2.10.X/5f971f/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"循环下标获取",slug:"循环下标获取",normalizedTitle:"循环下标获取",charIndex:446}],headersStr:"用法 循环下标获取",content:'# 用法\n\nLiteFlow从v2.9.0开始，提供了次数循环组件。返回的是一个int值的循环次数。 主要用于FOR...DO...表达式。\n\n关于FOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\nf节点的定义，需要继承NodeForComponent，需要实现processFor方法：\n\n@LiteflowComponent("f")\npublic class FCmp extends NodeForComponent {\n    @Override\n    public int processFor() throws Exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字FOR...DO...中DO里面的任意java组件都可以通过this.getLoopIndex()来获得下标。\n\n在脚本中通过_meta.loopIndex来获取。',normalizedContent:'# 用法\n\nliteflow从v2.9.0开始，提供了次数循环组件。返回的是一个int值的循环次数。 主要用于for...do...表达式。\n\n关于for...do...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\nf节点的定义，需要继承nodeforcomponent，需要实现processfor方法：\n\n@liteflowcomponent("f")\npublic class fcmp extends nodeforcomponent {\n    @override\n    public int processfor() throws exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字for...do...中do里面的任意java组件都可以通过this.getloopindex()来获得下标。\n\n在脚本中通过_meta.loopindex来获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⛓条件循环组件",frontmatter:{title:"⛓条件循环组件",date:"2022-10-06T17:11:06.000Z",permalink:"/pages/v2.10.X/e6995e/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/050.%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/055.🔗常规组件/050.条件循环组件.md",key:"v-da7a4520",path:"/pages/v2.10.X/e6995e/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"循环下标获取",slug:"循环下标获取",normalizedTitle:"循环下标获取",charIndex:446}],headersStr:"用法 循环下标获取",content:'# 用法\n\nLiteFlow从v2.9.0开始，支持了条件循环组件，主要用于WHILE...DO...表达式。\n\n关于WHILE...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行条件循环操作，可以如下定义：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b));\n</chain>\n\n\nw节点的定义，需要继承NodeWhileComponent，需要实现processWhile方法：\n\n@LiteflowComponent("w")\npublic class WCmp extends NodeWhileComponent {\n    @Override\n    public boolean processWhile() throws Exception {\n        //这里根据业务去返回while的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字WHILE...DO...中DO里面的任意节点都可以通过this.getLoopIndex()来获得下标。\n\n在脚本中通过_meta.loopIndex来获取。',normalizedContent:'# 用法\n\nliteflow从v2.9.0开始，支持了条件循环组件，主要用于while...do...表达式。\n\n关于while...do...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行条件循环操作，可以如下定义：\n\n<chain name="chain1">\n    while(w).do(then(a, b));\n</chain>\n\n\nw节点的定义，需要继承nodewhilecomponent，需要实现processwhile方法：\n\n@liteflowcomponent("w")\npublic class wcmp extends nodewhilecomponent {\n    @override\n    public boolean processwhile() throws exception {\n        //这里根据业务去返回while的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字while...do...中do里面的任意节点都可以通过this.getloopindex()来获得下标。\n\n在脚本中通过_meta.loopindex来获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧿退出循环组件",frontmatter:{title:"🧿退出循环组件",date:"2022-10-06T17:11:27.000Z",permalink:"/pages/v2.10.X/c078cd/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/060.%E9%80%80%E5%87%BA%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/055.🔗常规组件/060.退出循环组件.md",key:"v-59e3eeba",path:"/pages/v2.10.X/c078cd/",headersStr:null,content:'LiteFlow从v2.9.0开始，提供了退出循环组件。返回的是一个布尔值的循环次数。 主要用于FOR...DO...BREAK,WHILE...DO...BREAK,ITERATOR...DO...BREAK表达式。\n\n关于这两种表达式的用法，可以参考循环编排这一章。\n\n比如要对某一个循环操作进行退出的编排，可以如此定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n或者\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\nc节点的定义，需要继承NodeBreakComponent，需要实现processBreak方法：\n\n@LiteflowComponent("c")\npublic class CCmp extends NodeBreakComponent {\n    @Override\n    public boolean processBreak() throws Exception {\n        //这里根据业务去返回break的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'liteflow从v2.9.0开始，提供了退出循环组件。返回的是一个布尔值的循环次数。 主要用于for...do...break,while...do...break,iterator...do...break表达式。\n\n关于这两种表达式的用法，可以参考循环编排这一章。\n\n比如要对某一个循环操作进行退出的编排，可以如此定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b)).break(c);\n</chain>\n\n\n或者\n\n<chain name="chain1">\n    while(w).do(then(a, b)).break(c);\n</chain>\n\n\nc节点的定义，需要继承nodebreakcomponent，需要实现processbreak方法：\n\n@liteflowcomponent("c")\npublic class ccmp extends nodebreakcomponent {\n    @override\n    public boolean processbreak() throws exception {\n        //这里根据业务去返回break的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⌛️迭代循环组件",frontmatter:{title:"⌛️迭代循环组件",date:"2023-02-09T10:40:52.000Z",permalink:"/pages/v2.10.X/64262b/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/055.%E8%BF%AD%E4%BB%A3%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/055.🔗常规组件/055.迭代循环组件.md",key:"v-edcedb12",path:"/pages/v2.10.X/64262b/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"迭代对象的获取",slug:"迭代对象的获取",normalizedTitle:"迭代对象的获取",charIndex:559}],headersStr:"用法 迭代对象的获取",content:'# 用法\n\nLiteFlow从v2.9.7开始，支持了迭代循环组件，相当于Java语言的Iterator关键字，主要用于ITERATOR...DO...表达式。\n\n关于ITERATOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\nx节点的定义，需要继承NodeIteratorComponent，需要实现processIterator方法：\n\n@LiteflowComponent("x")\npublic class XCmp extends NodeIteratorComponent {\n    @Override\n    public Iterator<?> processIterator() throws Exception {\n        List<String> list = ListUtil.toList("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 迭代对象的获取\n\n关键字ITERATOR...DO...中DO里面所有的节点都可以通过this.getCurrLoopObj()获得迭代循环的当前对象。\n\n在脚本中通过_meta.loopObject来获取。',normalizedContent:'# 用法\n\nliteflow从v2.9.7开始，支持了迭代循环组件，相当于java语言的iterator关键字，主要用于iterator...do...表达式。\n\n关于iterator...do...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\nx节点的定义，需要继承nodeiteratorcomponent，需要实现processiterator方法：\n\n@liteflowcomponent("x")\npublic class xcmp extends nodeiteratorcomponent {\n    @override\n    public iterator<?> processiterator() throws exception {\n        list<string> list = listutil.tolist("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 迭代对象的获取\n\n关键字iterator...do...中do里面所有的节点都可以通过this.getcurrloopobj()获得迭代循环的当前对象。\n\n在脚本中通过_meta.loopobject来获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-29T15:30:16.000Z",permalink:"/pages/v2.10.X/16eca9/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/010.%E8%AF%B4%E6%98%8E.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/010.说明.md",key:"v-62a234fd",path:"/pages/v2.10.X/16eca9/",headersStr:null,content:"在本章，将说明如何撰写规则表达式。\n\nLiteFlow在2.8.X版本中设计了非常强大的规则表达式。一切复杂的流程在LiteFlow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",normalizedContent:"在本章，将说明如何撰写规则表达式。\n\nliteflow在2.8.x版本中设计了非常强大的规则表达式。一切复杂的流程在liteflow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎋并行编排",frontmatter:{title:"🎋并行编排",date:"2022-06-29T16:46:16.000Z",permalink:"/pages/v2.10.X/b3446a/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/030.%E5%B9%B6%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/030.并行编排.md",key:"v-c16515b8",path:"/pages/v2.10.X/b3446a/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:2},{level:2,title:"和串行嵌套起来(一)",slug:"和串行嵌套起来-一",normalizedTitle:"和串行嵌套起来(一)",charIndex:113},{level:2,title:"和串行嵌套起来(二)",slug:"和串行嵌套起来-二",normalizedTitle:"和串行嵌套起来(二)",charIndex:288},{level:2,title:"忽略错误",slug:"忽略错误",normalizedTitle:"忽略错误",charIndex:431},{level:2,title:"任一节点先执行完则忽略其他",slug:"任一节点先执行完则忽略其他",normalizedTitle:"任一节点先执行完则忽略其他",charIndex:645},{level:2,title:"关于组的概念",slug:"关于组的概念",normalizedTitle:"关于组的概念",charIndex:891}],headersStr:"最基本的例子 和串行嵌套起来(一) 和串行嵌套起来(二) 忽略错误 任一节点先执行完则忽略其他 关于组的概念",content:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用WHEN关键字，需要注意的是，WHEN必须大写。\n\n<chain name="chain1">\n    WHEN(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把THEN和WHEN结合起来用，看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nWHEN关键字提供了一个子关键字ignoreError(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).ignoreError(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nWHEN关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.X版本中，我们去除了组的概念。\n\n用EL表达式，其实你写2个不同的WHEN就是2个组。比如：\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b),\n        WHEN(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',normalizedContent:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用when关键字，需要注意的是，when必须大写。\n\n<chain name="chain1">\n    when(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把then和when结合起来用，看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nwhen关键字提供了一个子关键字ignoreerror(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).ignoreerror(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nwhen关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.x版本中，我们去除了组的概念。\n\n用el表达式，其实你写2个不同的when就是2个组。比如：\n\n<chain name="chain1">\n    then(\n        when(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    then(\n        when(a, b),\n        when(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌴串行编排",frontmatter:{title:"🌴串行编排",date:"2022-06-29T15:28:24.000Z",permalink:"/pages/v2.10.X/a590ee/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/020.%E4%B8%B2%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/020.串行编排.md",key:"v-069fc664",path:"/pages/v2.10.X/a590ee/",headersStr:null,content:'如果你要依次执行a,b,c,d四个组件，你可以用THEN关键字，需要注意的是，THEN必须大写。\n\n<chain name="chain1">\n    THEN(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    THEN(a, b, THEN(c, d));\n</chain>\n\n\n图示',normalizedContent:'如果你要依次执行a,b,c,d四个组件，你可以用then关键字，需要注意的是，then必须大写。\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    then(a, b, then(c, d));\n</chain>\n\n\n图示',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵条件编排",frontmatter:{title:"🌵条件编排",date:"2022-08-26T14:13:55.000Z",permalink:"/pages/v2.10.X/e76999/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/045.%E6%9D%A1%E4%BB%B6%E7%BC%96%E6%8E%92.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/045.条件编排.md",key:"v-2027f4d7",path:"/pages/v2.10.X/e76999/",headers:[{level:2,title:"IF的二元表达式",slug:"if的二元表达式",normalizedTitle:"if的二元表达式",charIndex:206},{level:2,title:"IF的三元表达式",slug:"if的三元表达式",normalizedTitle:"if的三元表达式",charIndex:363},{level:2,title:"ELSE表达式",slug:"else表达式",normalizedTitle:"else表达式",charIndex:529},{level:2,title:"ELIF表达式",slug:"elif表达式",normalizedTitle:"elif表达式",charIndex:707}],headersStr:"IF的二元表达式 IF的三元表达式 ELSE表达式 ELIF表达式",content:'LiteFlow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在LiteFlow EL语法中有一些不一样的用法。\n\n以下IF和ELIF的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# IF的二元表达式\n\n我们先来看IF关键字的二元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# IF的三元表达式\n\n我们接下来再来看IF关键字的三元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# ELSE表达式\n\nLiteFlow也提供了ELSE表达式，IF的二元表达式+ELSE表达式等同于IF三元表达式，比如：\n\n<chain name="chain1">\n    IF(x, a).ELSE(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n\n# ELIF表达式\n\nELIF关键字的用法其实和java语言的else if类似，可以跟多个，和IF二元表达式参数一样，一般最后还会跟个ELSE，用于多重条件的判断：\n\n<chain name="chain1">\n    IF(x1, a).ELIF(x2, b).ELIF(x3, c).ELIF(x4, d).ELSE(THEN(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有IF的二元表达式后面才能跟ELIF，如果IF三元表达式后面跟ELIF，最后一个表达式会被ELIF的表达式覆盖，就比如：\n\n<chain name="chain1">\n    IF(x1, a, b).ELIF(x2, c).ELSE(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实IF三元表达式已经能表达一切的可能了，有多重条件也可以不用ELIF，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    IF(\n        x1,\n        a, \n        IF(\n            x2,\n            b,\n            IF(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用ELIF来代替。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在liteflow el语法中有一些不一样的用法。\n\n以下if和elif的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# if的二元表达式\n\n我们先来看if关键字的二元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# if的三元表达式\n\n我们接下来再来看if关键字的三元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# else表达式\n\nliteflow也提供了else表达式，if的二元表达式+else表达式等同于if三元表达式，比如：\n\n<chain name="chain1">\n    if(x, a).else(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n\n# elif表达式\n\nelif关键字的用法其实和java语言的else if类似，可以跟多个，和if二元表达式参数一样，一般最后还会跟个else，用于多重条件的判断：\n\n<chain name="chain1">\n    if(x1, a).elif(x2, b).elif(x3, c).elif(x4, d).else(then(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有if的二元表达式后面才能跟elif，如果if三元表达式后面跟elif，最后一个表达式会被elif的表达式覆盖，就比如：\n\n<chain name="chain1">\n    if(x1, a, b).elif(x2, c).else(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实if三元表达式已经能表达一切的可能了，有多重条件也可以不用elif，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    if(\n        x1,\n        a, \n        if(\n            x2,\n            b,\n            if(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用elif来代替。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌾选择编排",frontmatter:{title:"🌾选择编排",date:"2022-06-29T17:15:38.000Z",permalink:"/pages/v2.10.X/d90483/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/040.%E9%80%89%E6%8B%A9%E7%BC%96%E6%8E%92.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/040.选择编排.md",key:"v-6777b86d",path:"/pages/v2.10.X/d90483/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:164},{level:2,title:"DEFAULT关键字",slug:"default关键字",normalizedTitle:"default关键字",charIndex:273},{level:2,title:"和THEN,WHEN嵌套起来",slug:"和then-when嵌套起来",normalizedTitle:"和then,when嵌套起来",charIndex:487},{level:2,title:"选择编排中的id语法",slug:"选择编排中的id语法",normalizedTitle:"选择编排中的id语法",charIndex:677},{level:2,title:"选择编排中的tag语法",slug:"选择编排中的tag语法",normalizedTitle:"选择编排中的tag语法",charIndex:1271}],headersStr:"最基本的例子 DEFAULT关键字 和THEN,WHEN嵌套起来 选择编排中的id语法 选择编排中的tag语法",content:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入A流程，如果返回结果2，则进入B流程，如果返回结果3，则进入C流程。在有些流程定义中也被定义为排他网关。\n\n这个通过LiteFLow的表达式也非常容易实现，你可以用SWITCH...TO的组合关键字，注意的是SWITCH必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# DEFAULT关键字\n\nLiteFlow从2.9.5开始，对选择编排新增了一个DEFAULT关键字。用法为SWITCH...TO...DEFAULT。\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(x).TO(a, b, c).DEFAULT(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然DEFAULT里面也可以是一个表达式。\n\n\n# 和THEN,WHEN嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(\n            b,\n            SWITCH(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个SWITCH中套THEN和WHEN的例子。\n\n如果你阅读过选择组件这一章，就应该知道，LiteFlow通过选择组件的返回来确定该选择什么。\n\n那么如果SWITCH中套一个THEN，那么选择组件如果要选择这个THEN应该返回什么呢？\n\nLiteFlow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回t1:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        //do your biz\n        return "t1";\n    }\n}\n\n\n\n# 选择编排中的tag语法\n\n事实上，除了给表达式赋值id属性之外，你还可以给表达式赋值tag属性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).tag("t1")\n        ),\n        f\n    );\n</chain>\n\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        return "tag:t1";\n        //以下这种也是可以的\n        return ":t1";\n    }\n}\n\n\n选择组件还有其他返回形式，详情请见选择组件这一章。',normalizedContent:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入a流程，如果返回结果2，则进入b流程，如果返回结果3，则进入c流程。在有些流程定义中也被定义为排他网关。\n\n这个通过liteflow的表达式也非常容易实现，你可以用switch...to的组合关键字，注意的是switch必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    switch(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# default关键字\n\nliteflow从2.9.5开始，对选择编排新增了一个default关键字。用法为switch...to...default。\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(x).to(a, b, c).default(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然default里面也可以是一个表达式。\n\n\n# 和then,when嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            b,\n            switch(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个switch中套then和when的例子。\n\n如果你阅读过选择组件这一章，就应该知道，liteflow通过选择组件的返回来确定该选择什么。\n\n那么如果switch中套一个then，那么选择组件如果要选择这个then应该返回什么呢？\n\nliteflow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回t1:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        //do your biz\n        return "t1";\n    }\n}\n\n\n\n# 选择编排中的tag语法\n\n事实上，除了给表达式赋值id属性之外，你还可以给表达式赋值tag属性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).tag("t1")\n        ),\n        f\n    );\n</chain>\n\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        return "tag:t1";\n        //以下这种也是可以的\n        return ":t1";\n    }\n}\n\n\n选择组件还有其他返回形式，详情请见选择组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌳循环编排",frontmatter:{title:"🌳循环编排",date:"2022-10-06T15:13:06.000Z",permalink:"/pages/v2.10.X/fbf715/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/046.%E5%BE%AA%E7%8E%AF%E7%BC%96%E6%8E%92.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/046.循环编排.md",key:"v-0a775c97",path:"/pages/v2.10.X/fbf715/",headers:[{level:2,title:"FOR循环",slug:"for循环",normalizedTitle:"for循环",charIndex:36},{level:2,title:"WHILE循环",slug:"while循环",normalizedTitle:"while循环",charIndex:310},{level:2,title:"ITERATOR迭代循环",slug:"iterator迭代循环",normalizedTitle:"iterator迭代循环",charIndex:463},{level:2,title:"BREAK",slug:"break",normalizedTitle:"break",charIndex:653}],headersStr:"FOR循环 WHILE循环 ITERATOR迭代循环 BREAK",content:'LiteFlow从v2.9.0开始，提供了循环编排表达式组合。\n\n\n# FOR循环\n\nFOR循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    FOR(5).DO(THEN(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# WHILE循环\n\nWHILE循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b));\n</chain>\n\n\n其中w这个节点需要为条件循环组件，返回一个布尔值，为true则继续循环，如何定义请参照条件循环组件。\n\n\n# ITERATOR迭代循环\n\nITERATOR迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# BREAK\n\nLiteFlow同样也支持BREAK语法，代表退出循环。\n\nBREAK关键字可以跟在FOR和WHILE后面，通常用法为：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n其中c这个节点需要为退出循环组件，返回一个布尔值，为true则退出循环。如何定义请参考退出循环组件。\n\n提示\n\nBREAK关键字是在每次循环的末尾进行判断的。',normalizedContent:'liteflow从v2.9.0开始，提供了循环编排表达式组合。\n\n\n# for循环\n\nfor循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    for(5).do(then(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# while循环\n\nwhile循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    while(w).do(then(a, b));\n</chain>\n\n\n其中w这个节点需要为条件循环组件，返回一个布尔值，为true则继续循环，如何定义请参照条件循环组件。\n\n\n# iterator迭代循环\n\niterator迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# break\n\nliteflow同样也支持break语法，代表退出循环。\n\nbreak关键字可以跟在for和while后面，通常用法为：\n\n<chain name="chain1">\n    for(f).do(then(a, b)).break(c);\n</chain>\n\n\n<chain name="chain1">\n    while(w).do(then(a, b)).break(c);\n</chain>\n\n\n其中c这个节点需要为退出循环组件，返回一个布尔值，为true则退出循环。如何定义请参考退出循环组件。\n\n提示\n\nbreak关键字是在每次循环的末尾进行判断的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎃捕获异常表达式",frontmatter:{title:"🎃捕获异常表达式",date:"2023-03-16T22:27:28.000Z",permalink:"/pages/v2.10.X/f53b51/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/047.%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/047.捕获异常表达式.md",key:"v-4a6ef0ef",path:"/pages/v2.10.X/f53b51/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:42},{level:2,title:"搭配循环使用",slug:"搭配循环使用",normalizedTitle:"搭配循环使用",charIndex:559}],headersStr:"基本用法 搭配循环使用",content:'LiteFlow从2.10.0开始，EL表达式语法中新增了捕获异常的表达式\n\n\n# 基本用法\n\n具体用法为CATCH...DO:\n\n<chain name="chain1">\n    CATCH(\n        THEN(a,b)\n    ).DO(c)\n</chain>\n\n\n上述语法表示，如果a组件出现异常并抛出，则不会执行b组件，会直接执行c组件。\n\n在c组件中，可以通过this.getSlot().getException()来获取异常。\n\n同时，当用了CATCH表达式之后，即便在CATCH包裹的组件有异常抛出，整个流程返回的LiteflowResponse中的isSuccess方法仍然为true，getCause中也没有任何的Exception。如果你写过java程序，应该会对这样的机制很容易理解。因为异常已经被你自己处理掉了。\n\n同时CATCH也可以不加DO，比如：\n\n<chain name="chain1">\n    THEN(\n        CATCH(\n            THEN(a,b)\n        ),\n        c\n    )\n</chain>\n\n\n上面这段表达式不管a,b有没有抛出异常，最终总会执行c。如果a抛出异常，那么最终执行链路就为a==>c\n\n\n# 搭配循环使用\n\nCATCH表达式和循环表达式搭配起来使用，还能做出java中continue的效果，比如：\n\n<chain name="chain1">\n    FOR(x).DO(\n        CATCH(\n            THEN(a,b,c)\n        )\n    )\n</chain>\n\n\n如果你希望在b组件中达成某一个条件就不执行c，继续循环，那么你可以借助CATCH语法，只要在b组件中往外抛一个异常即可。\n\n我相信这种用法对于写程序的同学来说，应该不用过多解释。',normalizedContent:'liteflow从2.10.0开始，el表达式语法中新增了捕获异常的表达式\n\n\n# 基本用法\n\n具体用法为catch...do:\n\n<chain name="chain1">\n    catch(\n        then(a,b)\n    ).do(c)\n</chain>\n\n\n上述语法表示，如果a组件出现异常并抛出，则不会执行b组件，会直接执行c组件。\n\n在c组件中，可以通过this.getslot().getexception()来获取异常。\n\n同时，当用了catch表达式之后，即便在catch包裹的组件有异常抛出，整个流程返回的liteflowresponse中的issuccess方法仍然为true，getcause中也没有任何的exception。如果你写过java程序，应该会对这样的机制很容易理解。因为异常已经被你自己处理掉了。\n\n同时catch也可以不加do，比如：\n\n<chain name="chain1">\n    then(\n        catch(\n            then(a,b)\n        ),\n        c\n    )\n</chain>\n\n\n上面这段表达式不管a,b有没有抛出异常，最终总会执行c。如果a抛出异常，那么最终执行链路就为a==>c\n\n\n# 搭配循环使用\n\ncatch表达式和循环表达式搭配起来使用，还能做出java中continue的效果，比如：\n\n<chain name="chain1">\n    for(x).do(\n        catch(\n            then(a,b,c)\n        )\n    )\n</chain>\n\n\n如果你希望在b组件中达成某一个条件就不执行c，继续循环，那么你可以借助catch语法，只要在b组件中往外抛一个异常即可。\n\n我相信这种用法对于写程序的同学来说，应该不用过多解释。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄与或非表达式",frontmatter:{title:"🍄与或非表达式",date:"2023-04-11T21:28:38.000Z",permalink:"/pages/v2.10.X/a8b344/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/048.%E4%B8%8E%E6%88%96%E9%9D%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/048.与或非表达式.md",key:"v-4812c664",path:"/pages/v2.10.X/a8b344/",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:2},{level:2,title:"可以用的地方",slug:"可以用的地方",normalizedTitle:"可以用的地方",charIndex:669},{level:2,title:"复杂嵌套",slug:"复杂嵌套",normalizedTitle:"复杂嵌套",charIndex:799}],headersStr:"基本用法 可以用的地方 复杂嵌套",content:'# 基本用法\n\nLiteFlow在v2.10.2版本带来了与或非表达式，就是AND，OR，NOT表达式。\n\n通过之前的几小章，应该可以知道，有些编排需要返回一个布尔值，比如条件编排：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n其中x组件应该为条件组件，返回的是一个布尔值。\n\n但是如果这个布尔值并不是由一个组件决定的，而是由多个组件决定的呢。这里就可以用与或非表达式了。\n\n假设这里的条件是要由x和y共同决定，利用与或非表达式中的AND:\n\n<chain name="chain1">\n    IF(AND(x,y), a, b);\n</chain>\n\n\n上述AND的意思是，如果x和y都为true，则为真，会执行组件a，如果x和y有一个为false，则执行b。\n\nAND里面可以有多个布尔组件或者与或非表达式。\n\n同理，这里也可以用OR来表示：\n\n<chain name="chain1">\n    IF(OR(x,y), a, b);\n</chain>\n\n\n上述OR的意思是，只要x和y中的一个为true，则为真，否则为假。\n\nOR里面可以有多个组件或者与或非表达式。\n\nNOT就是非的意思，比如：\n\n<chain name="chain1">\n    IF(NOT(x), a, b);\n</chain>\n\n\n如果x返回true，则经过非运算后，为假，执行b，如果x返回false，则经过非运算后，为真，执行a。\n\nNOT里面只能有一个布尔组件或者与或非表达式。\n\n\n# 可以用的地方\n\n在LiteFlow所有EL表达式中，返回布尔值的地方都可以用与或非表达式，除了上述的IF外，还可以用在WHILE，BREAK表达式中。\n\n提示\n\n如果你在THEN表达式中用与或非表达式，会报错的，因为普通组件并非是一个布尔值的的返回。\n\n\n# 复杂嵌套\n\n与或非表达式也可以进行多级嵌套，比如：\n\n<chain name="chain1">\n    IF(\n        OR(\n            AND(x1, x3), NOT(OR(x3, x4))\n        ),\n        a, b\n    );\n</chain>\n\n\n类似于这种，其实概念和java的与或非都一样，无非就是换了种写法。',normalizedContent:'# 基本用法\n\nliteflow在v2.10.2版本带来了与或非表达式，就是and，or，not表达式。\n\n通过之前的几小章，应该可以知道，有些编排需要返回一个布尔值，比如条件编排：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n其中x组件应该为条件组件，返回的是一个布尔值。\n\n但是如果这个布尔值并不是由一个组件决定的，而是由多个组件决定的呢。这里就可以用与或非表达式了。\n\n假设这里的条件是要由x和y共同决定，利用与或非表达式中的and:\n\n<chain name="chain1">\n    if(and(x,y), a, b);\n</chain>\n\n\n上述and的意思是，如果x和y都为true，则为真，会执行组件a，如果x和y有一个为false，则执行b。\n\nand里面可以有多个布尔组件或者与或非表达式。\n\n同理，这里也可以用or来表示：\n\n<chain name="chain1">\n    if(or(x,y), a, b);\n</chain>\n\n\n上述or的意思是，只要x和y中的一个为true，则为真，否则为假。\n\nor里面可以有多个组件或者与或非表达式。\n\nnot就是非的意思，比如：\n\n<chain name="chain1">\n    if(not(x), a, b);\n</chain>\n\n\n如果x返回true，则经过非运算后，为假，执行b，如果x返回false，则经过非运算后，为真，执行a。\n\nnot里面只能有一个布尔组件或者与或非表达式。\n\n\n# 可以用的地方\n\n在liteflow所有el表达式中，返回布尔值的地方都可以用与或非表达式，除了上述的if外，还可以用在while，break表达式中。\n\n提示\n\n如果你在then表达式中用与或非表达式，会报错的，因为普通组件并非是一个布尔值的的返回。\n\n\n# 复杂嵌套\n\n与或非表达式也可以进行多级嵌套，比如：\n\n<chain name="chain1">\n    if(\n        or(\n            and(x1, x3), not(or(x3, x4))\n        ),\n        a, b\n    );\n</chain>\n\n\n类似于这种，其实概念和java的与或非都一样，无非就是换了种写法。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍂使用子变量",frontmatter:{title:"🍂使用子变量",date:"2022-07-01T19:01:33.000Z",permalink:"/pages/v2.10.X/71ff49/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/060.%E4%BD%BF%E7%94%A8%E5%AD%90%E5%8F%98%E9%87%8F.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/060.使用子变量.md",key:"v-55515dc4",path:"/pages/v2.10.X/71ff49/",headersStr:null,content:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为LiteFlow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = THEN(C, WHEN(J, K));\n    w1 = WHEN(Q, THEN(P, R)).id("w01");\n    t2 = THEN(H, I);\n    \n    THEN(\n        A, B,\n        WHEN(t1, D, t2),\n        SWITCH(X).to(M, N, w1),\n        Z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',normalizedContent:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为liteflow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = then(c, when(j, k));\n    w1 = when(q, then(p, r)).id("w01");\n    t2 = then(h, i);\n    \n    then(\n        a, b,\n        when(t1, d, t2),\n        switch(x).to(m, n, w1),\n        z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"💐复杂编排例子",frontmatter:{title:"💐复杂编排例子",date:"2022-06-29T21:29:06.000Z",permalink:"/pages/v2.10.X/5156b3/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/070.%E5%A4%8D%E6%9D%82%E7%BC%96%E6%8E%92%E4%BE%8B%E5%AD%90.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/070.复杂编排例子.md",key:"v-4059e604",path:"/pages/v2.10.X/5156b3/",headers:[{level:2,title:"复杂例子一",slug:"复杂例子一",normalizedTitle:"复杂例子一",charIndex:85},{level:2,title:"复杂例子二",slug:"复杂例子二",normalizedTitle:"复杂例子二",charIndex:842},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1907}],headersStr:"复杂例子一 复杂例子二 总结",content:'经过上面几小章，你是不是已经大致了解了LiteFlow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        WHEN(\n            THEN(B, C),\n            THEN(D, E, F),\n            THEN(\n                SWITCH(G).to(\n                    THEN(H, I, WHEN(J, K)).id("t1"),\n                    THEN(L, M).id("t2")\n                ),\n                N\n            )\n        ),\n        Z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你如果用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = THEN(B, C);\n    item2 = THEN(D, E, F);\n    item3_1 = THEN(H, I, WHEN(J, K)).id("t1");\n    item3_2 = THEN(L, M).id("t2");\n    item3 = THEN(SWITCH(G).to(item3_1, item3_2), N);\n    \n    THEN(\n        A,\n        WHEN(item1, item2, item3),\n        Z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        SWITCH(B).to(\n            THEN(D, E, F).id("t1"),\n            THEN(\n                C,\n                WHEN(\n                    THEN(\n                        SWITCH(G).to(THEN(H, I).id("t2"), J),\n                        K\n                    ),\n                    THEN(L, M)\n                )\n            ).id("t3")\n        ),\n        Z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = THEN(D, E, F).id("t1");\n    \n    item2_1 = THEN(\n        SWITCH(G).to(\n            THEN(H, I).id("t2"),\n            J\n        ),\n        K\n    );\n    \n    item2_2 = THEN(L, M);\n    \n    item2 = THEN(C, WHEN(item2_1, item2_2)).id("t3");\n    \n    THEN(\n        A,\n        SWITCH(B).to(item1, item2),\n        Z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest2\n\n\n# 总结\n\nLiteFlow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',normalizedContent:'经过上面几小章，你是不是已经大致了解了liteflow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            then(b, c),\n            then(d, e, f),\n            then(\n                switch(g).to(\n                    then(h, i, when(j, k)).id("t1"),\n                    then(l, m).id("t2")\n                ),\n                n\n            )\n        ),\n        z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你如果用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = then(b, c);\n    item2 = then(d, e, f);\n    item3_1 = then(h, i, when(j, k)).id("t1");\n    item3_2 = then(l, m).id("t2");\n    item3 = then(switch(g).to(item3_1, item3_2), n);\n    \n    then(\n        a,\n        when(item1, item2, item3),\n        z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            then(d, e, f).id("t1"),\n            then(\n                c,\n                when(\n                    then(\n                        switch(g).to(then(h, i).id("t2"), j),\n                        k\n                    ),\n                    then(l, m)\n                )\n            ).id("t3")\n        ),\n        z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = then(d, e, f).id("t1");\n    \n    item2_1 = then(\n        switch(g).to(\n            then(h, i).id("t2"),\n            j\n        ),\n        k\n    );\n    \n    item2_2 = then(l, m);\n    \n    item2 = then(c, when(item2_1, item2_2)).id("t3");\n    \n    then(\n        a,\n        switch(b).to(item1, item2),\n        z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.complexelspringboottest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.complexelspringboottest2\n\n\n# 总结\n\nliteflow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍁使用子流程",frontmatter:{title:"🍁使用子流程",date:"2022-07-01T19:00:46.000Z",permalink:"/pages/v2.10.X/dc5df7/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/050.%E4%BD%BF%E7%94%A8%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/050.使用子流程.md",key:"v-b3dfd986",path:"/pages/v2.10.X/dc5df7/",headersStr:null,content:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    THEN(\n        A, B,\n        WHEN(\n            THEN(C, WHEN(J, K)),\n            D,\n            THEN(H, I)\n        ),\n        SWITCH(X).to(\n            M,\n            N,\n            WHEN(Q, THEN(P, R)).id("w01")\n        ),\n        Z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nLiteFlow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainChain">\n    THEN(\n    \tA, B,\n    \tWHEN(chain1, D, chain2),\n    \tSWITCH(X).to(M, N, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tTHEN(C, WHEN(J, K));\n</chain>\n\n<chain name="chain2">\n  \tTHEN(H, I);\n</chain>\n\n<chain name="chain3">\n  \tWHEN(Q, THEN(P, R)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',normalizedContent:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    then(\n        a, b,\n        when(\n            then(c, when(j, k)),\n            d,\n            then(h, i)\n        ),\n        switch(x).to(\n            m,\n            n,\n            when(q, then(p, r)).id("w01")\n        ),\n        z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nliteflow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainchain">\n    then(\n    \ta, b,\n    \twhen(chain1, d, chain2),\n    \tswitch(x).to(m, n, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tthen(c, when(j, k));\n</chain>\n\n<chain name="chain2">\n  \tthen(h, i);\n</chain>\n\n<chain name="chain3">\n  \twhen(q, then(p, r)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌻关于分号",frontmatter:{title:"🌻关于分号",date:"2022-07-10T10:58:25.000Z",permalink:"/pages/v2.10.X/af44a6/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/080.%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/080.关于分号.md",key:"v-e65234e8",path:"/pages/v2.10.X/af44a6/",headersStr:null,content:'大家可能注意到了，在EL规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nLiteFlow的EL规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    THEN(\n        a, \n        b, \n        WHEN(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = THEN(a, b);\n    w1 = WHEN(c, d);\n    \n    THEN(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为LiteFlow的IDEA插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',normalizedContent:'大家可能注意到了，在el规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nliteflow的el规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    then(a, b, when(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    then(\n        a, \n        b, \n        when(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = then(a, b);\n    w1 = when(c, d);\n    \n    then(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为liteflow的idea插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌰关于注释",frontmatter:{title:"🌰关于注释",date:"2022-07-19T10:34:21.000Z",permalink:"/pages/v2.10.X/f3dc09/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/090.%E5%85%B3%E4%BA%8E%E6%B3%A8%E9%87%8A.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/090.关于注释.md",key:"v-1ec8f1bf",path:"/pages/v2.10.X/f3dc09/",headersStr:null,content:'在LiteFlow的EL规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    THEN(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        WHEN(c, d)\n    )\n</chain>\n',normalizedContent:'在liteflow的el规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    then(a, b, when(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    then(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        when(c, d)\n    )\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🔆验证规则",frontmatter:{title:"🔆验证规则",date:"2022-12-01T00:10:24.000Z",permalink:"/pages/v2.10.X/395fd0/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/110.%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/110.验证规则.md",key:"v-998e0c66",path:"/pages/v2.10.X/395fd0/",headersStr:null,content:'LiteFlow从v2.9.4版本开始，为规则EL提供了一个验证的方法接口，用于验证EL是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourMethod() {\n    boolean isValid = LiteFlowChainELBuilder.validate("THEN(a, b, h)");\n    ...\n}\n',normalizedContent:'liteflow从v2.9.4版本开始，为规则el提供了一个验证的方法接口，用于验证el是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourmethod() {\n    boolean isvalid = liteflowchainelbuilder.validate("then(a, b, h)");\n    ...\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐚组件名包装",frontmatter:{title:"🐚组件名包装",date:"2022-07-26T23:58:18.000Z",permalink:"/pages/v2.10.X/2df3d9/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/100.%E7%BB%84%E4%BB%B6%E5%90%8D%E5%8C%85%E8%A3%85.html",relativePath:"09.v2.10.X文档/060.🧩EL规则的写法/100.组件名包装.md",key:"v-2f9e7ad0",path:"/pages/v2.10.X/2df3d9/",headersStr:null,content:'LiteFlow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88Cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    THEN(a, b, 88Cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nLiteFlow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    THEN(a, b, node("88Cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',normalizedContent:'liteflow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    then(a, b, 88cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nliteflow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    then(a, b, node("88cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯数据上下文的定义和使用",frontmatter:{title:"🌯数据上下文的定义和使用",date:"2022-07-01T23:49:40.000Z",permalink:"/pages/v2.10.X/501abf/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/020.%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8.html",relativePath:"09.v2.10.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.md",key:"v-728c7bd6",path:"/pages/v2.10.X/501abf/",headers:[{level:2,title:"默认上下文",slug:"默认上下文",normalizedTitle:"默认上下文",charIndex:2},{level:2,title:"自定义上下文",slug:"自定义上下文",normalizedTitle:"自定义上下文",charIndex:224},{level:2,title:"多上下文",slug:"多上下文",normalizedTitle:"多上下文",charIndex:816}],headersStr:"默认上下文 自定义上下文 多上下文",content:'# 默认上下文\n\nLiteFlow提供了一个默认的数据上下文的实现：DefaultContext。这个默认的实现其实里面主要存储数据的容器就是一个Map。\n\n你可以通过DefaultContext中的setData方法放入数据，通过getData方法获得数据。\n\n建议\n\nDefaultContext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的Bean当做上下文进行传入。LiteFlow对上下文的Bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, CustomContext.class);\n\n\n传入之后， LiteFlow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tCustomContext context = this.getContextBean(CustomContext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//CustomContext context = this.getFirstContextBean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nLiteFlow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, OrderContext.class, UserContext.class, SignContext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tOrderContext orderContext = this.getContextBean(OrderContext.class);\n\t\tUserContext userContext = this.getContextBean(UserContext.class);\n\t\tSignContext signContext = this.getContextBean(SignContext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是OrderContext，那么也可以用这个方法\n\t\t//OrderContext orderContext = this.getFirstContextBean();\n\t\t...\n\t}\n}\n',normalizedContent:'# 默认上下文\n\nliteflow提供了一个默认的数据上下文的实现：defaultcontext。这个默认的实现其实里面主要存储数据的容器就是一个map。\n\n你可以通过defaultcontext中的setdata方法放入数据，通过getdata方法获得数据。\n\n建议\n\ndefaultcontext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的bean当做上下文进行传入。liteflow对上下文的bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, customcontext.class);\n\n\n传入之后， liteflow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tcustomcontext context = this.getcontextbean(customcontext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//customcontext context = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nliteflow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, ordercontext.class, usercontext.class, signcontext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tordercontext ordercontext = this.getcontextbean(ordercontext.class);\n\t\tusercontext usercontext = this.getcontextbean(usercontext.class);\n\t\tsigncontext signcontext = this.getcontextbean(signcontext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是ordercontext，那么也可以用这个方法\n\t\t//ordercontext ordercontext = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪶用初始化好的上下文传入",frontmatter:{title:"🪶用初始化好的上下文传入",date:"2022-08-17T23:30:42.000Z",permalink:"/pages/v2.10.X/f05ed6/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/030.%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A5%BD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%A0%E5%85%A5.html",relativePath:"09.v2.10.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.md",key:"v-566b0654",path:"/pages/v2.10.X/f05ed6/",headersStr:null,content:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getRequestData()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nLiteFlow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到FlowExecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nOrderContext orderContext = new OrderContext();\norderContext.setOrderNo("SO11223344");\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", null, orderContext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',normalizedContent:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getrequestdata()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nliteflow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到flowexecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nordercontext ordercontext = new ordercontext();\nordercontext.setorderno("so11223344");\nliteflowresponse response = flowexecutor.execute2resp("chain1", null, ordercontext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T22:30:36.000Z",permalink:"/pages/v2.10.X/90b2a5/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/010.%E8%AF%B4%E6%98%8E.html",relativePath:"09.v2.10.X文档/080.🛩执行器/010.说明.md",key:"v-21b7443f",path:"/pages/v2.10.X/90b2a5/",headersStr:null,content:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合Hello World章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",normalizedContent:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合hello world章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T23:35:36.000Z",permalink:"/pages/v2.10.X/74b4bf/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/010.%E8%AF%B4%E6%98%8E.html",relativePath:"09.v2.10.X文档/070.🌮数据上下文/010.说明.md",key:"v-683cb17a",path:"/pages/v2.10.X/74b4bf/",headersStr:null,content:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在LiteFlow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nLiteFlow对此有独特的设计理念，平时我们写瀑布流的程序时，A调用B，那A一定要把B所需要的参数传递给B，而在LiteFlow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在LiteFlow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",normalizedContent:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在liteflow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nliteflow对此有独特的设计理念，平时我们写瀑布流的程序时，a调用b，那a一定要把b所需要的参数传递给b，而在liteflow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在liteflow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎡执行方法",frontmatter:{title:"🎡执行方法",date:"2022-07-01T23:03:12.000Z",permalink:"/pages/v2.10.X/20072e/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/020.%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.html",relativePath:"09.v2.10.X文档/080.🛩执行器/020.执行方法.md",key:"v-4501950c",path:"/pages/v2.10.X/20072e/",headers:[{level:2,title:"返回类型为LiteflowResponse",slug:"返回类型为liteflowresponse",normalizedTitle:"返回类型为liteflowresponse",charIndex:86},{level:2,title:"返回类型为Future",slug:"返回类型为future",normalizedTitle:"返回类型为future",charIndex:667}],headersStr:"返回类型为LiteflowResponse 返回类型为Future",content:"你可以在Springboot/Spring体系中的任何被Spring上下文管理的类中进行注入FlowExecutor。\n\nFlowExecutor有多个重载方法。\n\n\n# 返回类型为LiteflowResponse\n\n//参数为流程ID，无初始流程入参，上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId)\n//第一个参数为流程ID，第二个参数为流程入参。上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId, Object param);\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文class\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文的Bean\npublic LiteflowResponse execute2Resp(String chainId, Object param, Object... contextBeanArray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为Future\n\npublic Future<LiteflowResponse> execute2Future(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，LiteFlow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现ExecutorBuilder接口：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n",normalizedContent:"你可以在springboot/spring体系中的任何被spring上下文管理的类中进行注入flowexecutor。\n\nflowexecutor有多个重载方法。\n\n\n# 返回类型为liteflowresponse\n\n//参数为流程id，无初始流程入参，上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid)\n//第一个参数为流程id，第二个参数为流程入参。上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid, object param);\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文class\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文的bean\npublic liteflowresponse execute2resp(string chainid, object param, object... contextbeanarray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为future\n\npublic future<liteflowresponse> execute2future(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，liteflow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现executorbuilder接口：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎈LiteflowResponse对象",frontmatter:{title:"🎈LiteflowResponse对象",date:"2022-07-02T00:52:14.000Z",permalink:"/pages/v2.10.X/9f653d/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/040.LiteflowResponse%E5%AF%B9%E8%B1%A1.html",relativePath:"09.v2.10.X文档/080.🛩执行器/040.LiteflowResponse对象.md",key:"v-cafc7acc",path:"/pages/v2.10.X/9f653d/",headers:[{level:2,title:"流程执行是否成功",slug:"流程执行是否成功",normalizedTitle:"流程执行是否成功",charIndex:66},{level:2,title:"获取异常信息",slug:"获取异常信息",normalizedTitle:"获取异常信息",charIndex:240},{level:2,title:"获得执行步骤详细信息",slug:"获得执行步骤详细信息",normalizedTitle:"获得执行步骤详细信息",charIndex:481},{level:2,title:"上下文数据",slug:"上下文数据",normalizedTitle:"上下文数据",charIndex:890},{level:2,title:"获得步骤字符串信息",slug:"获得步骤字符串信息",normalizedTitle:"获得步骤字符串信息",charIndex:1516}],headersStr:"流程执行是否成功 获取异常信息 获得执行步骤详细信息 上下文数据 获得步骤字符串信息",content:'在执行器返回中，用的最多的就是返回一个LiteFlowResponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nboolean isSuccess = response.isSuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程isSuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了LiteFlowResponse对象之后，可以这样获得上下文Bean：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nCustomContext context = response.getContextBean(CustomContext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//CustomContext context = response.getFirstContextBean();\n\n\n对于多上下文来说，也是一样的用法：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, OrderContext.class, UserContext.class);\nOrderContext orderContext = response.getContextBean(OrderContext.class);\nUserContext userContext = response.getContextBean(UserContext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nString stepStr = response.getExecuteStepStrWithTime();\n\n\n这个字符串打印出来结果如下：\n\na[组件A]<201>==>b[组件B]<300>==>m[组件M]<1205>\n\n\n这里的表达形式为组件ID[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getExecuteStepStrWithoutTime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',normalizedContent:'在执行器返回中，用的最多的就是返回一个liteflowresponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nboolean issuccess = response.issuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程issuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了liteflowresponse对象之后，可以这样获得上下文bean：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\ncustomcontext context = response.getcontextbean(customcontext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//customcontext context = response.getfirstcontextbean();\n\n\n对于多上下文来说，也是一样的用法：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, ordercontext.class, usercontext.class);\nordercontext ordercontext = response.getcontextbean(ordercontext.class);\nusercontext usercontext = response.getcontextbean(usercontext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nstring stepstr = response.getexecutestepstrwithtime();\n\n\n这个字符串打印出来结果如下：\n\na[组件a]<201>==>b[组件b]<300>==>m[组件m]<1205>\n\n\n这里的表达形式为组件id[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getexecutestepstrwithouttime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎢流程入参",frontmatter:{title:"🎢流程入参",date:"2022-07-02T00:38:44.000Z",permalink:"/pages/v2.10.X/563b67/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/030.%E6%B5%81%E7%A8%8B%E5%85%A5%E5%8F%82.html",relativePath:"09.v2.10.X文档/080.🛩执行器/030.流程入参.md",key:"v-cc361230",path:"/pages/v2.10.X/563b67/",headersStr:null,content:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户Id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的Bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tYourBean requestBean = this.getRequestData();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getRequestData()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',normalizedContent:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tyourbean requestbean = this.getrequestdata();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getrequestdata()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍫选择脚本语言",frontmatter:{title:"🍫选择脚本语言",date:"2022-10-05T14:01:27.000Z",permalink:"/pages/v2.10.X/bd70f7/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%E9%80%89%E6%8B%A9%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80.html",relativePath:"09.v2.10.X文档/085.🍋脚本组件/010.选择脚本语言.md",key:"v-4c3a5f6c",path:"/pages/v2.10.X/bd70f7/",headers:[{level:2,title:"Groovy",slug:"groovy",normalizedTitle:"groovy",charIndex:23},{level:2,title:"Javascript",slug:"javascript",normalizedTitle:"javascript",charIndex:30},{level:2,title:"QLExpress",slug:"qlexpress",normalizedTitle:"qlexpress",charIndex:41},{level:2,title:"Python",slug:"python",normalizedTitle:"python",charIndex:51},{level:2,title:"Lua",slug:"lua",normalizedTitle:"lua",charIndex:58},{level:2,title:"Aviator",slug:"aviator",normalizedTitle:"aviator",charIndex:62},{level:2,title:"其他说明",slug:"其他说明",normalizedTitle:"其他说明",charIndex:2197}],headersStr:"Groovy Javascript QLExpress Python Lua Aviator 其他说明",content:'LiteFlow框架目前一共支持6种脚本语言：Groovy，Javascript，QLExpress，Python，Lua，Aviator\n\nLiteFlow采用SPI机制进行选择脚本框架来动态编译你的脚本。\n\n官方推荐使用Groovy，因为和java语法是最接近的。\n\n如果你不熟悉这5种脚本语言的语法。可以参照以下教程：\n\nGroovy语法教程\n\nJavascript语法教程\n\nQLExpress语法教程\n\nPython语法教程\n\nLua语法教程\n\nAviator语法教程\n\n\n# Groovy\n\nGroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-groovy</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# Javascript\n\n对于Javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持ES5。另一种是基于GraalJs引擎实现，支持ES6。\n\n官方建议，如果是简单的逻辑，就采用jdk引擎的，如果是复杂的，需要用ES6特性的，就用GraalJs引擎。\n\n顺便说下，jdk引擎并不支持java 17，而GraalJs引擎是能支持到java 17的。\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-javascript</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-graaljs</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# QLExpress\n\nQLExpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-qlexpress</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# Python\n\nPython脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-python</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n提示\n\npython解析执行依赖Jython环境，不安装部署启动会报错（IDEA里不会报错），环境安装说明如下\n\n一、下载安装Jython Installer\n\nhttps://www.jython.org/download\n\n二、Springboot启动类添加代码\n\nProperties props = new Properties();\nProperties preprops = System.getProperties();\nprops.put("python.home", jython安装目录);\nPythonInterpreter.initialize (preprops, props, new String[]{});\n\n\n\n# Lua\n\nLua脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-lua</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n提示\n\n在lua中，调用java方式是用:来调用的，并不是.，比如defaultContext:setData("s1",a*b)。\n\n\n# Aviator\n\nAviator脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-aviator</artifactId>\n    <version>2.10.7</version>\n</dependency>\n\n\n提示\n\n在aviator中，调用java方式和其他不一样，比如我们上下文是UserContext，在其他脚本语言中调用是用userContext.setName("jack")，而在aviator脚本中，调用方式是setName(userContext, "jack")，也就是method(bean, args)这种形式，有点类似java反射的invoke形式。这点要注意下\n\n\n# 其他说明\n\n你只需要依赖相应的脚本框架即可，SPI会动态选择你依赖的脚本框架进行编译解析你的脚本。\n\nLiteFlow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。',normalizedContent:'liteflow框架目前一共支持6种脚本语言：groovy，javascript，qlexpress，python，lua，aviator\n\nliteflow采用spi机制进行选择脚本框架来动态编译你的脚本。\n\n官方推荐使用groovy，因为和java语法是最接近的。\n\n如果你不熟悉这5种脚本语言的语法。可以参照以下教程：\n\ngroovy语法教程\n\njavascript语法教程\n\nqlexpress语法教程\n\npython语法教程\n\nlua语法教程\n\naviator语法教程\n\n\n# groovy\n\ngroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-groovy</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# javascript\n\n对于javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持es5。另一种是基于graaljs引擎实现，支持es6。\n\n官方建议，如果是简单的逻辑，就采用jdk引擎的，如果是复杂的，需要用es6特性的，就用graaljs引擎。\n\n顺便说下，jdk引擎并不支持java 17，而graaljs引擎是能支持到java 17的。\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-javascript</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-graaljs</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# qlexpress\n\nqlexpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-qlexpress</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n\n# python\n\npython脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-python</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n提示\n\npython解析执行依赖jython环境，不安装部署启动会报错（idea里不会报错），环境安装说明如下\n\n一、下载安装jython installer\n\nhttps://www.jython.org/download\n\n二、springboot启动类添加代码\n\nproperties props = new properties();\nproperties preprops = system.getproperties();\nprops.put("python.home", jython安装目录);\npythoninterpreter.initialize (preprops, props, new string[]{});\n\n\n\n# lua\n\nlua脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-lua</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n提示\n\n在lua中，调用java方式是用:来调用的，并不是.，比如defaultcontext:setdata("s1",a*b)。\n\n\n# aviator\n\naviator脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-aviator</artifactid>\n    <version>2.10.7</version>\n</dependency>\n\n\n提示\n\n在aviator中，调用java方式和其他不一样，比如我们上下文是usercontext，在其他脚本语言中调用是用usercontext.setname("jack")，而在aviator脚本中，调用方式是setname(usercontext, "jack")，也就是method(bean, args)这种形式，有点类似java反射的invoke形式。这点要注意下\n\n\n# 其他说明\n\n你只需要依赖相应的脚本框架即可，spi会动态选择你依赖的脚本框架进行编译解析你的脚本。\n\nliteflow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍕定义脚本组件",frontmatter:{title:"🍕定义脚本组件",date:"2022-10-05T14:04:49.000Z",permalink:"/pages/v2.10.X/81d53c/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/020.%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/085.🍋脚本组件/020.定义脚本组件.md",key:"v-53e924a7",path:"/pages/v2.10.X/81d53c/",headersStr:null,content:'脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" language="groovy">\n            <![CDATA[\n                def a=3;\n                def b=2;\n                defaultContext.setData("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="选择脚本" type="switch_script" language="groovy">\n            <![CDATA[\n                def count = defaultContext.getData("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n\n        <node id="s3" name="条件脚本" type="if_script" language="groovy">\n            <![CDATA[\n                return false;\n            ]]>\n        </node>\n\n        <node id="s4" name="数值循环脚本" type="for_script" language="groovy">\n            <![CDATA[\n                //此处可以用来获取你的循环次数，可以调用java对象来获取，这里演示直接返回循环次数\n                return 10;\n            ]]>\n        </node>\n\n        <node id="s5" name="条件循环脚本" type="while_script" language="groovy">\n            <![CDATA[\n                //此处用来获取什么时候继续循环的标识，可以调用java对象来获取，这里只是演示\n                def flag = yourJavaBean.getFlag();\n                return flag;\n            ]]>\n        </node>\n\n        <node id="s6" name="退出循环脚本" type="break_script" language="groovy">\n            <![CDATA[\n                //此处用来获取什么时候退出循环的标识，可以调用java对象来获取，这里只是演示\n                def breakFlag = yourJavaBean.getFlag();\n                return breakFlagt;\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1);\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, SWITCH(s2).to(a, b));\n    </chain>\n\n    <chain name="chain3">\n        THEN(d, IF(s3, b, c));\n    </chain>\n\n    <chain name="chain4">\n        FOR(s4).DO(THEN(a,b)).BREAK(s6);\n    </chain>\n\n    <chain name="chain5">\n        WHILE(s5).DO(THEN(a,b));\n    </chain>\n</flow>\n\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n如果你只引入一个脚本的话，这里language并不是必须的，如果你是多脚本共存的，那么这里language则是必须要指定的。\n\n但是官方建议你还是指定language属性，指定了语言，LiteFlowX插件则可以根据脚本语言进行语法高亮处理和代码提示。如果你不加，则不会有相应的语法高亮和提示。\n\n当然得确保你的LiteFlowX插件的版本在1.1.1及以上。\n\n提示\n\n这里示例是传入的上下文bean是默认的DefaultContext，如果是你自定义的上下文Bean，请调用相应的方法来设置和获取数据。',normalizedContent:'脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" language="groovy">\n            <![cdata[\n                def a=3;\n                def b=2;\n                defaultcontext.setdata("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="选择脚本" type="switch_script" language="groovy">\n            <![cdata[\n                def count = defaultcontext.getdata("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n\n        <node id="s3" name="条件脚本" type="if_script" language="groovy">\n            <![cdata[\n                return false;\n            ]]>\n        </node>\n\n        <node id="s4" name="数值循环脚本" type="for_script" language="groovy">\n            <![cdata[\n                //此处可以用来获取你的循环次数，可以调用java对象来获取，这里演示直接返回循环次数\n                return 10;\n            ]]>\n        </node>\n\n        <node id="s5" name="条件循环脚本" type="while_script" language="groovy">\n            <![cdata[\n                //此处用来获取什么时候继续循环的标识，可以调用java对象来获取，这里只是演示\n                def flag = yourjavabean.getflag();\n                return flag;\n            ]]>\n        </node>\n\n        <node id="s6" name="退出循环脚本" type="break_script" language="groovy">\n            <![cdata[\n                //此处用来获取什么时候退出循环的标识，可以调用java对象来获取，这里只是演示\n                def breakflag = yourjavabean.getflag();\n                return breakflagt;\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1);\n    </chain>\n\n    <chain name="chain2">\n        then(d, switch(s2).to(a, b));\n    </chain>\n\n    <chain name="chain3">\n        then(d, if(s3, b, c));\n    </chain>\n\n    <chain name="chain4">\n        for(s4).do(then(a,b)).break(s6);\n    </chain>\n\n    <chain name="chain5">\n        while(s5).do(then(a,b));\n    </chain>\n</flow>\n\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n如果你只引入一个脚本的话，这里language并不是必须的，如果你是多脚本共存的，那么这里language则是必须要指定的。\n\n但是官方建议你还是指定language属性，指定了语言，liteflowx插件则可以根据脚本语言进行语法高亮处理和代码提示。如果你不加，则不会有相应的语法高亮和提示。\n\n当然得确保你的liteflowx插件的版本在1.1.1及以上。\n\n提示\n\n这里示例是传入的上下文bean是默认的defaultcontext，如果是你自定义的上下文bean，请调用相应的方法来设置和获取数据。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍱多脚本语言混合共存",frontmatter:{title:"🍱多脚本语言混合共存",date:"2023-03-16T22:49:23.000Z",permalink:"/pages/v2.10.X/acba2c/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/025.%E5%A4%9A%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E5%85%B1%E5%AD%98.html",relativePath:"09.v2.10.X文档/085.🍋脚本组件/025.多脚本语言混合共存.md",key:"v-3ea3508a",path:"/pages/v2.10.X/acba2c/",headersStr:null,content:'LiteFlow从2.10.0开始，支持了多脚本语言混合共存的特性。你完全可以在规则文件内用不同的脚本语言书写不同的逻辑。\n\n当然有个前提：你使用了多个脚本，必须引入多个脚本对应的依赖，依赖选项在选择脚本语言有说过。\n\n比如你可以这样定义多个脚本：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="groovy脚本" type="script" language="groovy">\n            <![CDATA[\n                class Student {\n                    int studentID\n                    String studentName\n                }\n\n                Student student = new Student()\n                student.studentID = 100301\n                student.studentName = "张三"\n                defaultContext.setData("student", student)\n\n                def a = 3\n                def b = 2\n                defaultContext.setData("s1", a * b)\n            ]]>\n        </node>\n\n        <node id="s2" name="js脚本" type="script" language="js">\n            <![CDATA[\n                var student = defaultContext.getData("student");\n                student.studentID = 10032;\n            ]]>\n        </node>\n\n        <node id="s3" name="python脚本" type="script" language="python">\n            <![CDATA[\n                a = 3\n                s1 = defaultContext.getData("s1")\n                defaultContext.setData("s1",s1*a)\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, s1, b, s2, c, s3);\n    </chain>\n</flow>\n\n\n以上规则中，其中a,b,c为java组件，s1是groovy组件，s2是javascript组件，s3是python组件。\n\nLiteFlow能非常方便的能进行混合编排，并且实现参数互通。',normalizedContent:'liteflow从2.10.0开始，支持了多脚本语言混合共存的特性。你完全可以在规则文件内用不同的脚本语言书写不同的逻辑。\n\n当然有个前提：你使用了多个脚本，必须引入多个脚本对应的依赖，依赖选项在选择脚本语言有说过。\n\n比如你可以这样定义多个脚本：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="groovy脚本" type="script" language="groovy">\n            <![cdata[\n                class student {\n                    int studentid\n                    string studentname\n                }\n\n                student student = new student()\n                student.studentid = 100301\n                student.studentname = "张三"\n                defaultcontext.setdata("student", student)\n\n                def a = 3\n                def b = 2\n                defaultcontext.setdata("s1", a * b)\n            ]]>\n        </node>\n\n        <node id="s2" name="js脚本" type="script" language="js">\n            <![cdata[\n                var student = defaultcontext.getdata("student");\n                student.studentid = 10032;\n            ]]>\n        </node>\n\n        <node id="s3" name="python脚本" type="script" language="python">\n            <![cdata[\n                a = 3\n                s1 = defaultcontext.getdata("s1")\n                defaultcontext.setdata("s1",s1*a)\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, s1, b, s2, c, s3);\n    </chain>\n</flow>\n\n\n以上规则中，其中a,b,c为java组件，s1是groovy组件，s2是javascript组件，s3是python组件。\n\nliteflow能非常方便的能进行混合编排，并且实现参数互通。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯文件脚本的定义",frontmatter:{title:"🌯文件脚本的定义",date:"2022-10-05T14:16:29.000Z",permalink:"/pages/v2.10.X/f7acfd/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/030.%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9A%E4%B9%89.html",relativePath:"09.v2.10.X文档/085.🍋脚本组件/030.文件脚本的定义.md",key:"v-d9f3db50",path:"/pages/v2.10.X/f7acfd/",headersStr:null,content:'LiteFlow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟IDE对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前LiteFlow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n从2.9.7开始，LiteFlow已经支持脚本文件的绝对路径。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, IF(s3, b, c));\n    </chain>\n</flow>\n',normalizedContent:'liteflow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟ide对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前liteflow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n从2.9.7开始，liteflow已经支持脚本文件的绝对路径。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        then(d, if(s3, b, c));\n    </chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍘动态刷新脚本",frontmatter:{title:"🍘动态刷新脚本",date:"2022-10-05T22:47:47.000Z",permalink:"/pages/v2.10.X/cbcb14/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/050.%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E8%84%9A%E6%9C%AC.html",relativePath:"09.v2.10.X文档/085.🍋脚本组件/050.动态刷新脚本.md",key:"v-081f5879",path:"/pages/v2.10.X/cbcb14/",headersStr:null,content:"其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n但是如果你要仅仅热刷新脚本的话，这里也提供了单独的方式，你可以调用如下的代码进行脚本的热刷新：\n\nScriptExecutorFactory.loadInstance().getScriptExecutor().load(nodeId, script);\n",normalizedContent:"其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n但是如果你要仅仅热刷新脚本的话，这里也提供了单独的方式，你可以调用如下的代码进行脚本的热刷新：\n\nscriptexecutorfactory.loadinstance().getscriptexecutor().load(nodeid, script);\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣脚本与Java进行交互",frontmatter:{title:"🍣脚本与Java进行交互",date:"2022-10-05T14:18:24.000Z",permalink:"/pages/v2.10.X/d861c8/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/040.%E8%84%9A%E6%9C%AC%E4%B8%8EJava%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.html",relativePath:"09.v2.10.X文档/085.🍋脚本组件/040.脚本与Java进行交互.md",key:"v-70ba750c",path:"/pages/v2.10.X/d861c8/",headers:[{level:2,title:"和上下文进行交互",slug:"和上下文进行交互",normalizedTitle:"和上下文进行交互",charIndex:2},{level:2,title:"自定义上下文引用名称",slug:"自定义上下文引用名称",normalizedTitle:"自定义上下文引用名称",charIndex:541},{level:2,title:"元数据",slug:"元数据",normalizedTitle:"元数据",charIndex:841},{level:2,title:"和自定义的JavaBean进行交互",slug:"和自定义的javabean进行交互",normalizedTitle:"和自定义的javabean进行交互",charIndex:1211},{level:2,title:"直接注入方法",slug:"直接注入方法",normalizedTitle:"直接注入方法",charIndex:2561}],headersStr:"和上下文进行交互 自定义上下文引用名称 元数据 和自定义的JavaBean进行交互 直接注入方法",content:'# 和上下文进行交互\n\n因为LiteFlow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的className的驼峰形式来获取数据。\n\n比如你的上下文类叫OrderContext，那么脚本中的就用orderContext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取UserContext中的userName对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![CDATA[\n        //你可以这样定义\n        def name = userContext.userName;\n        //也可以这样定义，如果你对userName有getter方法的话\n        def name = userContext.getUserName();\n        //同理，你可以调用数据上下文中的任意方法\n        userContext.doYourMethod();\n    ]]>\n</node>\n\n\n\n# 自定义上下文引用名称\n\n上文提到，在脚本中默认的上下文引用规则为上下文类的simpleClassName，比如你的上下文为UserContext，那么脚本就用userContext去引用。\n\n那么可不可以自定义这个上下文的名称呢？\n\n可以。LiteFlow从2.10.0版本开始支持这个功能，如果你不想用userContext来引用，那么只需加一个@ContextBean的注解即可完成：\n\n@ContextBean("userCxt")\npublic class UserContext {\n    ...\n}\n\n\n这样定义后，那么脚本中，你就可以用userCtxt关键字去引用上下文了。\n\n\n# 元数据\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotIndex: slot下标，可以通过FlowBus.getSlot(slotIndex)来获得slot数据\n * currChainId: 当前执行chain的名称\n * nodeId: 当前执行node的Id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpData: 组件规则参数，关于cmpData的说明请查看组件参数\n * loopIndex: 在循环中的循环下标\n * loopObject: 在迭代循环中的循环对象\n * requestData: 流程初始参数\n * subRequestData: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 和自定义的JavaBean进行交互\n\nLiteFlow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@ScriptBean标注，即可完成注入。\n\n@Component\n@ScriptBean("demo")\npublic class DemoBean1 {\n\n    @Resource\n    private DemoBean2 demoBean2;\n\n    public String getDemoStr1(){\n        return "hello";\n    }\n\n    public String getDemoStr2(String name){\n        return demoBean2.getDemoStr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getDemoStr1()和getDemoStr2()方法了。\n\n我们在LiteFlow 2.9.5版本支持了@ScriptBean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", includeMethodName = {"test1","test2"})\npublic class DemoBean3 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", excludeMethodName = {"test2","test3"})\npublic class DemoBean4 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@ScriptBean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nScriptBeanManager.addScriptBean("demo", new DemoBean());\n\n\n\n# 直接注入方法\n\n如果你有一个java类，里面有100个方法，而我只想暴露其1个给脚本使用，用@ScriptBean可能会把整个bean都暴露出去，有没有方法呢？\n\n有。LiteFlow从2.9.5开始加入了@ScriptMethod注解，在方法上进行标注：\n\n@Component\npublic class DemoBean1 {\n\n    @ScriptMethod("demo")\n    public String getDemoStr1() {\n        return "hello";\n    }\n\n    public String method2() {\n       ...\n    }\n       \n    public String method3() {\n       ...\n    }\n    \n    ...\n}\n\n\n这样，你就可以在脚本中用demo.getDemoStr1()来调用到相应的java方法了。\n\n提示\n\n当然这里的前提同样是：java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@ScriptMethod注解也是没用的。',normalizedContent:'# 和上下文进行交互\n\n因为liteflow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的classname的驼峰形式来获取数据。\n\n比如你的上下文类叫ordercontext，那么脚本中的就用ordercontext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取usercontext中的username对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![cdata[\n        //你可以这样定义\n        def name = usercontext.username;\n        //也可以这样定义，如果你对username有getter方法的话\n        def name = usercontext.getusername();\n        //同理，你可以调用数据上下文中的任意方法\n        usercontext.doyourmethod();\n    ]]>\n</node>\n\n\n\n# 自定义上下文引用名称\n\n上文提到，在脚本中默认的上下文引用规则为上下文类的simpleclassname，比如你的上下文为usercontext，那么脚本就用usercontext去引用。\n\n那么可不可以自定义这个上下文的名称呢？\n\n可以。liteflow从2.10.0版本开始支持这个功能，如果你不想用usercontext来引用，那么只需加一个@contextbean的注解即可完成：\n\n@contextbean("usercxt")\npublic class usercontext {\n    ...\n}\n\n\n这样定义后，那么脚本中，你就可以用userctxt关键字去引用上下文了。\n\n\n# 元数据\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotindex: slot下标，可以通过flowbus.getslot(slotindex)来获得slot数据\n * currchainid: 当前执行chain的名称\n * nodeid: 当前执行node的id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpdata: 组件规则参数，关于cmpdata的说明请查看组件参数\n * loopindex: 在循环中的循环下标\n * loopobject: 在迭代循环中的循环对象\n * requestdata: 流程初始参数\n * subrequestdata: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 和自定义的javabean进行交互\n\nliteflow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@scriptbean标注，即可完成注入。\n\n@component\n@scriptbean("demo")\npublic class demobean1 {\n\n    @resource\n    private demobean2 demobean2;\n\n    public string getdemostr1(){\n        return "hello";\n    }\n\n    public string getdemostr2(string name){\n        return demobean2.getdemostr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getdemostr1()和getdemostr2()方法了。\n\n我们在liteflow 2.9.5版本支持了@scriptbean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", includemethodname = {"test1","test2"})\npublic class demobean3 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", excludemethodname = {"test2","test3"})\npublic class demobean4 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@scriptbean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nscriptbeanmanager.addscriptbean("demo", new demobean());\n\n\n\n# 直接注入方法\n\n如果你有一个java类，里面有100个方法，而我只想暴露其1个给脚本使用，用@scriptbean可能会把整个bean都暴露出去，有没有方法呢？\n\n有。liteflow从2.9.5开始加入了@scriptmethod注解，在方法上进行标注：\n\n@component\npublic class demobean1 {\n\n    @scriptmethod("demo")\n    public string getdemostr1() {\n        return "hello";\n    }\n\n    public string method2() {\n       ...\n    }\n       \n    public string method3() {\n       ...\n    }\n    \n    ...\n}\n\n\n这样，你就可以在脚本中用demo.getdemostr1()来调用到相应的java方法了。\n\n提示\n\n当然这里的前提同样是：java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@scriptmethod注解也是没用的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥭什么叫声明式组件",frontmatter:{title:"🥭什么叫声明式组件",date:"2022-10-05T23:19:02.000Z",permalink:"/pages/v2.10.X/46f0fa/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/010.%E4%BB%80%E4%B9%88%E5%8F%AB%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/086.🍇声明式组件/010.什么叫声明式组件.md",key:"v-5a76da12",path:"/pages/v2.10.X/46f0fa/",headersStr:null,content:"何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承NodeComponent或者NodeSwitchComponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成LiteFlow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。",normalizedContent:"何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承nodecomponent或者nodeswitchcomponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成liteflow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥥方法级别式声明",frontmatter:{title:"🥥方法级别式声明",date:"2022-10-05T23:40:08.000Z",permalink:"/pages/v2.10.X/797830/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/030.%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"09.v2.10.X文档/086.🍇声明式组件/030.方法级别式声明.md",key:"v-ebf01650",path:"/pages/v2.10.X/797830/",headersStr:null,content:'LiteFlow从v2.9.0版开始推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    //普通组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeName = "A组件")\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    //SWITCH组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeId = "b", nodeName = "B组件", nodeType = NodeTypeEnum.SWITCH)\n    public String processB(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //IF组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_IF, nodeId = "c", nodeName = "C组件", nodeType = NodeTypeEnum.IF)\n    public boolean processC(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //FOR组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeId = "d", nodeName = "D组件", nodeType = NodeTypeEnum.FOR)\n    public int processD(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //WHILE组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_WHILE, nodeId = "e", nodeName = "E组件", nodeType = NodeTypeEnum.WHILE)\n    public int processE(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //BREAK组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BREAK, nodeId = "f", nodeName = "F组件", nodeType = NodeTypeEnum.BREAK)\n    public int processF(NodeComponent bindCmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@LiteflowMethod注解上的nodeId一定要写。\n\nLiteFlow从v2.10.6开始，新增了nodeName的属性。方便对声明式的组件进行命名。这个属性是可选的。\n\n普通组件上的nodeType因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodeType = NodeTypeEnum.COMMON。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如IF组件的processIf方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public boolean isAccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void onSuccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_IF, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public boolean processF(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public boolean isAccessF(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public void onSuccessF(NodeComponent bindCmp){\n        ...\n    }\n}\n',normalizedContent:'liteflow从v2.9.0版开始推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    //普通组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodename = "a组件")\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    //switch组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodeid = "b", nodename = "b组件", nodetype = nodetypeenum.switch)\n    public string processb(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //if组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_if, nodeid = "c", nodename = "c组件", nodetype = nodetypeenum.if)\n    public boolean processc(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //for组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_for, nodeid = "d", nodename = "d组件", nodetype = nodetypeenum.for)\n    public int processd(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //while组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_while, nodeid = "e", nodename = "e组件", nodetype = nodetypeenum.while)\n    public int processe(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //break组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_break, nodeid = "f", nodename = "f组件", nodetype = nodetypeenum.break)\n    public int processf(nodecomponent bindcmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@liteflowmethod注解上的nodeid一定要写。\n\nliteflow从v2.10.6开始，新增了nodename的属性。方便对声明式的组件进行命名。这个属性是可选的。\n\n普通组件上的nodetype因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodetype = nodetypeenum.common。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如if组件的processif方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodetype = nodetypeenum.common)\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "a", nodetype = nodetypeenum.common)\n    public boolean isaccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "a", nodetype = nodetypeenum.common)\n    public void onsuccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.process_if, nodeid = "f", nodetype = nodetypeenum.if)\n    public boolean processf(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "f", nodetype = nodetypeenum.if)\n    public boolean isaccessf(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "f", nodetype = nodetypeenum.if)\n    public void onsuccessf(nodecomponent bindcmp){\n        ...\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:56:32.000Z",permalink:"/pages/v2.10.X/9aa85a/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/010.%E8%AF%B4%E6%98%8E.html",relativePath:"09.v2.10.X文档/090.🎲用代码动态构造规则/010.说明.md",key:"v-31418c47",path:"/pages/v2.10.X/9aa85a/",headersStr:null,content:"之前的章节讲述的是通过规则文件去构造流程。\n\nLiteFlow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，ruleSource不用去定义。完全用代码去构建。\n\n事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的API意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造API去构造链路。\n\nLiteFlow设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",normalizedContent:"之前的章节讲述的是通过规则文件去构造流程。\n\nliteflow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，rulesource不用去定义。完全用代码去构建。\n\n事实上，liteflow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的api意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造api去构造链路。\n\nliteflow设计了非常简单的构造方法链式api，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎯如何构造",frontmatter:{title:"🎯如何构造",date:"2022-07-02T15:57:38.000Z",permalink:"/pages/v2.10.X/6bc8fe/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/020.%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0.html",relativePath:"09.v2.10.X文档/090.🎲用代码动态构造规则/020.如何构造.md",key:"v-7c2126fd",path:"/pages/v2.10.X/6bc8fe/",headers:[{level:2,title:"什么时候构造",slug:"什么时候构造",normalizedTitle:"什么时候构造",charIndex:93},{level:2,title:"构造Node",slug:"构造node",normalizedTitle:"构造node",charIndex:145},{level:2,title:"构建一个Chain",slug:"构建一个chain",normalizedTitle:"构建一个chain",charIndex:1418},{level:2,title:"销毁一个Chain",slug:"销毁一个chain",normalizedTitle:"销毁一个chain",charIndex:1740}],headersStr:"什么时候构造 构造Node 构建一个Chain 销毁一个Chain",content:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造Node\n\n提示\n\n你可以像以下那样构造一个普通的Node，当然在spring/springboot环境，大多数情况你无需去构建一个Node，因为只要你的组件上标有@Component/@LiteflowComponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看定义脚本组件\n\n//构建一个普通组件\nLiteFlowNodeBuilder.createCommonNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个普通条件组件\nLiteFlowNodeBuilder.createSwitchNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个脚本组件\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nLiteFlowNodeBuilder.createScriptSwitchNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setFile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@LiteflowComponent或者@Component，如果项目是spring体系的话，LiteFlow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@Autowired和@Resource等等之类的spring任何注解。\n\n\n# 构建一个Chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个EL表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 销毁一个Chain\n\nLiteFlow中允许你手动运行以下代码来销毁一个流程：\n\nFlowBus.removeChain("你的流程ID")\n',normalizedContent:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造node\n\n提示\n\n你可以像以下那样构造一个普通的node，当然在spring/springboot环境，大多数情况你无需去构建一个node，因为只要你的组件上标有@component/@liteflowcomponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看定义脚本组件\n\n//构建一个普通组件\nliteflownodebuilder.createcommonnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个普通条件组件\nliteflownodebuilder.createswitchnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个脚本组件\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nliteflownodebuilder.createscriptswitchnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setfile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@liteflowcomponent或者@component，如果项目是spring体系的话，liteflow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@autowired和@resource等等之类的spring任何注解。\n\n\n# 构建一个chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个el表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 销毁一个chain\n\nliteflow中允许你手动运行以下代码来销毁一个流程：\n\nflowbus.removechain("你的流程id")\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧅类级别式声明",frontmatter:{title:"🧅类级别式声明",date:"2022-10-05T23:22:17.000Z",permalink:"/pages/v2.10.X/18f548/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/020.%E7%B1%BB%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"09.v2.10.X文档/086.🍇声明式组件/020.类级别式声明.md",key:"v-0eab1988",path:"/pages/v2.10.X/18f548/",headers:[{level:2,title:"普通组件的声明",slug:"普通组件的声明",normalizedTitle:"普通组件的声明",charIndex:147},{level:2,title:"选择组件的声明",slug:"选择组件的声明",normalizedTitle:"选择组件的声明",charIndex:1818},{level:2,title:"条件组件的声明",slug:"条件组件的声明",normalizedTitle:"条件组件的声明",charIndex:2193},{level:2,title:"数值循环组件的声明",slug:"数值循环组件的声明",normalizedTitle:"数值循环组件的声明",charIndex:2504},{level:2,title:"条件循环组件的声明",slug:"条件循环组件的声明",normalizedTitle:"条件循环组件的声明",charIndex:2816},{level:2,title:"退出循环组件的声明",slug:"退出循环组件的声明",normalizedTitle:"退出循环组件的声明",charIndex:3177},{level:2,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:1355}],headersStr:"普通组件的声明 选择组件的声明 条件组件的声明 数值循环组件的声明 条件循环组件的声明 退出循环组件的声明 注意点",content:'类级别式声明主要用处就是通过注解形式让普通的java bean变成LiteFlow的组件。无需通过继承类或者实现接口的方式。\n\n由于LiteFlow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@LiteflowComponent("a")\n@LiteflowCmpDefine\npublic class ACmp{\n  \n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS)\n\tpublic void processAcmp(NodeComponent bindCmp) {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)\n\tpublic boolean isAcmpAccess(NodeComponent bindCmp){\n\t\treturn true;\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.BEFORE_PROCESS)\n\tpublic void beforeAcmp(NodeComponent bindCmp){\n\t\tSystem.out.println("before A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.AFTER_PROCESS)\n\tpublic void afterAcmp(NodeComponent bindCmp){\n\t\tSystem.out.println("after A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_SUCCESS)\n\tpublic void onAcmpSuccess(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp success");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_ERROR)\n\tpublic void onAcmpError(NodeComponent bindCmp, Exception e){\n\t\tSystem.out.println("Acmp error");\n\t}\n\t\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_END)\n\tpublic boolean isAcmpEnd(NodeComponent bindCmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承NodeComponent了，在你定义的类上，只要类上加上LiteflowCmpDefine注解，相应的方法上加上LiteflowMethod注解，即可完成对任意自定义类的组件化工作。\n\n其中LiteFlowMethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n关于参数的参数，这里需要注意的是，方法上参数必须传入NodeComponent bindCmp这个参数，而且必须是第一个参数。\n\n比如原先的process()，那么在声明式里就是yourMethodName(NodeComponent bindCmp)。\n\n如果是原先的onError(Exception e)，那么在声明式里就是yourMethodName(NodeComponent bindCmp, Exception e)。\n\n规律很明显，就是原先的参数保留，在第一个位置插入NodeComponent对象，代替原先的this。\n\n以前获取上下文Bean是用this关键字，现在只需从bindCmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如IF组件的processIf方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.SWITCH参数。\n\n@Component("e")\n@LiteflowCmpDefine(NodeTypeEnum.SWITCH)\npublic class ECmp{\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeType = NodeTypeEnum.SWITCH)\n    public String processSwitch(NodeComponent bindCmp) throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.IF参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.IF)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_IF, nodeType = NodeTypeEnum.IF)\n\tpublic boolean processIf(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.FOR参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.FOR)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeType = NodeTypeEnum.FOR)\n\tpublic int processFor(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 条件循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.WHILE参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.WHILE)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_WHILE, nodeType = NodeTypeEnum.WHILE)\n\tpublic boolean processWhile(NodeComponent bindCmp) throws Exception {\n\t\t//get your while flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 退出循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.BREAK参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.BREAK)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BREAK, nodeType = NodeTypeEnum.BREAK)\n\tpublic boolean processBreak(NodeComponent bindCmp) throws Exception {\n\t\t//get your break flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processXxx一样的方式去声明。',normalizedContent:'类级别式声明主要用处就是通过注解形式让普通的java bean变成liteflow的组件。无需通过继承类或者实现接口的方式。\n\n由于liteflow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@liteflowcomponent("a")\n@liteflowcmpdefine\npublic class acmp{\n  \n\t@liteflowmethod(liteflowmethodenum.process)\n\tpublic void processacmp(nodecomponent bindcmp) {\n\t\tsystem.out.println("acmp executed!");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.is_access)\n\tpublic boolean isacmpaccess(nodecomponent bindcmp){\n\t\treturn true;\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.before_process)\n\tpublic void beforeacmp(nodecomponent bindcmp){\n\t\tsystem.out.println("before a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.after_process)\n\tpublic void afteracmp(nodecomponent bindcmp){\n\t\tsystem.out.println("after a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_success)\n\tpublic void onacmpsuccess(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp success");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_error)\n\tpublic void onacmperror(nodecomponent bindcmp, exception e){\n\t\tsystem.out.println("acmp error");\n\t}\n\t\n\t@liteflowmethod(liteflowmethodenum.is_end)\n\tpublic boolean isacmpend(nodecomponent bindcmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承nodecomponent了，在你定义的类上，只要类上加上liteflowcmpdefine注解，相应的方法上加上liteflowmethod注解，即可完成对任意自定义类的组件化工作。\n\n其中liteflowmethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n关于参数的参数，这里需要注意的是，方法上参数必须传入nodecomponent bindcmp这个参数，而且必须是第一个参数。\n\n比如原先的process()，那么在声明式里就是yourmethodname(nodecomponent bindcmp)。\n\n如果是原先的onerror(exception e)，那么在声明式里就是yourmethodname(nodecomponent bindcmp, exception e)。\n\n规律很明显，就是原先的参数保留，在第一个位置插入nodecomponent对象，代替原先的this。\n\n以前获取上下文bean是用this关键字，现在只需从bindcmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如if组件的processif方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.switch参数。\n\n@component("e")\n@liteflowcmpdefine(nodetypeenum.switch)\npublic class ecmp{\n\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodetype = nodetypeenum.switch)\n    public string processswitch(nodecomponent bindcmp) throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.if参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.if)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_if, nodetype = nodetypeenum.if)\n\tpublic boolean processif(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.for参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.for)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_for, nodetype = nodetypeenum.for)\n\tpublic int processfor(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 条件循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.while参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.while)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_while, nodetype = nodetypeenum.while)\n\tpublic boolean processwhile(nodecomponent bindcmp) throws exception {\n\t\t//get your while flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 退出循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.break参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.break)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_break, nodetype = nodetypeenum.break)\n\tpublic boolean processbreak(nodecomponent bindcmp) throws exception {\n\t\t//get your break flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processxxx一样的方式去声明。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍒前置和后置组件",frontmatter:{title:"🍒前置和后置组件",date:"2022-07-02T22:51:41.000Z",permalink:"/pages/v2.10.X/9f93be/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/030.%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/030.前置和后置组件.md",key:"v-2c6bf293",path:"/pages/v2.10.X/9f93be/",headers:[{level:2,title:"前置组件",slug:"前置组件",normalizedTitle:"前置组件",charIndex:11},{level:2,title:"后置节点",slug:"后置节点",normalizedTitle:"后置节点",charIndex:259},{level:2,title:"顺序问题",slug:"顺序问题",normalizedTitle:"顺序问题",charIndex:446},{level:2,title:"层级和范围",slug:"层级和范围",normalizedTitle:"层级和范围",charIndex:732}],headersStr:"前置组件 后置节点 顺序问题 层级和范围",content:'LiteFlow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用PRE关键字(必须大写)来表示:\n\n<chain name="chain1">\n    THEN(\n        PRE(p1, p2), \n        a, b, c, \n        WHEN(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受Exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用FINALLY关键字(必须大写)表示：\n\n<chain name="chain1">\n    THEN(\n        a, b, c, \n        FINALLY(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，PRE和FINALLY可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    THEN(\n        PRE(a), c, d, FINALLY(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    THEN(\n        FINALLY(f1, f2), c, PRE(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nLiteFlow 2.9.5中能支持PRE和FINALLY写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\nPRE和FINALLY只能写在THEN表达式中，如果你写在WHEN表达式中或者其他诸如SWITCH,IF的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = THEN(PRE(p1, p2), THEN(a, b, c), FINALLY(f1, f2));\n    THEN(PRE(p1, p2), c1, FINALLY(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',normalizedContent:'liteflow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用pre关键字(必须大写)来表示:\n\n<chain name="chain1">\n    then(\n        pre(p1, p2), \n        a, b, c, \n        when(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用finally关键字(必须大写)表示：\n\n<chain name="chain1">\n    then(\n        a, b, c, \n        finally(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，pre和finally可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    then(\n        pre(a), c, d, finally(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    then(\n        finally(f1, f2), c, pre(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nliteflow 2.9.5中能支持pre和finally写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\npre和finally只能写在then表达式中，如果你写在when表达式中或者其他诸如switch,if的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = then(pre(p1, p2), then(a, b, c), finally(f1, f2));\n    then(pre(p1, p2), c1, finally(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍌本地规则文件监听",frontmatter:{title:"🍌本地规则文件监听",date:"2023-03-16T22:59:58.000Z",permalink:"/pages/v2.10.X/f8aa79/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/031.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/031.本地规则文件监听.md",key:"v-219649a8",path:"/pages/v2.10.X/f8aa79/",headersStr:null,content:"首先，在LiteFlow的配置liteflow.rule-source中，不光可以配置项目内的规则文件，其实还可以配置本地磁盘上的文件的，比如：\n\nliteflow.rule-source=/Users/bryan31/liteflow/test/flow.xml\n\n\n但是当你本地规则文件改变了的情况下，你的项目是无法获知的，你只能通过手动刷新规则去实现热刷新(详细请阅读平滑热刷新)。\n\nLiteFlow从2.10.0开始，增加了对本地规则文件监听的特性。\n\n你只需要配置liteflow.enable-monitor-file=true，即可开启自动对文件的监听特性。文件改动，你的项目无需做任何事，立马自动刷新整个规则。非常方便。\n\n在各个环境中如何配置，前面的章节也提到过，详情请阅读配置项这一大章节。",normalizedContent:"首先，在liteflow的配置liteflow.rule-source中，不光可以配置项目内的规则文件，其实还可以配置本地磁盘上的文件的，比如：\n\nliteflow.rule-source=/users/bryan31/liteflow/test/flow.xml\n\n\n但是当你本地规则文件改变了的情况下，你的项目是无法获知的，你只能通过手动刷新规则去实现热刷新(详细请阅读平滑热刷新)。\n\nliteflow从2.10.0开始，增加了对本地规则文件监听的特性。\n\n你只需要配置liteflow.enable-monitor-file=true，即可开启自动对文件的监听特性。文件改动，你的项目无需做任何事，立马自动刷新整个规则。非常方便。\n\n在各个环境中如何配置，前面的章节也提到过，详情请阅读配置项这一大章节。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍉组件参数",frontmatter:{title:"🍉组件参数",date:"2022-10-06T22:55:30.000Z",permalink:"/pages/v2.10.X/6e4d15/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/036.%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/036.组件参数.md",key:"v-be426776",path:"/pages/v2.10.X/6e4d15/",headersStr:null,content:'LiteFlow从v2.9.0开始支持了组件参数特性，你可以在EL语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是JSON格式：\n\n<flow>\n    <chain name="chain1">\n        cmpData = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        THEN(a, b.data(cmpData), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpData = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        WHEN(c, b.data(cmpData));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过getCmpData方法也能拿到相应的参数。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tUser user = this.getCmpData(User.class);\n\t\t...\n\t}\n\n}\n\n\n上述的例子中,如果参数长度等于1 :cmpData = \'3\',会转换成Character,可以改成用双引号包裹cmpData = "3"',normalizedContent:'liteflow从v2.9.0开始支持了组件参数特性，你可以在el语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是json格式：\n\n<flow>\n    <chain name="chain1">\n        cmpdata = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        then(a, b.data(cmpdata), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpdata = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        when(c, b.data(cmpdata));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过getcmpdata方法也能拿到相应的参数。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tuser user = this.getcmpdata(user.class);\n\t\t...\n\t}\n\n}\n\n\n上述的例子中,如果参数长度等于1 :cmpdata = \'3\',会转换成character,可以改成用双引号包裹cmpdata = "3"',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥠替补组件",frontmatter:{title:"🥠替补组件",date:"2022-07-27T00:07:01.000Z",permalink:"/pages/v2.10.X/79289a/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/035.%E6%9B%BF%E8%A1%A5%E7%BB%84%E4%BB%B6.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/035.替补组件.md",key:"v-01f634c7",path:"/pages/v2.10.X/79289a/",headersStr:null,content:'如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了A，B，C三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    THEN(A, B, C, D);\n</chain>\n\n\n由于D组件不存在，所以启动时会报错。\n\n替补组件的意义是，当你写了一个不存在的组件时，在解析时会自动解析到你指定的替补组件上，由这个替补组件来代替你不存在的组件来执行，这样就不会报错了。\n\n你需要在配置中指定你的替补组件：\n\nliteflow.substitute-cmp-class=com.yomahub.liteflow.test.substituteNode.cmp.SubCmp\n\n\n替补组件本身定义和其他的组件没有任何区别，如果在spring体系中，需要被注册到上下文，如果非spring环境，也需要在规则文件中定义。\n\n当你指定了替补组件后，你的规则文件需要这么写：\n\n<chain name="chain1">\n    THEN(A, B, C, node("D"));\n</chain>\n\n\n提示\n\n这里注意下，如果不加node关键字，不会自动路由到替补组件的，所以一定得加。',normalizedContent:'如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了a，b，c三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n由于d组件不存在，所以启动时会报错。\n\n替补组件的意义是，当你写了一个不存在的组件时，在解析时会自动解析到你指定的替补组件上，由这个替补组件来代替你不存在的组件来执行，这样就不会报错了。\n\n你需要在配置中指定你的替补组件：\n\nliteflow.substitute-cmp-class=com.yomahub.liteflow.test.substitutenode.cmp.subcmp\n\n\n替补组件本身定义和其他的组件没有任何区别，如果在spring体系中，需要被注册到上下文，如果非spring环境，也需要在规则文件中定义。\n\n当你指定了替补组件后，你的规则文件需要这么写：\n\n<chain name="chain1">\n    then(a, b, c, node("d"));\n</chain>\n\n\n提示\n\n这里注意下，如果不加node关键字，不会自动路由到替补组件的，所以一定得加。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍍组件标签",frontmatter:{title:"🍍组件标签",date:"2022-07-03T00:32:36.000Z",permalink:"/pages/v2.10.X/0f788f/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/050.%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/050.组件标签.md",key:"v-4379ce02",path:"/pages/v2.10.X/0f788f/",headersStr:null,content:'tag有2种用途：\n\n * 用于SWITCH语法的选择\n * 赋值\n\n关于SWITCH的选择tag标签内容请参考选择编排这一章。\n\n这章主要阐述tag标签的赋值功能。\n\n你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    THEN(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.getTag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        String tag = this.getTag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    THEN(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',normalizedContent:'tag有2种用途：\n\n * 用于switch语法的选择\n * 赋值\n\n关于switch的选择tag标签内容请参考选择编排这一章。\n\n这章主要阐述tag标签的赋值功能。\n\n你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    then(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.gettag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n    @override\n    public void process() {\n        string tag = this.gettag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    then(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍑组件别名",frontmatter:{title:"🍑组件别名",date:"2022-07-03T00:31:22.000Z",permalink:"/pages/v2.10.X/92ef89/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/040.%E7%BB%84%E4%BB%B6%E5%88%AB%E5%90%8D.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/040.组件别名.md",key:"v-47815516",path:"/pages/v2.10.X/92ef89/",headers:[{level:2,title:"Springboot & Spring 扫描方式",slug:"springboot-spring-扫描方式",normalizedTitle:"springboot &amp; spring 扫描方式",charIndex:null},{level:2,title:"规则文件方式定义组件",slug:"规则文件方式定义组件",normalizedTitle:"规则文件方式定义组件",charIndex:381},{level:2,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:49}],headersStr:"Springboot & Spring 扫描方式 规则文件方式定义组件 打印",content:'LiteFlow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# Springboot & Spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@Component换成@LiteflowComponent，并做如下定义：\n\n@LiteflowComponent(id = "a", name = "组件A")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件A" class="com.yomahub.liteflow.test.config.cmp.ACmp"/>\n<node id="b" name="组件B" class="com.yomahub.liteflow.test.config.cmp.BCmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',normalizedContent:'liteflow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# springboot & spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@component换成@liteflowcomponent，并做如下定义：\n\n@liteflowcomponent(id = "a", name = "组件a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件a" class="com.yomahub.liteflow.test.config.cmp.acmp"/>\n<node id="b" name="组件b" class="com.yomahub.liteflow.test.config.cmp.bcmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥝组件事件回调",frontmatter:{title:"🥝组件事件回调",date:"2022-07-03T00:41:09.000Z",permalink:"/pages/v2.10.X/3ee755/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/060.%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/060.组件事件回调.md",key:"v-220fd8c2",path:"/pages/v2.10.X/3ee755/",headers:[{level:2,title:"成功事件",slug:"成功事件",normalizedTitle:"成功事件",charIndex:31},{level:2,title:"失败事件",slug:"失败事件",normalizedTitle:"失败事件",charIndex:36},{level:3,title:"注意点1",slug:"注意点1",normalizedTitle:"注意点1",charIndex:842},{level:3,title:"注意点2",slug:"注意点2",normalizedTitle:"注意点2",charIndex:912},{level:3,title:"注意点3",slug:"注意点3",normalizedTitle:"注意点3",charIndex:1393}],headersStr:"成功事件 失败事件 注意点1 注意点2 注意点3",content:'LiteFlow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onSuccess方法，那么组件成功后会回调这个方法。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void onSuccess() throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onError方法，那么组件发生异常后会回调这个方法。\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError(Exception e) throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonError方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onError方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onError方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError(Exception e) throws Exception {\n\t\tthrow new IllegalAccessException("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是NullPointerException而不是IllegalAccessException，但是IllegalAccessException这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonError方法执行后，afterProcess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterProcess方法都会被执行。',normalizedContent:'liteflow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onsuccess方法，那么组件成功后会回调这个方法。\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void onsuccess() throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onerror方法，那么组件发生异常后会回调这个方法。\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror(exception e) throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonerror方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onerror方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onerror方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror(exception e) throws exception {\n\t\tthrow new illegalaccessexception("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是nullpointerexception而不是illegalaccessexception，但是illegalaccessexception这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonerror方法执行后，afterprocess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterprocess方法都会被执行。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥑隐式子流程",frontmatter:{title:"🥑隐式子流程",date:"2022-07-03T00:42:38.000Z",permalink:"/pages/v2.10.X/80e873/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/070.%E9%9A%90%E5%BC%8F%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/070.隐式子流程.md",key:"v-8df99436",path:"/pages/v2.10.X/80e873/",headersStr:null,content:'LiteFlow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@Component("h")\npublic class HComponent extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("Hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeInAsync方法。\n\n同样，隐式子流程也支持返回LiteFlowResponse对象，需要调用invoke2Resp方法，关于返回对象为LiteFlowResponse的说明，请参照LiteflowResponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getSubChainReqData()去拿。\n\n如果你是用invokeInAsync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getSubChainReqDataInAsync()去拿。\n\n用this.getRequestData()是拿不到的！',normalizedContent:'liteflow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@component("h")\npublic class hcomponent extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeinasync方法。\n\n同样，隐式子流程也支持返回liteflowresponse对象，需要调用invoke2resp方法，关于返回对象为liteflowresponse的说明，请参照liteflowresponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getsubchainreqdata()去拿。\n\n如果你是用invokeinasync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getsubchainreqdatainasync()去拿。\n\n用this.getrequestdata()是拿不到的！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍕私有投递",frontmatter:{title:"🍕私有投递",date:"2022-07-03T10:59:19.000Z",permalink:"/pages/v2.10.X/fbb938/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/080.%E7%A7%81%E6%9C%89%E6%8A%95%E9%80%92.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/080.私有投递.md",key:"v-1cd3027c",path:"/pages/v2.10.X/fbb938/",headers:[{level:2,title:"什么叫私有投递",slug:"什么叫私有投递",normalizedTitle:"什么叫私有投递",charIndex:21},{level:2,title:"解决方式",slug:"解决方式",normalizedTitle:"解决方式",charIndex:657}],headersStr:"什么叫私有投递 解决方式",content:'LiteFlow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个LiteFLow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        THEN(\n            a,\n            WHEN(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，LiteFlow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\tcontext.setData("testSet", new HashSet<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendPrivateDeliveryData("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendPrivateDeliveryData方法，指定了b组件\n\n然后我们再来看b组件：\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("BCmp executed!");\n\t\tInteger value = this.getPrivateDeliveryData();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getPrivateDeliveryData()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',normalizedContent:'liteflow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个liteflow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        then(\n            a,\n            when(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，liteflow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\tcontext.setdata("testset", new hashset<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendprivatedeliverydata("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendprivatedeliverydata方法，指定了b组件\n\n然后我们再来看b组件：\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("bcmp executed!");\n\t\tinteger value = this.getprivatedeliverydata();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getprivatedeliverydata()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣组件重试",frontmatter:{title:"🍣组件重试",date:"2022-07-03T11:03:09.000Z",permalink:"/pages/v2.10.X/7e9da1/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/090.%E7%BB%84%E4%BB%B6%E9%87%8D%E8%AF%95.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/090.组件重试.md",key:"v-ef2e77de",path:"/pages/v2.10.X/7e9da1/",headers:[{level:2,title:"全局重试",slug:"全局重试",normalizedTitle:"全局重试",charIndex:21},{level:2,title:"单个组件重试",slug:"单个组件重试",normalizedTitle:"单个组件重试",charIndex:26},{level:2,title:"全局重试和单个组件重试都定义的情况下",slug:"全局重试和单个组件重试都定义的情况下",normalizedTitle:"全局重试和单个组件重试都定义的情况下",charIndex:970}],headersStr:"全局重试 单个组件重试 全局重试和单个组件重试都定义的情况下",content:'LiteFLow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了isContinueOnError，设为true的话，那流程会继续。\n\n异步流程的话，如果WHEN上配置了ignoreError为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreError的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nLiteFlow还提供了基于单个组件，指定Exception的重试特性，LiteFlow从2.6.0开始提供了@LiteflowRetry标注\n\n你可以在指定的组件上进行标注：\n\n@LiteflowComponent("c")\n@LiteflowRetry(5)\npublic class CCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@LiteflowComponent("e")\n@LiteflowRetry(retry = 5, forExceptions = {NullPointerException.class,IllegalArgumentException.class})\npublic class ECmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是NullPointerException或者IllegalArgumentException（或者是这两个Exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',normalizedContent:'liteflow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了iscontinueonerror，设为true的话，那流程会继续。\n\n异步流程的话，如果when上配置了ignoreerror为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreerror的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nliteflow还提供了基于单个组件，指定exception的重试特性，liteflow从2.6.0开始提供了@liteflowretry标注\n\n你可以在指定的组件上进行标注：\n\n@liteflowcomponent("c")\n@liteflowretry(5)\npublic class ccmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@liteflowcomponent("e")\n@liteflowretry(retry = 5, forexceptions = {nullpointerexception.class,illegalargumentexception.class})\npublic class ecmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是nullpointerexception或者illegalargumentexception（或者是这两个exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍖平滑热刷新",frontmatter:{title:"🍖平滑热刷新",date:"2022-07-03T11:04:48.000Z",permalink:"/pages/v2.10.X/204d71/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/100.%E5%B9%B3%E6%BB%91%E7%83%AD%E5%88%B7%E6%96%B0.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/100.平滑热刷新.md",key:"v-1f8d82d2",path:"/pages/v2.10.X/204d71/",headers:[{level:2,title:"自动刷新的场景",slug:"自动刷新的场景",normalizedTitle:"自动刷新的场景",charIndex:147},{level:2,title:"主动调用代码刷新",slug:"主动调用代码刷新",normalizedTitle:"主动调用代码刷新",charIndex:333},{level:2,title:"单独刷新某一个规则",slug:"单独刷新某一个规则",normalizedTitle:"单独刷新某一个规则",charIndex:793}],headersStr:"自动刷新的场景 主动调用代码刷新 单独刷新某一个规则",content:'LiteFlow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\n\n\n# 自动刷新的场景\n\n如果你使用LiteFlow原生支持的zookeeper，etcd，nacos，apollo等插件（关于如何集成插件，请参考规则文件这一大章节），不需要你做任何事，只要规则更改之后，会自动热平滑刷新。\n\n\n如果你是基于本地磁盘规则文件的，并且开启了自动监听设置，那么更改流程后也会自动平滑刷新。关于如何开启自动监听，请参考本地规则文件监听这一章。\n\n\n# 主动调用代码刷新\n\n如果你使用了数据库作为规则文件的存储方式，或是你自己实现了自定义配置源，那么LiteFlow还提供了一种基于代码刷新的方式。\n\n\n你可以在spring容器中拿到FlowExecutor对象后，调用以下接口：\n\nflowExecutor.reloadRule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n这样调用有以下2点注意事项：\n\n提示\n\n1.这样刷新是全量刷新，不过各位同学不用担心其性能，经测试，LiteFlow框架一秒可以刷新1000条规则左右，这都是一些cpu级别的操作，如果你规则没有上大几千，几w条，那么推荐这种方式。\n\n2.如果你的应用是多节点部署的，必须在每个节点上都要刷新，因为规则是存储在jvm内存里的。这就意味着，如果你把刷新规则做成一个rpc接口（诸如dubbo接口之类的），那么rpc接口只会调用到其中一个节点，也就是说，只会有一个节点的规则会刷新。\n\n正确的做法是：利用mq发一个消息，让各个节点去监听到，进行刷新。\n\n\n\n# 单独刷新某一个规则\n\n如果你的规则比较多，成千上万条，又或者你就是不想全量刷新。希望单独刷新某个改动的规则。\n\n那么LiteFlow也提供了相应的方式。\n\n你可以利用以下api来进行刷新：\n\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n提示\n\n既然是指定刷新，那么必须你要获取到改动的EL内容，然后再利用动态代码构建重新build下就可以了，这种方式会自动替换缓存中已有的规则。这种方式不用在build之前销毁流程。\n\n如果是多服务节点部署的情况下，还是要遵循每个节点要都刷新，上面已经说明具体建议的方式。这里不再赘述。',normalizedContent:'liteflow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\n\n\n# 自动刷新的场景\n\n如果你使用liteflow原生支持的zookeeper，etcd，nacos，apollo等插件（关于如何集成插件，请参考规则文件这一大章节），不需要你做任何事，只要规则更改之后，会自动热平滑刷新。\n\n\n如果你是基于本地磁盘规则文件的，并且开启了自动监听设置，那么更改流程后也会自动平滑刷新。关于如何开启自动监听，请参考本地规则文件监听这一章。\n\n\n# 主动调用代码刷新\n\n如果你使用了数据库作为规则文件的存储方式，或是你自己实现了自定义配置源，那么liteflow还提供了一种基于代码刷新的方式。\n\n\n你可以在spring容器中拿到flowexecutor对象后，调用以下接口：\n\nflowexecutor.reloadrule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n这样调用有以下2点注意事项：\n\n提示\n\n1.这样刷新是全量刷新，不过各位同学不用担心其性能，经测试，liteflow框架一秒可以刷新1000条规则左右，这都是一些cpu级别的操作，如果你规则没有上大几千，几w条，那么推荐这种方式。\n\n2.如果你的应用是多节点部署的，必须在每个节点上都要刷新，因为规则是存储在jvm内存里的。这就意味着，如果你把刷新规则做成一个rpc接口（诸如dubbo接口之类的），那么rpc接口只会调用到其中一个节点，也就是说，只会有一个节点的规则会刷新。\n\n正确的做法是：利用mq发一个消息，让各个节点去监听到，进行刷新。\n\n\n\n# 单独刷新某一个规则\n\n如果你的规则比较多，成千上万条，又或者你就是不想全量刷新。希望单独刷新某个改动的规则。\n\n那么liteflow也提供了相应的方式。\n\n你可以利用以下api来进行刷新：\n\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n提示\n\n既然是指定刷新，那么必须你要获取到改动的el内容，然后再利用动态代码构建重新build下就可以了，这种方式会自动替换缓存中已有的规则。这种方式不用在build之前销毁流程。\n\n如果是多服务节点部署的情况下，还是要遵循每个节点要都刷新，上面已经说明具体建议的方式。这里不再赘述。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍪组件切面",frontmatter:{title:"🍪组件切面",date:"2022-07-03T11:07:26.000Z",permalink:"/pages/v2.10.X/2373f5/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/110.%E7%BB%84%E4%BB%B6%E5%88%87%E9%9D%A2.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/110.组件切面.md",key:"v-534f7b4e",path:"/pages/v2.10.X/2373f5/",headers:[{level:2,title:"全局切面",slug:"全局切面",normalizedTitle:"全局切面",charIndex:47},{level:2,title:"Aspect的切面",slug:"aspect的切面",normalizedTitle:"aspect的切面",charIndex:504}],headersStr:"全局切面 Aspect的切面",content:'LiteFlow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@Component\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //before business\n    }\n\n    @Override\n    public void afterProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //after business\n    }\n}\n\n\n\n# Aspect的切面\n\nLiteFlow同时也支持了Spring Aspect的切面，你可以用@Aspect标注对任意包，任意规则内的组件进行切面\n\n@Aspect\npublic class CustomAspect {\n\n    @Pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @Around("cut()")\n    public Object around(ProceedingJoinPoint jp) throws Throwable {\n        //do before business\n        Object returnObj = jp.proceed();\n        //do after business\n        return returnObj;\n    }\n}\n',normalizedContent:'liteflow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@component\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //before business\n    }\n\n    @override\n    public void afterprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //after business\n    }\n}\n\n\n\n# aspect的切面\n\nliteflow同时也支持了spring aspect的切面，你可以用@aspect标注对任意包，任意规则内的组件进行切面\n\n@aspect\npublic class customaspect {\n\n    @pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @around("cut()")\n    public object around(proceedingjoinpoint jp) throws throwable {\n        //do before business\n        object returnobj = jp.proceed();\n        //do after business\n        return returnobj;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧊异常",frontmatter:{title:"🧊异常",date:"2022-07-26T23:38:00.000Z",permalink:"/pages/v2.10.X/dc9bfe/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/125.%E5%BC%82%E5%B8%B8.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/125.异常.md",key:"v-6b3ce286",path:"/pages/v2.10.X/dc9bfe/",headersStr:null,content:'通常在LiteFlow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreError关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进LiteflowResponse对象中。\n\n你可以在LiteflowResponse对象中通过以下方法来获取异常\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n如果你的业务中有获取异常Code的需求，则你自定义的异常需要实现LiteFlow提供的LiteFlowException接口：\n\npublic class YourException extends LiteFlowException {\n\tpublic YourException(String code, String message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了LiteFlowException接口的异常，你则可以在LiteflowResponse中获得message和code信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n  String code = response.getCode();\n  String message = response.getMessage();\n}\n\n\n提示\n\n如果你的异常没实现LiteFlowException，code和message字段都为null。',normalizedContent:'通常在liteflow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreerror关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进liteflowresponse对象中。\n\n你可以在liteflowresponse对象中通过以下方法来获取异常\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n如果你的业务中有获取异常code的需求，则你自定义的异常需要实现liteflow提供的liteflowexception接口：\n\npublic class yourexception extends liteflowexception {\n\tpublic yourexception(string code, string message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了liteflowexception接口的异常，你则可以在liteflowresponse中获得message和code信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n  string code = response.getcode();\n  string message = response.getmessage();\n}\n\n\n提示\n\n如果你的异常没实现liteflowexception，code和message字段都为null。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧇打印信息详解",frontmatter:{title:"🧇打印信息详解",date:"2022-07-03T11:12:19.000Z",permalink:"/pages/v2.10.X/4d614c/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/130.%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/130.打印信息详解.md",key:"v-69816759",path:"/pages/v2.10.X/4d614c/",headers:[{level:2,title:"流程执行中打印",slug:"流程执行中打印",normalizedTitle:"流程执行中打印",charIndex:2},{level:2,title:"打印步骤信息",slug:"打印步骤信息",normalizedTitle:"打印步骤信息",charIndex:558}],headersStr:"流程执行中打印 打印步骤信息",content:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[ACmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[BCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[X]start component[CCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[DCmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求ID，一个请求无论经历了多少个组件，他们的请求ID都是一致的，你可以根据这个ID在日志中进行快速定位进行排查。\n\n在后面会跟着一个[O]或者[X]，[O]代表了执行了这个组件的主要逻辑，[X]代表因为isAccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，LiteFlow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件ID<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件A]<100>==>b[组件B]<0>==>m[组件M]<256>\n\n\n这里的表达形式为：组件ID[组件别名]<耗时毫秒>",normalizedContent:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[acmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[bcmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[x]start component[ccmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[dcmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求id，一个请求无论经历了多少个组件，他们的请求id都是一致的，你可以根据这个id在日志中进行快速定位进行排查。\n\n在后面会跟着一个[o]或者[x]，[o]代表了执行了这个组件的主要逻辑，[x]代表因为isaccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，liteflow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件id<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件a]<100>==>b[组件b]<0>==>m[组件m]<256>\n\n\n这里的表达形式为：组件id[组件别名]<耗时毫秒>",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧁自定义请求Id",frontmatter:{title:"🧁自定义请求Id",date:"2022-07-03T11:12:53.000Z",permalink:"/pages/v2.10.X/47e8f5/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/140.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82Id.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/140.自定义请求Id.md",key:"v-778d22f4",path:"/pages/v2.10.X/47e8f5/",headers:[{level:2,title:"按照自己的规则生成",slug:"按照自己的规则生成",normalizedTitle:"按照自己的规则生成",charIndex:1149},{level:2,title:"传入已有的requestId/traceId",slug:"传入已有的requestid-traceid",normalizedTitle:"传入已有的requestid/traceid",charIndex:1594},{level:2,title:"给组件中的日志也加上请求ID前缀",slug:"给组件中的日志也加上请求id前缀",normalizedTitle:"给组件中的日志也加上请求id前缀",charIndex:1852}],headersStr:"按照自己的规则生成 传入已有的requestId/traceId 给组件中的日志也加上请求ID前缀",content:'LiteFlow支持让你自定义你的请求Id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[a] execution\n2022-07-03 11:15:00.204  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[b] execution\n2022-07-03 11:15:00.218  INFO 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[c] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[d] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [           main] com.yomahub.liteflow.slot.Slot           : [067a0baa6d434de3a8ccafa4b1506562]:CHAIN_NAME[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  INFO 71275 --- [           main] com.yomahub.liteflow.slot.DataBus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是RequestId，一个请求中的requestId都是相同的，方便你进行日志查找。\n\n这个requestId的形式也是可以自定义的。你可以按照自己的规则生成，也可以传入本来已有的TraceId来和系统做集成。\n\n\n# 按照自己的规则生成\n\n你只需要要声明一个类，然后实现RequestIdGenerator接口即可：\n\npublic class CustomRequestIdGenerator implements RequestIdGenerator {\n\n    @Override\n    public String generate() {\n        return System.nanoTime();\n    }\n}\n\n\n然后在LiteFlow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestId.config.CustomRequestIdGenerator\n\n\n一般情况下，LiteFlow有自己默认的Id生成规则。所以大多数情况下你并不需要去特别自定义这个Id生成器。\n\n\n# 传入已有的requestId/traceId\n\nLiteFlow在v2.10.5版本中对于这个特性给予了支持。在FlowExecutor进行调用的时候，你可以调用如下方法来传入一个已有的requestId：\n\nLiteflowResponse response = flowExecutor.execute2RespWithRid("chain1", arg, "T001234", YourContext.class);\n\n\n那么，这个链路中所有的框架日志前，都会带有[T001234]这个传入的ID了。\n\n\n# 给组件中的日志也加上请求ID前缀\n\n值得一提的是，LiteFlow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求ID前缀。\n\nprivate final LFLog logger = LFLoggerManager.getLogger(FlowExecutor.class);\n\n\n其中LFLog这个类是继承自slf4j的Logger类的，所以它的使用方式和Logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求ID，那么对于定位问题来说，会很方便。推荐大家使用此特性。',normalizedContent:'liteflow支持让你自定义你的请求id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[a] execution\n2022-07-03 11:15:00.204  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[b] execution\n2022-07-03 11:15:00.218  info 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[c] execution\n2022-07-03 11:15:00.220  info 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[d] execution\n2022-07-03 11:15:00.220  info 71275 --- [           main] com.yomahub.liteflow.slot.slot           : [067a0baa6d434de3a8ccafa4b1506562]:chain_name[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  info 71275 --- [           main] com.yomahub.liteflow.slot.databus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是requestid，一个请求中的requestid都是相同的，方便你进行日志查找。\n\n这个requestid的形式也是可以自定义的。你可以按照自己的规则生成，也可以传入本来已有的traceid来和系统做集成。\n\n\n# 按照自己的规则生成\n\n你只需要要声明一个类，然后实现requestidgenerator接口即可：\n\npublic class customrequestidgenerator implements requestidgenerator {\n\n    @override\n    public string generate() {\n        return system.nanotime();\n    }\n}\n\n\n然后在liteflow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestid.config.customrequestidgenerator\n\n\n一般情况下，liteflow有自己默认的id生成规则。所以大多数情况下你并不需要去特别自定义这个id生成器。\n\n\n# 传入已有的requestid/traceid\n\nliteflow在v2.10.5版本中对于这个特性给予了支持。在flowexecutor进行调用的时候，你可以调用如下方法来传入一个已有的requestid：\n\nliteflowresponse response = flowexecutor.execute2respwithrid("chain1", arg, "t001234", yourcontext.class);\n\n\n那么，这个链路中所有的框架日志前，都会带有[t001234]这个传入的id了。\n\n\n# 给组件中的日志也加上请求id前缀\n\n值得一提的是，liteflow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求id前缀。\n\nprivate final lflog logger = lfloggermanager.getlogger(flowexecutor.class);\n\n\n其中lflog这个类是继承自slf4j的logger类的，所以它的使用方式和logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求id，那么对于定位问题来说，会很方便。推荐大家使用此特性。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍡步骤信息",frontmatter:{title:"🍡步骤信息",date:"2022-07-03T11:09:40.000Z",permalink:"/pages/v2.10.X/e5ed0d/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/120.%E6%AD%A5%E9%AA%A4%E4%BF%A1%E6%81%AF.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/120.步骤信息.md",key:"v-b8a34636",path:"/pages/v2.10.X/e5ed0d/",headersStr:null,content:'LiteFlow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过LiteflowResponse对象来获取的：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "初始参数", CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得Map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的Map中这个组件id的value是最终的那个步骤信息。\n\n而获得Queue<CmpStep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在CmpStep这个对象里，你可以通过以下方法获得你要的数据：\n\n * isSuccess：此组件是否执行成功\n * getNodeId：获得组件Id\n * getNodeName：获得组件名称\n * getTag：获得组件标签值\n * getTimeSpent：获得组件的耗时，单位为毫秒\n * getException：获取此组件抛出的异常，如果isSuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getCause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',normalizedContent:'liteflow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过liteflowresponse对象来获取的：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "初始参数", customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的map中这个组件id的value是最终的那个步骤信息。\n\n而获得queue<cmpstep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在cmpstep这个对象里，你可以通过以下方法获得你要的数据：\n\n * issuccess：此组件是否执行成功\n * getnodeid：获得组件id\n * getnodename：获得组件名称\n * gettag：获得组件标签值\n * gettimespent：获得组件的耗时，单位为毫秒\n * getexception：获取此组件抛出的异常，如果issuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getcause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥗异步线程池自定义",frontmatter:{title:"🥗异步线程池自定义",date:"2022-07-03T11:21:39.000Z",permalink:"/pages/v2.10.X/7280ea/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/160.%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%87%AA%E5%AE%9A%E4%B9%89.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/160.异步线程池自定义.md",key:"v-3ca62d9a",path:"/pages/v2.10.X/7280ea/",headers:[{level:2,title:"默认全局线程池",slug:"默认全局线程池",normalizedTitle:"默认全局线程池",charIndex:2},{level:2,title:"自定义全局线程池",slug:"自定义全局线程池",normalizedTitle:"自定义全局线程池",charIndex:157},{level:2,title:"WHEN级别的单独线程池",slug:"when级别的单独线程池",normalizedTitle:"when级别的单独线程池",charIndex:1134},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1940}],headersStr:"默认全局线程池 自定义全局线程池 WHEN级别的单独线程池 优先级",content:'# 默认全局线程池\n\nLiteFlow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，LiteFlow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的Builder：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n\n\n然后把你的Builder加入LiteFlow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n\t<property name="ruleSource" value="customThreadPool/flow.el.xml"/>\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n  <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n这样，LiteFlow在启动的时候就会自动通过你声明的Builder加载到自定义的线程池了。\n\n\n# WHEN级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    WHEN(a, b);\n</chain>\n\n<chain name="chain2">\n    WHEN(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class CustomThreadExecutor1 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class CustomThreadExecutor2 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    WHEN(a, b).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor1");\n</chain>\n<chain name="chain2">\n    WHEN(c, d).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和Condition都配置自定义线程池的情况下，优先使用Condition上配置的线程池。',normalizedContent:'# 默认全局线程池\n\nliteflow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，liteflow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的builder：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n\n\n然后把你的builder加入liteflow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n\t<property name="rulesource" value="customthreadpool/flow.el.xml"/>\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.test.customthreadpool.customthreadbuilder"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n  <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n这样，liteflow在启动的时候就会自动通过你声明的builder加载到自定义的线程池了。\n\n\n# when级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    when(a, b);\n</chain>\n\n<chain name="chain2">\n    when(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class customthreadexecutor1 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class customthreadexecutor2 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    when(a, b).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor1");\n</chain>\n<chain name="chain2">\n    when(c, d).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和condition都配置自定义线程池的情况下，优先使用condition上配置的线程池。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌭不同格式规则加载",frontmatter:{title:"🌭不同格式规则加载",date:"2022-07-03T11:20:47.000Z",permalink:"/pages/v2.10.X/a7e02e/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/150.%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99%E5%8A%A0%E8%BD%BD.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/150.不同格式规则加载.md",key:"v-4c2fc162",path:"/pages/v2.10.X/a7e02e/",headersStr:null,content:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipleType/flow.el.xml,multipleType/flow.el.json\n\n\n这种模式在正常下会解析失败，但是LiteFLow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",normalizedContent:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipletype/flow.el.xml,multipletype/flow.el.json\n\n\n这种模式在正常下会解析失败，但是liteflow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍿自定义组件执行器",frontmatter:{title:"🍿自定义组件执行器",date:"2022-07-03T11:24:54.000Z",permalink:"/pages/v2.10.X/46bbed/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/170.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/170.自定义组件执行器.md",key:"v-7cb188a6",path:"/pages/v2.10.X/46bbed/",headers:[{level:2,title:"全局组件执行器",slug:"全局组件执行器",normalizedTitle:"全局组件执行器",charIndex:130},{level:2,title:"单个组件配置特殊的执行器",slug:"单个组件配置特殊的执行器",normalizedTitle:"单个组件配置特殊的执行器",charIndex:755},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1147},{level:2,title:"自定义执行器对于重试功能的影响",slug:"自定义执行器对于重试功能的影响",normalizedTitle:"自定义执行器对于重试功能的影响",charIndex:1196}],headersStr:"全局组件执行器 单个组件配置特殊的执行器 优先级 自定义执行器对于重试功能的影响",content:'LiteFlow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeExecutor.CustomerDefaultNodeExecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.NodeExecutor。\n\npublic class CustomerDefaultNodeExecutor extends NodeExecutor {\n    @Override\n    public void execute(NodeComponent instance) throws Exception {\n        LOG.info("使用customerDefaultNodeExecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getNodeExecutorClass 方法：\n\n@LiteflowComponent("d")\npublic class DCmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        System.out.println("DCmp executed!");\n    }\n\n    @Override\n    public Class<? extends NodeExecutor> getNodeExecutorClass() {\n        return CustomerNodeExecutorAndCustomRetry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@LiteflowRetry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',normalizedContent:'liteflow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeexecutor.customerdefaultnodeexecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.nodeexecutor。\n\npublic class customerdefaultnodeexecutor extends nodeexecutor {\n    @override\n    public void execute(nodecomponent instance) throws exception {\n        log.info("使用customerdefaultnodeexecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getnodeexecutorclass 方法：\n\n@liteflowcomponent("d")\npublic class dcmp extends nodecomponent {\n\n    @override\n    public void process() {\n        system.out.println("dcmp executed!");\n    }\n\n    @override\n    public class<? extends nodeexecutor> getnodeexecutorclass() {\n        return customernodeexecutorandcustomretry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@liteflowretry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧉XML的DTD",frontmatter:{title:"🧉XML的DTD",date:"2022-10-24T12:50:29.000Z",permalink:"/pages/v2.10.X/0066ae/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/190.XML%E7%9A%84DTD.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/190.XML的DTD.md",key:"v-58c1192e",path:"/pages/v2.10.X/0066ae/",headersStr:null,content:'LiteFlow从2.9.1版本起，对XML增加了DTD，方便在XML里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE flow PUBLIC  "liteflow" "liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        THEN(a,b,WHEN(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为LiteFlow xml节点非常简单，并没有很多的节点标签需要记忆。',normalizedContent:'liteflow从2.9.1版本起，对xml增加了dtd，方便在xml里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype flow public  "liteflow" "liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        then(a,b,when(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为liteflow xml节点非常简单，并没有很多的节点标签需要记忆。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍥简单监控",frontmatter:{title:"🍥简单监控",date:"2022-07-03T11:25:52.000Z",permalink:"/pages/v2.10.X/e59f3a/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/180.%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7.html",relativePath:"09.v2.10.X文档/100.🎨高级特性/180.简单监控.md",key:"v-18a455a2",path:"/pages/v2.10.X/e59f3a/",headersStr:null,content:"LiteFlow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",normalizedContent:"liteflow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪂性能表现",frontmatter:{title:"🪂性能表现",date:"2022-07-03T11:32:51.000Z",permalink:"/pages/v2.10.X/9bf839/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/120.%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0.html",relativePath:"09.v2.10.X文档/120.性能表现.md",key:"v-173c1703",path:"/pages/v2.10.X/9bf839/",headersStr:null,content:"LiteFlow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，LiteFlow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的TPS，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然LiteFlow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求IO，或者有bad sql，又或者有大量的rpc同步调用。那实际TPS也不会很高。但是这是业务组件的的问题，而不是LiteFlow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的TPS/QPS，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nLiteFlow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库IO。\n\n基于这个Demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",normalizedContent:"liteflow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，liteflow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的tps，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然liteflow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求io，或者有bad sql，又或者有大量的rpc同步调用。那实际tps也不会很高。但是这是业务组件的的问题，而不是liteflow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的tps/qps，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nliteflow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库io。\n\n基于这个demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪀DEMO案例",frontmatter:{title:"🪀DEMO案例",date:"2022-07-03T11:32:24.000Z",permalink:"/pages/v2.10.X/0a8188/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/020.DEMO%E6%A1%88%E4%BE%8B.html",relativePath:"09.v2.10.X文档/110.⛱测试用例以及示例/020.DEMO案例.md",key:"v-1c465c36",path:"/pages/v2.10.X/0a8188/",headers:[{level:2,title:"DEMO案例1",slug:"demo案例1",normalizedTitle:"demo案例1",charIndex:38},{level:2,title:"DEMO案例2",slug:"demo案例2",normalizedTitle:"demo案例2",charIndex:131},{level:2,title:"外置规则存储案例",slug:"外置规则存储案例",normalizedTitle:"外置规则存储案例",charIndex:217}],headersStr:"DEMO案例1 DEMO案例2 外置规则存储案例",content:"如果你想看一个实际的案例，加深对LiteFlow的理解。可以查看：\n\n\n# DEMO案例1\n\n> DEMO案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的Java业务！\n\n\n# DEMO案例2\n\n> DEMO案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到DB里，或者zk/nacos/etcd里，此案例为一个简单的DEMO，你可以根据此案例的演示来进行接入。",normalizedContent:"如果你想看一个实际的案例，加深对liteflow的理解。可以查看：\n\n\n# demo案例1\n\n> demo案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的java业务！\n\n\n# demo案例2\n\n> demo案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到db里，或者zk/nacos/etcd里，此案例为一个简单的demo，你可以根据此案例的演示来进行接入。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪁测试用例",frontmatter:{title:"🪁测试用例",date:"2022-07-03T11:28:26.000Z",permalink:"/pages/v2.10.X/81cdce/"},regularPath:"/09.v2.10.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/010.%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",relativePath:"09.v2.10.X文档/110.⛱测试用例以及示例/010.测试用例.md",key:"v-6712db4c",path:"/pages/v2.10.X/81cdce/",headersStr:null,content:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有900多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解LiteFlow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于Groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于QLExpress脚本框架的测试用例\n * liteflow-testcase-el-script-javascript-springboot: 基于JavaScript脚本框架的测试用例\n * liteflow-testcase-el-script-graaljs-springboot: 基于JavaScript脚本(graaljs实现，支持jdk17)框架的测试用例\n * liteflow-testcase-el-script-python-springboot: 基于Python脚本框架的测试用例\n * liteflow-testcase-el-script-lua-springboot: 基于Lua脚本框架的测试用例\n * liteflow-testcase-el-script-multi-language-springboot: 多脚本共存的测试用例\n * liteflow-testcase-el-zk-springboot: ZK配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: SQL数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: Nacos配置源场景下的测试用例\n * liteflow-testcase-el-apollo-springboot: Apollo配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: Etcd配置源场景下的测试用例",normalizedContent:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有900多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解liteflow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于qlexpress脚本框架的测试用例\n * liteflow-testcase-el-script-javascript-springboot: 基于javascript脚本框架的测试用例\n * liteflow-testcase-el-script-graaljs-springboot: 基于javascript脚本(graaljs实现，支持jdk17)框架的测试用例\n * liteflow-testcase-el-script-python-springboot: 基于python脚本框架的测试用例\n * liteflow-testcase-el-script-lua-springboot: 基于lua脚本框架的测试用例\n * liteflow-testcase-el-script-multi-language-springboot: 多脚本共存的测试用例\n * liteflow-testcase-el-zk-springboot: zk配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: sql数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: nacos配置源场景下的测试用例\n * liteflow-testcase-el-apollo-springboot: apollo配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: etcd配置源场景下的测试用例",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍓项目特性",frontmatter:{title:"🍓项目特性",date:"2022-06-01T21:13:18.000Z",permalink:"/pages/v2.9.X/724bc3/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/020.%E9%A1%B9%E7%9B%AE%E7%89%B9%E6%80%A7.html",relativePath:"10.v2.9.X文档/020.项目特性.md",key:"v-1ca17a9a",path:"/pages/v2.9.X/724bc3/",headersStr:null,content:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，Nacos，Etcd，Zookeeper，Apollo。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持Groovy，Javascript,QLExpress，Python，Lua。未来还会支持更多的脚本语言。\n * 脚本和Java全打通： 所有脚本语言均可调用Java方法，甚至于可以引用任意的实例，在脚本中调用RPC也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",normalizedContent:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 再复杂的逻辑过程，利用liteflow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则持久化： 框架原生支持把规则存储在标准结构化数据库，nacos，etcd，zookeeper，apollo。您也可以自己扩展，把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持groovy，javascript,qlexpress，python，lua。未来还会支持更多的脚本语言。\n * 脚本和java全打通： 所有脚本语言均可调用java方法，甚至于可以引用任意的实例，在脚本中调用rpc也是支持的。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:49:31.000Z",permalink:"/pages/v2.9.X/631fa1/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/005.%E8%AF%B4%E6%98%8E.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/005.说明.md",key:"v-7f5f767c",path:"/pages/v2.9.X/631fa1/",headersStr:null,content:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验LiteFlow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的Hello World里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到LiteFlow的优雅之处。",normalizedContent:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验liteflow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的hello world里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到liteflow的优雅之处。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.9.X/df6982/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md",key:"v-2d84a4c2",path:"/pages/v2.9.X/df6982/",headersStr:null,content:"LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring-boot-starter</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"liteflow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring-boot-starter</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍤LiteFlow简介",frontmatter:{title:"🍤LiteFlow简介",date:"2022-06-16T17:51:48.000Z",permalink:"/pages/v2.9.X/5816c5/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/010.LiteFlow%E7%AE%80%E4%BB%8B.html",relativePath:"10.v2.9.X文档/010.LiteFlow简介.md",key:"v-efb3dfca",path:"/pages/v2.9.X/5816c5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"LiteFlow框架的优势",slug:"liteflow框架的优势",normalizedTitle:"liteflow框架的优势",charIndex:390},{level:2,title:"LiteFlow的设计原则",slug:"liteflow的设计原则",normalizedTitle:"liteflow的设计原则",charIndex:934},{level:2,title:"LiteFlow不适用于哪些场景",slug:"liteflow不适用于哪些场景",normalizedTitle:"liteflow不适用于哪些场景",charIndex:1524},{level:2,title:"LiteFlow适用于哪些场景",slug:"liteflow适用于哪些场景",normalizedTitle:"liteflow适用于哪些场景",charIndex:1698}],headersStr:"前言 LiteFlow框架的优势 LiteFlow的设计原则 LiteFlow不适用于哪些场景 LiteFlow适用于哪些场景",content:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nLiteFlow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# LiteFlow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用LiteFlow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。LiteFlow拥有开源规则引擎最为简单的DSL语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nLiteFlow的脚本组件，支持众多脚本语言，完全和Java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nLiteFlow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用LiteFlow，轻而易举，你立马唾手可得！\n\n\n# LiteFlow的设计原则\n\nLiteFlow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。\n\n\n# LiteFlow不适用于哪些场景\n\nLiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。\n\n提示\n\n这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# LiteFlow适用于哪些场景\n\nLiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",normalizedContent:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统rpc调用等等。时间一长，项目几经易手，维护成本就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？liteflow为解耦逻辑而生，为编排而生，在使用liteflow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\nliteflow是一个非常强大的现代化的规则引擎框架，融合了编排特性和规则引擎的所有特性。\n\n\n# liteflow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用liteflow最合适不过。它是一个编排式的规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件。\n\n\n\n\n\n利用liteflow，你可以将瀑布流式的代码，转变成以组件为核心概念的代码结构，这种结构的好处是可以任意编排，组件与组件之间是解耦的，组件可以用脚本来定义，组件之间的流转全靠规则来驱动。liteflow拥有开源规则引擎最为简单的dsl语法。十分钟就可上手。\n\n\n\n\n\n组件可实时热更替，也可以给编排好的逻辑流里实时增加一个组件，从而改变你的业务逻辑。\n\n\n\n\n\nliteflow的脚本组件，支持众多脚本语言，完全和java打通，你可以用脚本来实现任何逻辑。\n\n\n\n\n\nliteflow支持把编排规则和脚本放在数据库，注册中心中，还有可以任意扩展的接口，方便你定制。\n\n我们的编排语法强大到可以编排出任何你想要的逻辑流程，你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用liteflow，轻而易举，你立马唾手可得！\n\n\n# liteflow的设计原则\n\nliteflow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到liteflow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以liteflow能做到统一解耦的组件和灵活的装配。\n\n\n# liteflow不适用于哪些场景\n\nliteflow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，a审批完应该是b审批，然后再流转到c角色。\n\n提示\n\n这里申明下，liteflow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# liteflow适用于哪些场景\n\nliteflow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用liteflow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.9.X/9f4489/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md",key:"v-22ef70cc",path:"/pages/v2.9.X/9f4489/",headersStr:null,content:'声明启动类：\n\n@SpringBootApplication\n//把你定义的组件扫入Spring上下文中\n@ComponentScan({"com.xxx.xxx.cmp"})\npublic class LiteflowExampleApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(LiteflowExampleApplication.class, args);\n    }\n}\n\n\n然后你就可以在Springboot任意被Spring托管的类中拿到flowExecutor，进行执行链路：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'声明启动类：\n\n@springbootapplication\n//把你定义的组件扫入spring上下文中\n@componentscan({"com.xxx.xxx.cmp"})\npublic class liteflowexampleapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(liteflowexampleapplication.class, args);\n    }\n}\n\n\n然后你就可以在springboot任意被spring托管的类中拿到flowexecutor，进行执行链路：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.9.X/82ef41/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md",key:"v-078be602",path:"/pages/v2.9.X/82ef41/",headers:[{level:2,title:"组件的定义",slug:"组件的定义",normalizedTitle:"组件的定义",charIndex:2},{level:2,title:"SpringBoot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:453},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:620}],headersStr:"组件的定义 SpringBoot配置文件 规则文件的定义",content:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文。\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# SpringBoot配置文件\n\n然后，在你的SpringBoot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c);\n    </chain>\n</flow>\n\n\nSpringBoot在启动时会自动装载规则文件。',normalizedContent:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保springboot会扫描到这些组件并注册进上下文。\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# springboot配置文件\n\n然后，在你的springboot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c);\n    </chain>\n</flow>\n\n\nspringboot在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.9.X/495f21/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md",key:"v-14b837d0",path:"/pages/v2.9.X/495f21/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"Spring xml中的配置",slug:"spring-xml中的配置",normalizedTitle:"spring xml中的配置",charIndex:452},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:1155}],headersStr:"定义你的组件 Spring xml中的配置 规则文件的定义",content:'# 定义你的组件\n\n你需要定义并实现一些组件，确保Spring会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# Spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springAware" class="com.yomahub.liteflow.spi.spring.SpringAware"/>\n\n<bean class="com.yomahub.liteflow.spring.ComponentScanner"/>\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\x3c!-- 如果上述enableLog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.MonitorBus">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c)\n    </chain>\n</flow>\n\n\nSpring在启动时会自动装载规则文件。',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件，确保spring会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springaware" class="com.yomahub.liteflow.spi.spring.springaware"/>\n\n<bean class="com.yomahub.liteflow.spring.componentscanner"/>\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\x3c!-- 如果上述enablelog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.monitorbus">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c)\n    </chain>\n</flow>\n\n\nspring在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.9.X/0a4573/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md",key:"v-402e1f5b",path:"/pages/v2.9.X/0a4573/",headersStr:null,content:"针对于使用了Spring但没有使用SpringBoot的项目\n\n<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring</artifactId>\n\t<version>2.9.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"针对于使用了spring但没有使用springboot的项目\n\n<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring</artifactid>\n\t<version>2.9.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.9.X/522432/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E8%AF%B4%E6%98%8E.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md",key:"v-27124f30",path:"/pages/v2.9.X/522432/",headersStr:null,content:"虽说Springboot/Spring已经成为了Java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合Spring我始终觉得是瑕疵，有点代码洁癖），现在在非Spring体系的环境中也能使用LiteFlow框架带来的便捷和高效。\n\nLiteFlow文档中提到的98%以上的特性功能都能在非Spring体系中生效。其中不生效的特性和功能有：\n\n * ruleSource的模糊路径匹配特性在非Spring体系下不生效\n * LiteflowComponent在非Spring体系下无法使用\n * 监控功能在非Spring体系中无法使用",normalizedContent:"虽说springboot/spring已经成为了java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合spring我始终觉得是瑕疵，有点代码洁癖），现在在非spring体系的环境中也能使用liteflow框架带来的便捷和高效。\n\nliteflow文档中提到的98%以上的特性功能都能在非spring体系中生效。其中不生效的特性和功能有：\n\n * rulesource的模糊路径匹配特性在非spring体系下不生效\n * liteflowcomponent在非spring体系下无法使用\n * 监控功能在非spring体系中无法使用",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-02T19:49:57.000Z",permalink:"/pages/v2.9.X/0e0fb5/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md",key:"v-050f5b36",path:"/pages/v2.9.X/0e0fb5/",headersStr:null,content:'和SpringBoot的执行方式一样，没有任何区别，你可以在你的任何受Spring托管的类里注入FlowExecutor进行执行：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'和springboot的执行方式一样，没有任何区别，你可以在你的任何受spring托管的类里注入flowexecutor进行执行：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.9.X/249d17/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E9%85%8D%E7%BD%AE.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md",key:"v-2e12cd9d",path:"/pages/v2.9.X/249d17/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"规则文件的配置",slug:"规则文件的配置",normalizedTitle:"规则文件的配置",charIndex:381}],headersStr:"定义你的组件 规则文件的配置",content:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.AComponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.BComponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.CComponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tTHEN(a, b, c);\n\t</chain>\n</flow>\n',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.acomponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.bcomponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.ccomponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tthen(a, b, c);\n\t</chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-06T23:15:50.000Z",permalink:"/pages/v2.9.X/151524/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/040.%E6%89%A7%E8%A1%8C.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md",key:"v-6685dc6a",path:"/pages/v2.9.X/151524/",headers:[{level:2,title:"初始化你的FlowExecutor执行器",slug:"初始化你的flowexecutor执行器",normalizedTitle:"初始化你的flowexecutor执行器",charIndex:2},{level:2,title:"用FlowExecutor执行",slug:"用flowexecutor执行",normalizedTitle:"用flowexecutor执行",charIndex:331}],headersStr:"初始化你的FlowExecutor执行器 用FlowExecutor执行",content:'# 初始化你的FlowExecutor执行器\n\n通过以下代码你可以轻易的初始化FlowExecutor处理器：\n\nLiteflowConfig config = new LiteflowConfig();\nconfig.setRuleSource("config/flow.el.xml");\nFlowExecutor flowExecutor = FlowExecutorHolder.loadInstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化FlowExecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用FlowExecutor执行\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'# 初始化你的flowexecutor执行器\n\n通过以下代码你可以轻易的初始化flowexecutor处理器：\n\nliteflowconfig config = new liteflowconfig();\nconfig.setrulesource("config/flow.el.xml");\nflowexecutor flowexecutor = flowexecutorholder.loadinstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化flowexecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用flowexecutor执行\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.9.X/8760c4/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E4%BE%9D%E8%B5%96.html",relativePath:"10.v2.9.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md",key:"v-43114340",path:"/pages/v2.9.X/8760c4/",headersStr:null,content:"<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-core</artifactId>\n\t<version>2.9.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-core</artifactid>\n\t<version>2.9.7</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring下的配置项",frontmatter:{title:"🌱Spring下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.9.X/33833a/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/030.Spring%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"10.v2.9.X文档/040.🍢配置项/030.Spring下的配置项.md",key:"v-23aeb7c2",path:"/pages/v2.9.X/33833a/",headersStr:null,content:'<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printBanner" value="true"/> \n    \x3c!-- zkNode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zkNode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotSize" value="1024"/> \n    \x3c!-- FlowExecutor的execute2Future的线程数，默认为64 --\x3e\n    <property name="mainExecutorWorks" value="64"/> \n    \x3c!-- FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="mainExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder"/>\n    \x3c!-- 自定义请求ID的生成类，LiteFlow提供了默认的生成类 --\x3e\n    <property name="requestIdGeneratorClass" value="com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator"/>\n    \x3c!-- 并行节点的线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder"/> \n    \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为15 --\x3e\n    <property name="whenMaxWaitSeconds" value="15"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenMaxWorkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenQueueLimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseOnStart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retryCount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportMultipleType" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeExecutorClass" value="com.yomahub.liteflow.flow.executor.DefaultNodeExecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printExecutionLog" value="true"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enableLog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queueLimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printbanner" value="true"/> \n    \x3c!-- zknode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zknode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotsize" value="1024"/> \n    \x3c!-- flowexecutor的execute2future的线程数，默认为64 --\x3e\n    <property name="mainexecutorworks" value="64"/> \n    \x3c!-- flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="mainexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder"/>\n    \x3c!-- 自定义请求id的生成类，liteflow提供了默认的生成类 --\x3e\n    <property name="requestidgeneratorclass" value="com.yomahub.liteflow.flow.id.defaultrequestidgenerator"/>\n    \x3c!-- 并行节点的线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder"/> \n    \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为15 --\x3e\n    <property name="whenmaxwaitseconds" value="15"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenmaxworkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenqueuelimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseonstart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retrycount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportmultipletype" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeexecutorclass" value="com.yomahub.liteflow.flow.executor.defaultnodeexecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printexecutionlog" value="true"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enablelog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queuelimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-06T21:42:12.000Z",permalink:"/pages/v2.9.X/b70ec8/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/010.%E8%AF%B4%E6%98%8E.html",relativePath:"10.v2.9.X文档/040.🍢配置项/010.说明.md",key:"v-e76eefa2",path:"/pages/v2.9.X/b70ec8/",headersStr:null,content:"LiteFlow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",normalizedContent:"liteflow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot下的配置项",frontmatter:{title:"🌿Springboot下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.9.X/4594ec/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/020.Springboot%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"10.v2.9.X文档/040.🍢配置项/020.Springboot下的配置项.md",key:"v-2eb8bbff",path:"/pages/v2.9.X/4594ec/",headersStr:null,content:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zkNode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#FlowExecutor的execute2Future的线程数，默认为64\nliteflow.main-executor-works=64\n#FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n#自定义请求ID的生成类，LiteFlow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n#并行节点的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为15\nliteflow.when-max-wait-seconds=15\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #FlowExecutor的execute2Future的线程数，默认为64\n  main-executor-works: 64\n  #FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\n  main-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n  #自定义请求ID的生成类，LiteFlow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n  #并行节点的线程池Builder，LiteFlow提供了默认的Builder\n  thread-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n  #异步线程最长的等待时间秒(只用于when)，默认值为15\n  when-max-wait-seconds: 15\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",normalizedContent:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zknode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#flowexecutor的execute2future的线程数，默认为64\nliteflow.main-executor-works=64\n#flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n#自定义请求id的生成类，liteflow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n#并行节点的线程池builder，liteflow提供了默认的builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为15\nliteflow.when-max-wait-seconds=15\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #flowexecutor的execute2future的线程数，默认为64\n  main-executor-works: 64\n  #flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\n  main-executor-class: com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n  #自定义请求id的生成类，liteflow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n  #并行节点的线程池builder，liteflow提供了默认的builder\n  thread-executor-class: com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n  #异步线程最长的等待时间秒(只用于when)，默认值为15\n  when-max-wait-seconds: 15\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵其他场景代码设置配置项",frontmatter:{title:"🌵其他场景代码设置配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.9.X/b5065a/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/040.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"10.v2.9.X文档/040.🍢配置项/040.其他场景代码设置配置项.md",key:"v-09f8dec5",path:"/pages/v2.9.X/b5065a/",headersStr:null,content:'LiteflowConfig config = new LiteflowConfig();\n//规则文件路径\nconfig.setRuleSource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setEnable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setPrintBanner(true);\n//zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setZkNode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setSlotSize(1024);\n//FlowExecutor的execute2Future的线程数，默认为64\nconfig.setMainExecutorWorks(64);\n//FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nconfig.setMainExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder");\n//自定义请求ID的生成类，LiteFlow提供了默认的生成类\nconfig.setRequestIdGeneratorClass("com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator");\n//并行节点的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setThreadExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder");\n//异步线程最长的等待时间秒(只用于when)，默认值为15\nconfig.setWhenMaxWaitSeconds(15);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setWhenMaxWorkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setWhenQueueLimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setParseOnStart(true);\n//全局重试次数，默认为0\nconfig.setRetryCount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setSupportMultipleType(false);\n//全局默认节点执行器\nconfig.setNodeExecutorClass("com.yomahub.liteflow.flow.executor.DefaultNodeExecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setPrintExecutionLog(true);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setEnableLog(false);\n//监控队列存储大小，默认值为200\nconfig.setQueueLimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setDelay(300000L);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setPeriod(300000L);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'liteflowconfig config = new liteflowconfig();\n//规则文件路径\nconfig.setrulesource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setenable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setprintbanner(true);\n//zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setzknode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setslotsize(1024);\n//flowexecutor的execute2future的线程数，默认为64\nconfig.setmainexecutorworks(64);\n//flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nconfig.setmainexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder");\n//自定义请求id的生成类，liteflow提供了默认的生成类\nconfig.setrequestidgeneratorclass("com.yomahub.liteflow.flow.id.defaultrequestidgenerator");\n//并行节点的线程池builder，liteflow提供了默认的builder\nconfig.setthreadexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder");\n//异步线程最长的等待时间秒(只用于when)，默认值为15\nconfig.setwhenmaxwaitseconds(15);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setwhenmaxworkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setwhenqueuelimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setparseonstart(true);\n//全局重试次数，默认为0\nconfig.setretrycount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setsupportmultipletype(false);\n//全局默认节点执行器\nconfig.setnodeexecutorclass("com.yomahub.liteflow.flow.executor.defaultnodeexecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setprintexecutionlog(true);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setenablelog(false);\n//监控队列存储大小，默认值为200\nconfig.setqueuelimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setdelay(300000l);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setperiod(300000l);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📔规则文件格式",frontmatter:{title:"📔规则文件格式",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.9.X/6fa87e/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/010.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/010.规则文件格式.md",key:"v-a93c3458",path:"/pages/v2.9.X/6fa87e/",headers:[{level:2,title:"规则组成部分",slug:"规则组成部分",normalizedTitle:"规则组成部分",charIndex:147}],headersStr:"规则组成部分",content:'LiteFlow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nLiteFlow的规则文件非常轻量，非常容易上手。主要由Node节点和Chain节点组成。\n\n提示\n\n必须要说明的是，Node节点在Springboot/Spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到Spring上下文中。\n\n在非Spring环境体系中，Node节点是必须的。如果不配置Node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nXML在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.ACmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.BCmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.CCmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.DCmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(\n            a, b, WHEN(c,d)\n        );\n    </chain>\n</flow>\n\n\nJSON在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.TestCustomParser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ACmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.BCmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.CCmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.DCmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "THEN(a, b, WHEN(c, d))"\n      }\n    ]\n  }\n}\n\n\nYAML在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.TestCustomParser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.ACmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.BCmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.CCmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.DCmp\n  chain:\n    - name: chain1\n      value: "THEN(a, b, WHEN(c, d))"\n',normalizedContent:'liteflow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nliteflow的规则文件非常轻量，非常容易上手。主要由node节点和chain节点组成。\n\n提示\n\n必须要说明的是，node节点在springboot/spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到spring上下文中。\n\n在非spring环境体系中，node节点是必须的。如果不配置node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nxml在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.acmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.bcmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.ccmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.dcmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(\n            a, b, when(c,d)\n        );\n    </chain>\n</flow>\n\n\njson在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.testcustomparser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.acmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.bcmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ccmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.dcmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "then(a, b, when(c, d))"\n      }\n    ]\n  }\n}\n\n\nyaml在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.testcustomparser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.acmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.bcmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.ccmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.dcmp\n  chain:\n    - name: chain1\n      value: "then(a, b, when(c, d))"\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📕本地规则文件配置",frontmatter:{title:"📕本地规则文件配置",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.9.X/51ddd5/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/020.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/020.本地规则文件配置.md",key:"v-36e19ec4",path:"/pages/v2.9.X/51ddd5/",headers:[{level:2,title:"常规配置",slug:"常规配置",normalizedTitle:"常规配置",charIndex:173},{level:2,title:"指定多个路径",slug:"指定多个路径",normalizedTitle:"指定多个路径",charIndex:300}],headersStr:"常规配置 指定多个路径",content:"在LiteFlow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是LiteFlow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用Spring EL表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n提示\n\n模糊匹配只限于Springboot/Spring体系中，非Spring环境，模糊匹配不生效",normalizedContent:"在liteflow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是liteflow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件为任何的*.xml形式即可，在v2.9.0之后，不存在老的表达式。但是文档为了兼容习惯，后面的示例依然会采用*.el.xml的形式。\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用spring el表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n提示\n\n模糊匹配只限于springboot/spring体系中，非spring环境，模糊匹配不生效",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📗ZK规则文件配置源",frontmatter:{title:"📗ZK规则文件配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.9.X/ffc345/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/030.ZK%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/030.ZK规则文件配置源.md",key:"v-795964ca",path:"/pages/v2.9.X/ffc345/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:17},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:648},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:784},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1152},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1220}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'# 依赖\n\nLiteFlow支持把配置放在zk集群中，基于zk的通知机制，LiteFlow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-zk</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectStr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainPath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectStr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectStr   zk的连接串，可以是集群\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在ZK中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainId，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手ZK规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'# 依赖\n\nliteflow支持把配置放在zk集群中，基于zk的通知机制，liteflow支持实时修改流程\n\n如果需要用到zk，需要添加以下额外依赖插件：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-zk</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    connectstr: 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    chainpath: /liteflow/chain\n    #如果你没有脚本组件，以下可以不配置\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "connectstr":"127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nconnectstr   zk的连接串，可以是集群\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在zk中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainid，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此zk配置源插件，凡是zk节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手zk规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换zk的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📘SQL数据库配置源",frontmatter:{title:"📘SQL数据库配置源",date:"2022-10-06T23:18:42.000Z",permalink:"/pages/v2.9.X/236b4f/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/040.SQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/040.SQL数据库配置源.md",key:"v-21f0ea1a",path:"/pages/v2.9.X/236b4f/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:67},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:35},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:1489},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:3823},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:3994}],headersStr:"依赖 配置 配置说明 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准SQL语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-sql</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverClassName: com.mysql.cj.jdbc.Driver\n    username: root\n    password: 123456\n    applicationName: demo\n    #以下是chain表的配置，这个一定得有\n    chainTableName: chain\n    chainApplicationNameField: application_name\n    chainNameField: chain_name\n    elDataField: el_data\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scriptTableName: script\n    scriptApplicationNameField: application_name\n    scriptIdField: script_id\n    scriptNameField: script_name\n    scriptDataField: script_data\n    scriptTypeField: script_type\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverClassName":"com.mysql.cj.jdbc.Driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationName": "demo",\\\n  "chainTableName": "chain",\\\n  "chainApplicationNameField": "application_name",\\\n  "chainNameField": "chain_name",\\\n  "elDataField": "el_data",\\\n  "scriptTableName": "script",\\\n  "scriptApplicationNameField": "application_name",\\\n  "scriptIdField": "script_id",\\\n  "scriptNameField": "script_name",\\\n  "scriptDataField": "script_data",\\\n  "scriptTypeField": "script_type"\n  }\n\n\n\n# 配置说明\n\nLiteFlow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明\nurl                          jdbc的连接url\ndriverClassName              驱动器类名\nusername                     数据库用户名\npassword                     数据库密码\napplicationName              你的应用名称\nchainTableName               编排规则表的表名\nchainApplicationNameField    编排规则表中应用名称存储字段名\nchainNameField               规则名称存储的字段名\nelDataField                  EL表达式的字段(只存EL)\nscriptTableName              你的脚本存储表的表名\nscriptApplicationNameField   脚本表中应用名称存储字段名\nscriptIdField                脚本组件的Id的字段名\nscriptNameField              脚本组件名称的字段名\nscriptDataField              脚本数据的字段名\nscriptTypeField              脚本类型的字段名(类型参照定义脚本组件)\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nID   APPLICATION_NAME   CHAIN_NAME   CHAIN_DESC   EL_DATA                 CREATE_TIME\n1    demo               chain1       测试流程1        THEN(a, b, c, s1,s2);   2022-09-19 19:31:00\n\n脚本表：liteflow_script\n\nID   APPLICATION_NAME   SCRIPT_ID   SCRIPT_NAME   SCRIPT_DATA                                                  SCRIPT_TYPE   CREATE_TIME\n1    demo               s1          脚本s1          import cn.hutool.core.date.DateUtil                          script        2022-09-19 19:31:00\n                                                  def date = DateUtil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultContext.setData("demoDate", date)\n                                                  class Student {\n                                                  int studentID\n                                                  String studentName\n                                                  }\n                                                  Student student = new Student() student.studentID = 100301\n                                                  student.studentName = "张三"\n                                                  defaultContext.setData("student",student) def a=3\n                                                  def b=2\n                                                  defaultContext.setData("s1",a*b)\n2    demo               s2          脚本s2          defaultContext.setData("s2","hello")                         script        2022-09-19 19:31:00\n\n\n# 自动刷新\n\n由于结构化数据库并不提供监听机制，所以当你的规则在数据库中发生变化，LiteFlow是感知不到变化的。不会自动刷新规则。\n\n你需要手动调用LiteFlow提供的相关API来完成规则刷新。在实际应用中，你可以把这个刷新做成页面上的一个按钮或者一个http链接来进行操作。\n\n具体如何调用API进行规则刷新请参照平滑热刷新。\n\n\n# 小例子\n\n为了让大家能简单上手SQL规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了标准关系型结构化数据库的配置源，只要你的数据库兼容标准sql语法，都可以支持。\n\n\n# 依赖\n\n如果使用数据库作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-sql</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://localhost:3306/poseidon\n    driverclassname: com.mysql.cj.jdbc.driver\n    username: root\n    password: 123456\n    applicationname: demo\n    #以下是chain表的配置，这个一定得有\n    chaintablename: chain\n    chainapplicationnamefield: application_name\n    chainnamefield: chain_name\n    eldatafield: el_data\n    #以下是script表的配置，如果你没使用到脚本，下面可以不配置\n    scripttablename: script\n    scriptapplicationnamefield: application_name\n    scriptidfield: script_id\n    scriptnamefield: script_name\n    scriptdatafield: script_data\n    scripttypefield: script_type\n\n\nliteflow.rule-source-ext-data={\\\n  "url":"jdbc:mysql://localhost:3306/poseidon",\\\n  "driverclassname":"com.mysql.cj.jdbc.driver",\\\n  "username":"root",\\\n  "password":"123456",\\\n  "applicationname": "demo",\\\n  "chaintablename": "chain",\\\n  "chainapplicationnamefield": "application_name",\\\n  "chainnamefield": "chain_name",\\\n  "eldatafield": "el_data",\\\n  "scripttablename": "script",\\\n  "scriptapplicationnamefield": "application_name",\\\n  "scriptidfield": "script_id",\\\n  "scriptnamefield": "script_name",\\\n  "scriptdatafield": "script_data",\\\n  "scripttypefield": "script_type"\n  }\n\n\n\n# 配置说明\n\nliteflow并不约束你的表名和表结构，你只需要把表名和相关的字段名配置在参数里即可。\n\n对于配置项说明如下：\n\n配置项                          说明\nurl                          jdbc的连接url\ndriverclassname              驱动器类名\nusername                     数据库用户名\npassword                     数据库密码\napplicationname              你的应用名称\nchaintablename               编排规则表的表名\nchainapplicationnamefield    编排规则表中应用名称存储字段名\nchainnamefield               规则名称存储的字段名\neldatafield                  el表达式的字段(只存el)\nscripttablename              你的脚本存储表的表名\nscriptapplicationnamefield   脚本表中应用名称存储字段名\nscriptidfield                脚本组件的id的字段名\nscriptnamefield              脚本组件名称的字段名\nscriptdatafield              脚本数据的字段名\nscripttypefield              脚本类型的字段名(类型参照定义脚本组件)\n\n\n在数据库中，你至少需要一张表来存储编排规则，这是必须的。\n\n如果你使用到了脚本，那么需要第二张表来存储脚本。\n\n在规则表中，一行数据就是一个规则。在脚本表中，一行数据就是一个脚本组件。\n\n\n举例：\n\n规则表：liteflow_chain\n\nid   application_name   chain_name   chain_desc   el_data                 create_time\n1    demo               chain1       测试流程1        then(a, b, c, s1,s2);   2022-09-19 19:31:00\n\n脚本表：liteflow_script\n\nid   application_name   script_id   script_name   script_data                                                  script_type   create_time\n1    demo               s1          脚本s1          import cn.hutool.core.date.dateutil                          script        2022-09-19 19:31:00\n                                                  def date = dateutil.parse("2022-10-17 13:31:43")\n                                                  println(date) defaultcontext.setdata("demodate", date)\n                                                  class student {\n                                                  int studentid\n                                                  string studentname\n                                                  }\n                                                  student student = new student() student.studentid = 100301\n                                                  student.studentname = "张三"\n                                                  defaultcontext.setdata("student",student) def a=3\n                                                  def b=2\n                                                  defaultcontext.setdata("s1",a*b)\n2    demo               s2          脚本s2          defaultcontext.setdata("s2","hello")                         script        2022-09-19 19:31:00\n\n\n# 自动刷新\n\n由于结构化数据库并不提供监听机制，所以当你的规则在数据库中发生变化，liteflow是感知不到变化的。不会自动刷新规则。\n\n你需要手动调用liteflow提供的相关api来完成规则刷新。在实际应用中，你可以把这个刷新做成页面上的一个按钮或者一个http链接来进行操作。\n\n具体如何调用api进行规则刷新请参照平滑热刷新。\n\n\n# 小例子\n\n为了让大家能简单上手sql规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换数据库的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🗄Etcd配置源",frontmatter:{title:"🗄Etcd配置源",date:"2022-10-06T23:19:17.000Z",permalink:"/pages/v2.9.X/4bfac2/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/060.Etcd%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/060.Etcd配置源.md",key:"v-c777c758",path:"/pages/v2.9.X/4bfac2/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:39},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:30},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:575},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:707},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1077},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1149}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了Etcd的规则配置源。\n\n\n# 依赖\n\n如果使用Etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-etcd</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainPath: /liteflow/chain\n    scriptPath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainPath":"/liteflow/chain",\\\n    "scriptPath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainPath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptPath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在etcd中，假设你的chainPath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainId，value为单纯的EL（THEN(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptPath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此Etcd配置源插件，凡是Etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手Etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了etcd的规则配置源。\n\n\n# 依赖\n\n如果使用etcd作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-etcd</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    endpoints: http://127.0.0.1:2379\n    chainpath: /liteflow/chain\n    scriptpath: /liteflow/script\n\n\nliteflow.rule-source-ext-data={\\\n    "endpoints":"http://127.0.0.1:2379",\\\n    "chainpath":"/liteflow/chain",\\\n    "scriptpath":"/liteflow/script"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nendpoints    etcd的连接串\nchainpath    你的规则目录节点（下面会有很多个规则，一个规则一个节点）\nscriptpath   你的脚本目录节点（下面会有很多个脚本，一个脚本一个节点）\n\n\n# 存储数据说明\n\n在etcd中，假设你的chainpath为：/liteflow/chain\n\n那么这个路径下的每一个节点就是一个规则，节点的key为chainid，value为单纯的el（then(a,b,c)），比如：\n\n> /liteflow/chain\n> \n> ---chain1\n> \n> ---chain2\n\n对于脚本path来说，假设你的scriptpath为：/liteflow/script\n\n那么这个路径下的每一个节点都是一个脚本组件，节点的key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，比如：\n\n> /liteflow/script\n> \n> ---s1:script:脚本组件s1\n> \n> ---s2:script:脚本组件s2\n\n关于脚本类型，可以参照定义脚本组件这一章节。\n\n\n# 自动刷新\n\n使用了此etcd配置源插件，凡是etcd节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手etcd规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换etcd的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📜Apollo配置源",frontmatter:{title:"📜Apollo配置源",date:"2022-12-12T22:42:40.000Z",permalink:"/pages/v2.9.X/bea809/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/065.Apollo%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/065.Apollo配置源.md",key:"v-524263f0",path:"/pages/v2.9.X/bea809/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:57},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:28},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:523},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:608},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1207}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新",content:'LiteFlow从2.9.5开始，原生支持了Apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用Apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-apollo</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainNamespace: chainConfig\n    scriptNamespace: scriptConfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainNamespace":"chainConfig",\\\n    "scriptNamespace":"scriptConfig",\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainNamespace    规则命名空间名称\nscriptNamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在Apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在LiteFlow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在Apollo中需要为规则单独创建一个Namespace，数据类型选择properties，那么这个Namespace 下的每一对kv都是一个规则，假设你的规则命名空间为:chainConfig，那么配置形式样例如下：\n\nNAMESPACE：CHAINCONFIG   \nchain1                  THEN(a, b, c);\nchain2                  IF(x, b).ELIF(y, c).ELSE(d);\n\n对于脚本命名空间来说，key有固定格式：脚本组件ID:脚本类型:脚本名称，value为脚本数据，假设你的脚本命名空间为：scriptConfig，那么配置形式样例如下：\n\nNAMESPACE：SCRIPTCONFIG   \ns1:script:脚本组件1          defaultContext.setData("s1","hello")\ns2:if_script:脚本组件2       if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\nApollo支持推送配置数据的变更，凡是在Apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你需做任何事情。',normalizedContent:'liteflow从2.9.5开始，原生支持了apollo配置中心。你可以在配置中心里配置你的链路和脚本。\n\n\n# 依赖\n\n如果使用apollo作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-apollo</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    chainnamespace: chainconfig\n    scriptnamespace: scriptconfig\n\n\nliteflow.rule-source-ext-data={\\\n    "chainnamespace":"chainconfig",\\\n    "scriptnamespace":"scriptconfig",\\\n}\n\n\n\n# 配置说明\n\n配置项               说明\nchainnamespace    规则命名空间名称\nscriptnamespace   脚本命名空间名称\n\n\n# 存储数据说明\n\n提示\n\n由于在apollo中，推荐的做法是把连接信息和环境信息放到服务器的appdatas下的server.properties 文件中的。所以在liteflow的配置文件中是不指定连接信息的。这点要注意下。\n\n对于规则来说，你在apollo中需要为规则单独创建一个namespace，数据类型选择properties，那么这个namespace 下的每一对kv都是一个规则，假设你的规则命名空间为:chainconfig，那么配置形式样例如下：\n\nnamespace：chainconfig   \nchain1                  then(a, b, c);\nchain2                  if(x, b).elif(y, c).else(d);\n\n对于脚本命名空间来说，key有固定格式：脚本组件id:脚本类型:脚本名称，value为脚本数据，假设你的脚本命名空间为：scriptconfig，那么配置形式样例如下：\n\nnamespace：scriptconfig   \ns1:script:脚本组件1          defaultcontext.setdata("s1","hello")\ns2:if_script:脚本组件2       if(a > 100){return true;}else{return false;}\n\n\n# 自动刷新\n\napollo支持推送配置数据的变更，凡是在apollo里的规则和脚本变动，会自动推送到业务系统，进行实时的平滑热刷新，你需做任何事情。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📋Nacos配置源",frontmatter:{title:"📋Nacos配置源",date:"2022-10-06T23:19:04.000Z",permalink:"/pages/v2.9.X/09b776/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/050.Nacos%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/050.Nacos配置源.md",key:"v-6def73d0",path:"/pages/v2.9.X/09b776/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:40},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:31},{level:2,title:"配置说明",slug:"配置说明",normalizedTitle:"配置说明",charIndex:693},{level:2,title:"存储数据说明",slug:"存储数据说明",normalizedTitle:"存储数据说明",charIndex:873},{level:2,title:"自动刷新",slug:"自动刷新",normalizedTitle:"自动刷新",charIndex:1143},{level:2,title:"小例子",slug:"小例子",normalizedTitle:"小例子",charIndex:1217}],headersStr:"依赖 配置 配置说明 存储数据说明 自动刷新 小例子",content:'LiteFlow从v2.9.0开始，原生支持了Nacos的规则配置源。\n\n\n# 依赖\n\n如果使用Nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-rule-nacos</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.ruleSource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serverAddr: 127.0.0.1:8848\n    dataId: demo_rule\n    group: DEFAULT_GROUP\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serverAddr":"127.0.0.1:8848",\\\n    "dataId":"demo_rule",\\\n    "group":"DEFAULT_GROUP",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserverAddr   nacos的连接串\ndataId       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用Nacos配置源的时候，Nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      THEN(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此Nacos配置源插件，凡是Nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手Nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换Nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',normalizedContent:'liteflow从v2.9.0开始，原生支持了nacos的规则配置源。\n\n\n# 依赖\n\n如果使用nacos作为规则配置源，你需要添加以下额外插件依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-rule-nacos</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n\n# 配置\n\n依赖了插件包之后，你无需再配置liteflow.rulesource路径。\n\n只需要配置插件的额外参数即可：\n\nliteflow:\n  rule-source-ext-data-map:\n    serveraddr: 127.0.0.1:8848\n    dataid: demo_rule\n    group: default_group\n    namespace: your namespace id\n    username: nacos\n    password: nacos\n\n\nliteflow.rule-source-ext-data={\\\n    "serveraddr":"127.0.0.1:8848",\\\n    "dataid":"demo_rule",\\\n    "group":"default_group",\\\n    "namespace":"your namespace id",\\\n    "username":"nacos",\\\n    "password":"nacos"\\\n}\n\n\n\n# 配置说明\n\n配置项          说明\nserveraddr   nacos的连接串\ndataid       整个规则+脚本的xml存储数据节点id\ngroup        nacos的group\nnamespace    nacos的namespace\nusername     nacos的用户\npassword     nacos的密码\n\n\n# 存储数据说明\n\n警告\n\n需要说明的是，使用nacos配置源的时候，nacos里存的只能是xml形式的配置。\n\n比如：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n  \t<nodes>\n      <node id="s1" type="script">\n        你的脚本代码\n      </node>\n    </nodes>\n  \n    <chain name="chain1">\n      then(a, b, c);\n    </chain>\n</flow>\n\n\n\n# 自动刷新\n\n使用了此nacos配置源插件，凡是nacos节点里面的规则改动，会自动推送到业务系统，进行实时的平滑热刷新。你无需做任何事情。\n\n\n# 小例子\n\n为了让大家能简单上手nacos规则文件的配置和运行，这里有一个小demo，大家可以拉到本地来运行，需要你替换nacos的配置信息。\n\n运行项目前，先读项目里的readme.txt文件。\n\n> https://github.com/bryan31/liteflow-ext-rule-demo',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📙自定义配置源",frontmatter:{title:"📙自定义配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.9.X/25f2c0/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/070.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"10.v2.9.X文档/050.🗂规则文件/070.自定义配置源.md",key:"v-554071f5",path:"/pages/v2.9.X/25f2c0/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:616}],headersStr:"说明 配置路径",content:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。LiteFlow支持自定义的配置源的扩展点。\n\nXML形式的规则文件请继承ClassXmlFlowELParser\n\nJSON形式的规则文件请继承ClassJsonFlowELParser\n\nYML形式的规则文件请继承ClassYmlFlowELParser\n\n以下以XML形式的自定义源配置类举例：\n\npublic class TestCustomParser extends ClassXmlFlowELParser {\n\n\t@Override\n\tpublic String parseCustom() {\n\t\tSystem.out.println("进入自定义parser");\n\t\tString xmlContent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlContent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@Autowired和@Resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n\n关于el_xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以EL的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',normalizedContent:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。liteflow支持自定义的配置源的扩展点。\n\nxml形式的规则文件请继承classxmlflowelparser\n\njson形式的规则文件请继承classjsonflowelparser\n\nyml形式的规则文件请继承classymlflowelparser\n\n以下以xml形式的自定义源配置类举例：\n\npublic class testcustomparser extends classxmlflowelparser {\n\n\t@override\n\tpublic string parsecustom() {\n\t\tsystem.out.println("进入自定义parser");\n\t\tstring xmlcontent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlcontent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@autowired和@resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n\n关于el_xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以el的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📎普通组件",frontmatter:{title:"📎普通组件",date:"2022-06-29T17:53:36.000Z",permalink:"/pages/v2.9.X/8486fb/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/010.%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/055.🔗常规组件/010.普通组件.md",key:"v-3950d9a7",path:"/pages/v2.9.X/8486fb/",headers:[{level:2,title:"可以覆盖的方法",slug:"可以覆盖的方法",normalizedTitle:"可以覆盖的方法",charIndex:335},{level:3,title:"isAccess",slug:"isaccess",normalizedTitle:"isaccess",charIndex:369},{level:3,title:"isContinueOnError",slug:"iscontinueonerror",normalizedTitle:"iscontinueonerror",charIndex:422},{level:3,title:"isEnd",slug:"isend",normalizedTitle:"isend",charIndex:472},{level:3,title:"beforeProcess和afterProcess",slug:"beforeprocess和afterprocess",normalizedTitle:"beforeprocess和afterprocess",charIndex:667},{level:3,title:"onSuccess和onError",slug:"onsuccess和onerror",normalizedTitle:"onsuccess和onerror",charIndex:797},{level:2,title:"This关键字可以调用的方法",slug:"this关键字可以调用的方法",normalizedTitle:"this关键字可以调用的方法",charIndex:845},{level:3,title:"获取上下文",slug:"获取上下文",normalizedTitle:"获取上下文",charIndex:864},{level:3,title:"getNodeId",slug:"getnodeid",normalizedTitle:"getnodeid",charIndex:942},{level:3,title:"getName",slug:"getname",normalizedTitle:"getname",charIndex:965},{level:3,title:"getChainName",slug:"getchainname",normalizedTitle:"getchainname",charIndex:986},{level:3,title:"getRequestData",slug:"getrequestdata",normalizedTitle:"getrequestdata",charIndex:1017},{level:3,title:"setIsEnd",slug:"setisend",normalizedTitle:"setisend",charIndex:613},{level:3,title:"getTag",slug:"gettag",normalizedTitle:"gettag",charIndex:1248},{level:3,title:"invoke和invoke2Response",slug:"invoke和invoke2response",normalizedTitle:"invoke和invoke2response",charIndex:1292},{level:2,title:"@LiteflowComponent",slug:"liteflowcomponent",normalizedTitle:"@liteflowcomponent",charIndex:58}],headersStr:"可以覆盖的方法 isAccess isContinueOnError isEnd beforeProcess和afterProcess onSuccess和onError This关键字可以调用的方法 获取上下文 getNodeId getName getChainName getRequestData setIsEnd getTag invoke和invoke2Response @LiteflowComponent",content:'普通组件节点需要继承NodeComponent，可用于THEN和WHEN关键字中。\n\n需要实现process方法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n提示\n\n@LiteflowComponent继承自@Component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@LiteflowComponent的参数a，就是你在写EL规则时需要用到组件ID。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isAccess\n\n推荐实现isAccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# isContinueOnError\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isEnd\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# beforeProcess和afterProcess\n\n流程的前置和后置处理器，其中前置处理器，在isAccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onSuccess和onError\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# This关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getContextBean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getNodeId\n\n获取组件ID。\n\n\n# getName\n\n获取组件别名。\n\n\n# getChainName\n\n获取当前执行的流程名称。\n\n\n# getRequestData\n\n获取流程的初始参数。\n\n\n# setIsEnd\n\n表示是否立即结束整个流程 ，用法为this.setIsEnd(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# getTag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2Response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @LiteflowComponent\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'普通组件节点需要继承nodecomponent，可用于then和when关键字中。\n\n需要实现process方法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n提示\n\n@liteflowcomponent继承自@component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@liteflowcomponent的参数a，就是你在写el规则时需要用到组件id。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isaccess\n\n推荐实现isaccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# iscontinueonerror\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isend\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# beforeprocess和afterprocess\n\n流程的前置和后置处理器，其中前置处理器，在isaccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onsuccess和onerror\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# this关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getcontextbean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getnodeid\n\n获取组件id。\n\n\n# getname\n\n获取组件别名。\n\n\n# getchainname\n\n获取当前执行的流程名称。\n\n\n# getrequestdata\n\n获取流程的初始参数。\n\n\n# setisend\n\n表示是否立即结束整个流程 ，用法为this.setisend(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# gettag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @liteflowcomponent\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"✂️选择组件",frontmatter:{title:"✂️选择组件",date:"2022-06-29T17:58:54.000Z",permalink:"/pages/v2.9.X/c0f5d7/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/020.%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/055.🔗常规组件/020.选择组件.md",key:"v-440b5bb0",path:"/pages/v2.9.X/c0f5d7/",headers:[{level:2,title:"根据nodeId进行选择",slug:"根据nodeid进行选择",normalizedTitle:"根据nodeid进行选择",charIndex:153},{level:2,title:"根据表达式的id进行选择",slug:"根据表达式的id进行选择",normalizedTitle:"根据表达式的id进行选择",charIndex:496},{level:2,title:"根据tag进行选择",slug:"根据tag进行选择",normalizedTitle:"根据tag进行选择",charIndex:882}],headersStr:"根据nodeId进行选择 根据表达式的id进行选择 根据tag进行选择",content:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于SWITCH关键字中。\n\n关于SWITCH表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承NodeSwitchComponent。\n\n需要实现方法processSwitch方法。\n\n\n# 根据nodeId进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c);\n</chain>\n\n\n这个方法需要返回String类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, WHEN(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nLiteFlow从v2.9.0开始支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    THEN(\n        a,\n        SWITCH(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class GSwitchCmp extends NodeSwitchComponent {\n\n\t@Override\n\tpublic String processSwitch() throws Exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetId是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetId是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetId是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetId是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetId是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetId是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetId是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetId是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于switch关键字中。\n\n关于switch表达式的用法，可以参考选择编排一章。\n\n选择节点a需要继承nodeswitchcomponent。\n\n需要实现方法processswitch方法。\n\n\n# 根据nodeid进行选择\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, c);\n</chain>\n\n\n这个方法需要返回string类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "c";\n    }\n}\n\n\n\n# 根据表达式的id进行选择\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, when(c,d).id("w1"));\n</chain>\n\n\n如果我要a组件要选择到后面那个表达式，那么必须在后面那个表达式后面添加id表达式，赋值一个名称。然后你的a组件就直接返回w1就可以了。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "w1";\n    }\n}\n\n\n\n# 根据tag进行选择\n\n关于tag(标签)的概念，请参照组件标签这一章。\n\n如下表达式：\n\n<chain name="chain1">\n    switch(a).to(\n        b.tag("cat"),\n        c.tag("dog")\n    );\n</chain>\n\n\nliteflow从v2.9.0开始支持对tag的选择，如果你想选择c组件，a组件可以返回c，也可以返回tag:dog。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "tag:dog";\n    }\n}\n\n\n以上是最简单的用法，还有如下用法：\n\n<chain name="chain4">\n    then(\n        a,\n        switch(g).to(b.tag("td"), d.tag("td"))\n    );\n</chain>\n\n\n利用简单的表示可以快速选择你想要的\n\npublic class gswitchcmp extends nodeswitchcomponent {\n\n\t@override\n\tpublic string processswitch() throws exception {\n                return ":td"      // 进入 b 节点，含义：选择第一个标签为td的节点\n                return "tag:td"   // 进入 b 节点，含义：选择第一个标签为td的节点\n\t\t        return "b";       // 进入 b 节点，含义：选择targetid是b的节点\n                return "b:";      // 进入 b 节点，含义：选择第一个targetid是b的节点\n\t\t        return "b:td";    // 进入 b 节点，含义：选择targetid是b且标签是td的节点\n                return ":";       // 进入 b 节点，含义：选择第一个节点\n\t\t        return "d";       // 进入 d 节点，含义：选择targetid是d的节点\n                return "d:";      // 进入 d 节点，含义：选择第一个targetid是d的节点\n                return "d:td";    // 进入 d 节点，含义：选择targetid是d且标签是td的节点\n                return "b:x";     // 报错，原因：没有targetid是b且标签是x的节点\n                return "x";       // 报错，原因：没有targetid是x的节点\n                return "::";      // 报错，原因：没有找到标签是":"的节点\n\t}\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬次数循环组件",frontmatter:{title:"🧬次数循环组件",date:"2022-10-06T15:04:44.000Z",permalink:"/pages/v2.9.X/5f971f/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/040.%E6%AC%A1%E6%95%B0%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/055.🔗常规组件/040.次数循环组件.md",key:"v-1b6941c6",path:"/pages/v2.9.X/5f971f/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"循环下标获取",slug:"循环下标获取",normalizedTitle:"循环下标获取",charIndex:446}],headersStr:"用法 循环下标获取",content:'# 用法\n\nLiteFlow从v2.9.0开始，提供了次数循环组件。返回的是一个int值的循环次数。 主要用于FOR...DO...表达式。\n\n关于FOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\nf节点的定义，需要继承NodeForComponent，需要实现processFor方法：\n\n@LiteflowComponent("f")\npublic class FCmp extends NodeForComponent {\n    @Override\n    public int processFor() throws Exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字FOR...DO...中DO里面的任意节点都可以通过this.getLoopIndex()来获得下标。',normalizedContent:'# 用法\n\nliteflow从v2.9.0开始，提供了次数循环组件。返回的是一个int值的循环次数。 主要用于for...do...表达式。\n\n关于for...do...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行固定次数的循环操作，可以如下定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\nf节点的定义，需要继承nodeforcomponent，需要实现processfor方法：\n\n@liteflowcomponent("f")\npublic class fcmp extends nodeforcomponent {\n    @override\n    public int processfor() throws exception {\n        //这里根据业务去返回for的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字for...do...中do里面的任意节点都可以通过this.getloopindex()来获得下标。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📌条件组件",frontmatter:{title:"📌条件组件",date:"2022-08-26T12:25:04.000Z",permalink:"/pages/v2.9.X/cb0b59/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/030.%E6%9D%A1%E4%BB%B6%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/055.🔗常规组件/030.条件组件.md",key:"v-4cfdd4d2",path:"/pages/v2.9.X/cb0b59/",headersStr:null,content:'LiteFlow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为IF组件，返回是一个true/false。可用于IF...ELIF...ELSE等关键字。\n\n关于IF...ELIF...ELSE表达式的用法，可以参考条件编排这一章。\n\n比如一个IF三元表达式，如下所示，x就是IF组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承NodeIfComponent：\n\n@Component("x")\npublic class XCmp extends NodeIfComponent {\n\t@Override\n\tpublic boolean processIf() throws Exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为if组件，返回是一个true/false。可用于if...elif...else等关键字。\n\n关于if...elif...else表达式的用法，可以参考条件编排这一章。\n\n比如一个if三元表达式，如下所示，x就是if组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承nodeifcomponent：\n\n@component("x")\npublic class xcmp extends nodeifcomponent {\n\t@override\n\tpublic boolean processif() throws exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⛓条件循环组件",frontmatter:{title:"⛓条件循环组件",date:"2022-10-06T17:11:06.000Z",permalink:"/pages/v2.9.X/e6995e/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/050.%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/055.🔗常规组件/050.条件循环组件.md",key:"v-0edc713a",path:"/pages/v2.9.X/e6995e/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"循环下标获取",slug:"循环下标获取",normalizedTitle:"循环下标获取",charIndex:446}],headersStr:"用法 循环下标获取",content:'# 用法\n\nLiteFlow从v2.9.0开始，支持了条件循环组件，主要用于WHILE...DO...表达式。\n\n关于WHILE...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行条件循环操作，可以如下定义：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b));\n</chain>\n\n\nw节点的定义，需要继承NodeWhileComponent，需要实现processWhile方法：\n\n@LiteflowComponent("w")\npublic class WCmp extends NodeWhileComponent {\n    @Override\n    public boolean processWhile() throws Exception {\n        //这里根据业务去返回while的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字WHILE...DO...中DO里面的任意节点都可以通过this.getLoopIndex()来获得下标。',normalizedContent:'# 用法\n\nliteflow从v2.9.0开始，支持了条件循环组件，主要用于while...do...表达式。\n\n关于while...do...表达式的用法，可以参考循环编排这一章。\n\n比如要对一段表达式进行条件循环操作，可以如下定义：\n\n<chain name="chain1">\n    while(w).do(then(a, b));\n</chain>\n\n\nw节点的定义，需要继承nodewhilecomponent，需要实现processwhile方法：\n\n@liteflowcomponent("w")\npublic class wcmp extends nodewhilecomponent {\n    @override\n    public boolean processwhile() throws exception {\n        //这里根据业务去返回while的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 循环下标获取\n\n关键字while...do...中do里面的任意节点都可以通过this.getloopindex()来获得下标。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧿退出循环组件",frontmatter:{title:"🧿退出循环组件",date:"2022-10-06T17:11:27.000Z",permalink:"/pages/v2.9.X/c078cd/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/060.%E9%80%80%E5%87%BA%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/055.🔗常规组件/060.退出循环组件.md",key:"v-67317150",path:"/pages/v2.9.X/c078cd/",headersStr:null,content:'LiteFlow从v2.9.0开始，提供了退出循环组件。返回的是一个布尔值的循环次数。 主要用于FOR...DO...BREAK和WHILE...DO...BREAK表达式。\n\n关于这两种表达式的用法，可以参考循环编排这一章。\n\n比如要对某一个循环操作进行退出的编排，可以如此定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n或者\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\nc节点的定义，需要继承NodeBreakComponent，需要实现processBreak方法：\n\n@LiteflowComponent("c")\npublic class CCmp extends NodeBreakComponent {\n    @Override\n    public boolean processBreak() throws Exception {\n        //这里根据业务去返回break的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'liteflow从v2.9.0开始，提供了退出循环组件。返回的是一个布尔值的循环次数。 主要用于for...do...break和while...do...break表达式。\n\n关于这两种表达式的用法，可以参考循环编排这一章。\n\n比如要对某一个循环操作进行退出的编排，可以如此定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b)).break(c);\n</chain>\n\n\n或者\n\n<chain name="chain1">\n    while(w).do(then(a, b)).break(c);\n</chain>\n\n\nc节点的定义，需要继承nodebreakcomponent，需要实现processbreak方法：\n\n@liteflowcomponent("c")\npublic class ccmp extends nodebreakcomponent {\n    @override\n    public boolean processbreak() throws exception {\n        //这里根据业务去返回break的结果\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-29T15:30:16.000Z",permalink:"/pages/v2.9.X/16eca9/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/010.%E8%AF%B4%E6%98%8E.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/010.说明.md",key:"v-21f94fdd",path:"/pages/v2.9.X/16eca9/",headersStr:null,content:"在本章，将说明如何撰写规则表达式。\n\nLiteFlow在2.8.X版本中设计了非常强大的规则表达式。一切复杂的流程在LiteFlow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",normalizedContent:"在本章，将说明如何撰写规则表达式。\n\nliteflow在2.8.x版本中设计了非常强大的规则表达式。一切复杂的流程在liteflow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⌛️迭代循环组件",frontmatter:{title:"⌛️迭代循环组件",date:"2023-02-09T10:40:52.000Z",permalink:"/pages/v2.9.X/64262b/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/055.%E8%BF%AD%E4%BB%A3%E5%BE%AA%E7%8E%AF%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/055.🔗常规组件/055.迭代循环组件.md",key:"v-354ec439",path:"/pages/v2.9.X/64262b/",headers:[{level:2,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2},{level:2,title:"迭代对象的获取",slug:"迭代对象的获取",normalizedTitle:"迭代对象的获取",charIndex:559}],headersStr:"用法 迭代对象的获取",content:'# 用法\n\nLiteFlow从v2.9.7开始，支持了迭代循环组件，相当于Java语言的Iterator关键字，主要用于ITERATOR...DO...表达式。\n\n关于ITERATOR...DO...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\nx节点的定义，需要继承NodeIteratorComponent，需要实现processIterator方法：\n\n@LiteflowComponent("x")\npublic class XCmp extends NodeIteratorComponent {\n    @Override\n    public Iterator<?> processIterator() throws Exception {\n        List<String> list = ListUtil.toList("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 迭代对象的获取\n\n关键字ITERATOR...DO...中DO里面所有的节点都可以通过this.getCurrLoopObj()获得迭代循环的当前对象。',normalizedContent:'# 用法\n\nliteflow从v2.9.7开始，支持了迭代循环组件，相当于java语言的iterator关键字，主要用于iterator...do...表达式。\n\n关于iterator...do...表达式的用法，可以参考循环编排这一章。\n\n比如要进行迭代循环操作，可以如下定义：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\nx节点的定义，需要继承nodeiteratorcomponent，需要实现processiterator方法：\n\n@liteflowcomponent("x")\npublic class xcmp extends nodeiteratorcomponent {\n    @override\n    public iterator<?> processiterator() throws exception {\n        list<string> list = listutil.tolist("jack", "mary", "tom");\n        return list.iterator();\n    }\n}\n\n\n内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。\n\n\n# 迭代对象的获取\n\n关键字iterator...do...中do里面所有的节点都可以通过this.getcurrloopobj()获得迭代循环的当前对象。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎋并行编排",frontmatter:{title:"🎋并行编排",date:"2022-06-29T16:46:16.000Z",permalink:"/pages/v2.9.X/b3446a/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/030.%E5%B9%B6%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/030.并行编排.md",key:"v-56d7f860",path:"/pages/v2.9.X/b3446a/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:2},{level:2,title:"和串行嵌套起来(一)",slug:"和串行嵌套起来-一",normalizedTitle:"和串行嵌套起来(一)",charIndex:113},{level:2,title:"和串行嵌套起来(二)",slug:"和串行嵌套起来-二",normalizedTitle:"和串行嵌套起来(二)",charIndex:288},{level:2,title:"忽略错误",slug:"忽略错误",normalizedTitle:"忽略错误",charIndex:431},{level:2,title:"任一节点先执行完则忽略其他",slug:"任一节点先执行完则忽略其他",normalizedTitle:"任一节点先执行完则忽略其他",charIndex:645},{level:2,title:"关于组的概念",slug:"关于组的概念",normalizedTitle:"关于组的概念",charIndex:891}],headersStr:"最基本的例子 和串行嵌套起来(一) 和串行嵌套起来(二) 忽略错误 任一节点先执行完则忽略其他 关于组的概念",content:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用WHEN关键字，需要注意的是，WHEN必须大写。\n\n<chain name="chain1">\n    WHEN(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把THEN和WHEN结合起来用，看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nWHEN关键字提供了一个子关键字ignoreError(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).ignoreError(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nWHEN关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.X版本中，我们去除了组的概念。\n\n用EL表达式，其实你写2个不同的WHEN就是2个组。比如：\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b),\n        WHEN(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',normalizedContent:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用when关键字，需要注意的是，when必须大写。\n\n<chain name="chain1">\n    when(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把then和when结合起来用，看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nwhen关键字提供了一个子关键字ignoreerror(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).ignoreerror(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nwhen关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.x版本中，我们去除了组的概念。\n\n用el表达式，其实你写2个不同的when就是2个组。比如：\n\n<chain name="chain1">\n    then(\n        when(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    then(\n        when(a, b),\n        when(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌾选择编排",frontmatter:{title:"🌾选择编排",date:"2022-06-29T17:15:38.000Z",permalink:"/pages/v2.9.X/d90483/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/040.%E9%80%89%E6%8B%A9%E7%BC%96%E6%8E%92.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/040.选择编排.md",key:"v-680d383a",path:"/pages/v2.9.X/d90483/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:164},{level:2,title:"DEFAULT关键字",slug:"default关键字",normalizedTitle:"default关键字",charIndex:273},{level:2,title:"和THEN,WHEN嵌套起来",slug:"和then-when嵌套起来",normalizedTitle:"和then,when嵌套起来",charIndex:487},{level:2,title:"选择编排中的id语法",slug:"选择编排中的id语法",normalizedTitle:"选择编排中的id语法",charIndex:677}],headersStr:"最基本的例子 DEFAULT关键字 和THEN,WHEN嵌套起来 选择编排中的id语法",content:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入A流程，如果返回结果2，则进入B流程，如果返回结果3，则进入C流程。在有些流程定义中也被定义为排他网关。\n\n这个通过LiteFLow的表达式也非常容易实现，你可以用SWITCH...TO的组合关键字，注意的是SWITCH必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# DEFAULT关键字\n\nLiteFlow从2.9.5开始，对选择编排新增了一个DEFAULT关键字。用法为SWITCH...TO...DEFAULT。\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(x).TO(a, b, c).DEFAULT(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然DEFAULT里面也可以是一个表达式。\n\n\n# 和THEN,WHEN嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(\n            b,\n            SWITCH(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个SWITCH中套THEN和WHEN的例子。\n\n如果你阅读过选择组件这一章，就应该知道，LiteFlow通过选择组件的返回来确定该选择什么。\n\n那么如果SWITCH中套一个THEN，那么选择组件如果要选择这个THEN应该返回什么呢？\n\nLiteFlow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回t1:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        //do your biz\n        return "t1";\n    }\n}\n',normalizedContent:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入a流程，如果返回结果2，则进入b流程，如果返回结果3，则进入c流程。在有些流程定义中也被定义为排他网关。\n\n这个通过liteflow的表达式也非常容易实现，你可以用switch...to的组合关键字，注意的是switch必须大写，to大小写均可。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    switch(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# default关键字\n\nliteflow从2.9.5开始，对选择编排新增了一个default关键字。用法为switch...to...default。\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(x).to(a, b, c).default(y);\n</chain>\n\n\n如上表达式的x如果返回非a,b,c中的一个，则默认选择到y。当然default里面也可以是一个表达式。\n\n\n# 和then,when嵌套起来\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            b,\n            switch(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 选择编排中的id语法\n\n接下来展示一个switch中套then和when的例子。\n\n如果你阅读过选择组件这一章，就应该知道，liteflow通过选择组件的返回来确定该选择什么。\n\n那么如果switch中套一个then，那么选择组件如果要选择这个then应该返回什么呢？\n\nliteflow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回t1:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        //do your biz\n        return "t1";\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌴串行编排",frontmatter:{title:"🌴串行编排",date:"2022-06-29T15:28:24.000Z",permalink:"/pages/v2.9.X/a590ee/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/020.%E4%B8%B2%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/020.串行编排.md",key:"v-53b4cc2a",path:"/pages/v2.9.X/a590ee/",headersStr:null,content:'如果你要依次执行a,b,c,d四个组件，你可以用THEN关键字，需要注意的是，THEN必须大写。\n\n<chain name="chain1">\n    THEN(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    THEN(a, b, THEN(c, d));\n</chain>\n\n\n图示',normalizedContent:'如果你要依次执行a,b,c,d四个组件，你可以用then关键字，需要注意的是，then必须大写。\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    then(a, b, then(c, d));\n</chain>\n\n\n图示',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌳循环编排",frontmatter:{title:"🌳循环编排",date:"2022-10-06T15:13:06.000Z",permalink:"/pages/v2.9.X/fbf715/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/046.%E5%BE%AA%E7%8E%AF%E7%BC%96%E6%8E%92.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/046.循环编排.md",key:"v-9475cda2",path:"/pages/v2.9.X/fbf715/",headers:[{level:2,title:"FOR循环",slug:"for循环",normalizedTitle:"for循环",charIndex:36},{level:2,title:"WHILE循环",slug:"while循环",normalizedTitle:"while循环",charIndex:310},{level:2,title:"ITERATOR迭代循环",slug:"iterator迭代循环",normalizedTitle:"iterator迭代循环",charIndex:463},{level:2,title:"BREAK",slug:"break",normalizedTitle:"break",charIndex:653}],headersStr:"FOR循环 WHILE循环 ITERATOR迭代循环 BREAK",content:'LiteFlow从v2.9.0开始，提供了循环编排表达式组合。\n\n\n# FOR循环\n\nFOR循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    FOR(5).DO(THEN(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# WHILE循环\n\nWHILE循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b));\n</chain>\n\n\n其中w这个节点需要为条件循环组件，返回一个布尔值，为true则继续循环，如何定义请参照条件循环组件。\n\n\n# ITERATOR迭代循环\n\nITERATOR迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    ITERATOR(x).DO(THEN(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# BREAK\n\nLiteFlow同样也支持BREAK语法，代表退出循环。\n\nBREAK关键字可以跟在FOR和WHILE后面，通常用法为：\n\n<chain name="chain1">\n    FOR(f).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b)).BREAK(c);\n</chain>\n\n\n其中c这个节点需要为退出循环组件，返回一个布尔值，为true则退出循环。如何定义请参考退出循环组件。\n\n提示\n\nBREAK关键字是在每次循环的末尾进行判断的。',normalizedContent:'liteflow从v2.9.0开始，提供了循环编排表达式组合。\n\n\n# for循环\n\nfor循环表达式用于固定次数的循环，通常的用法为：\n\n<chain name="chain1">\n    for(5).do(then(a, b));\n</chain>\n\n\n上述表达式表示把a->b这个链路固定循环了5次。\n\n如果你在定义规则的时候并不确定要循环几次，要在代码运行的时候才知道。那你也可以这样定义：\n\n<chain name="chain1">\n    for(f).do(then(a, b));\n</chain>\n\n\n其中f这个节点需要为次数循环组件，返回一个int循环次数，如何定义请参照次数循环组件。\n\n\n# while循环\n\nwhile循环表达式用于有条件的循环，通常用法为：\n\n<chain name="chain1">\n    while(w).do(then(a, b));\n</chain>\n\n\n其中w这个节点需要为条件循环组件，返回一个布尔值，为true则继续循环，如何定义请参照条件循环组件。\n\n\n# iterator迭代循环\n\niterator迭代循环表达式通常用于集合的循环，通常用法为：\n\n<chain name="chain1">\n    iterator(x).do(then(a, b));\n</chain>\n\n\n其中x这个节点需要为迭代循环组件，返回一个迭代器，如何定义请参照迭代循环组件。\n\n提示\n\n要注意的是，迭代循环组件只支持java定义，不支持脚本。\n\n\n# break\n\nliteflow同样也支持break语法，代表退出循环。\n\nbreak关键字可以跟在for和while后面，通常用法为：\n\n<chain name="chain1">\n    for(f).do(then(a, b)).break(c);\n</chain>\n\n\n<chain name="chain1">\n    while(w).do(then(a, b)).break(c);\n</chain>\n\n\n其中c这个节点需要为退出循环组件，返回一个布尔值，为true则退出循环。如何定义请参考退出循环组件。\n\n提示\n\nbreak关键字是在每次循环的末尾进行判断的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵条件编排",frontmatter:{title:"🌵条件编排",date:"2022-08-26T14:13:55.000Z",permalink:"/pages/v2.9.X/e76999/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/045.%E6%9D%A1%E4%BB%B6%E7%BC%96%E6%8E%92.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/045.条件编排.md",key:"v-6f0f39a6",path:"/pages/v2.9.X/e76999/",headers:[{level:2,title:"IF的二元表达式",slug:"if的二元表达式",normalizedTitle:"if的二元表达式",charIndex:206},{level:2,title:"IF的三元表达式",slug:"if的三元表达式",normalizedTitle:"if的三元表达式",charIndex:363},{level:2,title:"ELSE表达式",slug:"else表达式",normalizedTitle:"else表达式",charIndex:529},{level:2,title:"ELIF表达式",slug:"elif表达式",normalizedTitle:"elif表达式",charIndex:707}],headersStr:"IF的二元表达式 IF的三元表达式 ELSE表达式 ELIF表达式",content:'LiteFlow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在LiteFlow EL语法中有一些不一样的用法。\n\n以下IF和ELIF的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# IF的二元表达式\n\n我们先来看IF关键字的二元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# IF的三元表达式\n\n我们接下来再来看IF关键字的三元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# ELSE表达式\n\nLiteFlow也提供了ELSE表达式，IF的二元表达式+ELSE表达式等同于IF三元表达式，比如：\n\n<chain name="chain1">\n    IF(x, a).ELSE(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n\n# ELIF表达式\n\nELIF关键字的用法其实和java语言的else if类似，可以跟多个，和IF二元表达式参数一样，一般最后还会跟个ELSE，用于多重条件的判断：\n\n<chain name="chain1">\n    IF(x1, a).ELIF(x2, b).ELIF(x3, c).ELIF(x4, d).ELSE(THEN(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有IF的二元表达式后面才能跟ELIF，如果IF三元表达式后面跟ELIF，最后一个表达式会被ELIF的表达式覆盖，就比如：\n\n<chain name="chain1">\n    IF(x1, a, b).ELIF(x2, c).ELSE(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实IF三元表达式已经能表达一切的可能了，有多重条件也可以不用ELIF，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    IF(\n        x1,\n        a, \n        IF(\n            x2,\n            b,\n            IF(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用ELIF来代替。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是编程语言中的if else。只不过在liteflow el语法中有一些不一样的用法。\n\n以下if和elif的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# if的二元表达式\n\n我们先来看if关键字的二元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# if的三元表达式\n\n我们接下来再来看if关键字的三元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# else表达式\n\nliteflow也提供了else表达式，if的二元表达式+else表达式等同于if三元表达式，比如：\n\n<chain name="chain1">\n    if(x, a).else(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n\n# elif表达式\n\nelif关键字的用法其实和java语言的else if类似，可以跟多个，和if二元表达式参数一样，一般最后还会跟个else，用于多重条件的判断：\n\n<chain name="chain1">\n    if(x1, a).elif(x2, b).elif(x3, c).elif(x4, d).else(then(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有if的二元表达式后面才能跟elif，如果if三元表达式后面跟elif，最后一个表达式会被elif的表达式覆盖，就比如：\n\n<chain name="chain1">\n    if(x1, a, b).elif(x2, c).else(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实if三元表达式已经能表达一切的可能了，有多重条件也可以不用elif，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    if(\n        x1,\n        a, \n        if(\n            x2,\n            b,\n            if(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用elif来代替。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍁使用子流程",frontmatter:{title:"🍁使用子流程",date:"2022-07-01T19:00:46.000Z",permalink:"/pages/v2.9.X/dc5df7/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/050.%E4%BD%BF%E7%94%A8%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/050.使用子流程.md",key:"v-91354242",path:"/pages/v2.9.X/dc5df7/",headersStr:null,content:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    THEN(\n        A, B,\n        WHEN(\n            THEN(C, WHEN(J, K)),\n            D,\n            THEN(H, I)\n        ),\n        SWITCH(X).to(\n            M,\n            N,\n            WHEN(Q, THEN(P, R)).id("w01")\n        ),\n        Z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nLiteFlow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainChain">\n    THEN(\n    \tA, B,\n    \tWHEN(chain1, D, chain2),\n    \tSWITCH(X).to(M, N, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tTHEN(C, WHEN(J, K));\n</chain>\n\n<chain name="chain2">\n  \tTHEN(H, I);\n</chain>\n\n<chain name="chain3">\n  \tWHEN(Q, THEN(P, R)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',normalizedContent:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    then(\n        a, b,\n        when(\n            then(c, when(j, k)),\n            d,\n            then(h, i)\n        ),\n        switch(x).to(\n            m,\n            n,\n            when(q, then(p, r)).id("w01")\n        ),\n        z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nliteflow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainchain">\n    then(\n    \ta, b,\n    \twhen(chain1, d, chain2),\n    \tswitch(x).to(m, n, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tthen(c, when(j, k));\n</chain>\n\n<chain name="chain2">\n  \tthen(h, i);\n</chain>\n\n<chain name="chain3">\n  \twhen(q, then(p, r)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"💐复杂编排例子",frontmatter:{title:"💐复杂编排例子",date:"2022-06-29T21:29:06.000Z",permalink:"/pages/v2.9.X/5156b3/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/070.%E5%A4%8D%E6%9D%82%E7%BC%96%E6%8E%92%E4%BE%8B%E5%AD%90.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/070.复杂编排例子.md",key:"v-8642e540",path:"/pages/v2.9.X/5156b3/",headers:[{level:2,title:"复杂例子一",slug:"复杂例子一",normalizedTitle:"复杂例子一",charIndex:85},{level:2,title:"复杂例子二",slug:"复杂例子二",normalizedTitle:"复杂例子二",charIndex:842},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1907}],headersStr:"复杂例子一 复杂例子二 总结",content:'经过上面几小章，你是不是已经大致了解了LiteFlow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        WHEN(\n            THEN(B, C),\n            THEN(D, E, F),\n            THEN(\n                SWITCH(G).to(\n                    THEN(H, I, WHEN(J, K)).id("t1"),\n                    THEN(L, M).id("t2")\n                ),\n                N\n            )\n        ),\n        Z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你如果用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = THEN(B, C);\n    item2 = THEN(D, E, F);\n    item3_1 = THEN(H, I, WHEN(J, K)).id("t1");\n    item3_2 = THEN(L, M).id("t2");\n    item3 = THEN(SWITCH(G).to(item3_1, item3_2), N);\n    \n    THEN(\n        A,\n        WHEN(item1, item2, item3),\n        Z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        SWITCH(B).to(\n            THEN(D, E, F).id("t1"),\n            THEN(\n                C,\n                WHEN(\n                    THEN(\n                        SWITCH(G).to(THEN(H, I).id("t2"), J),\n                        K\n                    ),\n                    THEN(L, M)\n                )\n            ).id("t3")\n        ),\n        Z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = THEN(D, E, F).id("t1");\n    \n    item2_1 = THEN(\n        SWITCH(G).to(\n            THEN(H, I).id("t2"),\n            J\n        ),\n        K\n    );\n    \n    item2_2 = THEN(L, M);\n    \n    item2 = THEN(C, WHEN(item2_1, item2_2)).id("t3");\n    \n    THEN(\n        A,\n        SWITCH(B).to(item1, item2),\n        Z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest2\n\n\n# 总结\n\nLiteFlow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',normalizedContent:'经过上面几小章，你是不是已经大致了解了liteflow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            then(b, c),\n            then(d, e, f),\n            then(\n                switch(g).to(\n                    then(h, i, when(j, k)).id("t1"),\n                    then(l, m).id("t2")\n                ),\n                n\n            )\n        ),\n        z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你如果用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = then(b, c);\n    item2 = then(d, e, f);\n    item3_1 = then(h, i, when(j, k)).id("t1");\n    item3_2 = then(l, m).id("t2");\n    item3 = then(switch(g).to(item3_1, item3_2), n);\n    \n    then(\n        a,\n        when(item1, item2, item3),\n        z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            then(d, e, f).id("t1"),\n            then(\n                c,\n                when(\n                    then(\n                        switch(g).to(then(h, i).id("t2"), j),\n                        k\n                    ),\n                    then(l, m)\n                )\n            ).id("t3")\n        ),\n        z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = then(d, e, f).id("t1");\n    \n    item2_1 = then(\n        switch(g).to(\n            then(h, i).id("t2"),\n            j\n        ),\n        k\n    );\n    \n    item2_2 = then(l, m);\n    \n    item2 = then(c, when(item2_1, item2_2)).id("t3");\n    \n    then(\n        a,\n        switch(b).to(item1, item2),\n        z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.complexelspringboottest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.complexelspringboottest2\n\n\n# 总结\n\nliteflow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍂使用子变量",frontmatter:{title:"🍂使用子变量",date:"2022-07-01T19:01:33.000Z",permalink:"/pages/v2.9.X/71ff49/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/060.%E4%BD%BF%E7%94%A8%E5%AD%90%E5%8F%98%E9%87%8F.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/060.使用子变量.md",key:"v-7731e1d0",path:"/pages/v2.9.X/71ff49/",headersStr:null,content:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为LiteFlow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = THEN(C, WHEN(J, K));\n    w1 = WHEN(Q, THEN(P, R)).id("w01");\n    t2 = THEN(H, I);\n    \n    THEN(\n        A, B,\n        WHEN(t1, D, t2),\n        SWITCH(X).to(M, N, w1),\n        Z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',normalizedContent:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为liteflow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = then(c, when(j, k));\n    w1 = when(q, then(p, r)).id("w01");\n    t2 = then(h, i);\n    \n    then(\n        a, b,\n        when(t1, d, t2),\n        switch(x).to(m, n, w1),\n        z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌻关于分号",frontmatter:{title:"🌻关于分号",date:"2022-07-10T10:58:25.000Z",permalink:"/pages/v2.9.X/af44a6/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/080.%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/080.关于分号.md",key:"v-2142b61a",path:"/pages/v2.9.X/af44a6/",headersStr:null,content:'大家可能注意到了，在EL规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nLiteFlow的EL规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    THEN(\n        a, \n        b, \n        WHEN(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = THEN(a, b);\n    w1 = WHEN(c, d);\n    \n    THEN(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为LiteFlow的IDEA插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',normalizedContent:'大家可能注意到了，在el规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nliteflow的el规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    then(a, b, when(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    then(\n        a, \n        b, \n        when(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = then(a, b);\n    w1 = when(c, d);\n    \n    then(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为liteflow的idea插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌰关于注释",frontmatter:{title:"🌰关于注释",date:"2022-07-19T10:34:21.000Z",permalink:"/pages/v2.9.X/f3dc09/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/090.%E5%85%B3%E4%BA%8E%E6%B3%A8%E9%87%8A.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/090.关于注释.md",key:"v-a9fc73ae",path:"/pages/v2.9.X/f3dc09/",headersStr:null,content:'在LiteFlow的EL规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    THEN(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        WHEN(c, d)\n    )\n</chain>\n',normalizedContent:'在liteflow的el规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    then(a, b, when(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    then(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        when(c, d)\n    )\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐚组件名包装",frontmatter:{title:"🐚组件名包装",date:"2022-07-26T23:58:18.000Z",permalink:"/pages/v2.9.X/2df3d9/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/100.%E7%BB%84%E4%BB%B6%E5%90%8D%E5%8C%85%E8%A3%85.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/100.组件名包装.md",key:"v-b6f05fdc",path:"/pages/v2.9.X/2df3d9/",headersStr:null,content:'LiteFlow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88Cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    THEN(a, b, 88Cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nLiteFlow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    THEN(a, b, node("88Cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',normalizedContent:'liteflow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    then(a, b, 88cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nliteflow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    then(a, b, node("88cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🔆验证规则",frontmatter:{title:"🔆验证规则",date:"2022-12-01T00:10:24.000Z",permalink:"/pages/v2.9.X/395fd0/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/110.%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99.html",relativePath:"10.v2.9.X文档/060.🧩EL规则的写法/110.验证规则.md",key:"v-170cb6af",path:"/pages/v2.9.X/395fd0/",headersStr:null,content:'LiteFlow从v2.9.4版本开始，为规则EL提供了一个验证的方法接口，用于验证EL是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourMethod() {\n    boolean isValid = LiteFlowChainELBuilder.validate("THEN(a, b, h)");\n    ...\n}\n',normalizedContent:'liteflow从v2.9.4版本开始，为规则el提供了一个验证的方法接口，用于验证el是不是能被正确解析。\n\n你可以调用如下方法来进行验证：\n\npublic void yourmethod() {\n    boolean isvalid = liteflowchainelbuilder.validate("then(a, b, h)");\n    ...\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T23:35:36.000Z",permalink:"/pages/v2.9.X/74b4bf/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/010.%E8%AF%B4%E6%98%8E.html",relativePath:"10.v2.9.X文档/070.🌮数据上下文/010.说明.md",key:"v-3fc46a1b",path:"/pages/v2.9.X/74b4bf/",headersStr:null,content:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在LiteFlow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nLiteFlow对此有独特的设计理念，平时我们写瀑布流的程序时，A调用B，那A一定要把B所需要的参数传递给B，而在LiteFlow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在LiteFlow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",normalizedContent:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在liteflow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nliteflow对此有独特的设计理念，平时我们写瀑布流的程序时，a调用b，那a一定要把b所需要的参数传递给b，而在liteflow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在liteflow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪶用初始化好的上下文传入",frontmatter:{title:"🪶用初始化好的上下文传入",date:"2022-08-17T23:30:42.000Z",permalink:"/pages/v2.9.X/f05ed6/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/030.%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A5%BD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%A0%E5%85%A5.html",relativePath:"10.v2.9.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.md",key:"v-5d4d5890",path:"/pages/v2.9.X/f05ed6/",headersStr:null,content:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getRequestData()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nLiteFlow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到FlowExecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nOrderContext orderContext = new OrderContext();\norderContext.setOrderNo("SO11223344");\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", null, orderContext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',normalizedContent:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getrequestdata()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nliteflow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到flowexecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nordercontext ordercontext = new ordercontext();\nordercontext.setorderno("so11223344");\nliteflowresponse response = flowexecutor.execute2resp("chain1", null, ordercontext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。\n\n警告\n\n框架并不支持上下文bean和class混传，你要么都传bean，要么都传class。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯数据上下文的定义和使用",frontmatter:{title:"🌯数据上下文的定义和使用",date:"2022-07-01T23:49:40.000Z",permalink:"/pages/v2.9.X/501abf/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/020.%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8.html",relativePath:"10.v2.9.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.md",key:"v-41af40b2",path:"/pages/v2.9.X/501abf/",headers:[{level:2,title:"默认上下文",slug:"默认上下文",normalizedTitle:"默认上下文",charIndex:2},{level:2,title:"自定义上下文",slug:"自定义上下文",normalizedTitle:"自定义上下文",charIndex:224},{level:2,title:"多上下文",slug:"多上下文",normalizedTitle:"多上下文",charIndex:816}],headersStr:"默认上下文 自定义上下文 多上下文",content:'# 默认上下文\n\nLiteFlow提供了一个默认的数据上下文的实现：DefaultContext。这个默认的实现其实里面主要存储数据的容器就是一个Map。\n\n你可以通过DefaultContext中的setData方法放入数据，通过getData方法获得数据。\n\n建议\n\nDefaultContext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的Bean当做上下文进行传入。LiteFlow对上下文的Bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, CustomContext.class);\n\n\n传入之后， LiteFlow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tCustomContext context = this.getContextBean(CustomContext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//CustomContext context = this.getFirstContextBean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nLiteFlow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, OrderContext.class, UserContext.class, SignContext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tOrderContext orderContext = this.getContextBean(OrderContext.class);\n\t\tUserContext userContext = this.getContextBean(UserContext.class);\n\t\tSignContext signContext = this.getContextBean(SignContext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是OrderContext，那么也可以用这个方法\n\t\t//OrderContext orderContext = this.getFirstContextBean();\n\t\t...\n\t}\n}\n',normalizedContent:'# 默认上下文\n\nliteflow提供了一个默认的数据上下文的实现：defaultcontext。这个默认的实现其实里面主要存储数据的容器就是一个map。\n\n你可以通过defaultcontext中的setdata方法放入数据，通过getdata方法获得数据。\n\n建议\n\ndefaultcontext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的bean当做上下文进行传入。liteflow对上下文的bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, customcontext.class);\n\n\n传入之后， liteflow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tcustomcontext context = this.getcontextbean(customcontext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//customcontext context = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nliteflow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, ordercontext.class, usercontext.class, signcontext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tordercontext ordercontext = this.getcontextbean(ordercontext.class);\n\t\tusercontext usercontext = this.getcontextbean(usercontext.class);\n\t\tsigncontext signcontext = this.getcontextbean(signcontext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是ordercontext，那么也可以用这个方法\n\t\t//ordercontext ordercontext = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T22:30:36.000Z",permalink:"/pages/v2.9.X/90b2a5/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/010.%E8%AF%B4%E6%98%8E.html",relativePath:"10.v2.9.X文档/080.🛩执行器/010.说明.md",key:"v-4eb00f52",path:"/pages/v2.9.X/90b2a5/",headersStr:null,content:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合Hello World章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",normalizedContent:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合hello world章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎡执行方法",frontmatter:{title:"🎡执行方法",date:"2022-07-01T23:03:12.000Z",permalink:"/pages/v2.9.X/20072e/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/020.%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.html",relativePath:"10.v2.9.X文档/080.🛩执行器/020.执行方法.md",key:"v-3fa50058",path:"/pages/v2.9.X/20072e/",headers:[{level:2,title:"返回类型为LiteflowResponse",slug:"返回类型为liteflowresponse",normalizedTitle:"返回类型为liteflowresponse",charIndex:86},{level:2,title:"返回类型为Future",slug:"返回类型为future",normalizedTitle:"返回类型为future",charIndex:667}],headersStr:"返回类型为LiteflowResponse 返回类型为Future",content:"你可以在Springboot/Spring体系中的任何被Spring上下文管理的类中进行注入FlowExecutor。\n\nFlowExecutor有多个重载方法。\n\n\n# 返回类型为LiteflowResponse\n\n//参数为流程ID，无初始流程入参，上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId)\n//第一个参数为流程ID，第二个参数为流程入参。上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId, Object param);\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文class\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文的Bean\npublic LiteflowResponse execute2Resp(String chainId, Object param, Object... contextBeanArray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为Future\n\npublic Future<LiteflowResponse> execute2Future(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，LiteFlow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现ExecutorBuilder接口：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n",normalizedContent:"你可以在springboot/spring体系中的任何被spring上下文管理的类中进行注入flowexecutor。\n\nflowexecutor有多个重载方法。\n\n\n# 返回类型为liteflowresponse\n\n//参数为流程id，无初始流程入参，上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid)\n//第一个参数为流程id，第二个参数为流程入参。上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid, object param);\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文class\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文的bean\npublic liteflowresponse execute2resp(string chainid, object param, object... contextbeanarray)\n\n\n建议\n\n在这里，官方只推荐你用第3，4个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为future\n\npublic future<liteflowresponse> execute2future(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，liteflow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现executorbuilder接口：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍫选择脚本语言",frontmatter:{title:"🍫选择脚本语言",date:"2022-10-05T14:01:27.000Z",permalink:"/pages/v2.9.X/bd70f7/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/010.%E9%80%89%E6%8B%A9%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80.html",relativePath:"10.v2.9.X文档/085.🍋脚本组件/010.选择脚本语言.md",key:"v-04e73544",path:"/pages/v2.9.X/bd70f7/",headersStr:null,content:'LiteFlow框架目前一共支持5种脚本语言：Groovy，Javascript，QLExpress，Python，Lua\n\nLiteFlow采用SPI机制进行选择脚本框架来动态编译你的脚本。\n\n官方推荐使用Groovy，因为和java语法是最接近的。\n\n如果你不熟悉这5种脚本语言的语法。可以参照以下教程：\n\nGroovy语法教程\n\nJavascript语法教程\n\nQLExpress语法教程\n\nPython语法教程\n\nLua语法教程\n\nGroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-groovy</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n对于Javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持ES5。另一种是基于GraalJs引擎实现，支持ES6。\n\n官方建议，如果是简单的逻辑，就采用jdk引擎的，如果是复杂的，需要用ES6特性的，就用GraalJs引擎。\n\n顺便说下，jdk引擎并不支持java 17，而GraalJs引擎是能支持到java 17的。\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-javascript</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-graaljs</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\nQLExpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-qlexpress</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\nPython脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-python</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\nLua脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-lua</artifactId>\n    <version>2.9.7</version>\n</dependency>\n\n\n提示\n\n在lua中，调用java方式是用:来调用的，并不是.，比如defaultContext:setData("s1",a*b)。\n\n警告\n\n因为是基于SPI方式实现的，5种脚本语言插件只能5选1。LiteFlow不支持多个脚本分别使用不同的脚本。这点要注意下。\n\n你只需要依赖相应的脚本框架即可，SPI会动态选择你依赖的脚本框架进行编译解析你的脚本。\n\nLiteFlow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。',normalizedContent:'liteflow框架目前一共支持5种脚本语言：groovy，javascript，qlexpress，python，lua\n\nliteflow采用spi机制进行选择脚本框架来动态编译你的脚本。\n\n官方推荐使用groovy，因为和java语法是最接近的。\n\n如果你不熟悉这5种脚本语言的语法。可以参照以下教程：\n\ngroovy语法教程\n\njavascript语法教程\n\nqlexpress语法教程\n\npython语法教程\n\nlua语法教程\n\ngroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-groovy</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n对于javascript脚本，你有两种引擎可以选择，一种是基于jdk的js引擎实现，只支持es5。另一种是基于graaljs引擎实现，支持es6。\n\n官方建议，如果是简单的逻辑，就采用jdk引擎的，如果是复杂的，需要用es6特性的，就用graaljs引擎。\n\n顺便说下，jdk引擎并不支持java 17，而graaljs引擎是能支持到java 17的。\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-javascript</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-graaljs</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\nqlexpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-qlexpress</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\npython脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-python</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\nlua脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-lua</artifactid>\n    <version>2.9.7</version>\n</dependency>\n\n\n提示\n\n在lua中，调用java方式是用:来调用的，并不是.，比如defaultcontext:setdata("s1",a*b)。\n\n警告\n\n因为是基于spi方式实现的，5种脚本语言插件只能5选1。liteflow不支持多个脚本分别使用不同的脚本。这点要注意下。\n\n你只需要依赖相应的脚本框架即可，spi会动态选择你依赖的脚本框架进行编译解析你的脚本。\n\nliteflow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎢流程入参",frontmatter:{title:"🎢流程入参",date:"2022-07-02T00:38:44.000Z",permalink:"/pages/v2.9.X/563b67/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/030.%E6%B5%81%E7%A8%8B%E5%85%A5%E5%8F%82.html",relativePath:"10.v2.9.X文档/080.🛩执行器/030.流程入参.md",key:"v-13087c82",path:"/pages/v2.9.X/563b67/",headersStr:null,content:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户Id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的Bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tYourBean requestBean = this.getRequestData();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getRequestData()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',normalizedContent:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tyourbean requestbean = this.getrequestdata();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getrequestdata()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍕定义脚本组件",frontmatter:{title:"🍕定义脚本组件",date:"2022-10-05T14:04:49.000Z",permalink:"/pages/v2.9.X/81d53c/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/020.%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/085.🍋脚本组件/020.定义脚本组件.md",key:"v-a6e7c306",path:"/pages/v2.9.X/81d53c/",headersStr:null,content:'脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" language="groovy">\n            <![CDATA[\n                def a=3;\n                def b=2;\n                defaultContext.setData("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="选择脚本" type="switch_script" language="groovy">\n            <![CDATA[\n                def count = defaultContext.getData("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n\n        <node id="s3" name="条件脚本" type="if_script" language="groovy">\n            <![CDATA[\n                return false;\n            ]]>\n        </node>\n\n        <node id="s4" name="数值循环脚本" type="for_script" language="groovy">\n            <![CDATA[\n                //此处可以用来获取你的循环次数，可以调用java对象来获取，这里演示直接返回循环次数\n                return 10;\n            ]]>\n        </node>\n\n        <node id="s5" name="条件循环脚本" type="while_script" language="groovy">\n            <![CDATA[\n                //此处用来获取什么时候继续循环的标识，可以调用java对象来获取，这里只是演示\n                def flag = yourJavaBean.getFlag();\n                return flag;\n            ]]>\n        </node>\n\n        <node id="s6" name="退出循环脚本" type="break_script" language="groovy">\n            <![CDATA[\n                //此处用来获取什么时候退出循环的标识，可以调用java对象来获取，这里只是演示\n                def breakFlag = yourJavaBean.getFlag();\n                return flag;\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1);\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, SWITCH(s2).to(a, b));\n    </chain>\n\n    <chain name="chain3">\n        THEN(d, IF(s3, b, c));\n    </chain>\n\n    <chain name="chain4">\n        FOR(s4).DO(THEN(a,b)).BREAK(s6);\n    </chain>\n\n    <chain name="chain5">\n        WHILE(s5).DO(THEN(a,b));\n    </chain>\n</flow>\n\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n这里language并不是必须的，由于LiteFlow是根据你依赖的jar包里动态选择脚本语言，采用的是SPI机制。\n\n这里的language声明主要是用来给LiteFlowX插件用来做语法高亮提示处理用的。如果你不加，则不会有相应的语法高亮和提示。\n\n当然得确保你的LiteFlowX插件的版本在1.1.1及以上。\n\n提示\n\n这里示例是传入的上下文bean是默认的DefaultContext，如果是你自定义的上下文Bean，请调用相应的方法来设置和获取数据。',normalizedContent:'脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" language="groovy">\n            <![cdata[\n                def a=3;\n                def b=2;\n                defaultcontext.setdata("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="选择脚本" type="switch_script" language="groovy">\n            <![cdata[\n                def count = defaultcontext.getdata("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n\n        <node id="s3" name="条件脚本" type="if_script" language="groovy">\n            <![cdata[\n                return false;\n            ]]>\n        </node>\n\n        <node id="s4" name="数值循环脚本" type="for_script" language="groovy">\n            <![cdata[\n                //此处可以用来获取你的循环次数，可以调用java对象来获取，这里演示直接返回循环次数\n                return 10;\n            ]]>\n        </node>\n\n        <node id="s5" name="条件循环脚本" type="while_script" language="groovy">\n            <![cdata[\n                //此处用来获取什么时候继续循环的标识，可以调用java对象来获取，这里只是演示\n                def flag = yourjavabean.getflag();\n                return flag;\n            ]]>\n        </node>\n\n        <node id="s6" name="退出循环脚本" type="break_script" language="groovy">\n            <![cdata[\n                //此处用来获取什么时候退出循环的标识，可以调用java对象来获取，这里只是演示\n                def breakflag = yourjavabean.getflag();\n                return flag;\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1);\n    </chain>\n\n    <chain name="chain2">\n        then(d, switch(s2).to(a, b));\n    </chain>\n\n    <chain name="chain3">\n        then(d, if(s3, b, c));\n    </chain>\n\n    <chain name="chain4">\n        for(s4).do(then(a,b)).break(s6);\n    </chain>\n\n    <chain name="chain5">\n        while(s5).do(then(a,b));\n    </chain>\n</flow>\n\n\n要注意的是，type分为6种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false。\n\nfor_script：数量循环节点，脚本里需要返回数值，表示循环次数。\n\nwhile_script：条件循环节点，脚本里需要返回true/false，表示什么条件才继续循环。\n\nbreak_script：退出循环节点，脚本里需要返回true/false，表示什么时候退出循环。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n这里language并不是必须的，由于liteflow是根据你依赖的jar包里动态选择脚本语言，采用的是spi机制。\n\n这里的language声明主要是用来给liteflowx插件用来做语法高亮提示处理用的。如果你不加，则不会有相应的语法高亮和提示。\n\n当然得确保你的liteflowx插件的版本在1.1.1及以上。\n\n提示\n\n这里示例是传入的上下文bean是默认的defaultcontext，如果是你自定义的上下文bean，请调用相应的方法来设置和获取数据。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎈LiteflowResponse对象",frontmatter:{title:"🎈LiteflowResponse对象",date:"2022-07-02T00:52:14.000Z",permalink:"/pages/v2.9.X/9f653d/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/040.LiteflowResponse%E5%AF%B9%E8%B1%A1.html",relativePath:"10.v2.9.X文档/080.🛩执行器/040.LiteflowResponse对象.md",key:"v-169395d6",path:"/pages/v2.9.X/9f653d/",headers:[{level:2,title:"流程执行是否成功",slug:"流程执行是否成功",normalizedTitle:"流程执行是否成功",charIndex:66},{level:2,title:"获取异常信息",slug:"获取异常信息",normalizedTitle:"获取异常信息",charIndex:240},{level:2,title:"获得执行步骤详细信息",slug:"获得执行步骤详细信息",normalizedTitle:"获得执行步骤详细信息",charIndex:481},{level:2,title:"上下文数据",slug:"上下文数据",normalizedTitle:"上下文数据",charIndex:890},{level:2,title:"获得步骤字符串信息",slug:"获得步骤字符串信息",normalizedTitle:"获得步骤字符串信息",charIndex:1516}],headersStr:"流程执行是否成功 获取异常信息 获得执行步骤详细信息 上下文数据 获得步骤字符串信息",content:'在执行器返回中，用的最多的就是返回一个LiteFlowResponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nboolean isSuccess = response.isSuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程isSuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了LiteFlowResponse对象之后，可以这样获得上下文Bean：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nCustomContext context = response.getContextBean(CustomContext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//CustomContext context = response.getFirstContextBean();\n\n\n对于多上下文来说，也是一样的用法：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, OrderContext.class, UserContext.class);\nOrderContext orderContext = response.getContextBean(OrderContext.class);\nUserContext userContext = response.getContextBean(UserContext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nString stepStr = response.getExecuteStepStrWithTime();\n\n\n这个字符串打印出来结果如下：\n\na[组件A]<201>==>b[组件B]<300>==>m[组件M]<1205>\n\n\n这里的表达形式为组件ID[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getExecuteStepStrWithoutTime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',normalizedContent:'在执行器返回中，用的最多的就是返回一个liteflowresponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nboolean issuccess = response.issuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程issuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了liteflowresponse对象之后，可以这样获得上下文bean：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\ncustomcontext context = response.getcontextbean(customcontext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//customcontext context = response.getfirstcontextbean();\n\n\n对于多上下文来说，也是一样的用法：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, ordercontext.class, usercontext.class);\nordercontext ordercontext = response.getcontextbean(ordercontext.class);\nusercontext usercontext = response.getcontextbean(usercontext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nstring stepstr = response.getexecutestepstrwithtime();\n\n\n这个字符串打印出来结果如下：\n\na[组件a]<201>==>b[组件b]<300>==>m[组件m]<1205>\n\n\n这里的表达形式为组件id[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getexecutestepstrwithouttime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯文件脚本的定义",frontmatter:{title:"🌯文件脚本的定义",date:"2022-10-05T14:16:29.000Z",permalink:"/pages/v2.9.X/f7acfd/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/030.%E6%96%87%E4%BB%B6%E8%84%9A%E6%9C%AC%E7%9A%84%E5%AE%9A%E4%B9%89.html",relativePath:"10.v2.9.X文档/085.🍋脚本组件/030.文件脚本的定义.md",key:"v-098d1892",path:"/pages/v2.9.X/f7acfd/",headersStr:null,content:'LiteFlow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟IDE对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前LiteFlow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, IF(s3, b, c));\n    </chain>\n</flow>\n',normalizedContent:'liteflow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟ide对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前liteflow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        then(d, if(s3, b, c));\n    </chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍘动态刷新脚本",frontmatter:{title:"🍘动态刷新脚本",date:"2022-10-05T22:47:47.000Z",permalink:"/pages/v2.9.X/cbcb14/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/050.%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0%E8%84%9A%E6%9C%AC.html",relativePath:"10.v2.9.X文档/085.🍋脚本组件/050.动态刷新脚本.md",key:"v-d7fb7712",path:"/pages/v2.9.X/cbcb14/",headersStr:null,content:"其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n但是如果你要仅仅热刷新脚本的话，这里也提供了单独的方式，你可以调用如下的代码进行脚本的热刷新：\n\nScriptExecutorFactory.loadInstance().getScriptExecutor().load(nodeId, script);\n",normalizedContent:"其实在平滑热刷新这章所描述的刷新整个规则已经包含了脚本的热刷新。\n\n但是如果你要仅仅热刷新脚本的话，这里也提供了单独的方式，你可以调用如下的代码进行脚本的热刷新：\n\nscriptexecutorfactory.loadinstance().getscriptexecutor().load(nodeid, script);\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥭什么叫声明式组件",frontmatter:{title:"🥭什么叫声明式组件",date:"2022-10-05T23:19:02.000Z",permalink:"/pages/v2.9.X/46f0fa/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/010.%E4%BB%80%E4%B9%88%E5%8F%AB%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/086.🍇声明式组件/010.什么叫声明式组件.md",key:"v-5846da0c",path:"/pages/v2.9.X/46f0fa/",headersStr:null,content:"何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承NodeComponent或者NodeSwitchComponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成LiteFlow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。",normalizedContent:"何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承nodecomponent或者nodeswitchcomponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成liteflow组件的声明。\n\n甚至于你可以用一个类去定义多个组件，仅仅依靠注解就可以完成，这个特性也叫做方法级别式声明。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣与Java进行交互",frontmatter:{title:"🍣与Java进行交互",date:"2022-10-05T14:18:24.000Z",permalink:"/pages/v2.9.X/d861c8/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/085.%F0%9F%8D%8B%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6/040.%E4%B8%8EJava%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.html",relativePath:"10.v2.9.X文档/085.🍋脚本组件/040.与Java进行交互.md",key:"v-25e08f44",path:"/pages/v2.9.X/d861c8/",headers:[{level:2,title:"和数据上下文进行交互",slug:"和数据上下文进行交互",normalizedTitle:"和数据上下文进行交互",charIndex:2},{level:2,title:"元数据",slug:"元数据",normalizedTitle:"元数据",charIndex:543},{level:2,title:"和自定义的JavaBean进行交互",slug:"和自定义的javabean进行交互",normalizedTitle:"和自定义的javabean进行交互",charIndex:862}],headersStr:"和数据上下文进行交互 元数据 和自定义的JavaBean进行交互",content:'# 和数据上下文进行交互\n\n因为LiteFlow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的className的驼峰形式来获取数据。\n\n比如你的上下文类叫OrderContext，那么脚本中的就用orderContext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取UserContext中的userName对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![CDATA[\n        //你可以这样定义\n        def name = userContext.userName;\n        //也可以这样定义，如果你对userName有getter方法的话\n        def name = userContext.getUserName();\n        //同理，你可以调用数据上下文中的任意方法\n        userContext.doYourMethod();\n    ]]>\n</node>\n\n\n\n# 元数据\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotIndex: slot下标，可以通过FlowBus.getSlot(slotIndex)来获得slot数据\n * currChainId: 当前执行chain的名称\n * nodeId: 当前执行node的Id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpData: 组件规则参数，关于cmpData的说明请查看组件参数\n * requestData: 流程初始参数\n * subRequestData: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 和自定义的JavaBean进行交互\n\nLiteFlow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@ScriptBean标注，即可完成注入。\n\n@Component\n@ScriptBean("demo")\npublic class DemoBean1 {\n\n    @Resource\n    private DemoBean2 demoBean2;\n\n    public String getDemoStr1(){\n        return "hello";\n    }\n\n    public String getDemoStr2(String name){\n        return demoBean2.getDemoStr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getDemoStr1()和getDemoStr2()方法了。\n\n我们在LiteFlow 2.9.5版本支持了@ScriptBean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", includeMethodName = {"test1","test2"})\npublic class DemoBean3 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@Component\n@ScriptBean(name = "demo", excludeMethodName = {"test2","test3"})\npublic class DemoBean4 {\n\n    public String test1(String name){\n        ...\n    }\n\n    public String test2(String name){\n        ...\n    }\n\n    public String test3(String name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@ScriptBean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nScriptBeanManager.addScriptBean("demo", new DemoBean());\n',normalizedContent:'# 和数据上下文进行交互\n\n因为liteflow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的classname的驼峰形式来获取数据。\n\n比如你的上下文类叫ordercontext，那么脚本中的就用ordercontext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n比如，你想获取usercontext中的username对象。你可以这样写（以下以groovy作例子）：\n\n<node id="s1" name="普通脚本" type="script">\n    <![cdata[\n        //你可以这样定义\n        def name = usercontext.username;\n        //也可以这样定义，如果你对username有getter方法的话\n        def name = usercontext.getusername();\n        //同理，你可以调用数据上下文中的任意方法\n        usercontext.doyourmethod();\n    ]]>\n</node>\n\n\n\n# 元数据\n\n在脚本中可以用通过_meta关键字获取元数据，可以通过_meta.xxx获取元数据，元数据里包括：\n\n * slotindex: slot下标，可以通过flowbus.getslot(slotindex)来获得slot数据\n * currchainid: 当前执行chain的名称\n * nodeid: 当前执行node的id\n * tag: tag值，关于tag的说明请查看组件标签\n * cmpdata: 组件规则参数，关于cmpdata的说明请查看组件参数\n * requestdata: 流程初始参数\n * subrequestdata: 当前隐式流程的入参，如果此节点编排在隐式流程里的话，能获取到，反之不能\n\n\n# 和自定义的javabean进行交互\n\nliteflow从v2.9.0开始支持在脚本中注入你自己定义的任何java对象。\n\n在spring体系中，你只需要在你需要注入的java对象上使用@scriptbean标注，即可完成注入。\n\n@component\n@scriptbean("demo")\npublic class demobean1 {\n\n    @resource\n    private demobean2 demobean2;\n\n    public string getdemostr1(){\n        return "hello";\n    }\n\n    public string getdemostr2(string name){\n        return demobean2.getdemostr2(name);\n    }\n}\n\n\n以上例子中，脚本里就可以直接使用demo关键字来调用getdemostr1()和getdemostr2()方法了。\n\n我们在liteflow 2.9.5版本支持了@scriptbean的指定方法和排除方法功能。\n\n如果你想指定这个类中的某2个方法可以被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", includemethodname = {"test1","test2"})\npublic class demobean3 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问test1和test2方法。\n\n如果你想指定这个类中的某些访问无法被脚本访问到，你可以这样写：\n\n@component\n@scriptbean(name = "demo", excludemethodname = {"test2","test3"})\npublic class demobean4 {\n\n    public string test1(string name){\n        ...\n    }\n\n    public string test2(string name){\n        ...\n    }\n\n    public string test3(string name){\n        ...\n    }\n}\n\n\n这样你在脚本中只能访问到test1方法了。\n\n提示\n\n需要注意的是，java对象在spring体系中一定要注册进上下文，如果不注册进上下文，光加@scriptbean注解也是没用的。\n\n在非spring体系下面，如果你要把自己的定义的java对象注入脚本，则需要手动写代码（最好在启动应用的时候）：\n\nscriptbeanmanager.addscriptbean("demo", new demobean());\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧅类级别式声明",frontmatter:{title:"🧅类级别式声明",date:"2022-10-05T23:22:17.000Z",permalink:"/pages/v2.9.X/18f548/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/020.%E7%B1%BB%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"10.v2.9.X文档/086.🍇声明式组件/020.类级别式声明.md",key:"v-025b9304",path:"/pages/v2.9.X/18f548/",headers:[{level:2,title:"普通组件的声明",slug:"普通组件的声明",normalizedTitle:"普通组件的声明",charIndex:147},{level:2,title:"选择组件的声明",slug:"选择组件的声明",normalizedTitle:"选择组件的声明",charIndex:1661},{level:2,title:"条件组件的声明",slug:"条件组件的声明",normalizedTitle:"条件组件的声明",charIndex:2036},{level:2,title:"数值循环组件的声明",slug:"数值循环组件的声明",normalizedTitle:"数值循环组件的声明",charIndex:2351},{level:2,title:"条件循环组件的声明",slug:"条件循环组件的声明",normalizedTitle:"条件循环组件的声明",charIndex:2663},{level:2,title:"退出循环组件的声明",slug:"退出循环组件的声明",normalizedTitle:"退出循环组件的声明",charIndex:3024},{level:2,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:1348}],headersStr:"普通组件的声明 选择组件的声明 条件组件的声明 数值循环组件的声明 条件循环组件的声明 退出循环组件的声明 注意点",content:'类级别式声明主要用处就是通过注解形式让普通的java bean变成LiteFlow的组件。无需通过继承类或者实现接口的方式。\n\n由于LiteFlow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@LiteflowComponent("a")\n@LiteflowCmpDefine\npublic class ACmp{\n  \n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS)\n\tpublic void processAcmp(NodeComponent bindCmp) {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)\n\tpublic boolean isAcmpAccess(NodeComponent bindCmp){\n\t\treturn true;\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.BEFORE_PROCESS)\n\tpublic void beforeAcmp(String nodeId, Slot slot){\n\t\tSystem.out.println("before A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.AFTER_PROCESS)\n\tpublic void afterAcmp(String nodeId, Slot slot){\n\t\tSystem.out.println("after A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_SUCCESS)\n\tpublic void onAcmpSuccess(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp success");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_ERROR)\n\tpublic void onAcmpError(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp error");\n\t}\n\t\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_END)\n\tpublic boolean isAcmpEnd(NodeComponent bindCmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承NodeComponent了，在你定义的类上，只要类上加上LiteflowCmpDefine注解，相应的方法上加上LiteflowMethod注解，即可完成对任意自定义类的组件化工作。\n\n其中LiteFlowMethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n这里注意的是，大部分方法上参数必须传入NodeComponent bindCmp这个参数，而且必须只有一个参数，否则会报错，而beforeProcess和afterProcess还是按照以前的参数定义。这点要注意下，可以查看上面的示例。\n\n以前获取上下文Bean是用this关键字，现在只需从bindCmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如IF组件的processIf方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.SWITCH参数。\n\n@Component("e")\n@LiteflowCmpDefine(NodeTypeEnum.SWITCH)\npublic class ECmp{\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeType = NodeTypeEnum.SWITCH)\n    public String processSwitch(NodeComponent bindCmp) throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.IF参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.IF)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeType = NodeTypeEnum.IF)\n\tpublic boolean processIf(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.FOR参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.FOR)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeType = NodeTypeEnum.FOR)\n\tpublic int processFor(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 条件循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.WHILE参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.WHILE)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_WHILE, nodeType = NodeTypeEnum.WHILE)\n\tpublic boolean processWhile(NodeComponent bindCmp) throws Exception {\n\t\t//get your while flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 退出循环组件的声明\n\n声明选择组件在类和方法上都需要加上NodeTypeEnum.BREAK参数。\n\n@Component("x")\n@LiteflowCmpDefine(NodeTypeEnum.BREAK)\npublic class XCmp{\n\n\t@LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BREAK, nodeType = NodeTypeEnum.BREAK)\n\tpublic boolean processBreak(NodeComponent bindCmp) throws Exception {\n\t\t//get your break flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processXxx一样的方式去声明。',normalizedContent:'类级别式声明主要用处就是通过注解形式让普通的java bean变成liteflow的组件。无需通过继承类或者实现接口的方式。\n\n由于liteflow的组件常规方式下需要继承类来定义，使得你无法再继承自己业务的类了。这个特性可以解决这个问题。但是和常规组件一样，需要一个类对应一个组件。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@liteflowcomponent("a")\n@liteflowcmpdefine\npublic class acmp{\n  \n\t@liteflowmethod(liteflowmethodenum.process)\n\tpublic void processacmp(nodecomponent bindcmp) {\n\t\tsystem.out.println("acmp executed!");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.is_access)\n\tpublic boolean isacmpaccess(nodecomponent bindcmp){\n\t\treturn true;\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.before_process)\n\tpublic void beforeacmp(string nodeid, slot slot){\n\t\tsystem.out.println("before a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.after_process)\n\tpublic void afteracmp(string nodeid, slot slot){\n\t\tsystem.out.println("after a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_success)\n\tpublic void onacmpsuccess(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp success");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_error)\n\tpublic void onacmperror(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp error");\n\t}\n\t\n\t@liteflowmethod(liteflowmethodenum.is_end)\n\tpublic boolean isacmpend(nodecomponent bindcmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承nodecomponent了，在你定义的类上，只要类上加上liteflowcmpdefine注解，相应的方法上加上liteflowmethod注解，即可完成对任意自定义类的组件化工作。\n\n其中liteflowmethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n注意点1\n\n这里注意的是，大部分方法上参数必须传入nodecomponent bindcmp这个参数，而且必须只有一个参数，否则会报错，而beforeprocess和afterprocess还是按照以前的参数定义。这点要注意下，可以查看上面的示例。\n\n以前获取上下文bean是用this关键字，现在只需从bindcmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如if组件的processif方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n\n# 选择组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.switch参数。\n\n@component("e")\n@liteflowcmpdefine(nodetypeenum.switch)\npublic class ecmp{\n\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodetype = nodetypeenum.switch)\n    public string processswitch(nodecomponent bindcmp) throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.if参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.if)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_switch, nodetype = nodetypeenum.if)\n\tpublic boolean processif(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 数值循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.for参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.for)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_for, nodetype = nodetypeenum.for)\n\tpublic int processfor(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn 10;\n\t}\n}\n\n\n\n# 条件循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.while参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.while)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_while, nodetype = nodetypeenum.while)\n\tpublic boolean processwhile(nodecomponent bindcmp) throws exception {\n\t\t//get your while flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 退出循环组件的声明\n\n声明选择组件在类和方法上都需要加上nodetypeenum.break参数。\n\n@component("x")\n@liteflowcmpdefine(nodetypeenum.break)\npublic class xcmp{\n\n\t@liteflowmethod(value = liteflowmethodenum.process_break, nodetype = nodetypeenum.break)\n\tpublic boolean processbreak(nodecomponent bindcmp) throws exception {\n\t\t//get your break flag\n\t\tboolean flag = xxxxxx;\n\t\treturn flag;\n\t}\n}\n\n\n\n# 注意点\n\n提示\n\n对于类里的其他方法，也都和processxxx一样的方式去声明。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:56:32.000Z",permalink:"/pages/v2.9.X/9aa85a/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/010.%E8%AF%B4%E6%98%8E.html",relativePath:"10.v2.9.X文档/090.🎲用代码动态构造规则/010.说明.md",key:"v-ffa44e3a",path:"/pages/v2.9.X/9aa85a/",headersStr:null,content:"之前的章节讲述的是通过规则文件去构造流程。\n\nLiteFlow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，ruleSource不用去定义。完全用代码去构建。\n\n事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的API意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造API去构造链路。\n\nLiteFlow设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",normalizedContent:"之前的章节讲述的是通过规则文件去构造流程。\n\nliteflow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，rulesource不用去定义。完全用代码去构建。\n\n事实上，liteflow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的api意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造api去构造链路。\n\nliteflow设计了非常简单的构造方法链式api，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥥方法级别式声明",frontmatter:{title:"🥥方法级别式声明",date:"2022-10-05T23:40:08.000Z",permalink:"/pages/v2.9.X/797830/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/086.%F0%9F%8D%87%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6/030.%E6%96%B9%E6%B3%95%E7%BA%A7%E5%88%AB%E5%BC%8F%E5%A3%B0%E6%98%8E.html",relativePath:"10.v2.9.X文档/086.🍇声明式组件/030.方法级别式声明.md",key:"v-69f60b1c",path:"/pages/v2.9.X/797830/",headersStr:null,content:'LiteFlow从v2.9.0版开始推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    //普通组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a")\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    //SWITCH组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeId = "b", nodeType = NodeTypeEnum.SWITCH)\n    public String processB(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //IF组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_IF, nodeId = "c", nodeType = NodeTypeEnum.IF)\n    public boolean processC(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //FOR组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_FOR, nodeId = "d", nodeType = NodeTypeEnum.FOR)\n    public int processD(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //WHILE组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_WHILE, nodeId = "e", nodeType = NodeTypeEnum.WHILE)\n    public int processE(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //BREAK组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BREAK, nodeId = "f", nodeType = NodeTypeEnum.BREAK)\n    public int processF(NodeComponent bindCmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@LiteflowMethod注解上的nodeId一定要写。\n\n普通组件上的nodeType因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodeType = NodeTypeEnum.COMMON。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如IF组件的processIf方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public boolean isAccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "a", nodeType = NodeTypeEnum.COMMON)\n    public void onSuccessA(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_IF, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public boolean processF(NodeComponent bindCmp) {\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.IS_ACCESS, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public boolean isAccessF(NodeComponent bindCmp){\n        ...\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.ON_SUCCESS, nodeId = "f", nodeType = NodeTypeEnum.IF)\n    public void onSuccessF(NodeComponent bindCmp){\n        ...\n    }\n}\n',normalizedContent:'liteflow从v2.9.0版开始推出了方法级别的声明特性。\n\n方法级别式声明可以让用户在一个类中通过注解定义多个组件，更加的灵活。\n\n如果你有非常多的组件，又同时想避免类的定义过多的问题，那这个特性非常适合这种需求。\n\n你可以像这样来在一个bean里定义多个组件：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    //普通组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a")\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    //switch组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodeid = "b", nodetype = nodetypeenum.switch)\n    public string processb(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //if组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_if, nodeid = "c", nodetype = nodetypeenum.if)\n    public boolean processc(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //for组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_for, nodeid = "d", nodetype = nodetypeenum.for)\n    public int processd(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //while组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_while, nodeid = "e", nodetype = nodetypeenum.while)\n    public int processe(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //break组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_break, nodeid = "f", nodetype = nodetypeenum.break)\n    public int processf(nodecomponent bindcmp) {\n        ...\n    }\n}\n\n\n注意点1\n\n这里要注意的是，对于方法级别声明特性来说，@liteflowmethod注解上的nodeid一定要写。\n\n普通组件上的nodetype因为有默认值，所以可以不写，但是为了理解清晰，还是建议大家加上nodetype = nodetypeenum.common。\n\n注意点2\n\n自己定义方法时，返回值要和常规组件里的对应方法返回值一致。比如普通组件的process方法是不返回的，比如if组件的processif方法是返回布尔值的。\n\n如果写错，也会发生一点异常，可能会增加你的排查时间。\n\n对于其他组件的方法，也是一样的声明方式，比如我在一个类里定义2个组件，每个组件分别实现3个方法，可以这么写：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodetype = nodetypeenum.common)\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "a", nodetype = nodetypeenum.common)\n    public boolean isaccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "a", nodetype = nodetypeenum.common)\n    public void onsuccessa(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.process_if, nodeid = "f", nodetype = nodetypeenum.if)\n    public boolean processf(nodecomponent bindcmp) {\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.is_access, nodeid = "f", nodetype = nodetypeenum.if)\n    public boolean isaccessf(nodecomponent bindcmp){\n        ...\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.on_success, nodeid = "f", nodetype = nodetypeenum.if)\n    public void onsuccessf(nodecomponent bindcmp){\n        ...\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎯如何构造",frontmatter:{title:"🎯如何构造",date:"2022-07-02T15:57:38.000Z",permalink:"/pages/v2.9.X/6bc8fe/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/020.%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0.html",relativePath:"10.v2.9.X文档/090.🎲用代码动态构造规则/020.如何构造.md",key:"v-10f0512d",path:"/pages/v2.9.X/6bc8fe/",headers:[{level:2,title:"什么时候构造",slug:"什么时候构造",normalizedTitle:"什么时候构造",charIndex:93},{level:2,title:"构造Node",slug:"构造node",normalizedTitle:"构造node",charIndex:145},{level:2,title:"构建一个Chain",slug:"构建一个chain",normalizedTitle:"构建一个chain",charIndex:1416},{level:2,title:"销毁一个Chain",slug:"销毁一个chain",normalizedTitle:"销毁一个chain",charIndex:1738}],headersStr:"什么时候构造 构造Node 构建一个Chain 销毁一个Chain",content:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造Node\n\n提示\n\n你可以像以下那样构造一个普通的Node，当然在spring/springboot环境，大多数情况你无需去构建一个Node，因为只要你的组件上标有@Component/@LiteflowComponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件\n\n//构建一个普通组件\nLiteFlowNodeBuilder.createCommonNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个普通条件组件\nLiteFlowNodeBuilder.createSwitchNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个脚本组件\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nLiteFlowNodeBuilder.createScriptSwitchNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setFile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@LiteflowComponent或者@Component，如果项目是spring体系的话，LiteFlow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@Autowired和@Resource等等之类的spring任何注解。\n\n\n# 构建一个Chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个EL表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 销毁一个Chain\n\nLiteFlow中允许你手动运行以下代码来销毁一个流程：\n\nFlowBus.removeChain("你的流程ID")\n',normalizedContent:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造node\n\n提示\n\n你可以像以下那样构造一个普通的node，当然在spring/springboot环境，大多数情况你无需去构建一个node，因为只要你的组件上标有@component/@liteflowcomponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件\n\n//构建一个普通组件\nliteflownodebuilder.createcommonnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个普通条件组件\nliteflownodebuilder.createswitchnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个脚本组件\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nliteflownodebuilder.createscriptswitchnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setfile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@liteflowcomponent或者@component，如果项目是spring体系的话，liteflow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@autowired和@resource等等之类的spring任何注解。\n\n\n# 构建一个chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个el表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 销毁一个chain\n\nliteflow中允许你手动运行以下代码来销毁一个流程：\n\nflowbus.removechain("你的流程id")\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥠替补组件",frontmatter:{title:"🥠替补组件",date:"2022-07-27T00:07:01.000Z",permalink:"/pages/v2.9.X/79289a/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/035.%E6%9B%BF%E8%A1%A5%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/035.替补组件.md",key:"v-75fc0eca",path:"/pages/v2.9.X/79289a/",headersStr:null,content:'如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了A，B，C三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    THEN(A, B, C, D);\n</chain>\n\n\n由于D组件不存在，所以启动时会报错。\n\n替补组件的意义是，当你写了一个不存在的组件时，在解析时会自动解析到你指定的替补组件上，由这个替补组件来代替你不存在的组件来执行，这样就不会报错了。\n\n你需要在配置中指定你的替补组件：\n\nliteflow.substitute-cmp-class=com.yomahub.liteflow.test.substituteNode.cmp.SubCmp\n\n\n替补组件本身定义和其他的组件没有任何区别，如果在spring体系中，需要被注册到上下文，如果非spring环境，也需要在规则文件中定义。\n\n当你指定了替补组件后，你的规则文件需要这么写：\n\n<chain name="chain1">\n    THEN(A, B, C, node("D"));\n</chain>\n\n\n提示\n\n这里注意下，如果不加node关键字，不会自动路由到替补组件的，所以一定得加。',normalizedContent:'如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了a，b，c三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n由于d组件不存在，所以启动时会报错。\n\n替补组件的意义是，当你写了一个不存在的组件时，在解析时会自动解析到你指定的替补组件上，由这个替补组件来代替你不存在的组件来执行，这样就不会报错了。\n\n你需要在配置中指定你的替补组件：\n\nliteflow.substitute-cmp-class=com.yomahub.liteflow.test.substitutenode.cmp.subcmp\n\n\n替补组件本身定义和其他的组件没有任何区别，如果在spring体系中，需要被注册到上下文，如果非spring环境，也需要在规则文件中定义。\n\n当你指定了替补组件后，你的规则文件需要这么写：\n\n<chain name="chain1">\n    then(a, b, c, node("d"));\n</chain>\n\n\n提示\n\n这里注意下，如果不加node关键字，不会自动路由到替补组件的，所以一定得加。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍒前置和后置组件",frontmatter:{title:"🍒前置和后置组件",date:"2022-07-02T22:51:41.000Z",permalink:"/pages/v2.9.X/9f93be/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/030.%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E7%BB%84%E4%BB%B6.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/030.前置和后置组件.md",key:"v-21e11e33",path:"/pages/v2.9.X/9f93be/",headers:[{level:2,title:"前置组件",slug:"前置组件",normalizedTitle:"前置组件",charIndex:11},{level:2,title:"后置节点",slug:"后置节点",normalizedTitle:"后置节点",charIndex:259},{level:2,title:"顺序问题",slug:"顺序问题",normalizedTitle:"顺序问题",charIndex:446},{level:2,title:"层级和范围",slug:"层级和范围",normalizedTitle:"层级和范围",charIndex:732}],headersStr:"前置组件 后置节点 顺序问题 层级和范围",content:'LiteFlow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用PRE关键字(必须大写)来表示:\n\n<chain name="chain1">\n    THEN(\n        PRE(p1, p2), \n        a, b, c, \n        WHEN(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受Exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用FINALLY关键字(必须大写)表示：\n\n<chain name="chain1">\n    THEN(\n        a, b, c, \n        FINALLY(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，PRE和FINALLY可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    THEN(\n        PRE(a), c, d, FINALLY(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    THEN(\n        FINALLY(f1, f2), c, PRE(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nLiteFlow 2.9.5中能支持PRE和FINALLY写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\nPRE和FINALLY只能写在THEN表达式中，如果你写在WHEN表达式中或者其他诸如SWITCH,IF的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = THEN(PRE(p1, p2), THEN(a, b, c), FINALLY(f1, f2));\n    THEN(PRE(p1, p2), c1, FINALLY(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',normalizedContent:'liteflow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用pre关键字(必须大写)来表示:\n\n<chain name="chain1">\n    then(\n        pre(p1, p2), \n        a, b, c, \n        when(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用finally关键字(必须大写)表示：\n\n<chain name="chain1">\n    then(\n        a, b, c, \n        finally(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，pre和finally可以写在任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    then(\n        pre(a), c, d, finally(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    then(\n        finally(f1, f2), c, pre(a), d\n    );\n</chain>\n\n\n\n# 层级和范围\n\nliteflow 2.9.5中能支持pre和finally写在表达式的任意层级。也意味着你在子流程中，子变量中也可以用前置和后置组件。\n\n提示\n\npre和finally只能写在then表达式中，如果你写在when表达式中或者其他诸如switch,if的表达式中，是不会生效的，而且这样写也是毫无意义的。这点需要注意下。\n\n比如你可以这么写：\n\n<chain name="chain6">\n    c1 = then(pre(p1, p2), then(a, b, c), finally(f1, f2));\n    then(pre(p1, p2), c1, finally(f1));\n</chain>\n\n\n最终执行结果就是：\n\np1==>p2==>p1==>p2==>a==>b==>c==>f1==>f2==>f1\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍍组件标签",frontmatter:{title:"🍍组件标签",date:"2022-07-03T00:32:36.000Z",permalink:"/pages/v2.9.X/0f788f/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/050.%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/050.组件标签.md",key:"v-18ac2dc6",path:"/pages/v2.9.X/0f788f/",headersStr:null,content:'你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    THEN(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.getTag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        String tag = this.getTag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    THEN(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',normalizedContent:'你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    then(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.gettag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n    @override\n    public void process() {\n        string tag = this.gettag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    then(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍑组件别名",frontmatter:{title:"🍑组件别名",date:"2022-07-03T00:31:22.000Z",permalink:"/pages/v2.9.X/92ef89/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/040.%E7%BB%84%E4%BB%B6%E5%88%AB%E5%90%8D.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/040.组件别名.md",key:"v-1c718c24",path:"/pages/v2.9.X/92ef89/",headers:[{level:2,title:"Springboot & Spring 扫描方式",slug:"springboot-spring-扫描方式",normalizedTitle:"springboot &amp; spring 扫描方式",charIndex:null},{level:2,title:"规则文件方式定义组件",slug:"规则文件方式定义组件",normalizedTitle:"规则文件方式定义组件",charIndex:381},{level:2,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:49}],headersStr:"Springboot & Spring 扫描方式 规则文件方式定义组件 打印",content:'LiteFlow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# Springboot & Spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@Component换成@LiteflowComponent，并做如下定义：\n\n@LiteflowComponent(id = "a", name = "组件A")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件A" class="com.yomahub.liteflow.test.config.cmp.ACmp"/>\n<node id="b" name="组件B" class="com.yomahub.liteflow.test.config.cmp.BCmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',normalizedContent:'liteflow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# springboot & spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@component换成@liteflowcomponent，并做如下定义：\n\n@liteflowcomponent(id = "a", name = "组件a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件a" class="com.yomahub.liteflow.test.config.cmp.acmp"/>\n<node id="b" name="组件b" class="com.yomahub.liteflow.test.config.cmp.bcmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍉组件参数",frontmatter:{title:"🍉组件参数",date:"2022-10-06T22:55:30.000Z",permalink:"/pages/v2.9.X/6e4d15/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/036.%E7%BB%84%E4%BB%B6%E5%8F%82%E6%95%B0.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/036.组件参数.md",key:"v-40e52047",path:"/pages/v2.9.X/6e4d15/",headersStr:null,content:'LiteFlow从v2.9.0开始支持了组件参数特性，你可以在EL语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是JSON格式：\n\n<flow>\n    <chain name="chain1">\n        cmpData = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        THEN(a, b.data(cmpData), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpData = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        WHEN(c, b.data(cmpData));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过getCmpData方法也能拿到相应的参数。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tUser user = this.getCmpData(User.class);\n\t\t...\n\t}\n\n}\n',normalizedContent:'liteflow从v2.9.0开始支持了组件参数特性，你可以在el语法中来给组件设置外置参数。\n\n这对于相同组件的编排是非常有用的特性。\n\n你可以使用data关键字来给某个组件设置外置参数，建议最好是json格式：\n\n<flow>\n    <chain name="chain1">\n        cmpdata = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n    \n        then(a, b.data(cmpdata), c);\n    </chain>\n    \n    <chain name="chain2">\n        cmpdata = \'{"name":"rose","age":20,"birth":"1997-07-01"}\';\n    \n        when(c, b.data(cmpdata));\n    </chain>\n</flow>\n\n\n上述表达式中，同一个b组件，在不同的chain中被赋予了不同的外置参数，运行中在组件中通过getcmpdata方法也能拿到相应的参数。\n\n这个方法是可以返回对应结构的java对象的，只要传入相对应的class即可。\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tuser user = this.getcmpdata(user.class);\n\t\t...\n\t}\n\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥝组件事件回调",frontmatter:{title:"🥝组件事件回调",date:"2022-07-03T00:41:09.000Z",permalink:"/pages/v2.9.X/3ee755/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/060.%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/060.组件事件回调.md",key:"v-46a8dc7a",path:"/pages/v2.9.X/3ee755/",headers:[{level:2,title:"成功事件",slug:"成功事件",normalizedTitle:"成功事件",charIndex:31},{level:2,title:"失败事件",slug:"失败事件",normalizedTitle:"失败事件",charIndex:36},{level:3,title:"注意点1",slug:"注意点1",normalizedTitle:"注意点1",charIndex:831},{level:3,title:"注意点2",slug:"注意点2",normalizedTitle:"注意点2",charIndex:901},{level:3,title:"注意点3",slug:"注意点3",normalizedTitle:"注意点3",charIndex:1371}],headersStr:"成功事件 失败事件 注意点1 注意点2 注意点3",content:'LiteFlow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onSuccess方法，那么组件成功后会回调这个方法。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void onSuccess() throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onError方法，那么组件发生异常后会回调这个方法。\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError() throws Exception {\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonError方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onError方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onError方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError() throws Exception {\n\t\tthrow new IllegalAccessException("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是NullPointerException而不是IllegalAccessException，但是IllegalAccessException这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonError方法执行后，afterProcess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterProcess方法都会被执行。',normalizedContent:'liteflow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onsuccess方法，那么组件成功后会回调这个方法。\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void onsuccess() throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onerror方法，那么组件发生异常后会回调这个方法。\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror() throws exception {\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonerror方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onerror方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onerror方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror() throws exception {\n\t\tthrow new illegalaccessexception("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是nullpointerexception而不是illegalaccessexception，但是illegalaccessexception这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonerror方法执行后，afterprocess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterprocess方法都会被执行。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥑隐式子流程",frontmatter:{title:"🥑隐式子流程",date:"2022-07-03T00:42:38.000Z",permalink:"/pages/v2.9.X/80e873/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/070.%E9%9A%90%E5%BC%8F%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/070.隐式子流程.md",key:"v-0cadd811",path:"/pages/v2.9.X/80e873/",headersStr:null,content:'LiteFlow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@Component("h")\npublic class HComponent extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("Hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeInAsync方法。\n\n同样，隐式子流程也支持返回LiteFlowResponse对象，需要调用invoke2Resp方法，关于返回对象为LiteFlowResponse的说明，请参照LiteflowResponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getSubChainReqData()去拿。\n\n如果你是用invokeInAsync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getSubChainReqDataInAsync()去拿。\n\n用this.getRequestData()是拿不到的！',normalizedContent:'liteflow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@component("h")\npublic class hcomponent extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeinasync方法。\n\n同样，隐式子流程也支持返回liteflowresponse对象，需要调用invoke2resp方法，关于返回对象为liteflowresponse的说明，请参照liteflowresponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getsubchainreqdata()去拿。\n\n如果你是用invokeinasync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getsubchainreqdatainasync()去拿。\n\n用this.getrequestdata()是拿不到的！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍕私有投递",frontmatter:{title:"🍕私有投递",date:"2022-07-03T10:59:19.000Z",permalink:"/pages/v2.9.X/fbb938/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/080.%E7%A7%81%E6%9C%89%E6%8A%95%E9%80%92.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/080.私有投递.md",key:"v-253500a4",path:"/pages/v2.9.X/fbb938/",headers:[{level:2,title:"什么叫私有投递",slug:"什么叫私有投递",normalizedTitle:"什么叫私有投递",charIndex:21},{level:2,title:"解决方式",slug:"解决方式",normalizedTitle:"解决方式",charIndex:657}],headersStr:"什么叫私有投递 解决方式",content:'LiteFlow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个LiteFLow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        THEN(\n            a,\n            WHEN(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，LiteFlow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t\tDefaultContext context = this.getContextBean(DefaultContext.class);\n\t\tcontext.setData("testSet", new HashSet<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendPrivateDeliveryData("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendPrivateDeliveryData方法，指定了b组件\n\n然后我们再来看b组件：\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("BCmp executed!");\n\t\tInteger value = this.getPrivateDeliveryData();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getPrivateDeliveryData()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',normalizedContent:'liteflow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个liteflow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        then(\n            a,\n            when(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，liteflow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t\tdefaultcontext context = this.getcontextbean(defaultcontext.class);\n\t\tcontext.setdata("testset", new hashset<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendprivatedeliverydata("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendprivatedeliverydata方法，指定了b组件\n\n然后我们再来看b组件：\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("bcmp executed!");\n\t\tinteger value = this.getprivatedeliverydata();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getprivatedeliverydata()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣组件重试",frontmatter:{title:"🍣组件重试",date:"2022-07-03T11:03:09.000Z",permalink:"/pages/v2.9.X/7e9da1/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/090.%E7%BB%84%E4%BB%B6%E9%87%8D%E8%AF%95.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/090.组件重试.md",key:"v-7b67b75f",path:"/pages/v2.9.X/7e9da1/",headers:[{level:2,title:"全局重试",slug:"全局重试",normalizedTitle:"全局重试",charIndex:21},{level:2,title:"单个组件重试",slug:"单个组件重试",normalizedTitle:"单个组件重试",charIndex:26},{level:2,title:"全局重试和单个组件重试都定义的情况下",slug:"全局重试和单个组件重试都定义的情况下",normalizedTitle:"全局重试和单个组件重试都定义的情况下",charIndex:970}],headersStr:"全局重试 单个组件重试 全局重试和单个组件重试都定义的情况下",content:'LiteFLow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了isContinueOnError，设为true的话，那流程会继续。\n\n异步流程的话，如果WHEN上配置了ignoreError为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreError的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nLiteFlow还提供了基于单个组件，指定Exception的重试特性，LiteFlow从2.6.0开始提供了@LiteflowRetry标注\n\n你可以在指定的组件上进行标注：\n\n@LiteflowComponent("c")\n@LiteflowRetry(5)\npublic class CCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@LiteflowComponent("e")\n@LiteflowRetry(retry = 5, forExceptions = {NullPointerException.class,IllegalArgumentException.class})\npublic class ECmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是NullPointerException或者IllegalArgumentException（或者是这两个Exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',normalizedContent:'liteflow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了iscontinueonerror，设为true的话，那流程会继续。\n\n异步流程的话，如果when上配置了ignoreerror为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreerror的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nliteflow还提供了基于单个组件，指定exception的重试特性，liteflow从2.6.0开始提供了@liteflowretry标注\n\n你可以在指定的组件上进行标注：\n\n@liteflowcomponent("c")\n@liteflowretry(5)\npublic class ccmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@liteflowcomponent("e")\n@liteflowretry(retry = 5, forexceptions = {nullpointerexception.class,illegalargumentexception.class})\npublic class ecmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是nullpointerexception或者illegalargumentexception（或者是这两个exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍖平滑热刷新",frontmatter:{title:"🍖平滑热刷新",date:"2022-07-03T11:04:48.000Z",permalink:"/pages/v2.9.X/204d71/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/100.%E5%B9%B3%E6%BB%91%E7%83%AD%E5%88%B7%E6%96%B0.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/100.平滑热刷新.md",key:"v-7526d598",path:"/pages/v2.9.X/204d71/",headers:[{level:2,title:"基于规则文件-主动刷新",slug:"基于规则文件-主动刷新",normalizedTitle:"基于规则文件-主动刷新",charIndex:255},{level:2,title:"基于规则文件-被动刷新",slug:"基于规则文件-被动刷新",normalizedTitle:"基于规则文件-被动刷新",charIndex:377},{level:2,title:"基于动态代码构建-刷新",slug:"基于动态代码构建-刷新",normalizedTitle:"基于动态代码构建-刷新",charIndex:704}],headersStr:"基于规则文件-主动刷新 基于规则文件-被动刷新 基于动态代码构建-刷新",content:"LiteFlow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nLiteFlow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，LiteFlow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到FlowExecutor对象后，调用以下接口：\n\nflowExecutor.reloadRule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nFlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_EL_XML, newContent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml，这里注意下，在EL规则表达式下，都是TYPE_EL_XXX的形式，不带EL的那是旧的形式，请不要用错！\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",normalizedContent:"liteflow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nliteflow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，liteflow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到flowexecutor对象后，调用以下接口：\n\nflowexecutor.reloadrule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nflowbus.refreshflowmetadata(flowparsertypeenum.type_el_xml, newcontent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml，这里注意下，在el规则表达式下，都是type_el_xxx的形式，不带el的那是旧的形式，请不要用错！\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍪组件切面",frontmatter:{title:"🍪组件切面",date:"2022-07-03T11:07:26.000Z",permalink:"/pages/v2.9.X/2373f5/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/110.%E7%BB%84%E4%BB%B6%E5%88%87%E9%9D%A2.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/110.组件切面.md",key:"v-df4a91a0",path:"/pages/v2.9.X/2373f5/",headers:[{level:2,title:"全局切面",slug:"全局切面",normalizedTitle:"全局切面",charIndex:47},{level:2,title:"Aspect的切面",slug:"aspect的切面",normalizedTitle:"aspect的切面",charIndex:520}],headersStr:"全局切面 Aspect的切面",content:'LiteFlow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@Component\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(String nodeId, Slot slot) {\n        YourContextBean context = slot.getContextBean(YourContextBean.class);\n        //before business\n    }\n\n    @Override\n    public void afterProcess(String nodeId, Slot slot) {\n        YourContextBean context = slot.getContextBean(YourContextBean.class);\n        //after business\n    }\n}\n\n\n\n# Aspect的切面\n\nLiteFlow同时也支持了Spring Aspect的切面，你可以用@Aspect标注对任意包，任意规则内的组件进行切面\n\n@Aspect\npublic class CustomAspect {\n\n    @Pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @Around("cut()")\n    public Object around(ProceedingJoinPoint jp) throws Throwable {\n        //do before business\n        Object returnObj = jp.proceed();\n        //do after business\n        return returnObj;\n    }\n}\n',normalizedContent:'liteflow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\n@component\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(string nodeid, slot slot) {\n        yourcontextbean context = slot.getcontextbean(yourcontextbean.class);\n        //before business\n    }\n\n    @override\n    public void afterprocess(string nodeid, slot slot) {\n        yourcontextbean context = slot.getcontextbean(yourcontextbean.class);\n        //after business\n    }\n}\n\n\n\n# aspect的切面\n\nliteflow同时也支持了spring aspect的切面，你可以用@aspect标注对任意包，任意规则内的组件进行切面\n\n@aspect\npublic class customaspect {\n\n    @pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @around("cut()")\n    public object around(proceedingjoinpoint jp) throws throwable {\n        //do before business\n        object returnobj = jp.proceed();\n        //do after business\n        return returnobj;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍡步骤信息",frontmatter:{title:"🍡步骤信息",date:"2022-07-03T11:09:40.000Z",permalink:"/pages/v2.9.X/e5ed0d/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/120.%E6%AD%A5%E9%AA%A4%E4%BF%A1%E6%81%AF.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/120.步骤信息.md",key:"v-4b48812e",path:"/pages/v2.9.X/e5ed0d/",headersStr:null,content:'LiteFlow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过LiteflowResponse对象来获取的：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "初始参数", CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得Map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的Map中这个组件id的value是最终的那个步骤信息。\n\n而获得Queue<CmpStep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在CmpStep这个对象里，你可以通过以下方法获得你要的数据：\n\n * isSuccess：此组件是否执行成功\n * getNodeId：获得组件Id\n * getNodeName：获得组件名称\n * getTag：获得组件标签值\n * getTimeSpent：获得组件的耗时，单位为毫秒\n * getException：获取此组件抛出的异常，如果isSuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getCause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',normalizedContent:'liteflow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过liteflowresponse对象来获取的：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "初始参数", customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的map中这个组件id的value是最终的那个步骤信息。\n\n而获得queue<cmpstep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在cmpstep这个对象里，你可以通过以下方法获得你要的数据：\n\n * issuccess：此组件是否执行成功\n * getnodeid：获得组件id\n * getnodename：获得组件名称\n * gettag：获得组件标签值\n * gettimespent：获得组件的耗时，单位为毫秒\n * getexception：获取此组件抛出的异常，如果issuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getcause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧊异常",frontmatter:{title:"🧊异常",date:"2022-07-26T23:38:00.000Z",permalink:"/pages/v2.9.X/dc9bfe/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/125.%E5%BC%82%E5%B8%B8.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/125.异常.md",key:"v-4d862e92",path:"/pages/v2.9.X/dc9bfe/",headersStr:null,content:'通常在LiteFlow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreError关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进LiteflowResponse对象中。\n\n你可以在LiteflowResponse对象中通过以下方法来获取异常\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n如果你的业务中有获取异常Code的需求，则你自定义的异常需要实现LiteFlow提供的LiteFlowException接口：\n\npublic class YourException extends LiteFlowException {\n\tpublic YourException(String code, String message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了LiteFlowException接口的异常，你则可以在LiteflowResponse中获得message和code信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n  String code = response.getCode();\n  String message = response.getMessage();\n}\n\n\n提示\n\n如果你的异常没实现LiteFlowException，code和message字段都为null。',normalizedContent:'通常在liteflow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreerror关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进liteflowresponse对象中。\n\n你可以在liteflowresponse对象中通过以下方法来获取异常\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n如果你的业务中有获取异常code的需求，则你自定义的异常需要实现liteflow提供的liteflowexception接口：\n\npublic class yourexception extends liteflowexception {\n\tpublic yourexception(string code, string message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了liteflowexception接口的异常，你则可以在liteflowresponse中获得message和code信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n  string code = response.getcode();\n  string message = response.getmessage();\n}\n\n\n提示\n\n如果你的异常没实现liteflowexception，code和message字段都为null。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧇打印信息详解",frontmatter:{title:"🧇打印信息详解",date:"2022-07-03T11:12:19.000Z",permalink:"/pages/v2.9.X/4d614c/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/130.%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/130.打印信息详解.md",key:"v-3b3b3795",path:"/pages/v2.9.X/4d614c/",headers:[{level:2,title:"流程执行中打印",slug:"流程执行中打印",normalizedTitle:"流程执行中打印",charIndex:2},{level:2,title:"打印步骤信息",slug:"打印步骤信息",normalizedTitle:"打印步骤信息",charIndex:558}],headersStr:"流程执行中打印 打印步骤信息",content:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[ACmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[BCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[X]start component[CCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[DCmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求ID，一个请求无论经历了多少个组件，他们的请求ID都是一致的，你可以根据这个ID在日志中进行快速定位进行排查。\n\n在后面会跟着一个[O]或者[X]，[O]代表了执行了这个组件的主要逻辑，[X]代表因为isAccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，LiteFlow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件ID<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件A]<100>==>b[组件B]<0>==>m[组件M]<256>\n\n\n这里的表达形式为：组件ID[组件别名]<耗时毫秒>",normalizedContent:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[acmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[bcmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[x]start component[ccmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[dcmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求id，一个请求无论经历了多少个组件，他们的请求id都是一致的，你可以根据这个id在日志中进行快速定位进行排查。\n\n在后面会跟着一个[o]或者[x]，[o]代表了执行了这个组件的主要逻辑，[x]代表因为isaccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，liteflow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件id<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件a]<100>==>b[组件b]<0>==>m[组件m]<256>\n\n\n这里的表达形式为：组件id[组件别名]<耗时毫秒>",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧁自定义请求Id",frontmatter:{title:"🧁自定义请求Id",date:"2022-07-03T11:12:53.000Z",permalink:"/pages/v2.9.X/47e8f5/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/140.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82Id.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/140.自定义请求Id.md",key:"v-4027c910",path:"/pages/v2.9.X/47e8f5/",headersStr:null,content:"LiteFlow支持让你自定义你的请求Id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[a] execution\n2022-07-03 11:15:00.204  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[b] execution\n2022-07-03 11:15:00.218  INFO 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[c] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[d] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [           main] com.yomahub.liteflow.slot.Slot           : [067a0baa6d434de3a8ccafa4b1506562]:CHAIN_NAME[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  INFO 71275 --- [           main] com.yomahub.liteflow.slot.DataBus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是RequestId，一个请求中的requestId都是相同的，方便你进行日志查找。\n\n这个requestId的形式也是可以自定义的。\n\n你只需要要声明一个类，然后实现RequestIdGenerator接口即可：\n\npublic class CustomRequestIdGenerator implements RequestIdGenerator {\n\n    @Override\n    public String generate() {\n        return System.nanoTime();\n    }\n}\n\n\n然后在LiteFlow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestId.config.CustomRequestIdGenerator\n\n\n一般情况下，LiteFlow有自己默认的Id生成规则。所以大多数情况下你并不需要去特别自定义这个Id生成器。",normalizedContent:"liteflow支持让你自定义你的请求id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[a] execution\n2022-07-03 11:15:00.204  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[b] execution\n2022-07-03 11:15:00.218  info 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[c] execution\n2022-07-03 11:15:00.220  info 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[d] execution\n2022-07-03 11:15:00.220  info 71275 --- [           main] com.yomahub.liteflow.slot.slot           : [067a0baa6d434de3a8ccafa4b1506562]:chain_name[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  info 71275 --- [           main] com.yomahub.liteflow.slot.databus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是requestid，一个请求中的requestid都是相同的，方便你进行日志查找。\n\n这个requestid的形式也是可以自定义的。\n\n你只需要要声明一个类，然后实现requestidgenerator接口即可：\n\npublic class customrequestidgenerator implements requestidgenerator {\n\n    @override\n    public string generate() {\n        return system.nanotime();\n    }\n}\n\n\n然后在liteflow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestid.config.customrequestidgenerator\n\n\n一般情况下，liteflow有自己默认的id生成规则。所以大多数情况下你并不需要去特别自定义这个id生成器。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌭不同格式规则加载",frontmatter:{title:"🌭不同格式规则加载",date:"2022-07-03T11:20:47.000Z",permalink:"/pages/v2.9.X/a7e02e/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/150.%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99%E5%8A%A0%E8%BD%BD.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/150.不同格式规则加载.md",key:"v-73a75c4c",path:"/pages/v2.9.X/a7e02e/",headersStr:null,content:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipleType/flow.el.xml,multipleType/flow.el.json\n\n\n这种模式在正常下会解析失败，但是LiteFLow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",normalizedContent:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipletype/flow.el.xml,multipletype/flow.el.json\n\n\n这种模式在正常下会解析失败，但是liteflow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥗异步线程池自定义",frontmatter:{title:"🥗异步线程池自定义",date:"2022-07-03T11:21:39.000Z",permalink:"/pages/v2.9.X/7280ea/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/160.%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%87%AA%E5%AE%9A%E4%B9%89.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/160.异步线程池自定义.md",key:"v-7a595d3c",path:"/pages/v2.9.X/7280ea/",headers:[{level:2,title:"默认全局线程池",slug:"默认全局线程池",normalizedTitle:"默认全局线程池",charIndex:2},{level:2,title:"自定义全局线程池",slug:"自定义全局线程池",normalizedTitle:"自定义全局线程池",charIndex:157},{level:2,title:"WHEN级别的单独线程池",slug:"when级别的单独线程池",normalizedTitle:"when级别的单独线程池",charIndex:1134},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1940}],headersStr:"默认全局线程池 自定义全局线程池 WHEN级别的单独线程池 优先级",content:'# 默认全局线程池\n\nLiteFlow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，LiteFlow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的Builder：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n\n\n然后把你的Builder加入LiteFlow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n\t<property name="ruleSource" value="customThreadPool/flow.el.xml"/>\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.test.customThreadPool.CustomThreadBuilder"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n  <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n这样，LiteFlow在启动的时候就会自动通过你声明的Builder加载到自定义的线程池了。\n\n\n# WHEN级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    WHEN(a, b);\n</chain>\n\n<chain name="chain2">\n    WHEN(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class CustomThreadExecutor1 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class CustomThreadExecutor2 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    WHEN(a, b).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor1");\n</chain>\n<chain name="chain2">\n    WHEN(c, d).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和Condition都配置自定义线程池的情况下，优先使用Condition上配置的线程池。',normalizedContent:'# 默认全局线程池\n\nliteflow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，liteflow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的builder：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n\n\n然后把你的builder加入liteflow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadbuilder\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n\t<property name="rulesource" value="customthreadpool/flow.el.xml"/>\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.test.customthreadpool.customthreadbuilder"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n  <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n这样，liteflow在启动的时候就会自动通过你声明的builder加载到自定义的线程池了。\n\n\n# when级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    when(a, b);\n</chain>\n\n<chain name="chain2">\n    when(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class customthreadexecutor1 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class customthreadexecutor2 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    when(a, b).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor1");\n</chain>\n<chain name="chain2">\n    when(c, d).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和condition都配置自定义线程池的情况下，优先使用condition上配置的线程池。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍿自定义组件执行器",frontmatter:{title:"🍿自定义组件执行器",date:"2022-07-03T11:24:54.000Z",permalink:"/pages/v2.9.X/46bbed/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/170.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/170.自定义组件执行器.md",key:"v-29f3fb6c",path:"/pages/v2.9.X/46bbed/",headers:[{level:2,title:"全局组件执行器",slug:"全局组件执行器",normalizedTitle:"全局组件执行器",charIndex:130},{level:2,title:"单个组件配置特殊的执行器",slug:"单个组件配置特殊的执行器",normalizedTitle:"单个组件配置特殊的执行器",charIndex:755},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1147},{level:2,title:"自定义执行器对于重试功能的影响",slug:"自定义执行器对于重试功能的影响",normalizedTitle:"自定义执行器对于重试功能的影响",charIndex:1196}],headersStr:"全局组件执行器 单个组件配置特殊的执行器 优先级 自定义执行器对于重试功能的影响",content:'LiteFlow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeExecutor.CustomerDefaultNodeExecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.NodeExecutor。\n\npublic class CustomerDefaultNodeExecutor extends NodeExecutor {\n    @Override\n    public void execute(NodeComponent instance) throws Exception {\n        LOG.info("使用customerDefaultNodeExecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getNodeExecutorClass 方法：\n\n@LiteflowComponent("d")\npublic class DCmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        System.out.println("DCmp executed!");\n    }\n\n    @Override\n    public Class<? extends NodeExecutor> getNodeExecutorClass() {\n        return CustomerNodeExecutorAndCustomRetry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@LiteflowRetry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',normalizedContent:'liteflow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeexecutor.customerdefaultnodeexecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.nodeexecutor。\n\npublic class customerdefaultnodeexecutor extends nodeexecutor {\n    @override\n    public void execute(nodecomponent instance) throws exception {\n        log.info("使用customerdefaultnodeexecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getnodeexecutorclass 方法：\n\n@liteflowcomponent("d")\npublic class dcmp extends nodecomponent {\n\n    @override\n    public void process() {\n        system.out.println("dcmp executed!");\n    }\n\n    @override\n    public class<? extends nodeexecutor> getnodeexecutorclass() {\n        return customernodeexecutorandcustomretry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@liteflowretry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍥简单监控",frontmatter:{title:"🍥简单监控",date:"2022-07-03T11:25:52.000Z",permalink:"/pages/v2.9.X/e59f3a/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/180.%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/180.简单监控.md",key:"v-0d8f95bb",path:"/pages/v2.9.X/e59f3a/",headersStr:null,content:"LiteFlow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",normalizedContent:"liteflow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧉XML的DTD",frontmatter:{title:"🧉XML的DTD",date:"2022-10-24T12:50:29.000Z",permalink:"/pages/v2.9.X/0066ae/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/190.XML%E7%9A%84DTD.html",relativePath:"10.v2.9.X文档/100.🎨高级特性/190.XML的DTD.md",key:"v-3aec6ce4",path:"/pages/v2.9.X/0066ae/",headersStr:null,content:'LiteFlow从2.9.1版本起，对XML增加了DTD，方便在XML里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE flow PUBLIC  "liteflow" "liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        THEN(a,b,WHEN(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为LiteFlow xml节点非常简单，并没有很多的节点标签需要记忆。',normalizedContent:'liteflow从2.9.1版本起，对xml增加了dtd，方便在xml里作一些检查和提醒约束。\n\n具体引用方法为：\n\n\n\n \n\n\n\n\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype flow public  "liteflow" "liteflow.dtd">\n<flow>\n    <chain name="chain1">\n        then(a,b,when(c,d));\n    </chain>\n</flow>\n\n\n提示\n\n当然不加也是没有关系的，因为liteflow xml节点非常简单，并没有很多的节点标签需要记忆。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪁测试用例",frontmatter:{title:"🪁测试用例",date:"2022-07-03T11:28:26.000Z",permalink:"/pages/v2.9.X/81cdce/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/010.%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",relativePath:"10.v2.9.X文档/110.⛱测试用例以及示例/010.测试用例.md",key:"v-21afc496",path:"/pages/v2.9.X/81cdce/",headersStr:null,content:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有600多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解LiteFlow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于Groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于QLExpress脚本框架的测试用例\n * liteflow-testcase-el-zk-springboot: ZK配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: SQL数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: Nacos配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: Etcd配置源场景下的测试用例",normalizedContent:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有600多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解liteflow的同学可以去看看测试用例来学会如何在细节点上的配置和使用\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例\n * liteflow-testcase-el-nospring: 非spring体系的测试用例\n * liteflow-testcase-el-declare-springboot: 类声明式组件场景下的测试用例\n * liteflow-testcase-el-declare-multi-springboot: 方法级声明式组件场景下的测试用例\n * liteflow-testcase-el-script-groovy-springboot: 基于groovy脚本框架的测试用例\n * liteflow-testcase-el-script-qlexpress-springboot: 基于qlexpress脚本框架的测试用例\n * liteflow-testcase-el-zk-springboot: zk配置源场景下的测试用例\n * liteflow-testcase-el-sql-springboot: sql数据库配置源场景下的测试用例\n * liteflow-testcase-el-nacos-springboot: nacos配置源场景下的测试用例\n * liteflow-testcase-el-etcd-springboot: etcd配置源场景下的测试用例",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪀DEMO案例",frontmatter:{title:"🪀DEMO案例",date:"2022-07-03T11:32:24.000Z",permalink:"/pages/v2.9.X/0a8188/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/020.DEMO%E6%A1%88%E4%BE%8B.html",relativePath:"10.v2.9.X文档/110.⛱测试用例以及示例/020.DEMO案例.md",key:"v-65d1f9ad",path:"/pages/v2.9.X/0a8188/",headers:[{level:2,title:"DEMO案例1",slug:"demo案例1",normalizedTitle:"demo案例1",charIndex:38},{level:2,title:"DEMO案例2",slug:"demo案例2",normalizedTitle:"demo案例2",charIndex:131},{level:2,title:"外置规则存储案例",slug:"外置规则存储案例",normalizedTitle:"外置规则存储案例",charIndex:217}],headersStr:"DEMO案例1 DEMO案例2 外置规则存储案例",content:"如果你想看一个实际的案例，加深对LiteFlow的理解。可以查看：\n\n\n# DEMO案例1\n\n> DEMO案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的Java业务！\n\n\n# DEMO案例2\n\n> DEMO案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到DB里，或者zk/nacos/etcd里，此案例为一个简单的DEMO，你可以根据此案例的演示来进行接入。",normalizedContent:"如果你想看一个实际的案例，加深对liteflow的理解。可以查看：\n\n\n# demo案例1\n\n> demo案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的java业务！\n\n\n# demo案例2\n\n> demo案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n\n\n\n# 外置规则存储案例\n\n> 外置规则存储案例\n\n如果你想把规则放到db里，或者zk/nacos/etcd里，此案例为一个简单的demo，你可以根据此案例的演示来进行接入。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪂性能表现",frontmatter:{title:"🪂性能表现",date:"2022-07-03T11:32:51.000Z",permalink:"/pages/v2.9.X/9bf839/"},regularPath:"/10.v2.9.X%E6%96%87%E6%A1%A3/120.%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0.html",relativePath:"10.v2.9.X文档/120.性能表现.md",key:"v-c10bbfe2",path:"/pages/v2.9.X/9bf839/",headersStr:null,content:"LiteFlow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，LiteFlow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的TPS，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然LiteFlow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求IO，或者有bad sql，又或者有大量的rpc同步调用。那实际TPS也不会很高。但是这是业务组件的的问题，而不是LiteFlow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的TPS/QPS，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nLiteFlow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库IO。\n\n基于这个Demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",normalizedContent:"liteflow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，liteflow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的tps，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然liteflow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求io，或者有bad sql，又或者有大量的rpc同步调用。那实际tps也不会很高。但是这是业务组件的的问题，而不是liteflow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的tps/qps，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nliteflow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库io。\n\n基于这个demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍤LiteFlow简介",frontmatter:{title:"🍤LiteFlow简介",date:"2022-06-16T17:51:48.000Z",permalink:"/pages/v2.8.X/5816c5/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/010.LiteFlow%E7%AE%80%E4%BB%8B.html",relativePath:"15.v2.8.X文档/010.LiteFlow简介.md",key:"v-55f81e62",path:"/pages/v2.8.X/5816c5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"LiteFlow框架的优势",slug:"liteflow框架的优势",normalizedTitle:"liteflow框架的优势",charIndex:345},{level:2,title:"LiteFlow的设计原则",slug:"liteflow的设计原则",normalizedTitle:"liteflow的设计原则",charIndex:721},{level:2,title:"LiteFlow不适用于哪些场景",slug:"liteflow不适用于哪些场景",normalizedTitle:"liteflow不适用于哪些场景",charIndex:1311},{level:2,title:"LiteFlow适用于哪些场景",slug:"liteflow适用于哪些场景",normalizedTitle:"liteflow适用于哪些场景",charIndex:1485}],headersStr:"前言 LiteFlow框架的优势 LiteFlow的设计原则 LiteFlow不适用于哪些场景 LiteFlow适用于哪些场景",content:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护的成本得就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？LiteFlow为解耦逻辑而生，为编排而生，在使用LiteFlow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\n\n# LiteFlow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个轻量，快速的组件式规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。\n\n使用LiteFlow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，都能按照你的规则配置去进行复杂的流转。\n\n而这一切，只需要你定义其规则就行。LiteFlow提供了极其简单易懂的规则表达式。\n\n你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用LiteFlow，轻而易举，你立马唾手可得！\n\n\n# LiteFlow的设计原则\n\nLiteFlow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。\n\n\n# LiteFlow不适用于哪些场景\n\nLiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。\n\n提示\n\n这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# LiteFlow适用于哪些场景\n\nLiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",normalizedContent:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统rpc调用等等。时间一长，项目几经易手，维护的成本得就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n如何打破僵局？liteflow为解耦逻辑而生，为编排而生，在使用liteflow之后，你会发现打造一个低耦合，灵活的系统会变得易如反掌！\n\n\n# liteflow框架的优势\n\n如果你要对复杂业务逻辑进行新写或者重构，用liteflow最合适不过。它是一个轻量，快速的组件式规则引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。\n\n使用liteflow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，都能按照你的规则配置去进行复杂的流转。\n\n而这一切，只需要你定义其规则就行。liteflow提供了极其简单易懂的规则表达式。\n\n你有想过，要在代码中实现下面这种复杂逻辑流程该如何实现吗？\n\n例如：\n\n图示\n\n又例如：\n\n图示\n\n同时要保证所有组件都是灵活可变的。\n\n我相信肯定有人能实现，但是是需要付出一定的开发成本的。\n\n而以上这一切，利用liteflow，轻而易举，你立马唾手可得！\n\n\n# liteflow的设计原则\n\nliteflow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到liteflow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以liteflow能做到统一解耦的组件和灵活的装配。\n\n\n# liteflow不适用于哪些场景\n\nliteflow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，a审批完应该是b审批，然后再流转到c角色。\n\n提示\n\n这里申明下，liteflow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# liteflow适用于哪些场景\n\nliteflow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用liteflow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也可以避免改一处而动全身的这样的风险。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍓项目特性",frontmatter:{title:"🍓项目特性",date:"2022-06-01T21:13:18.000Z",permalink:"/pages/v2.8.X/724bc3/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/020.%E9%A1%B9%E7%9B%AE%E7%89%B9%E6%80%A7.html",relativePath:"15.v2.8.X文档/020.项目特性.md",key:"v-3dc1ade7",path:"/pages/v2.8.X/724bc3/",headersStr:null,content:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则表达式入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 同步异步混编，再复杂的逻辑过程，利用LiteFlow的规则，都是易如反掌，看规则文件就能知道逻辑是如何运转的，所见即所得。\n * 规则能从任意地方加载： 框架中提供本地文件配置源和zk配置源的实现，也提供了扩展接口，您可以把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持QLExpress和Groovy两种脚本。未来还会支持更多的脚本语言。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",normalizedContent:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则表达式入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 同步异步混编，再复杂的逻辑过程，利用liteflow的规则，都是易如反掌，看规则文件就能知道逻辑是如何运转的，所见即所得。\n * 规则能从任意地方加载： 框架中提供本地文件配置源和zk配置源的实现，也提供了扩展接口，您可以把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持qlexpress和groovy两种脚本。未来还会支持更多的脚本语言。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:49:31.000Z",permalink:"/pages/v2.8.X/631fa1/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/005.%E8%AF%B4%E6%98%8E.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/005.说明.md",key:"v-4c728b76",path:"/pages/v2.8.X/631fa1/",headersStr:null,content:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验LiteFlow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的Hello World里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到LiteFlow的优雅之处。",normalizedContent:"这章是一个快速入门的指引，帮助你用最快的时间去立马体验liteflow。\n\n笔记\n\n大家可以根据自己的实际环境从下面的hello world里选择一种。\n\n建议跟着文档操作一遍。你会初步感受到liteflow的优雅之处。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.8.X/82ef41/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md",key:"v-4e3584bf",path:"/pages/v2.8.X/82ef41/",headers:[{level:2,title:"组件的定义",slug:"组件的定义",normalizedTitle:"组件的定义",charIndex:2},{level:2,title:"SpringBoot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:453},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:691}],headersStr:"组件的定义 SpringBoot配置文件 规则文件的定义",content:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文。\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# SpringBoot配置文件\n\n然后，在你的SpringBoot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n注意\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。EL形式的规则将不生效。\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c);\n    </chain>\n</flow>\n\n\nSpringBoot在启动时会自动装载规则文件。',normalizedContent:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保springboot会扫描到这些组件并注册进上下文。\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c组件：\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# springboot配置文件\n\n然后，在你的springboot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.el.xml\n\n\n注意\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。el形式的规则将不生效。\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.el.xml中定义规则：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c);\n    </chain>\n</flow>\n\n\nspringboot在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.8.X/df6982/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md",key:"v-7f801c82",path:"/pages/v2.8.X/df6982/",headersStr:null,content:"LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring-boot-starter</artifactId>\n    <version>2.8.5</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"liteflow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring-boot-starter</artifactid>\n    <version>2.8.5</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-16T18:08:08.000Z",permalink:"/pages/v2.8.X/9f4489/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.%F0%9F%8C%BFSpringboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md",key:"v-74eae88c",path:"/pages/v2.8.X/9f4489/",headersStr:null,content:'声明启动类：\n\n@SpringBootApplication\n//把你定义的组件扫入Spring上下文中\n@ComponentScan({"com.xxx.xxx.cmp"})\npublic class LiteflowExampleApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(LiteflowExampleApplication.class, args);\n    }\n}\n\n\n然后你就可以在Springboot任意被Spring托管的类中拿到flowExecutor，进行执行链路：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'声明启动类：\n\n@springbootapplication\n//把你定义的组件扫入spring上下文中\n@componentscan({"com.xxx.xxx.cmp"})\npublic class liteflowexampleapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(liteflowexampleapplication.class, args);\n    }\n}\n\n\n然后你就可以在springboot任意被spring托管的类中拿到flowexecutor，进行执行链路：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.8.X/0a4573/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md",key:"v-476157ca",path:"/pages/v2.8.X/0a4573/",headersStr:null,content:"针对于使用了Spring但没有使用SpringBoot的项目\n\n<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring</artifactId>\n\t<version>2.8.5</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"针对于使用了spring但没有使用springboot的项目\n\n<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring</artifactid>\n\t<version>2.8.5</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.8.X/495f21/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md",key:"v-dc75ce50",path:"/pages/v2.8.X/495f21/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"Spring xml中的配置",slug:"spring-xml中的配置",normalizedTitle:"spring xml中的配置",charIndex:452},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:1226}],headersStr:"定义你的组件 Spring xml中的配置 规则文件的定义",content:'# 定义你的组件\n\n你需要定义并实现一些组件，确保Spring会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@Component("b")\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@Component("c")\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# Spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springAware" class="com.yomahub.liteflow.spi.spring.SpringAware"/>\n\n<bean class="com.yomahub.liteflow.spring.ComponentScanner"/>\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\x3c!-- 如果上述enableLog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.MonitorBus">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n注意\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。EL形式的规则将不生效。\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        THEN(a, b, c)\n    </chain>\n</flow>\n\n\nSpring在启动时会自动装载规则文件。',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件，确保spring会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件:\n\n@component("b")\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n@component("c")\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springaware" class="com.yomahub.liteflow.spi.spring.springaware"/>\n\n<bean class="com.yomahub.liteflow.spring.componentscanner"/>\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\x3c!-- 如果上述enablelog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.monitorbus">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n注意\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。el形式的规则将不生效。\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.el.xml中如下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        then(a, b, c)\n    </chain>\n</flow>\n\n\nspring在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-02T19:49:57.000Z",permalink:"/pages/v2.8.X/0e0fb5/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.%F0%9F%8C%B1Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md",key:"v-ccccf1b6",path:"/pages/v2.8.X/0e0fb5/",headersStr:null,content:'和SpringBoot的执行方式一样，没有任何区别，你可以在你的任何受Spring托管的类里注入FlowExecutor进行执行：\n\n@Component\npublic class YourClass{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'和springboot的执行方式一样，没有任何区别，你可以在你的任何受spring托管的类里注入flowexecutor进行执行：\n\n@component\npublic class yourclass{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.8.X/522432/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E8%AF%B4%E6%98%8E.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md",key:"v-6fb5ca28",path:"/pages/v2.8.X/522432/",headersStr:null,content:"虽说Springboot/Spring已经成为了Java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合Spring我始终觉得是瑕疵，有点代码洁癖），现在在非Spring体系的环境中也能使用LiteFlow框架带来的便捷和高效。\n\nLiteFlow文档中提到的98%以上的特性功能都能在非Spring体系中生效。其中不生效的特性和功能有：\n\n * ruleSource的模糊路径匹配特性在非Spring体系下不生效\n * LiteflowComponent在非Spring体系下无法使用\n * 监控功能在非Spring体系中无法使用",normalizedContent:"虽说springboot/spring已经成为了java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合spring我始终觉得是瑕疵，有点代码洁癖），现在在非spring体系的环境中也能使用liteflow框架带来的便捷和高效。\n\nliteflow文档中提到的98%以上的特性功能都能在非spring体系中生效。其中不生效的特性和功能有：\n\n * rulesource的模糊路径匹配特性在非spring体系下不生效\n * liteflowcomponent在非spring体系下无法使用\n * 监控功能在非spring体系中无法使用",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧬依赖",frontmatter:{title:"🧬依赖",date:"2022-06-15T11:36:43.000Z",permalink:"/pages/v2.8.X/8760c4/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E4%BE%9D%E8%B5%96.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md",key:"v-61b65020",path:"/pages/v2.8.X/8760c4/",headersStr:null,content:"<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-core</artifactId>\n\t<version>2.8.5</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-core</artifactid>\n\t<version>2.8.5</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"⚙️配置",frontmatter:{title:"⚙️配置",date:"2022-06-06T23:18:00.000Z",permalink:"/pages/v2.8.X/249d17/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E9%85%8D%E7%BD%AE.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md",key:"v-9d5c8146",path:"/pages/v2.8.X/249d17/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"规则文件的配置",slug:"规则文件的配置",normalizedTitle:"规则文件的配置",charIndex:381}],headersStr:"定义你的组件 规则文件的配置",content:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class BCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class CCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.AComponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.BComponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.CComponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tTHEN(a, b, c);\n\t</chain>\n</flow>\n',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c组件：\n\npublic class bcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\npublic class ccmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.acomponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.bcomponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.ccomponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\tthen(a, b, c);\n\t</chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-06T21:42:12.000Z",permalink:"/pages/v2.8.X/b70ec8/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/010.%E8%AF%B4%E6%98%8E.html",relativePath:"15.v2.8.X文档/040.🍢配置项/010.说明.md",key:"v-0433e063",path:"/pages/v2.8.X/b70ec8/",headersStr:null,content:"LiteFlow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",normalizedContent:"liteflow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🛫执行",frontmatter:{title:"🛫执行",date:"2022-06-06T23:15:50.000Z",permalink:"/pages/v2.8.X/151524/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/030.%F0%9F%8D%9F%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%F0%9F%8C%B5%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/040.%E6%89%A7%E8%A1%8C.html",relativePath:"15.v2.8.X文档/030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md",key:"v-2c7663ac",path:"/pages/v2.8.X/151524/",headers:[{level:2,title:"初始化你的FlowExecutor执行器",slug:"初始化你的flowexecutor执行器",normalizedTitle:"初始化你的flowexecutor执行器",charIndex:2},{level:2,title:"用FlowExecutor执行",slug:"用flowexecutor执行",normalizedTitle:"用flowexecutor执行",charIndex:402}],headersStr:"初始化你的FlowExecutor执行器 用FlowExecutor执行",content:'# 初始化你的FlowExecutor执行器\n\n通过以下代码你可以轻易的初始化FlowExecutor处理器：\n\nLiteflowConfig config = new LiteflowConfig();\nconfig.setRuleSource("config/flow.el.xml");\nFlowExecutor flowExecutor = FlowExecutorHolder.loadInstance(config);\n\n\n注意\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。EL形式的规则将不生效。\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化FlowExecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用FlowExecutor执行\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "arg");\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看数据上下文这一章节。',normalizedContent:'# 初始化你的flowexecutor执行器\n\n通过以下代码你可以轻易的初始化flowexecutor处理器：\n\nliteflowconfig config = new liteflowconfig();\nconfig.setrulesource("config/flow.el.xml");\nflowexecutor flowexecutor = flowexecutorholder.loadinstance(config);\n\n\n注意\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。el形式的规则将不生效。\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化flowexecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用flowexecutor执行\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "arg");\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看数据上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌿Springboot下的配置项",frontmatter:{title:"🌿Springboot下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.8.X/4594ec/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/020.Springboot%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"15.v2.8.X文档/040.🍢配置项/020.Springboot下的配置项.md",key:"v-30dcc1bf",path:"/pages/v2.8.X/4594ec/",headersStr:null,content:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zkNode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#FlowExecutor的execute2Future的线程数，默认为64\nliteflow.main-executor-works=64\n#FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n#自定义请求ID的生成类，LiteFlow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n#并行节点的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为15\nliteflow.when-max-wait-seconds=15\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #FlowExecutor的execute2Future的线程数，默认为64\n  main-executor-works: 64\n  #FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\n  main-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n  #自定义请求ID的生成类，LiteFlow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator\n  #并行节点的线程池Builder，LiteFlow提供了默认的Builder\n  thread-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n  #异步线程最长的等待时间秒(只用于when)，默认值为15\n  when-max-wait-seconds: 15\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",normalizedContent:"#规则文件路径\nliteflow.rule-source=config/flow.el.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zknode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#flowexecutor的execute2future的线程数，默认为64\nliteflow.main-executor-works=64\n#flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n#自定义请求id的生成类，liteflow提供了默认的生成类\nliteflow.request-id-generator-class=com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n#并行节点的线程池builder，liteflow提供了默认的builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为15\nliteflow.when-max-wait-seconds=15\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.el.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #flowexecutor的execute2future的线程数，默认为64\n  main-executor-works: 64\n  #flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\n  main-executor-class: com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n  #自定义请求id的生成类，liteflow提供了默认的生成类\n  request-id-generator-class: com.yomahub.liteflow.flow.id.defaultrequestidgenerator\n  #并行节点的线程池builder，liteflow提供了默认的builder\n  thread-executor-class: com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n  #异步线程最长的等待时间秒(只用于when)，默认值为15\n  when-max-wait-seconds: 15\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌱Spring下的配置项",frontmatter:{title:"🌱Spring下的配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.8.X/33833a/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/030.Spring%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"15.v2.8.X文档/040.🍢配置项/030.Spring下的配置项.md",key:"v-07cee6df",path:"/pages/v2.8.X/33833a/",headersStr:null,content:'<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printBanner" value="true"/> \n    \x3c!-- zkNode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zkNode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotSize" value="1024"/> \n    \x3c!-- FlowExecutor的execute2Future的线程数，默认为64 --\x3e\n    <property name="mainExecutorWorks" value="64"/> \n    \x3c!-- FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="mainExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder"/>\n    \x3c!-- 自定义请求ID的生成类，LiteFlow提供了默认的生成类 --\x3e\n    <property name="requestIdGeneratorClass" value="com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator"/>\n    \x3c!-- 并行节点的线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder"/> \n    \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为15 --\x3e\n    <property name="whenMaxWaitSeconds" value="15"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenMaxWorkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenQueueLimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseOnStart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retryCount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportMultipleType" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeExecutorClass" value="com.yomahub.liteflow.flow.executor.DefaultNodeExecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printExecutionLog" value="true"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enableLog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queueLimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.el.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printbanner" value="true"/> \n    \x3c!-- zknode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zknode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotsize" value="1024"/> \n    \x3c!-- flowexecutor的execute2future的线程数，默认为64 --\x3e\n    <property name="mainexecutorworks" value="64"/> \n    \x3c!-- flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="mainexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder"/>\n    \x3c!-- 自定义请求id的生成类，liteflow提供了默认的生成类 --\x3e\n    <property name="requestidgeneratorclass" value="com.yomahub.liteflow.flow.id.defaultrequestidgenerator"/>\n    \x3c!-- 并行节点的线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder"/> \n    \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为15 --\x3e\n    <property name="whenmaxwaitseconds" value="15"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenmaxworkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenqueuelimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseonstart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retrycount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportmultipletype" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeexecutorclass" value="com.yomahub.liteflow.flow.executor.defaultnodeexecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printexecutionlog" value="true"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enablelog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queuelimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵其他场景代码设置配置项",frontmatter:{title:"🌵其他场景代码设置配置项",date:"2022-06-06T23:19:26.000Z",permalink:"/pages/v2.8.X/b5065a/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/040.%F0%9F%8D%A2%E9%85%8D%E7%BD%AE%E9%A1%B9/040.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"15.v2.8.X文档/040.🍢配置项/040.其他场景代码设置配置项.md",key:"v-2086a185",path:"/pages/v2.8.X/b5065a/",headersStr:null,content:'LiteflowConfig config = new LiteflowConfig();\n//规则文件路径\nconfig.setRuleSource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setEnable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setPrintBanner(true);\n//zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setZkNode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setSlotSize(1024);\n//FlowExecutor的execute2Future的线程数，默认为64\nconfig.setMainExecutorWorks(64);\n//FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nconfig.setMainExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder");\n//自定义请求ID的生成类，LiteFlow提供了默认的生成类\nconfig.setRequestIdGeneratorClass("com.yomahub.liteflow.flow.id.DefaultRequestIdGenerator");\n//并行节点的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setThreadExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder");\n//异步线程最长的等待时间秒(只用于when)，默认值为15\nconfig.setWhenMaxWaitSeconds(15);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setWhenMaxWorkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setWhenQueueLimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setParseOnStart(true);\n//全局重试次数，默认为0\nconfig.setRetryCount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setSupportMultipleType(false);\n//全局默认节点执行器\nconfig.setNodeExecutorClass("com.yomahub.liteflow.flow.executor.DefaultNodeExecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setPrintExecutionLog(true);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setEnableLog(false);\n//监控队列存储大小，默认值为200\nconfig.setQueueLimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setDelay(300000L);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setPeriod(300000L);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'liteflowconfig config = new liteflowconfig();\n//规则文件路径\nconfig.setrulesource("config/flow.el.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setenable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setprintbanner(true);\n//zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setzknode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setslotsize(1024);\n//flowexecutor的execute2future的线程数，默认为64\nconfig.setmainexecutorworks(64);\n//flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nconfig.setmainexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder");\n//自定义请求id的生成类，liteflow提供了默认的生成类\nconfig.setrequestidgeneratorclass("com.yomahub.liteflow.flow.id.defaultrequestidgenerator");\n//并行节点的线程池builder，liteflow提供了默认的builder\nconfig.setthreadexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder");\n//异步线程最长的等待时间秒(只用于when)，默认值为15\nconfig.setwhenmaxwaitseconds(15);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setwhenmaxworkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setwhenqueuelimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setparseonstart(true);\n//全局重试次数，默认为0\nconfig.setretrycount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setsupportmultipletype(false);\n//全局默认节点执行器\nconfig.setnodeexecutorclass("com.yomahub.liteflow.flow.executor.defaultnodeexecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setprintexecutionlog(true);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setenablelog(false);\n//监控队列存储大小，默认值为200\nconfig.setqueuelimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setdelay(300000l);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setperiod(300000l);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📔规则文件格式",frontmatter:{title:"📔规则文件格式",date:"2022-06-04T00:00:04.000Z",permalink:"/pages/v2.8.X/6fa87e/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/010.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html",relativePath:"15.v2.8.X文档/050.🗂规则文件/010.规则文件格式.md",key:"v-70666594",path:"/pages/v2.8.X/6fa87e/",headers:[{level:2,title:"规则组成部分",slug:"规则组成部分",normalizedTitle:"规则组成部分",charIndex:147}],headersStr:"规则组成部分",content:'LiteFlow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nLiteFlow的规则文件非常轻量，非常容易上手。主要由Node节点和Chain节点组成。\n\n提示\n\n必须要说明的是，Node节点在Springboot/Spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到Spring上下文中。\n\n在非Spring环境体系中，Node节点是必须的。如果不配置Node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nXML在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\nzk方式：liteflow.rule-source=el_xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.ACmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.BCmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.CCmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.DCmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(\n            a, b, WHEN(c,d)\n        );\n    </chain>\n</flow>\n\n\nJSON在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\nzk方式：liteflow.rule-source=el_json:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.TestCustomParser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ACmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.BCmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.CCmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.DCmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "THEN(a, b, WHEN(c, d))"\n      }\n    ]\n  }\n}\n\n\nYAML在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\nzk方式：liteflow.rule-source=el_yml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.TestCustomParser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.ACmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.BCmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.CCmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.DCmp\n  chain:\n    - name: chain1\n      value: "THEN(a, b, WHEN(c, d))"\n',normalizedContent:'liteflow支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nliteflow的规则文件非常轻量，非常容易上手。主要由node节点和chain节点组成。\n\n提示\n\n必须要说明的是，node节点在springboot/spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到spring上下文中。\n\n在非spring环境体系中，node节点是必须的。如果不配置node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\nxml在三种模式下的配置示例\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.xml\n\nzk方式：liteflow.rule-source=el_xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.acmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.bcmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.ccmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.dcmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(\n            a, b, when(c,d)\n        );\n    </chain>\n</flow>\n\n\njson在三种模式下的配置示例\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.json\n\nzk方式：liteflow.rule-source=el_json:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=el_json:com.yomahub.liteflow.test.testcustomparser\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.acmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.bcmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ccmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.dcmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain1",\n        "value": "then(a, b, when(c, d))"\n      }\n    ]\n  }\n}\n\n\nyaml在三种模式下的配置示例\n\n在yaml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.el.yml\n\nzk方式：liteflow.rule-source=el_yml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=el_yml:com.yomahub.liteflow.test.testcustomparser\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.acmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.bcmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.ccmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.dcmp\n  chain:\n    - name: chain1\n      value: "then(a, b, when(c, d))"\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📕本地规则文件配置",frontmatter:{title:"📕本地规则文件配置",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.8.X/51ddd5/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/020.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"15.v2.8.X文档/050.🗂规则文件/020.本地规则文件配置.md",key:"v-62b15ff8",path:"/pages/v2.8.X/51ddd5/",headers:[{level:2,title:"常规配置",slug:"常规配置",normalizedTitle:"常规配置",charIndex:173},{level:2,title:"指定多个路径",slug:"指定多个路径",normalizedTitle:"指定多个路径",charIndex:295}],headersStr:"常规配置 指定多个路径",content:"在LiteFlow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是LiteFlow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。EL形式的规则将不生效。\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用Spring EL表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n提示\n\n模糊匹配只限于Springboot/Spring体系中，非Spring环境，模糊匹配不生效",normalizedContent:"在liteflow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是liteflow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.el.xml\n\n\n提示\n\n规则文件须定义成xxxx.el.xml的形式，如果你定义成了xxxx.xml的形式，那是基于旧的规则模式。el形式的规则将不生效。\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.el.xml,config/flow2.el.xml,config/flow3.el.xml\n\n\n你也可以使用spring el表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.el.xml\n\n\n提示\n\n模糊匹配只限于springboot/spring体系中，非spring环境，模糊匹配不生效",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📗ZK规则文件配置",frontmatter:{title:"📗ZK规则文件配置",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.8.X/ffc345/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/030.ZK%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"15.v2.8.X文档/050.🗂规则文件/030.ZK规则文件配置.md",key:"v-c273b4aa",path:"/pages/v2.8.X/ffc345/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:527}],headersStr:"依赖 配置路径",content:"# 依赖\n\n提示\n\nLiteFlow支持把配置放在zk集群中，基于zk的通知机制，LiteFlow支持实时修改流程\n\n你只需在原来配置流程的地方，把本地xml路径换成zk地址就ok了，当然ZK里存放的内容还是以xml/json/yml存储的，具体请请参考规则文件格式这章。\n\n如果需要用到zk，需要加以下依赖，LiteFlow在2.6.3之后不再传递依赖：\n\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-framework</artifactId>\n    <version>${curator.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>${curator.version}</version>\n</dependency>\n\n\n${curator.version}建议为5.1.0\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n只需要改变rule-source变成zk的地址就可以了，集群用逗号分隔。\n\nliteflow.rule-source=el_xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n\n关于el_xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以EL的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这一章。",normalizedContent:"# 依赖\n\n提示\n\nliteflow支持把配置放在zk集群中，基于zk的通知机制，liteflow支持实时修改流程\n\n你只需在原来配置流程的地方，把本地xml路径换成zk地址就ok了，当然zk里存放的内容还是以xml/json/yml存储的，具体请请参考规则文件格式这章。\n\n如果需要用到zk，需要加以下依赖，liteflow在2.6.3之后不再传递依赖：\n\n<dependency>\n    <groupid>org.apache.curator</groupid>\n    <artifactid>curator-framework</artifactid>\n    <version>${curator.version}</version>\n</dependency>\n<dependency>\n    <groupid>org.apache.curator</groupid>\n    <artifactid>curator-recipes</artifactid>\n    <version>${curator.version}</version>\n</dependency>\n\n\n${curator.version}建议为5.1.0\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n只需要改变rule-source变成zk的地址就可以了，集群用逗号分隔。\n\nliteflow.rule-source=el_xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n\n关于el_xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以el的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这一章。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📎普通组件",frontmatter:{title:"📎普通组件",date:"2022-06-29T17:53:36.000Z",permalink:"/pages/v2.8.X/8486fb/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/010.%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6.html",relativePath:"15.v2.8.X文档/055.🔗常规组件/010.普通组件.md",key:"v-9f99f032",path:"/pages/v2.8.X/8486fb/",headers:[{level:2,title:"可以覆盖的方法",slug:"可以覆盖的方法",normalizedTitle:"可以覆盖的方法",charIndex:336},{level:3,title:"isAccess",slug:"isaccess",normalizedTitle:"isaccess",charIndex:370},{level:3,title:"isContinueOnError",slug:"iscontinueonerror",normalizedTitle:"iscontinueonerror",charIndex:423},{level:3,title:"isEnd",slug:"isend",normalizedTitle:"isend",charIndex:473},{level:3,title:"beforeProcess和afterProcess",slug:"beforeprocess和afterprocess",normalizedTitle:"beforeprocess和afterprocess",charIndex:668},{level:3,title:"onSuccess和onError",slug:"onsuccess和onerror",normalizedTitle:"onsuccess和onerror",charIndex:798},{level:2,title:"This关键字可以调用的方法",slug:"this关键字可以调用的方法",normalizedTitle:"this关键字可以调用的方法",charIndex:846},{level:3,title:"获取上下文",slug:"获取上下文",normalizedTitle:"获取上下文",charIndex:865},{level:3,title:"getNodeId",slug:"getnodeid",normalizedTitle:"getnodeid",charIndex:943},{level:3,title:"getName",slug:"getname",normalizedTitle:"getname",charIndex:966},{level:3,title:"getChainName",slug:"getchainname",normalizedTitle:"getchainname",charIndex:987},{level:3,title:"getRequestData",slug:"getrequestdata",normalizedTitle:"getrequestdata",charIndex:1018},{level:3,title:"setIsEnd",slug:"setisend",normalizedTitle:"setisend",charIndex:614},{level:3,title:"getTag",slug:"gettag",normalizedTitle:"gettag",charIndex:1249},{level:3,title:"invoke和invoke2Response",slug:"invoke和invoke2response",normalizedTitle:"invoke和invoke2response",charIndex:1293},{level:2,title:"@LiteflowComponent",slug:"liteflowcomponent",normalizedTitle:"@liteflowcomponent",charIndex:59}],headersStr:"可以覆盖的方法 isAccess isContinueOnError isEnd beforeProcess和afterProcess onSuccess和onError This关键字可以调用的方法 获取上下文 getNodeId getName getChainName getRequestData setIsEnd getTag invoke和invoke2Response @LiteflowComponent",content:'普通组件节点需要继承NodeComponent类，可用于THEN和WHEN关键字中。\n\n需要实现process方法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n提示\n\n@LiteflowComponent继承自@Component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@LiteflowComponent的参数a，就是你在写EL规则时需要用到组件ID。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isAccess\n\n推荐实现isAccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# isContinueOnError\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isEnd\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# beforeProcess和afterProcess\n\n流程的前置和后置处理器，其中前置处理器，在isAccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onSuccess和onError\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# This关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getContextBean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getNodeId\n\n获取组件ID。\n\n\n# getName\n\n获取组件别名。\n\n\n# getChainName\n\n获取当前执行的流程名称。\n\n\n# getRequestData\n\n获取流程的初始参数。\n\n\n# setIsEnd\n\n表示是否立即结束整个流程 ，用法为this.setIsEnd(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# getTag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2Response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @LiteflowComponent\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'普通组件节点需要继承nodecomponent类，可用于then和when关键字中。\n\n需要实现process方法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n提示\n\n@liteflowcomponent继承自@component，如果你在spring体系的环境里，组件里可以任意注入spring的bean进行使用。\n\n@liteflowcomponent的参数a，就是你在写el规则时需要用到组件id。\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isaccess\n\n推荐实现isaccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# iscontinueonerror\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isend\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# beforeprocess和afterprocess\n\n流程的前置和后置处理器，其中前置处理器，在isaccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onsuccess和onerror\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# this关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getcontextbean(clazz)获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getnodeid\n\n获取组件id。\n\n\n# getname\n\n获取组件别名。\n\n\n# getchainname\n\n获取当前执行的流程名称。\n\n\n# getrequestdata\n\n获取流程的初始参数。\n\n\n# setisend\n\n表示是否立即结束整个流程 ，用法为this.setisend(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# gettag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签。\n\n\n# invoke和invoke2response\n\n调用隐式流程，关于隐式流程的说明和用法，请参考隐式子流程。\n\n\n# @liteflowcomponent\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📙自定义配置源",frontmatter:{title:"📙自定义配置源",date:"2022-06-07T01:03:17.000Z",permalink:"/pages/v2.8.X/25f2c0/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/050.%F0%9F%97%82%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/040.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"15.v2.8.X文档/050.🗂规则文件/040.自定义配置源.md",key:"v-3eb52555",path:"/pages/v2.8.X/25f2c0/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:616}],headersStr:"说明 配置路径",content:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。LiteFlow支持自定义的配置源的扩展点。\n\nXML形式的规则文件请继承ClassXmlFlowELParser\n\nJSON形式的规则文件请继承ClassJsonFlowELParser\n\nYML形式的规则文件请继承ClassYmlFlowELParser\n\n以下以XML形式的自定义源配置类举例：\n\npublic class TestCustomParser extends ClassXmlFlowELParser {\n\n\t@Override\n\tpublic String parseCustom() {\n\t\tSystem.out.println("进入自定义parser");\n\t\tString xmlContent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlContent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@Autowired和@Resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.TestCustomParser\n\n\n关于el_xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以EL的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',normalizedContent:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。liteflow支持自定义的配置源的扩展点。\n\nxml形式的规则文件请继承classxmlflowelparser\n\njson形式的规则文件请继承classjsonflowelparser\n\nyml形式的规则文件请继承classymlflowelparser\n\n以下以xml形式的自定义源配置类举例：\n\npublic class testcustomparser extends classxmlflowelparser {\n\n\t@override\n\tpublic string parsecustom() {\n\t\tsystem.out.println("进入自定义parser");\n\t\tstring xmlcontent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlcontent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@autowired和@resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=el_xml:com.yomahub.liteflow.test.testcustomparser\n\n\n关于el_xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里el_xml:开头是表明这里读取的内容是xml形式的配置，并以el的方式进行解析。关于规则文件支持格式请详细阅读规则文件格式这章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"✂️选择组件",frontmatter:{title:"✂️选择组件",date:"2022-06-29T17:58:54.000Z",permalink:"/pages/v2.8.X/c0f5d7/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/020.%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6.html",relativePath:"15.v2.8.X文档/055.🔗常规组件/020.选择组件.md",key:"v-54dc8068",path:"/pages/v2.8.X/c0f5d7/",headersStr:null,content:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于SWITCH关键字中。\n\n关于SWITCH表达式的用法，可以参考选择编排一章。\n\n比如如下表达式：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c);\n</chain>\n\n\n选择节点a需要继承NodeSwitchComponent类\n\n需要实现方法processSwitch，这个方法需要返回String类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        System.out.println("Acomp executed!");\n        return "c";\n    }\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点，这就引申出了选择节点，选择节点可以用于switch关键字中。\n\n关于switch表达式的用法，可以参考选择编排一章。\n\n比如如下表达式：\n\n<chain name="chain1">\n    switch(a).to(b, c);\n</chain>\n\n\n选择节点a需要继承nodeswitchcomponent类\n\n需要实现方法processswitch，这个方法需要返回string类型，就是具体的结果，以下代码示例了选择到了c节点。\n\n@liteflowcomponent("a")\npublic class acmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        system.out.println("acomp executed!");\n        return "c";\n    }\n}\n\n\n选择节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-06-29T15:30:16.000Z",permalink:"/pages/v2.8.X/16eca9/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/010.%E8%AF%B4%E6%98%8E.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/010.说明.md",key:"v-755d6911",path:"/pages/v2.8.X/16eca9/",headersStr:null,content:"在本章，将说明如何撰写规则表达式。\n\nLiteFlow在2.8.X版本中设计了非常强大的规则表达式。一切复杂的流程在LiteFlow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",normalizedContent:"在本章，将说明如何撰写规则表达式。\n\nliteflow在2.8.x版本中设计了非常强大的规则表达式。一切复杂的流程在liteflow表达式的加持下，都异常丝滑简便。\n\n你只需要很短的时间即可学会如何写一个很复杂流程的表达式。\n\n提示\n\n本章是整个规则编排的重点，建议仔细看下。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"📌条件组件",frontmatter:{title:"📌条件组件",date:"2022-08-26T12:25:04.000Z",permalink:"/pages/v2.8.X/cb0b59/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/055.%F0%9F%94%97%E5%B8%B8%E8%A7%84%E7%BB%84%E4%BB%B6/030.%E6%9D%A1%E4%BB%B6%E7%BB%84%E4%BB%B6.html",relativePath:"15.v2.8.X文档/055.🔗常规组件/030.条件组件.md",key:"v-783ff9dc",path:"/pages/v2.8.X/cb0b59/",headersStr:null,content:'LiteFlow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为IF组件，返回是一个true/false。可用于IF...ELIF...ELSE等关键字。\n\n关于IF...ELIF...ELSE表达式的用法，可以参考条件编排这一章。\n\n比如一个IF三元表达式，如下所示，x就是IF组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承NodeIfComponent类：\n\n@Component("x")\npublic class XCmp extends NodeIfComponent {\n\t@Override\n\tpublic boolean processIf() throws Exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件组件的定义。\n\n条件组件，也可以称之为if组件，返回是一个true/false。可用于if...elif...else等关键字。\n\n关于if...elif...else表达式的用法，可以参考条件编排这一章。\n\n比如一个if三元表达式，如下所示，x就是if组件，为真，执行a，为假，执行b：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\nx节点的定义，需要继承nodeifcomponent类：\n\n@component("x")\npublic class xcmp extends nodeifcomponent {\n\t@override\n\tpublic boolean processif() throws exception {\n\t    //do your biz\n\t\treturn true;\n\t}\n}\n\n\n条件节点的内部可以覆盖的方法和this关键字可调用的方法见普通组件这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌴串行编排",frontmatter:{title:"🌴串行编排",date:"2022-06-29T15:28:24.000Z",permalink:"/pages/v2.8.X/a590ee/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/020.%E4%B8%B2%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/020.串行编排.md",key:"v-23c101de",path:"/pages/v2.8.X/a590ee/",headersStr:null,content:'如果你要依次执行a,b,c,d四个组件，你可以用THEN关键字，需要注意的是，THEN必须大写。\n\n<chain name="chain1">\n    THEN(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    THEN(a, b, THEN(c, d));\n</chain>\n\n\n图示',normalizedContent:'如果你要依次执行a,b,c,d四个组件，你可以用then关键字，需要注意的是，then必须大写。\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n当然你如果嵌套来写，也是和上面等价的\n\n<chain name="chain1">\n    then(a, b, then(c, d));\n</chain>\n\n\n图示',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎋并行编排",frontmatter:{title:"🎋并行编排",date:"2022-06-29T16:46:16.000Z",permalink:"/pages/v2.8.X/b3446a/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/030.%E5%B9%B6%E8%A1%8C%E7%BC%96%E6%8E%92.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/030.并行编排.md",key:"v-b6bf8cf8",path:"/pages/v2.8.X/b3446a/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:2},{level:2,title:"和串行嵌套起来(一)",slug:"和串行嵌套起来-一",normalizedTitle:"和串行嵌套起来(一)",charIndex:113},{level:2,title:"和串行嵌套起来(二)",slug:"和串行嵌套起来-二",normalizedTitle:"和串行嵌套起来(二)",charIndex:288},{level:2,title:"忽略错误",slug:"忽略错误",normalizedTitle:"忽略错误",charIndex:431},{level:2,title:"任一节点先执行完则忽略其他",slug:"任一节点先执行完则忽略其他",normalizedTitle:"任一节点先执行完则忽略其他",charIndex:645},{level:2,title:"关于组的概念",slug:"关于组的概念",normalizedTitle:"关于组的概念",charIndex:891}],headersStr:"最基本的例子 和串行嵌套起来(一) 和串行嵌套起来(二) 忽略错误 任一节点先执行完则忽略其他 关于组的概念",content:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用WHEN关键字，需要注意的是，WHEN必须大写。\n\n<chain name="chain1">\n    WHEN(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把THEN和WHEN结合起来用，看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nWHEN关键字提供了一个子关键字ignoreError(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).ignoreError(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nWHEN关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.X版本中，我们去除了组的概念。\n\n用EL表达式，其实你写2个不同的WHEN就是2个组。比如：\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    THEN(\n        WHEN(a, b),\n        WHEN(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',normalizedContent:'# 最基本的例子\n\n如果你要并行执行a,b,c三个组件，你可以用when关键字，需要注意的是，when必须大写。\n\n<chain name="chain1">\n    when(a, b, c);\n</chain>\n\n\n\n# 和串行嵌套起来(一)\n\n接下来，让我们把then和when结合起来用，看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d),\n        e\n    );\n</chain>\n\n\n图示\n\n在以上示例里，b,c,d默认并行都执行完毕后，才会执行e。\n\n\n# 和串行嵌套起来(二)\n\n上面的示例应该很好理解吧，那么再看一个示例：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d)),\n        e\n    );\n</chain>\n\n\n图示\n\n\n# 忽略错误\n\nwhen关键字提供了一个子关键字ignoreerror(默认为false)来提供忽略错误的特性，用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).ignoreerror(true),\n        e\n    );\n</chain>\n\n\n图示\n\n以上假设b,c,d中任一一个节点有异常，那么最终e仍旧会被执行。\n\n\n# 任一节点先执行完则忽略其他\n\nwhen关键字提供了一个子关键字any(默认为false)用来提供并行流程中，任一条分支先执行完即忽略其他分支，继续执行的特性。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d), e).any(true),\n        f\n    );\n</chain>\n\n\n图示\n\n以上流程，假设e节点先执行完，那么不管其他分支是否执行完，会立马执行节点f。\n\n\n# 关于组的概念\n\n在以前的版本中，并行编排有组(group)的概念，而在2.8.x版本中，我们去除了组的概念。\n\n用el表达式，其实你写2个不同的when就是2个组。比如：\n\n<chain name="chain1">\n    then(\n        when(a, b, c, d)\n    );\n</chain>\n\n\n以上abcd都在同一个并行组中。\n\n<chain name="chain1">\n    then(\n        when(a, b),\n        when(c, d)\n    );\n</chain>\n\n\n以上例子，ab是一个并行组，而cd是另一个并行组。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌾选择编排",frontmatter:{title:"🌾选择编排",date:"2022-06-29T17:15:38.000Z",permalink:"/pages/v2.8.X/d90483/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/040.%E9%80%89%E6%8B%A9%E7%BC%96%E6%8E%92.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/040.选择编排.md",key:"v-c7f4ccd2",path:"/pages/v2.8.X/d90483/",headers:[{level:2,title:"最基本的例子",slug:"最基本的例子",normalizedTitle:"最基本的例子",charIndex:161},{level:2,title:"和THEN,WHEN嵌套起来(一)",slug:"和then-when嵌套起来-一",normalizedTitle:"和then,when嵌套起来(一)",charIndex:270},{level:2,title:"和THEN,WHEN嵌套起来(二)",slug:"和then-when嵌套起来-二",normalizedTitle:"和then,when嵌套起来(二)",charIndex:463}],headersStr:"最基本的例子 和THEN,WHEN嵌套起来(一) 和THEN,WHEN嵌套起来(二)",content:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入A流程，如果返回结果2，则进入B流程，如果返回结果3，则进入C流程。在有些流程定义中也被定义为排他网关。\n\n这个通过LiteFLow的表达式也非常容易实现，你可以用SWITCH...to的组合关键字，注意的是SWITCH必须大写，to小写。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    SWITCH(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# 和THEN,WHEN嵌套起来(一)\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(\n            b,\n            SWITCH(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 和THEN,WHEN嵌套起来(二)\n\n接下来展示一个SWITCH中套THEN和WHEN的例子。\n\n如果你阅读过选择组件这一章，就应该知道，LiteFlow通过选择组件的返回来确定该选择什么。\n\n那么如果SWITCH中套一个THEN，那么选择组件如果要选择这个THEN应该返回什么呢？\n\nLiteFlow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    THEN(\n        a,\n        SWITCH(b).to(\n            c, \n            THEN(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择THEN这个表达式，那么你可以在选择节点里返回t1:\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeSwitchComponent {\n\n    @Override\n    public String processSwitch() throws Exception {\n        //do your biz\n        return "t1";\n    }\n}\n',normalizedContent:'我们在写业务逻辑的时候，通常会碰到选择性问题，即，如果返回结果1，则进入a流程，如果返回结果2，则进入b流程，如果返回结果3，则进入c流程。在有些流程定义中也被定义为排他网关。\n\n这个通过liteflow的表达式也非常容易实现，你可以用switch...to的组合关键字，注意的是switch必须大写，to小写。\n\n\n# 最基本的例子\n\n如果，根据组件a，来选择执行b,c,d中的一个，你可以如下声明：\n\n<chain name="chain1">\n    switch(a).to(b, c, d);\n</chain>\n\n\n图示\n\n\n# 和then,when嵌套起来(一)\n\n我们结合之前两章，把三种表达式嵌套起来看一些例子\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            b,\n            switch(c).to(d,e)\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n\n# 和then,when嵌套起来(二)\n\n接下来展示一个switch中套then和when的例子。\n\n如果你阅读过选择组件这一章，就应该知道，liteflow通过选择组件的返回来确定该选择什么。\n\n那么如果switch中套一个then，那么选择组件如果要选择这个then应该返回什么呢？\n\nliteflow中规定，每个表达式都可以有一个id值，你可以设置id值来设置一个表达式的id值。然后在选择组件里返回这个id即可。用法如下：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            c, \n            then(d, e).id("t1")\n        ),\n        f\n    );\n</chain>\n\n\n图示\n\n如果你想选择then这个表达式，那么你可以在选择节点里返回t1:\n\n@liteflowcomponent("b")\npublic class bcmp extends nodeswitchcomponent {\n\n    @override\n    public string processswitch() throws exception {\n        //do your biz\n        return "t1";\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌵条件编排",frontmatter:{title:"🌵条件编排",date:"2022-08-26T14:13:55.000Z",permalink:"/pages/v2.8.X/e76999/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/045.%E6%9D%A1%E4%BB%B6%E7%BC%96%E6%8E%92.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/045.条件编排.md",key:"v-cef6ce3e",path:"/pages/v2.8.X/e76999/",headers:[{level:2,title:"IF的二元表达式",slug:"if的二元表达式",normalizedTitle:"if的二元表达式",charIndex:206},{level:2,title:"IF的三元表达式",slug:"if的三元表达式",normalizedTitle:"if的三元表达式",charIndex:363},{level:2,title:"ELSE表达式",slug:"else表达式",normalizedTitle:"else表达式",charIndex:529},{level:2,title:"ELIF表达式",slug:"elif表达式",normalizedTitle:"elif表达式",charIndex:707}],headersStr:"IF的二元表达式 IF的三元表达式 ELSE表达式 ELIF表达式",content:'LiteFlow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是变成语言中的if else。只不过在LiteFlow EL语法中有一些不一样的用法。\n\n以下IF和ELIF的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# IF的二元表达式\n\n我们先来看IF关键字的二元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# IF的三元表达式\n\n我们接下来再来看IF关键字的三元表达式：\n\n<chain name="chain1">\n    THEN(\n        IF(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# ELSE表达式\n\nLiteFlow也提供了ELSE表达式，IF的二元表达式+ELSE表达式等同于IF三元表达式，比如：\n\n<chain name="chain1">\n    IF(x, a).ELSE(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    IF(x, a, b);\n</chain>\n\n\n\n# ELIF表达式\n\nELIF关键字的用法其实和java语言的else if类似，可以跟多个，和IF二元表达式参数一样，一般最后还会跟个ELSE，用于多重条件的判断：\n\n<chain name="chain1">\n    IF(x1, a).ELIF(x2, b).ELIF(x3, c).ELIF(x4, d).ELSE(THEN(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有IF的二元表达式后面才能跟ELIF，如果IF三元表达式后面跟ELIF，最后一个表达式会被ELIF的表达式覆盖，就比如：\n\n<chain name="chain1">\n    IF(x1, a, b).ELIF(x2, c).ELSE(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实IF三元表达式已经能表达一切的可能了，有多重条件也可以不用ELIF，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    IF(\n        x1,\n        a, \n        IF(\n            x2,\n            b,\n            IF(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用ELIF来代替。',normalizedContent:'liteflow从2.8.5版本开始，提供了条件编排表达式组合。\n\n条件编排是选择编排一个变种，选择编排是根据逻辑去选择多个子项中的一项。而条件编排只有真和假2个子项，这处理某些业务的过程中非常有用。\n\n其实简单来说，条件编排就是变成语言中的if else。只不过在liteflow el语法中有一些不一样的用法。\n\n以下if和elif的第一个参数要求定义条件组件，关于如何定义请参考条件组件这一章节。\n\n\n# if的二元表达式\n\n我们先来看if关键字的二元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a),\n        b\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->b，为假链路就为x->b。\n\n\n# if的三元表达式\n\n我们接下来再来看if关键字的三元表达式：\n\n<chain name="chain1">\n    then(\n        if(x, a, b),\n        c\n    );\n</chain>\n\n\n图示\n\n其中x为条件节点，为真的情况下，执行链路就为x->a->c，为假链路就为x->b->c。\n\n\n# else表达式\n\nliteflow也提供了else表达式，if的二元表达式+else表达式等同于if三元表达式，比如：\n\n<chain name="chain1">\n    if(x, a).else(b);\n</chain>\n\n\n其实就等同于：\n\n<chain name="chain1">\n    if(x, a, b);\n</chain>\n\n\n\n# elif表达式\n\nelif关键字的用法其实和java语言的else if类似，可以跟多个，和if二元表达式参数一样，一般最后还会跟个else，用于多重条件的判断：\n\n<chain name="chain1">\n    if(x1, a).elif(x2, b).elif(x3, c).elif(x4, d).else(then(m, n));\n</chain>\n\n\n图示\n\n其实写过代码的，对这个表达式应该很好理解。\n\n注意一\n\n值得注意的是，只有if的二元表达式后面才能跟elif，如果if三元表达式后面跟elif，最后一个表达式会被elif的表达式覆盖，就比如：\n\n<chain name="chain1">\n    if(x1, a, b).elif(x2, c).else(d);\n</chain>\n\n\n这样x1即使为false，也不会执行到b，会去判断x2。虽然框架做了容错处理，但是我们在写表达式的时候，不推荐这样写。容易造成理解上的困扰。\n\n注意二\n\n其实if三元表达式已经能表达一切的可能了，有多重条件也可以不用elif，可以用嵌套来完成，比如：\n\n<chain name="chain1">\n    if(\n        x1,\n        a, \n        if(\n            x2,\n            b,\n            if(x3, c, d)\n        )\n    );\n</chain>\n\n\n但是官方依旧不推荐你这么写，多重嵌套在理解起来会比较吃力，所以尽量用elif来代替。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍁使用子流程",frontmatter:{title:"🍁使用子流程",date:"2022-07-01T19:00:46.000Z",permalink:"/pages/v2.8.X/dc5df7/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/050.%E4%BD%BF%E7%94%A8%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/050.使用子流程.md",key:"v-4135901f",path:"/pages/v2.8.X/dc5df7/",headersStr:null,content:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    THEN(\n        A, B,\n        WHEN(\n            THEN(C, WHEN(J, K)),\n            D,\n            THEN(H, I)\n        ),\n        SWITCH(X).to(\n            M,\n            N,\n            WHEN(Q, THEN(P, R)).id("w01")\n        ),\n        Z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nLiteFlow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainChain">\n    THEN(\n    \tA, B,\n    \tWHEN(chain1, D, chain2),\n    \tSWITCH(X).to(M, N, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tTHEN(C, WHEN(J, K));\n</chain>\n\n<chain name="chain2">\n  \tTHEN(H, I);\n</chain>\n\n<chain name="chain3">\n  \tWHEN(Q, THEN(P, R)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',normalizedContent:'在某些情况下，可能你用表达式写规则，会嵌套很多层。\n\n比如下面这一个流程，是不是看上去就很复杂？\n\n图示\n\n其实你用规则表达式来写，注意好缩进，也是可以很容易读懂的。上面的图可以写成以下规则表达式：\n\n<chain name="chain4">\n    then(\n        a, b,\n        when(\n            then(c, when(j, k)),\n            d,\n            then(h, i)\n        ),\n        switch(x).to(\n            m,\n            n,\n            when(q, then(p, r)).id("w01")\n        ),\n        z\n    );\n</chain>\n\n\n但可能还是会有人觉得有点复杂。\n\nliteflow在新版的表达式里同样也支持子流程的定义，你可以拆分开来分别定义子流程，所以上面的表达式也可以写成以下的形式：\n\n<chain name="mainchain">\n    then(\n    \ta, b,\n    \twhen(chain1, d, chain2),\n    \tswitch(x).to(m, n, chain3),\n    \tz\n    );\n</chain>\n\n<chain name="chain1">\n  \tthen(c, when(j, k));\n</chain>\n\n<chain name="chain2">\n  \tthen(h, i);\n</chain>\n\n<chain name="chain3">\n  \twhen(q, then(p, r)).id("w01");\n</chain>\n\n\n是不是通过拆分成子流程，就清晰多了呢？',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍂使用子变量",frontmatter:{title:"🍂使用子变量",date:"2022-07-01T19:01:33.000Z",permalink:"/pages/v2.8.X/71ff49/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/060.%E4%BD%BF%E7%94%A8%E5%AD%90%E5%8F%98%E9%87%8F.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/060.使用子变量.md",key:"v-4e374058",path:"/pages/v2.8.X/71ff49/",headersStr:null,content:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为LiteFlow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = THEN(C, WHEN(J, K));\n    w1 = WHEN(Q, THEN(P, R)).id("w01");\n    t2 = THEN(H, I);\n    \n    THEN(\n        A, B,\n        WHEN(t1, D, t2),\n        SWITCH(X).to(M, N, w1),\n        Z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',normalizedContent:'如果你看过上一章使用子流程后再来看这章，你会觉得其实使用子流程都是多此一举！\n\n因为liteflow新的表达式语法可以直接让你在规则里定义子流程变量！\n\n这可以说是新版语法中一个骚操作了！\n\n还是这个流程：\n\n图示\n\n我们如果定义子流程变量，可以这么写：\n\n<chain>\n    t1 = then(c, when(j, k));\n    w1 = when(q, then(p, r)).id("w01");\n    t2 = then(h, i);\n    \n    then(\n        a, b,\n        when(t1, d, t2),\n        switch(x).to(m, n, w1),\n        z\n    );\n</chain>\n\n\n看到这里的你，是不是有种恍然大悟的感觉呢？用这种方式，其实子流程都显得黯然失色了。对于逻辑能力强大的你来说，利用这套表达式是不是任意复杂流程都能写出来了呢。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌻关于分号",frontmatter:{title:"🌻关于分号",date:"2022-07-10T10:58:25.000Z",permalink:"/pages/v2.8.X/af44a6/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/080.%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/080.关于分号.md",key:"v-1d622864",path:"/pages/v2.8.X/af44a6/",headersStr:null,content:'大家可能注意到了，在EL规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nLiteFlow的EL规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    THEN(\n        a, \n        b, \n        WHEN(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = THEN(a, b);\n    w1 = WHEN(c, d);\n    \n    THEN(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为LiteFlow的IDEA插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',normalizedContent:'大家可能注意到了，在el规则的后面，示例都加上了分号。\n\n但实际你运行的时候，不加分号也是可以正常运行的。\n\n那分号到底要不要加呢？\n\nliteflow的el规则依托于底层的表达式语言，进行了扩展和封装。在表示单行语句的时候可以不加。比如：\n\n<chain name="chain1">\n    then(a, b, when(c, d))\n</chain>\n\n\n当然以下形式也认为是单行表达式，只是你人为地换行了而已，其实还是一句表达式\n\n<chain name="chain1">\n    then(\n        a, \n        b, \n        when(c, d)\n    )\n</chain>\n\n\n在使用子变量的时候，因为是多行表达式，所以一定得需要加分号，否则解析不通过，会报错，正确的规范是如下所示：\n\n<chain name="chain1">\n    t1 = then(a, b);\n    w1 = when(c, d);\n    \n    then(t1, w1);\n</chain>\n\n\n注意\n\n但是官方建议，不管是单行还是多行，尽量在每句表达式后加上分号。\n\n因为liteflow的idea插件(7月13日上线)会去检查语法，如果每句表达式后面没加分号，会有红波浪线去提示。\n\n当然对于单行表达式，即便忽略了语法检查提示，去运行，也是可以正常运行的，但是在子变量的场景中，一定得加上分号，这个要格外注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌰关于注释",frontmatter:{title:"🌰关于注释",date:"2022-07-19T10:34:21.000Z",permalink:"/pages/v2.8.X/f3dc09/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/090.%E5%85%B3%E4%BA%8E%E6%B3%A8%E9%87%8A.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/090.关于注释.md",key:"v-7b0dfbdd",path:"/pages/v2.8.X/f3dc09/",headersStr:null,content:'在LiteFlow的EL规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    THEN(a, b, WHEN(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    THEN(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        WHEN(c, d)\n    )\n</chain>\n',normalizedContent:'在liteflow的el规则写法里，你也可以写注释。注释的写法有2种\n\n单行注释\n\n\n<chain name="chain1">\n    //我是注释\n    then(a, b, when(c, d))\n</chain>\n\n\n多行注释\n\n<chain name="chain1">\n    then(\n        //我是注释\n        a, \n        b, \n        /**\n        * 我是多行注释\n        * 我是多行注释\n        **/\n        when(c, d)\n    )\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T23:35:36.000Z",permalink:"/pages/v2.8.X/74b4bf/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/010.%E8%AF%B4%E6%98%8E.html",relativePath:"15.v2.8.X文档/070.🌮数据上下文/010.说明.md",key:"v-7d329ecf",path:"/pages/v2.8.X/74b4bf/",headersStr:null,content:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在LiteFlow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nLiteFlow对此有独特的设计理念，平时我们写瀑布流的程序时，A调用B，那A一定要把B所需要的参数传递给B，而在LiteFlow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在LiteFlow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",normalizedContent:"概念\n\n在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n数据上下文这个概念在liteflow框架中非常重要，你所有的业务数据都是放在数据上下文中。\n\n要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。\n\nliteflow对此有独特的设计理念，平时我们写瀑布流的程序时，a调用b，那a一定要把b所需要的参数传递给b，而在liteflow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。\n\n每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在liteflow简介中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。\n\n一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🐚组件名包装",frontmatter:{title:"🐚组件名包装",date:"2022-07-26T23:58:18.000Z",permalink:"/pages/v2.8.X/2df3d9/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/100.%E7%BB%84%E4%BB%B6%E5%90%8D%E5%8C%85%E8%A3%85.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/100.组件名包装.md",key:"v-2e580152",path:"/pages/v2.8.X/2df3d9/",headersStr:null,content:'LiteFlow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88Cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    THEN(a, b, 88Cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nLiteFlow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    THEN(a, b, node("88Cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',normalizedContent:'liteflow的组件名是有规范的，不能以数字开头，并且中间不能有运算符号的出现。\n\n比如这些都是不行的：88cmp，cmp-11, user=123。\n\n以下这种定义在启动时是会报错的：\n\n<chain name="chain1">\n    then(a, b, 88cmp, cmp-11);\n</chain>\n\n\n但是有些业务中组件名你需要自动生成，会打破这个规则，怎么办呢？\n\nliteflow也提供了一种组件包装语法，让你可以用任意形式的组件名。\n\n你需要使用node关键字：\n\n<chain name="chain1">\n    then(a, b, node("88cmp"), node("cmp-11"));\n</chain>\n\n\n这样就可以了。\n\n当然a本身和node("a")是等价的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"💐复杂编排例子",frontmatter:{title:"💐复杂编排例子",date:"2022-06-29T21:29:06.000Z",permalink:"/pages/v2.8.X/5156b3/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/060.%F0%9F%A7%A9EL%E8%A7%84%E5%88%99%E7%9A%84%E5%86%99%E6%B3%95/070.%E5%A4%8D%E6%9D%82%E7%BC%96%E6%8E%92%E4%BE%8B%E5%AD%90.html",relativePath:"15.v2.8.X文档/060.🧩EL规则的写法/070.复杂编排例子.md",key:"v-47a4ff94",path:"/pages/v2.8.X/5156b3/",headers:[{level:2,title:"复杂例子一",slug:"复杂例子一",normalizedTitle:"复杂例子一",charIndex:85},{level:2,title:"复杂例子二",slug:"复杂例子二",normalizedTitle:"复杂例子二",charIndex:842},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1907}],headersStr:"复杂例子一 复杂例子二 总结",content:'经过上面几小章，你是不是已经大致了解了LiteFlow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        WHEN(\n            THEN(B, C),\n            THEN(D, E, F),\n            THEN(\n                SWITCH(G).to(\n                    THEN(H, I, WHEN(J, K)).id("t1"),\n                    THEN(L, M).id("t2")\n                ),\n                N\n            )\n        ),\n        Z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你如果用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = THEN(B, C);\n    item2 = THEN(D, E, F);\n    item3_1 = THEN(H, I, WHEN(J, K)).id("t1");\n    item3_2 = THEN(L, M).id("t2");\n    item3 = THEN(SWITCH(G).to(item3_1, item3_2), N);\n    \n    THEN(\n        A,\n        WHEN(item1, item2, item3),\n        Z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    THEN(\n        A,\n        SWITCH(B).to(\n            THEN(D, E, F).id("t1"),\n            THEN(\n                C,\n                WHEN(\n                    THEN(\n                        SWITCH(G).to(THEN(H, I).id("t2"), J),\n                        K\n                    ),\n                    THEN(L, M)\n                )\n            ).id("t3")\n        ),\n        Z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = THEN(D, E, F).id("t1");\n    \n    item2_1 = THEN(\n        SWITCH(G).to(\n            THEN(H, I).id("t2"),\n            J\n        ),\n        K\n    );\n    \n    item2_2 = THEN(L, M);\n    \n    item2 = THEN(C, WHEN(item2_1, item2_2)).id("t3");\n    \n    THEN(\n        A,\n        SWITCH(B).to(item1, item2),\n        Z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.ComplexELSpringbootTest2\n\n\n# 总结\n\nLiteFlow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',normalizedContent:'经过上面几小章，你是不是已经大致了解了liteflow该如何编排了呢？\n\n这章我们结合以上几个章节，来看下复杂流程编排的例子。\n\n这章我们举两个比较复杂的例子。\n\n\n# 复杂例子一\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        when(\n            then(b, c),\n            then(d, e, f),\n            then(\n                switch(g).to(\n                    then(h, i, when(j, k)).id("t1"),\n                    then(l, m).id("t2")\n                ),\n                n\n            )\n        ),\n        z\n    );\n</chain>\n\n\n我相信大多数人应该能看懂，但是如果你如果用子变量再优化的话，会更加清晰，上面的可以优化成：\n\n<chain name="chain1">\n    item1 = then(b, c);\n    item2 = then(d, e, f);\n    item3_1 = then(h, i, when(j, k)).id("t1");\n    item3_2 = then(l, m).id("t2");\n    item3 = then(switch(g).to(item3_1, item3_2), n);\n    \n    then(\n        a,\n        when(item1, item2, item3),\n        z\n    );\n</chain>\n\n\n是不是清晰很多了？\n\n如果你已经看懂上面这个例子，那我们再来看一个巨复杂的\n\n\n# 复杂例子二\n\n图示\n\n上面这个图可以表示为以下的编排表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        switch(b).to(\n            then(d, e, f).id("t1"),\n            then(\n                c,\n                when(\n                    then(\n                        switch(g).to(then(h, i).id("t2"), j),\n                        k\n                    ),\n                    then(l, m)\n                )\n            ).id("t3")\n        ),\n        z\n    );\n</chain>\n\n\n这个表达式初看，我觉得一部分人会晕，括号都得数半天，当然如果你仔细研读的话，应该能看懂。\n\n对于这种比较难以阅读的表达式来说，官方建议拆子流程或者拆子变量。下面我用拆子变量的方式优化下：\n\n<chain name="chain1">\n    item1 = then(d, e, f).id("t1");\n    \n    item2_1 = then(\n        switch(g).to(\n            then(h, i).id("t2"),\n            j\n        ),\n        k\n    );\n    \n    item2_2 = then(l, m);\n    \n    item2 = then(c, when(item2_1, item2_2)).id("t3");\n    \n    then(\n        a,\n        switch(b).to(item1, item2),\n        z\n    );\n</chain>\n\n\n提示\n\n以上2个例子可在源码中的测试用例中找到，你可以运行并测试。\n\n复杂案例一：com.yomahub.liteflow.test.complex.complexelspringboottest1\n\n复杂案例二：com.yomahub.liteflow.test.complex.complexelspringboottest2\n\n\n# 总结\n\nliteflow的规则表达式语法简单，但是却可以描绘出大多数编排场景。努力让你的规则最大程度的简化。\n\n在实际场景中，如果遇到复杂编排，完全可以使用子流程或者子变量来简化你的整个规则。让你的规则优雅且更容易阅读！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌯数据上下文的定义和使用",frontmatter:{title:"🌯数据上下文的定义和使用",date:"2022-07-01T23:49:40.000Z",permalink:"/pages/v2.8.X/501abf/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/020.%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8.html",relativePath:"15.v2.8.X文档/070.🌮数据上下文/020.数据上下文的定义和使用.md",key:"v-6425d832",path:"/pages/v2.8.X/501abf/",headers:[{level:2,title:"默认上下文",slug:"默认上下文",normalizedTitle:"默认上下文",charIndex:2},{level:2,title:"自定义上下文",slug:"自定义上下文",normalizedTitle:"自定义上下文",charIndex:224},{level:2,title:"多上下文",slug:"多上下文",normalizedTitle:"多上下文",charIndex:816}],headersStr:"默认上下文 自定义上下文 多上下文",content:'# 默认上下文\n\nLiteFlow提供了一个默认的数据上下文的实现：DefaultContext。这个默认的实现其实里面主要存储数据的容器就是一个Map。\n\n你可以通过DefaultContext中的setData方法放入数据，通过getData方法获得数据。\n\n建议\n\nDefaultContext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的Bean当做上下文进行传入。LiteFlow对上下文的Bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, CustomContext.class);\n\n\n传入之后， LiteFlow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tCustomContext context = this.getContextBean(CustomContext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//CustomContext context = this.getFirstContextBean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nLiteFlow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 流程初始参数, OrderContext.class, UserContext.class, SignContext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@LiteflowComponent("yourCmpId")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tOrderContext orderContext = this.getContextBean(OrderContext.class);\n\t\tUserContext userContext = this.getContextBean(UserContext.class);\n\t\tSignContext signContext = this.getContextBean(SignContext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是OrderContext，那么也可以用这个方法\n\t\t//OrderContext orderContext = this.getFirstContextBean();\n\t\t...\n\t}\n}\n',normalizedContent:'# 默认上下文\n\nliteflow提供了一个默认的数据上下文的实现：defaultcontext。这个默认的实现其实里面主要存储数据的容器就是一个map。\n\n你可以通过defaultcontext中的setdata方法放入数据，通过getdata方法获得数据。\n\n建议\n\ndefaultcontext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的bean当做上下文进行传入。liteflow对上下文的bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, customcontext.class);\n\n\n传入之后， liteflow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tcustomcontext context = this.getcontextbean(customcontext.class);\n\t\t//或者你也可以用这个方法去获取上下文实例，和上面是等价的\n\t\t//customcontext context = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 多上下文\n\nliteflow在新版本中支持了多上下文，在执行的时候同时初始化你传入的多个上下文。在组件里也可以根据class类型很方便的拿到。\n\n你可以像这样进行传入（看不全的可以往后拉）：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 流程初始参数, ordercontext.class, usercontext.class, signcontext.class);\n\n\n在组件之中可以这样去获得这个上下文实例：\n\n@liteflowcomponent("yourcmpid")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tordercontext ordercontext = this.getcontextbean(ordercontext.class);\n\t\tusercontext usercontext = this.getcontextbean(usercontext.class);\n\t\tsigncontext signcontext = this.getcontextbean(signcontext.class);\n\t\t\n\t\t//如果你只想获取第一个上下文，第一个上下文是ordercontext，那么也可以用这个方法\n\t\t//ordercontext ordercontext = this.getfirstcontextbean();\n\t\t...\n\t}\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪶用初始化好的上下文传入",frontmatter:{title:"🪶用初始化好的上下文传入",date:"2022-08-17T23:30:42.000Z",permalink:"/pages/v2.8.X/f05ed6/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/070.%F0%9F%8C%AE%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87/030.%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A5%BD%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BC%A0%E5%85%A5.html",relativePath:"15.v2.8.X文档/070.🌮数据上下文/030.用初始化好的上下文传入.md",key:"v-7fc3f010",path:"/pages/v2.8.X/f05ed6/",headersStr:null,content:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getRequestData()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nLiteFlow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到FlowExecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nOrderContext orderContext = new OrderContext();\norderContext.setOrderNo("SO11223344");\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", null, orderContext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。',normalizedContent:'你可能注意到了，在执行器执行流程的时候，需要传入流程入参和上下文class定义(一个或多个)两种参数。\n\n关于流程入参在流程入参章节有具体说明。\n\n对于数据上下文而言，初始化动作是由框架来处理的。也就是说，在你执行第一个组件时，上下文对象里面是没有用户数据的。而你的流程入参是用this.getrequestdata()获取的，这部分不包含在上下文里面。\n\n如果你需要将流程入参放入上下文，那这一动作是需要你自己来完成的。\n\n可能会有人觉得这一步骤略显繁琐。\n\nliteflow从2.8.4版本开始，允许用户传入一个或多个已经初始化好的bean作为上下文，而不是传入class对象。\n\n在拿到flowexecutor之后，你可以像如下一样，传入已经初始化好的bean作为上下文（当然也支持多上下文，这里只演示单上下文）：\n\nordercontext ordercontext = new ordercontext();\nordercontext.setorderno("so11223344");\nliteflowresponse response = flowexecutor.execute2resp("chain1", null, ordercontext);\n\n\n如果你这样调用，等于你的上下文中已经初始化好了一个一些数据。从某种意义上来说，这已经等同于流程入参了，所以使用这个的时候，你完全可以不传流程入参了。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-01T22:30:36.000Z",permalink:"/pages/v2.8.X/90b2a5/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/010.%E8%AF%B4%E6%98%8E.html",relativePath:"15.v2.8.X文档/080.🛩执行器/010.说明.md",key:"v-5093508b",path:"/pages/v2.8.X/90b2a5/",headersStr:null,content:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合Hello World章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",normalizedContent:"上面的几章节说明了，规则文件如何配置，如何定义组件，如何撰写规则。\n\n相信你已经结合hello world章节做了初步的尝试。\n\n这章节将会详细介绍执行器。\n\n执行器是一个流程的触发点，你可以在代码的任意地方用执行器进行执行流程。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎢流程入参",frontmatter:{title:"🎢流程入参",date:"2022-07-02T00:38:44.000Z",permalink:"/pages/v2.8.X/563b67/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/030.%E6%B5%81%E7%A8%8B%E5%85%A5%E5%8F%82.html",relativePath:"15.v2.8.X文档/080.🛩执行器/030.流程入参.md",key:"v-5076b136",path:"/pages/v2.8.X/563b67/",headersStr:null,content:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户Id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的Bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tYourBean requestBean = this.getRequestData();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getRequestData()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',normalizedContent:'在实际使用中，很多同学会对流程入参这一概念有所疑惑。\n\n在一个流程中，总会有一些初始的参数，比如订单号，用户id等等一些的初始参数。这时候需要通过以下方法的第二个参数传入：\n\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n请注意，这个流程入参，可以是任何对象，一般生产业务场景下，你可以把自己封装好的bean传入。\n\n这个值你可以通过以下的方法在组件中拿到：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tyourbean requestbean = this.getrequestdata();\n\t}\n}\n\n\n提示\n\n在这里，流程入参可以是任何对象，如果你把数据上下文的实例传入了，并不意味着你拿到的相同类型的数据上下文中就是有值的。因为这2个对象根本就是2个实例。 流程入参只能通过this.getrequestdata()去拿。\n\n如果你真实目的是想提前传入初始化好的上下文对象，可以参考用初始化好的上下文传入这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎡执行方法",frontmatter:{title:"🎡执行方法",date:"2022-07-01T23:03:12.000Z",permalink:"/pages/v2.8.X/20072e/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/020.%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95.html",relativePath:"15.v2.8.X文档/080.🛩执行器/020.执行方法.md",key:"v-1d9bb488",path:"/pages/v2.8.X/20072e/",headers:[{level:2,title:"返回类型为LiteflowResponse",slug:"返回类型为liteflowresponse",normalizedTitle:"返回类型为liteflowresponse",charIndex:86},{level:2,title:"返回类型为Future",slug:"返回类型为future",normalizedTitle:"返回类型为future",charIndex:529}],headersStr:"返回类型为LiteflowResponse 返回类型为Future",content:"你可以在Springboot/Spring体系中的任何被Spring上下文管理的类中进行注入FlowExecutor。\n\nFlowExecutor有多个重载方法。\n\n\n# 返回类型为LiteflowResponse\n\n//参数为流程ID，无初始流程入参，上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId)\n//第一个参数为流程ID，第二个参数为流程入参。上下文类型为默认的DefaultContext\npublic LiteflowResponse execute2Resp(String chainId, Object param);\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文class\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n建议\n\n在这里，官方只推荐你用第三个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为Future\n\npublic Future<LiteflowResponse> execute2Future(String chainId, Object param, Class<?>... contextBeanClazzArray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，LiteFlow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现ExecutorBuilder接口：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n",normalizedContent:"你可以在springboot/spring体系中的任何被spring上下文管理的类中进行注入flowexecutor。\n\nflowexecutor有多个重载方法。\n\n\n# 返回类型为liteflowresponse\n\n//参数为流程id，无初始流程入参，上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid)\n//第一个参数为流程id，第二个参数为流程入参。上下文类型为默认的defaultcontext\npublic liteflowresponse execute2resp(string chainid, object param);\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文class\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n建议\n\n在这里，官方只推荐你用第三个方法，前面2个因为是默认上下文，可以用于测试场景，在生产场景中尽量别用默认上下文。\n\n\n# 返回类型为future\n\npublic future<liteflowresponse> execute2future(string chainid, object param, class<?>... contextbeanclazzarray)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到response，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，liteflow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现executorbuilder接口：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎯如何构造",frontmatter:{title:"🎯如何构造",date:"2022-07-02T15:57:38.000Z",permalink:"/pages/v2.8.X/6bc8fe/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/020.%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0.html",relativePath:"15.v2.8.X文档/090.🎲用代码动态构造规则/020.如何构造.md",key:"v-5713db61",path:"/pages/v2.8.X/6bc8fe/",headers:[{level:2,title:"什么时候构造",slug:"什么时候构造",normalizedTitle:"什么时候构造",charIndex:93},{level:2,title:"构造Node",slug:"构造node",normalizedTitle:"构造node",charIndex:145},{level:2,title:"构建一个Chain",slug:"构建一个chain",normalizedTitle:"构建一个chain",charIndex:1416},{level:2,title:"销毁一个Chain",slug:"销毁一个chain",normalizedTitle:"销毁一个chain",charIndex:1738}],headersStr:"什么时候构造 构造Node 构建一个Chain 销毁一个Chain",content:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造Node\n\n提示\n\n你可以像以下那样构造一个普通的Node，当然在spring/springboot环境，大多数情况你无需去构建一个Node，因为只要你的组件上标有@Component/@LiteflowComponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件\n\n//构建一个普通组件\nLiteFlowNodeBuilder.createCommonNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个普通条件组件\nLiteFlowNodeBuilder.createSwitchNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个脚本组件\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nLiteFlowNodeBuilder.createScriptSwitchNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setFile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@LiteflowComponent或者@Component，如果项目是spring体系的话，LiteFlow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@Autowired和@Resource等等之类的spring任何注解。\n\n\n# 构建一个Chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nLiteFlowChainELBuilder.createChain().setChainName("chain2").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个EL表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 销毁一个Chain\n\nLiteFlow中允许你手动运行以下代码来销毁一个流程：\n\nFlowBus.removeChain("你的流程ID")\n',normalizedContent:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造node\n\n提示\n\n你可以像以下那样构造一个普通的node，当然在spring/springboot环境，大多数情况你无需去构建一个node，因为只要你的组件上标有@component/@liteflowcomponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件\n\n//构建一个普通组件\nliteflownodebuilder.createcommonnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个普通条件组件\nliteflownodebuilder.createswitchnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个脚本组件\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nliteflownodebuilder.createscriptswitchnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setfile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@liteflowcomponent或者@component，如果项目是spring体系的话，liteflow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@autowired和@resource等等之类的spring任何注解。\n\n\n# 构建一个chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nliteflowchainelbuilder.createchain().setchainname("chain2").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你用了子流程，如果chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n但是经过上面几章的学习，其实一个el表达式完全可以表示一个复杂的流程，即便不能也可以用子变量来优化流程。\n\n\n# 销毁一个chain\n\nliteflow中允许你手动运行以下代码来销毁一个流程：\n\nflowbus.removechain("你的流程id")\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🎈LiteflowResponse对象",frontmatter:{title:"🎈LiteflowResponse对象",date:"2022-07-02T00:52:14.000Z",permalink:"/pages/v2.8.X/9f653d/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/080.%F0%9F%9B%A9%E6%89%A7%E8%A1%8C%E5%99%A8/040.LiteflowResponse%E5%AF%B9%E8%B1%A1.html",relativePath:"15.v2.8.X文档/080.🛩执行器/040.LiteflowResponse对象.md",key:"v-2a88920a",path:"/pages/v2.8.X/9f653d/",headers:[{level:2,title:"流程执行是否成功",slug:"流程执行是否成功",normalizedTitle:"流程执行是否成功",charIndex:66},{level:2,title:"获取异常信息",slug:"获取异常信息",normalizedTitle:"获取异常信息",charIndex:240},{level:2,title:"获得执行步骤详细信息",slug:"获得执行步骤详细信息",normalizedTitle:"获得执行步骤详细信息",charIndex:481},{level:2,title:"上下文数据",slug:"上下文数据",normalizedTitle:"上下文数据",charIndex:890},{level:2,title:"获得步骤字符串信息",slug:"获得步骤字符串信息",normalizedTitle:"获得步骤字符串信息",charIndex:1516}],headersStr:"流程执行是否成功 获取异常信息 获得执行步骤详细信息 上下文数据 获得步骤字符串信息",content:'在执行器返回中，用的最多的就是返回一个LiteFlowResponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nboolean isSuccess = response.isSuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程isSuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了LiteFlowResponse对象之后，可以这样获得上下文Bean：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nCustomContext context = response.getContextBean(CustomContext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//CustomContext context = response.getFirstContextBean();\n\n\n对于多上下文来说，也是一样的用法：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, OrderContext.class, UserContext.class);\nOrderContext orderContext = response.getContextBean(OrderContext.class);\nUserContext userContext = response.getContextBean(UserContext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nString stepStr = response.getExecuteStepStrWithTime();\n\n\n这个字符串打印出来结果如下：\n\na[组件A]<201>==>b[组件B]<300>==>m[组件M]<1205>\n\n\n这里的表达形式为组件ID[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getExecuteStepStrWithoutTime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',normalizedContent:'在执行器返回中，用的最多的就是返回一个liteflowresponse对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nboolean issuccess = response.issuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程issuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n关于异常的解释请详细查看异常这一章节。\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过这个方法来获取：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n\n\n你也可以通过这样的方式也取到一个队列：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n关于这上面2个方法的区别和步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了liteflowresponse对象之后，可以这样获得上下文bean：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\ncustomcontext context = response.getcontextbean(customcontext.class);\n//对于只有一个上下文的response来说，用下面这句也是等价的\n//customcontext context = response.getfirstcontextbean();\n\n\n对于多上下文来说，也是一样的用法：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, ordercontext.class, usercontext.class);\nordercontext ordercontext = response.getcontextbean(ordercontext.class);\nusercontext usercontext = response.getcontextbean(usercontext.class);\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nstring stepstr = response.getexecutestepstrwithtime();\n\n\n这个字符串打印出来结果如下：\n\na[组件a]<201>==>b[组件b]<300>==>m[组件m]<1205>\n\n\n这里的表达形式为组件id[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getexecutestepstrwithouttime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍄说明",frontmatter:{title:"🍄说明",date:"2022-07-02T09:56:32.000Z",permalink:"/pages/v2.8.X/9aa85a/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/090.%F0%9F%8E%B2%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/010.%E8%AF%B4%E6%98%8E.html",relativePath:"15.v2.8.X文档/090.🎲用代码动态构造规则/010.说明.md",key:"v-cabfb2d2",path:"/pages/v2.8.X/9aa85a/",headersStr:null,content:"之前的章节讲述的是通过规则文件去构造流程。\n\nLiteFlow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，ruleSource不用去定义。完全用代码去构建。\n\n事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的API意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造API去构造链路。\n\nLiteFlow设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",normalizedContent:"之前的章节讲述的是通过规则文件去构造流程。\n\nliteflow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，rulesource不用去定义。完全用代码去构建。\n\n事实上，liteflow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的api意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造api去构造链路。\n\nliteflow设计了非常简单的构造方法链式api，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍋脚本组件",frontmatter:{title:"🍋脚本组件",date:"2022-07-02T17:48:18.000Z",permalink:"/pages/v2.8.X/40b16f/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/010.%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/010.脚本组件.md",key:"v-ece90370",path:"/pages/v2.8.X/40b16f/",headers:[{level:2,title:"如何定义",slug:"如何定义",normalizedTitle:"如何定义",charIndex:120},{level:2,title:"文件脚本的定义",slug:"文件脚本的定义",normalizedTitle:"文件脚本的定义",charIndex:1318},{level:2,title:"如何与java变量进行交互",slug:"如何与java变量进行交互",normalizedTitle:"如何与java变量进行交互",charIndex:1998},{level:2,title:"如何选择脚本框架",slug:"如何选择脚本框架",normalizedTitle:"如何选择脚本框架",charIndex:2404},{level:2,title:"脚本运行性能如何",slug:"脚本运行性能如何",normalizedTitle:"脚本运行性能如何",charIndex:2830},{level:2,title:"如何动态刷新脚本",slug:"如何动态刷新脚本",normalizedTitle:"如何动态刷新脚本",charIndex:2900}],headersStr:"如何定义 文件脚本的定义 如何与java变量进行交互 如何选择脚本框架 脚本运行性能如何 如何动态刷新脚本",content:'LiteFlow支持脚本节点的创建。支持热刷新脚本，支持QLExpress和Groovy两种脚本的编写。\n\n关于这两种脚本语言的语法，可能提前大家要稍加熟悉，这里给出两个教程：\n\nGroovy语法教程\n\nQLExpress语法教程\n\n\n# 如何定义\n\n脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script">\n            <![CDATA[\n                a=3;\n                b=2;\n                defaultContext.setData("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="选择脚本" type="switch_script">\n            <![CDATA[\n                count = defaultContext.getData("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n\n        <node id="s3" name="条件脚本" type="if_script">\n            <![CDATA[\n                return false;\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1);\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, SWITCH(s2).to(a, b));\n    </chain>\n\n    <chain name="chain3">\n        THEN(d, IF(s3, b, c));\n    </chain>\n</flow>\n\n\n要注意的是，type分为三种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点Id。\n\nif_script：条件脚本节点，脚本里需要返回true/false\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n这里示例是传入的上下文bean是默认的DefaultContext，如果是你自定义的上下文Bean，请调用相应的方法来设置和获取数据。\n\n\n# 文件脚本的定义\n\nLiteFlow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟IDE对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前LiteFlow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        THEN(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        THEN(d, IF(s3, b, c));\n    </chain>\n</flow>\n\n\n\n# 如何与java变量进行交互\n\n因为LiteFlow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的className的驼峰形式来获取数据。\n\n比如你的上下文类叫OrderContext，那么脚本中的就用orderContext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n如果想获得流程初始参数，脚本内置了requestData关键字。\n\n如果你的脚本在隐式流程中，想获取当前隐式流程的入参，则应该用subRequestData关键字。\n\n普通脚本组件，脚本中无需返回值。只需要把结果设置到context即可（这和普通的java编写的组件是一致的）。\n\n而条件脚本节点，则需要在脚本中返回条件路由到的节点ID，返回String类型（这也和java编写的选择组件是一致的）。\n\n\n# 如何选择脚本框架\n\nLiteFlow采用SPI机制进行选择脚本框架来动态编译你的脚本。\n\nQLExpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-qlexpress</artifactId>\n    <version>2.8.5</version>\n</dependency>\n\n\nGroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-groovy</artifactId>\n    <version>2.8.5</version>\n</dependency>\n\n\n你只需要依赖相应的脚本框架即可，SPI会动态选择你依赖的脚本框架进行编译解析你的脚本\n\n\n# 脚本运行性能如何\n\nLiteFlow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。\n\n\n# 如何动态刷新脚本\n\n提供了编码形式的刷新，刷新后可以重新编译脚本\n\nScriptExecutorFactory.loadInstance().getScriptExecutor().load(nodeId, script);\n',normalizedContent:'liteflow支持脚本节点的创建。支持热刷新脚本，支持qlexpress和groovy两种脚本的编写。\n\n关于这两种脚本语言的语法，可能提前大家要稍加熟悉，这里给出两个教程：\n\ngroovy语法教程\n\nqlexpress语法教程\n\n\n# 如何定义\n\n脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script">\n            <![cdata[\n                a=3;\n                b=2;\n                defaultcontext.setdata("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="选择脚本" type="switch_script">\n            <![cdata[\n                count = defaultcontext.getdata("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n\n        <node id="s3" name="条件脚本" type="if_script">\n            <![cdata[\n                return false;\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1);\n    </chain>\n\n    <chain name="chain2">\n        then(d, switch(s2).to(a, b));\n    </chain>\n\n    <chain name="chain3">\n        then(d, if(s3, b, c));\n    </chain>\n</flow>\n\n\n要注意的是，type分为三种：\n\nscript：普通脚本节点，脚本里无需返回。\n\nswitch_script：选择脚本节点，脚本里需要返回选择的节点id。\n\nif_script：条件脚本节点，脚本里需要返回true/false\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n这里示例是传入的上下文bean是默认的defaultcontext，如果是你自定义的上下文bean，请调用相应的方法来设置和获取数据。\n\n\n# 文件脚本的定义\n\nliteflow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟ide对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前liteflow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="选择脚本" type="switch_script" file="xml-script-file/s2.groovy"/>\n        <node id="s3" name="条件脚本" type="switch_script" file="xml-script-file/s3.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        then(a, b, c, s1)\n    </chain>\n\n    <chain name="chain2">\n        then(d, if(s3, b, c));\n    </chain>\n</flow>\n\n\n\n# 如何与java变量进行交互\n\n因为liteflow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，你可以通过你定义数据上下文的classname的驼峰形式来获取数据。\n\n比如你的上下文类叫ordercontext，那么脚本中的就用ordercontext这个关键字来获取数据或调用方法。\n\n如果你是多上下文，同样的，你也可以在脚本中用多个上下文来获取数据或调用context内部的逻辑方法。\n\n如果想获得流程初始参数，脚本内置了requestdata关键字。\n\n如果你的脚本在隐式流程中，想获取当前隐式流程的入参，则应该用subrequestdata关键字。\n\n普通脚本组件，脚本中无需返回值。只需要把结果设置到context即可（这和普通的java编写的组件是一致的）。\n\n而条件脚本节点，则需要在脚本中返回条件路由到的节点id，返回string类型（这也和java编写的选择组件是一致的）。\n\n\n# 如何选择脚本框架\n\nliteflow采用spi机制进行选择脚本框架来动态编译你的脚本。\n\nqlexpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-qlexpress</artifactid>\n    <version>2.8.5</version>\n</dependency>\n\n\ngroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-groovy</artifactid>\n    <version>2.8.5</version>\n</dependency>\n\n\n你只需要依赖相应的脚本框架即可，spi会动态选择你依赖的脚本框架进行编译解析你的脚本\n\n\n# 脚本运行性能如何\n\nliteflow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。\n\n\n# 如何动态刷新脚本\n\n提供了编码形式的刷新，刷新后可以重新编译脚本\n\nscriptexecutorfactory.loadinstance().getscriptexecutor().load(nodeid, script);\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍇声明式组件",frontmatter:{title:"🍇声明式组件",date:"2022-07-02T22:02:46.000Z",permalink:"/pages/v2.8.X/f33919/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/020.%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/020.声明式组件.md",key:"v-14a2d8cc",path:"/pages/v2.8.X/f33919/",headers:[{level:2,title:"普通组件的声明",slug:"普通组件的声明",normalizedTitle:"普通组件的声明",charIndex:205},{level:2,title:"选择组件的声明",slug:"选择组件的声明",normalizedTitle:"选择组件的声明",charIndex:1604},{level:2,title:"条件组件的声明",slug:"条件组件的声明",normalizedTitle:"条件组件的声明",charIndex:1905},{level:2,title:"关于实现",slug:"关于实现",normalizedTitle:"关于实现",charIndex:2128}],headersStr:"普通组件的声明 选择组件的声明 条件组件的声明 关于实现",content:'何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承NodeComponent或者NodeSwitchComponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成LiteFlow组件的声明。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@LiteflowComponent("a")\n@LiteflowCmpDefine\npublic class ACmp{\n  \n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS)\n\tpublic void processAcmp(NodeComponent bindCmp) {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)\n\tpublic boolean isAcmpAccess(NodeComponent bindCmp){\n\t\treturn true;\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.BEFORE_PROCESS)\n\tpublic void beforeAcmp(String nodeId, Slot slot){\n\t\tSystem.out.println("before A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.AFTER_PROCESS)\n\tpublic void afterAcmp(String nodeId, Slot slot){\n\t\tSystem.out.println("after A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_SUCCESS)\n\tpublic void onAcmpSuccess(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp success");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_ERROR)\n\tpublic void onAcmpError(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp error");\n\t}\n\t\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_END)\n\tpublic boolean isAcmpEnd(NodeComponent bindCmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承NodeComponent了，在你定义的类上，只要类上加上LiteflowCmpDefine注解，相应的方法上加上LiteflowMethod注解，即可完成对任意自定义类的组件化工作。\n\n其中LiteFlowMethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n提示\n\n这里注意的是，大部分方法上参数必须传入NodeComponent bindCmp这个参数，而且必须只有一个参数，否则会报错，而beforeProcess和afterProcess还是按照以前的参数定义。这点要注意下，可以查看上面的示例。\n\n以前获取上下文Bean是用this关键字，现在只需从bindCmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n\n# 选择组件的声明\n\n声明选择组件和普通组件差不多，如下所示：\n\n@Component("e")\n@LiteflowSwitchCmpDefine\npublic class ECmp{\n\n    @LiteflowMethod(LiteFlowMethodEnum.PROCESS_SWITCH)\n    public String processSwitch(NodeComponent bindCmp) throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n@Component("x")\n@LiteflowIfCmpDefine\npublic class XCmp{\n\n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS_IF)\n\tpublic boolean processIf(NodeComponent bindCmp) throws Exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 关于实现\n\n声明式组件依靠动态代理来实现，底层用的动态代理框架为ByteBuddy。\n\n所有的动态代理类在注册时类名均做了处理，所以你会看到如下的日志打印\n\n2022-05-16 13:05:56.492  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$a$JLWBAK   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$a$JLWBAK] execution\n2022-05-16 13:05:56.496  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$b$JZXUWG   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$b$JZXUWG] execution\n2022-05-16 13:05:56.505  INFO 73054 --- [lf-when-thead-0] c.y.l.test.base.cmp.ByteBuddy$c$RWWUCJ   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$c$RWWUCJ] execution\n2022-05-16 13:05:56.506  INFO 73054 --- [lf-when-thead-1] c.y.l.test.base.cmp.ByteBuddy$d$RECNPY   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$d$RECNPY] execution\n\n\n仔细看会发现，所有的动态代理后的类名的格式为：ByteBuddy$你的组件名$随机6位字符串。\n\n所以在看日志时，对于声明式组件而言，你只需要看两个$中间的那个，即为你的组件ID。这点怕有人有疑惑，特地说明一下。',normalizedContent:'何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承nodecomponent或者nodeswitchcomponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成liteflow组件的声明。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@liteflowcomponent("a")\n@liteflowcmpdefine\npublic class acmp{\n  \n\t@liteflowmethod(liteflowmethodenum.process)\n\tpublic void processacmp(nodecomponent bindcmp) {\n\t\tsystem.out.println("acmp executed!");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.is_access)\n\tpublic boolean isacmpaccess(nodecomponent bindcmp){\n\t\treturn true;\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.before_process)\n\tpublic void beforeacmp(string nodeid, slot slot){\n\t\tsystem.out.println("before a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.after_process)\n\tpublic void afteracmp(string nodeid, slot slot){\n\t\tsystem.out.println("after a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_success)\n\tpublic void onacmpsuccess(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp success");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_error)\n\tpublic void onacmperror(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp error");\n\t}\n\t\n\t@liteflowmethod(liteflowmethodenum.is_end)\n\tpublic boolean isacmpend(nodecomponent bindcmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承nodecomponent了，在你定义的类上，只要类上加上liteflowcmpdefine注解，相应的方法上加上liteflowmethod注解，即可完成对任意自定义类的组件化工作。\n\n其中liteflowmethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n提示\n\n这里注意的是，大部分方法上参数必须传入nodecomponent bindcmp这个参数，而且必须只有一个参数，否则会报错，而beforeprocess和afterprocess还是按照以前的参数定义。这点要注意下，可以查看上面的示例。\n\n以前获取上下文bean是用this关键字，现在只需从bindcmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n\n# 选择组件的声明\n\n声明选择组件和普通组件差不多，如下所示：\n\n@component("e")\n@liteflowswitchcmpdefine\npublic class ecmp{\n\n    @liteflowmethod(liteflowmethodenum.process_switch)\n    public string processswitch(nodecomponent bindcmp) throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 条件组件的声明\n\n@component("x")\n@liteflowifcmpdefine\npublic class xcmp{\n\n\t@liteflowmethod(liteflowmethodenum.process_if)\n\tpublic boolean processif(nodecomponent bindcmp) throws exception {\n\t\t//do your biz\n\t\treturn true;\n\t}\n}\n\n\n\n# 关于实现\n\n声明式组件依靠动态代理来实现，底层用的动态代理框架为bytebuddy。\n\n所有的动态代理类在注册时类名均做了处理，所以你会看到如下的日志打印\n\n2022-05-16 13:05:56.492  info 73054 --- [           main] c.y.l.test.base.cmp.bytebuddy$a$jlwbak   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$a$jlwbak] execution\n2022-05-16 13:05:56.496  info 73054 --- [           main] c.y.l.test.base.cmp.bytebuddy$b$jzxuwg   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$b$jzxuwg] execution\n2022-05-16 13:05:56.505  info 73054 --- [lf-when-thead-0] c.y.l.test.base.cmp.bytebuddy$c$rwwucj   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$c$rwwucj] execution\n2022-05-16 13:05:56.506  info 73054 --- [lf-when-thead-1] c.y.l.test.base.cmp.bytebuddy$d$recnpy   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$d$recnpy] execution\n\n\n仔细看会发现，所有的动态代理后的类名的格式为：bytebuddy$你的组件名$随机6位字符串。\n\n所以在看日志时，对于声明式组件而言，你只需要看两个$中间的那个，即为你的组件id。这点怕有人有疑惑，特地说明一下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥠替补组件",frontmatter:{title:"🥠替补组件",date:"2022-07-27T00:07:01.000Z",permalink:"/pages/v2.8.X/79289a/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/035.%E6%9B%BF%E8%A1%A5%E7%BB%84%E4%BB%B6.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/035.替补组件.md",key:"v-3be426db",path:"/pages/v2.8.X/79289a/",headersStr:null,content:'如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了A，B，C三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    THEN(A, B, C, D);\n</chain>\n\n\n由于D组件不存在，所以启动时会报错。\n\n替补组件的意义是，当你写了一个不存在的组件时，在解析时会自动解析到你指定的替补组件上，由这个替补组件来代替你不存在的组件来执行，这样就不会报错了。\n\n你需要在配置中指定你的替补组件：\n\nliteflow.substitute-cmp-class=com.yomahub.liteflow.test.substituteNode.cmp.SubCmp\n\n\n替补组件本身定义和其他的组件没有任何区别，如果在spring体系中，需要被注册到上下文，如果非spring环境，也需要在规则文件中定义。\n\n当你指定了替补组件后，你的规则文件需要这么写：\n\n<chain name="chain1">\n    THEN(A, B, C, node("D"));\n</chain>\n\n\n提示\n\n这里注意下，如果不加node关键字，不会自动路由到替补组件的，所以一定得加。',normalizedContent:'如果你在编排时写了一个不存在的组件，通常情况下是会报错的。\n\n比如你的系统中只定义了a，b，c三个组件。但是你在规则里这样写：\n\n<chain name="chain1">\n    then(a, b, c, d);\n</chain>\n\n\n由于d组件不存在，所以启动时会报错。\n\n替补组件的意义是，当你写了一个不存在的组件时，在解析时会自动解析到你指定的替补组件上，由这个替补组件来代替你不存在的组件来执行，这样就不会报错了。\n\n你需要在配置中指定你的替补组件：\n\nliteflow.substitute-cmp-class=com.yomahub.liteflow.test.substitutenode.cmp.subcmp\n\n\n替补组件本身定义和其他的组件没有任何区别，如果在spring体系中，需要被注册到上下文，如果非spring环境，也需要在规则文件中定义。\n\n当你指定了替补组件后，你的规则文件需要这么写：\n\n<chain name="chain1">\n    then(a, b, c, node("d"));\n</chain>\n\n\n提示\n\n这里注意下，如果不加node关键字，不会自动路由到替补组件的，所以一定得加。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍒前置和后置组件",frontmatter:{title:"🍒前置和后置组件",date:"2022-07-02T22:51:41.000Z",permalink:"/pages/v2.8.X/9f93be/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/030.%E5%89%8D%E7%BD%AE%E5%92%8C%E5%90%8E%E7%BD%AE%E7%BB%84%E4%BB%B6.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/030.前置和后置组件.md",key:"v-3c536be7",path:"/pages/v2.8.X/9f93be/",headers:[{level:2,title:"前置组件",slug:"前置组件",normalizedTitle:"前置组件",charIndex:11},{level:2,title:"后置节点",slug:"后置节点",normalizedTitle:"后置节点",charIndex:259},{level:2,title:"顺序问题",slug:"顺序问题",normalizedTitle:"顺序问题",charIndex:446},{level:2,title:"作用范围",slug:"作用范围",normalizedTitle:"作用范围",charIndex:881}],headersStr:"前置组件 后置节点 顺序问题 作用范围",content:'LiteFlow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用PRE关键字(必须大写)来表示:\n\n<chain name="chain1">\n    THEN(\n        PRE(p1, p2), \n        a, b, c, \n        WHEN(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受Exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用FINALLY关键字(必须大写)表示：\n\n<chain name="chain1">\n    THEN(\n        a, b, c, \n        FINALLY(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，PRE和FINALLY可以写在第一层的任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    THEN(\n        PRE(a), c, d, FINALLY(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    THEN(\n        FINALLY(f1, f2), c, PRE(a), d\n    );\n</chain>\n\n\n那什么叫第一层，请看以下例子：\n\n<chain name="chain1">\n    THEN(\n        a, THEN(PRE(b,c), d)\n    );\n</chain>\n\n\n以上这个例子，PRE是不会被执行的。因为在第二层。只有在第一层的PRE和FINALLY才有效。\n\n\n# 作用范围\n\n值得一提的是，PRE和FINALLY的作用范围是当前的Chain。\n\n这也意味着如果你在子流程里用PRE和FINALLY，只会对子流程生效。\n\n可以看下以下这个例子：\n\n<chain name="chain1">\n    THEN(PRE(p1, p2), chain2, FINALLY(f1));\n</chain>\n\n<chain name="chain2">\n    THEN(PRE(p3), a, b, FINALLY(f2));\n</chain>\n\n\n如果正常执行，得到的步骤应该是这样的：\n\np1=>p2=>p3=>a=>b=>f2=>f1',normalizedContent:'liteflow支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点，规则表达式中用pre关键字(必须大写)来表示:\n\n<chain name="chain1">\n    then(\n        pre(p1, p2), \n        a, b, c, \n        when(d, e)\n    );\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受exception影响，即便节点出错，后置节点依旧会执行。在规则表达式中用finally关键字(必须大写)表示：\n\n<chain name="chain1">\n    then(\n        a, b, c, \n        finally(f1, f2)\n    );\n</chain>\n\n\n\n# 顺序问题\n\n前置节点一定要写在前面吗？后置节点一定要写在最后吗？\n\n并不是，pre和finally可以写在第一层的任意地方。\n\n举个例子：\n\n<chain name="chain1">\n    then(\n        pre(a), c, d, finally(f1, f2)\n    );\n</chain>\n\n\n下面这个表达式和上面是等价效果的, 即使不放在相对应的位置，还是一样的效果。\n\n<chain name="chain1">\n    then(\n        finally(f1, f2), c, pre(a), d\n    );\n</chain>\n\n\n那什么叫第一层，请看以下例子：\n\n<chain name="chain1">\n    then(\n        a, then(pre(b,c), d)\n    );\n</chain>\n\n\n以上这个例子，pre是不会被执行的。因为在第二层。只有在第一层的pre和finally才有效。\n\n\n# 作用范围\n\n值得一提的是，pre和finally的作用范围是当前的chain。\n\n这也意味着如果你在子流程里用pre和finally，只会对子流程生效。\n\n可以看下以下这个例子：\n\n<chain name="chain1">\n    then(pre(p1, p2), chain2, finally(f1));\n</chain>\n\n<chain name="chain2">\n    then(pre(p3), a, b, finally(f2));\n</chain>\n\n\n如果正常执行，得到的步骤应该是这样的：\n\np1=>p2=>p3=>a=>b=>f2=>f1',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍑组件别名",frontmatter:{title:"🍑组件别名",date:"2022-07-03T00:31:22.000Z",permalink:"/pages/v2.8.X/92ef89/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/040.%E7%BB%84%E4%BB%B6%E5%88%AB%E5%90%8D.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/040.组件别名.md",key:"v-68a9682e",path:"/pages/v2.8.X/92ef89/",headers:[{level:2,title:"Springboot & Spring 扫描方式",slug:"springboot-spring-扫描方式",normalizedTitle:"springboot &amp; spring 扫描方式",charIndex:null},{level:2,title:"规则文件方式定义组件",slug:"规则文件方式定义组件",normalizedTitle:"规则文件方式定义组件",charIndex:381},{level:2,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:49}],headersStr:"Springboot & Spring 扫描方式 规则文件方式定义组件 打印",content:'LiteFlow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# Springboot & Spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@Component换成@LiteflowComponent，并做如下定义：\n\n@LiteflowComponent(id = "a", name = "组件A")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件A" class="com.yomahub.liteflow.test.config.cmp.ACmp"/>\n<node id="b" name="组件B" class="com.yomahub.liteflow.test.config.cmp.BCmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',normalizedContent:'liteflow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# springboot & spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@component换成@liteflowcomponent，并做如下定义：\n\n@liteflowcomponent(id = "a", name = "组件a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件a" class="com.yomahub.liteflow.test.config.cmp.acmp"/>\n<node id="b" name="组件b" class="com.yomahub.liteflow.test.config.cmp.bcmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥝组件事件回调",frontmatter:{title:"🥝组件事件回调",date:"2022-07-03T00:41:09.000Z",permalink:"/pages/v2.8.X/3ee755/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/060.%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/060.组件事件回调.md",key:"v-0bad5c3a",path:"/pages/v2.8.X/3ee755/",headers:[{level:2,title:"成功事件",slug:"成功事件",normalizedTitle:"成功事件",charIndex:31},{level:2,title:"失败事件",slug:"失败事件",normalizedTitle:"失败事件",charIndex:36},{level:3,title:"注意点1",slug:"注意点1",normalizedTitle:"注意点1",charIndex:771},{level:3,title:"注意点2",slug:"注意点2",normalizedTitle:"注意点2",charIndex:841},{level:3,title:"注意点3",slug:"注意点3",normalizedTitle:"注意点3",charIndex:1311}],headersStr:"成功事件 失败事件 注意点1 注意点2 注意点3",content:'LiteFlow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onSuccess方法，那么组件成功后会回调这个方法。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tDefaultContext context = this.getContextBean();\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void onSuccess() throws Exception {\n\t\tDefaultContext context = this.getContextBean();\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onError方法，那么组件发生异常后会回调这个方法。\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError() throws Exception {\n\t\tDefaultContext context = this.getContextBean();\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonError方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onError方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onError方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError() throws Exception {\n\t\tthrow new IllegalAccessException("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是NullPointerException而不是IllegalAccessException，但是IllegalAccessException这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonError方法执行后，afterProcess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterProcess方法都会被执行。',normalizedContent:'liteflow支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onsuccess方法，那么组件成功后会回调这个方法。\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tdefaultcontext context = this.getcontextbean();\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void onsuccess() throws exception {\n\t\tdefaultcontext context = this.getcontextbean();\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onerror方法，那么组件发生异常后会回调这个方法。\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror() throws exception {\n\t\tdefaultcontext context = this.getcontextbean();\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonerror方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onerror方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onerror方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror() throws exception {\n\t\tthrow new illegalaccessexception("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是nullpointerexception而不是illegalaccessexception，但是illegalaccessexception这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonerror方法执行后，afterprocess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterprocess方法都会被执行。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥑隐式子流程",frontmatter:{title:"🥑隐式子流程",date:"2022-07-03T00:42:38.000Z",permalink:"/pages/v2.8.X/80e873/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/070.%E9%9A%90%E5%BC%8F%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/070.隐式子流程.md",key:"v-11410945",path:"/pages/v2.8.X/80e873/",headersStr:null,content:'LiteFlow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@Component("h")\npublic class HComponent extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("Hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeInAsync方法。\n\n同样，隐式子流程也支持返回LiteFlowResponse对象，需要调用invoke2Resp方法，关于返回对象为LiteFlowResponse的说明，请参照LiteflowResponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getSubChainReqData()去拿。\n\n如果你是用invokeInAsync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getSubChainReqDataInAsync()去拿。\n\n用this.getRequestData()是拿不到的！',normalizedContent:'liteflow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用，复杂条件判断等等。隐式子流程需要你在组件里通过this.invoke这个语句来调用。\n\n@component("h")\npublic class hcomponent extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("hcomponent executed!");\n        for(int i=0;i<10;i++){\n            this.invoke("strategy1","隐式流程的初始参数，可为null");\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n提示\n\n要注意的是，如果你在组件里另外开线程去调用隐式组件，推荐用invokeinasync方法。\n\n同样，隐式子流程也支持返回liteflowresponse对象，需要调用invoke2resp方法，关于返回对象为liteflowresponse的说明，请参照liteflowresponse对象。\n\n注意\n\n如果你是用invoke去调用隐式流程，在组件中拿到传入的隐式流程请求参数，通过this.getsubchainreqdata()去拿。\n\n如果你是用invokeinasync去调用隐式流程，在组件中拿到传入的隐式流程请求参数，请通过this.getsubchainreqdatainasync()去拿。\n\n用this.getrequestdata()是拿不到的！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍍组件标签",frontmatter:{title:"🍍组件标签",date:"2022-07-03T00:32:36.000Z",permalink:"/pages/v2.8.X/0f788f/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/050.%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/050.组件标签.md",key:"v-e0e347f4",path:"/pages/v2.8.X/0f788f/",headersStr:null,content:'你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    THEN(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.getTag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        String tag = this.getTag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    THEN(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',normalizedContent:'你可以在规则表达式里给每个组件添加运行时的标签值，用tag关键字表示：\n\n<chain name="chain1">\n    then(\n        a.tag("tag1"),\n        b.tag("tag2"),\n        c.tag("tag3")\n    );\n</chain>\n\n\n这样，你在代码里可以通过this.gettag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到不同的参数。或者根据tag标签来给相同的组件作不同的判断。\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n    @override\n    public void process() {\n        string tag = this.gettag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<chain name="chain1">\n    then(\n        a.tag("1"), a.tag("2"), a.tag("3"), a.tag("4"), a.tag("5"), a.tag("6")\n    );\n</chain>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍣组件重试",frontmatter:{title:"🍣组件重试",date:"2022-07-03T11:03:09.000Z",permalink:"/pages/v2.8.X/7e9da1/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/090.%E7%BB%84%E4%BB%B6%E9%87%8D%E8%AF%95.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/090.组件重试.md",key:"v-1b6c34c2",path:"/pages/v2.8.X/7e9da1/",headers:[{level:2,title:"全局重试",slug:"全局重试",normalizedTitle:"全局重试",charIndex:21},{level:2,title:"单个组件重试",slug:"单个组件重试",normalizedTitle:"单个组件重试",charIndex:26},{level:2,title:"全局重试和单个组件重试都定义的情况下",slug:"全局重试和单个组件重试都定义的情况下",normalizedTitle:"全局重试和单个组件重试都定义的情况下",charIndex:970}],headersStr:"全局重试 单个组件重试 全局重试和单个组件重试都定义的情况下",content:'LiteFLow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了isContinueOnError，设为true的话，那流程会继续。\n\n异步流程的话，如果WHEN上配置了ignoreError为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreError的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nLiteFlow还提供了基于单个组件，指定Exception的重试特性，LiteFlow从2.6.0开始提供了@LiteflowRetry标注\n\n你可以在指定的组件上进行标注：\n\n@LiteflowComponent("c")\n@LiteflowRetry(5)\npublic class CCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@LiteflowComponent("e")\n@LiteflowRetry(retry = 5, forExceptions = {NullPointerException.class,IllegalArgumentException.class})\npublic class ECmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是NullPointerException或者IllegalArgumentException（或者是这两个Exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',normalizedContent:'liteflow支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了iscontinueonerror，设为true的话，那流程会继续。\n\n异步流程的话，如果when上配置了ignoreerror为true的话(默认为false)，则下一个不同并行组会继续。关于ignoreerror的定义和使用，可以查看并行编排章节\n\n\n# 单个组件重试\n\nliteflow还提供了基于单个组件，指定exception的重试特性，liteflow从2.6.0开始提供了@liteflowretry标注\n\n你可以在指定的组件上进行标注：\n\n@liteflowcomponent("c")\n@liteflowretry(5)\npublic class ccmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@liteflowcomponent("e")\n@liteflowretry(retry = 5, forexceptions = {nullpointerexception.class,illegalargumentexception.class})\npublic class ecmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是nullpointerexception或者illegalargumentexception（或者是这两个exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍕私有投递",frontmatter:{title:"🍕私有投递",date:"2022-07-03T10:59:19.000Z",permalink:"/pages/v2.8.X/fbb938/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/080.%E7%A7%81%E6%9C%89%E6%8A%95%E9%80%92.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/080.私有投递.md",key:"v-c7d1a238",path:"/pages/v2.8.X/fbb938/",headers:[{level:2,title:"什么叫私有投递",slug:"什么叫私有投递",normalizedTitle:"什么叫私有投递",charIndex:21},{level:2,title:"解决方式",slug:"解决方式",normalizedTitle:"解决方式",charIndex:657}],headersStr:"什么叫私有投递 解决方式",content:'LiteFlow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个LiteFLow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        THEN(\n            a,\n            WHEN(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，LiteFlow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t\tDefaultContext context = this.getContextBean();\n\t\tcontext.setData("testSet", new HashSet<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendPrivateDeliveryData("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendPrivateDeliveryData方法，指定了b组件\n\n然后我们再来看b组件：\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("BCmp executed!");\n\t\tInteger value = this.getPrivateDeliveryData();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getPrivateDeliveryData()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',normalizedContent:'liteflow支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个liteflow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    \x3c!-- 5个相同的b组件并发执行 --\x3e\n    <chain name="chain1">\n        then(\n            a,\n            when(b, b, b, b, b),\n            c\n        );\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，liteflow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t\tdefaultcontext context = this.getcontextbean();\n\t\tcontext.setdata("testset", new hashset<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendprivatedeliverydata("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendprivatedeliverydata方法，指定了b组件\n\n然后我们再来看b组件：\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("bcmp executed!");\n\t\tinteger value = this.getprivatedeliverydata();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getprivatedeliverydata()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍖平滑热刷新",frontmatter:{title:"🍖平滑热刷新",date:"2022-07-03T11:04:48.000Z",permalink:"/pages/v2.8.X/204d71/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/100.%E5%B9%B3%E6%BB%91%E7%83%AD%E5%88%B7%E6%96%B0.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/100.平滑热刷新.md",key:"v-6c007330",path:"/pages/v2.8.X/204d71/",headers:[{level:2,title:"基于规则文件-主动刷新",slug:"基于规则文件-主动刷新",normalizedTitle:"基于规则文件-主动刷新",charIndex:255},{level:2,title:"基于规则文件-被动刷新",slug:"基于规则文件-被动刷新",normalizedTitle:"基于规则文件-被动刷新",charIndex:377},{level:2,title:"基于动态代码构建-刷新",slug:"基于动态代码构建-刷新",normalizedTitle:"基于动态代码构建-刷新",charIndex:704}],headersStr:"基于规则文件-主动刷新 基于规则文件-被动刷新 基于动态代码构建-刷新",content:"LiteFlow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nLiteFlow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，LiteFlow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到FlowExecutor对象后，调用以下接口：\n\nflowExecutor.reloadRule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nFlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_EL_XML, newContent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml，这里注意下，在EL规则表达式下，都是TYPE_EL_XXX的形式，不带EL的那是旧的形式，请不要用错！\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",normalizedContent:"liteflow支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nliteflow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，liteflow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到flowexecutor对象后，调用以下接口：\n\nflowexecutor.reloadrule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nflowbus.refreshflowmetadata(flowparsertypeenum.type_el_xml, newcontent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml，这里注意下，在el规则表达式下，都是type_el_xxx的形式，不带el的那是旧的形式，请不要用错！\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍡步骤信息",frontmatter:{title:"🍡步骤信息",date:"2022-07-03T11:09:40.000Z",permalink:"/pages/v2.8.X/e5ed0d/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/120.%E6%AD%A5%E9%AA%A4%E4%BF%A1%E6%81%AF.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/120.步骤信息.md",key:"v-513deda9",path:"/pages/v2.8.X/e5ed0d/",headersStr:null,content:'LiteFlow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过LiteflowResponse对象来获取的：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", "初始参数", CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nQueue<CmpStep> stepQueue = response.getExecuteStepQueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得Map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的Map中这个组件id的value是最终的那个步骤信息。\n\n而获得Queue<CmpStep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在CmpStep这个对象里，你可以通过以下方法获得你要的数据：\n\n * isSuccess：此组件是否执行成功\n * getNodeId：获得组件Id\n * getNodeName：获得组件名称\n * getTag：获得组件标签值\n * getTimeSpent：获得组件的耗时，单位为毫秒\n * getException：获取此组件抛出的异常，如果isSuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getCause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',normalizedContent:'liteflow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过liteflowresponse对象来获取的：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", "初始参数", customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n//或者你也可以通过以下的语句来获得一个步骤队列\nqueue<cmpstep> stepqueue = response.getexecutestepqueue();\n\n\n以上这2个方法的区别是：\n\n提示\n\n获得map返回值的那个方法，如果有多个相同的组件，那么以上这个方法获得的map中这个组件id的value是最终的那个步骤信息。\n\n而获得queue<cmpstep>这个返回值的方法，返回值里包含了所有的步骤信息，相同的组件在规则里定义n次，那么这里也有n个步骤。\n\n在cmpstep这个对象里，你可以通过以下方法获得你要的数据：\n\n * issuccess：此组件是否执行成功\n * getnodeid：获得组件id\n * getnodename：获得组件名称\n * gettag：获得组件标签值\n * gettimespent：获得组件的耗时，单位为毫秒\n * getexception：获取此组件抛出的异常，如果issuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getcause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍪组件切面",frontmatter:{title:"🍪组件切面",date:"2022-07-03T11:07:26.000Z",permalink:"/pages/v2.8.X/2373f5/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/110.%E7%BB%84%E4%BB%B6%E5%88%87%E9%9D%A2.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/110.组件切面.md",key:"v-073ce570",path:"/pages/v2.8.X/2373f5/",headers:[{level:2,title:"全局切面",slug:"全局切面",normalizedTitle:"全局切面",charIndex:47},{level:2,title:"Aspect的切面",slug:"aspect的切面",normalizedTitle:"aspect的切面",charIndex:509}],headersStr:"全局切面 Aspect的切面",content:'LiteFlow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(String nodeId, Slot slot) {\n        YourContextBean context = slot.getContextBean(YourContextBean.class);\n        //before business\n    }\n\n    @Override\n    public void afterProcess(String nodeId, Slot slot) {\n        YourContextBean context = slot.getContextBean(YourContextBean.class);\n        //after business\n    }\n}\n\n\n\n# Aspect的切面\n\nLiteFlow同时也支持了Spring Aspect的切面，你可以用@Aspect标注对任意包，任意规则内的组件进行切面\n\n@Aspect\npublic class CustomAspect {\n\n    @Pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @Around("cut()")\n    public Object around(ProceedingJoinPoint jp) throws Throwable {\n        //do before business\n        Object returnObj = jp.proceed();\n        //do after business\n        return returnObj;\n    }\n}\n',normalizedContent:'liteflow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(string nodeid, slot slot) {\n        yourcontextbean context = slot.getcontextbean(yourcontextbean.class);\n        //before business\n    }\n\n    @override\n    public void afterprocess(string nodeid, slot slot) {\n        yourcontextbean context = slot.getcontextbean(yourcontextbean.class);\n        //after business\n    }\n}\n\n\n\n# aspect的切面\n\nliteflow同时也支持了spring aspect的切面，你可以用@aspect标注对任意包，任意规则内的组件进行切面\n\n@aspect\npublic class customaspect {\n\n    @pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @around("cut()")\n    public object around(proceedingjoinpoint jp) throws throwable {\n        //do before business\n        object returnobj = jp.proceed();\n        //do after business\n        return returnobj;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧊异常",frontmatter:{title:"🧊异常",date:"2022-07-26T23:38:00.000Z",permalink:"/pages/v2.8.X/dc9bfe/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/125.%E5%BC%82%E5%B8%B8.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/125.异常.md",key:"v-4d06295c",path:"/pages/v2.8.X/dc9bfe/",headersStr:null,content:'通常在LiteFlow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreError关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进LiteflowResponse对象中。\n\n你可以在LiteflowResponse对象中通过以下方法来获取异常\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n如果你的业务中有获取异常Code的需求，则你自定义的异常需要实现LiteFlow提供的LiteFlowException接口：\n\npublic class YourException extends LiteFlowException {\n\tpublic YourException(String code, String message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了LiteFlowException接口的异常，你则可以在LiteflowResponse中获得message和code信息：\n\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", 初始参数, CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n  String code = response.getCode();\n  String message = response.getMessage();\n}\n\n\n提示\n\n如果你的异常没实现LiteFlowException，code和message字段都为null。',normalizedContent:'通常在liteflow组件里如果往外抛出异常，流程会中断。除了在并行编排中设置ignoreerror关键字以外。\n\n往外抛出的异常会被最外层的执行器捕获，并被包装进liteflowresponse对象中。\n\n你可以在liteflowresponse对象中通过以下方法来获取异常\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n如果你的业务中有获取异常code的需求，则你自定义的异常需要实现liteflow提供的liteflowexception接口：\n\npublic class yourexception extends liteflowexception {\n\tpublic yourexception(string code, string message) {\n\t\tsuper(code, message);\n\t}\n}\n\n\n如果你的业务抛出了实现了liteflowexception接口的异常，你则可以在liteflowresponse中获得message和code信息：\n\nliteflowresponse response = flowexecutor.execute2resp("chain1", 初始参数, customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n  string code = response.getcode();\n  string message = response.getmessage();\n}\n\n\n提示\n\n如果你的异常没实现liteflowexception，code和message字段都为null。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🌭不同格式规则加载",frontmatter:{title:"🌭不同格式规则加载",date:"2022-07-03T11:20:47.000Z",permalink:"/pages/v2.8.X/a7e02e/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/150.%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99%E5%8A%A0%E8%BD%BD.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/150.不同格式规则加载.md",key:"v-5df2031a",path:"/pages/v2.8.X/a7e02e/",headersStr:null,content:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipleType/flow.el.xml,multipleType/flow.el.json\n\n\n这种模式在正常下会解析失败，但是LiteFLow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",normalizedContent:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipletype/flow.el.xml,multipletype/flow.el.json\n\n\n这种模式在正常下会解析失败，但是liteflow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧇打印信息详解",frontmatter:{title:"🧇打印信息详解",date:"2022-07-03T11:12:19.000Z",permalink:"/pages/v2.8.X/4d614c/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/130.%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/130.打印信息详解.md",key:"v-003fb755",path:"/pages/v2.8.X/4d614c/",headers:[{level:2,title:"流程执行中打印",slug:"流程执行中打印",normalizedTitle:"流程执行中打印",charIndex:2},{level:2,title:"打印步骤信息",slug:"打印步骤信息",normalizedTitle:"打印步骤信息",charIndex:558}],headersStr:"流程执行中打印 打印步骤信息",content:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[ACmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[BCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[X]start component[CCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[DCmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求ID，一个请求无论经历了多少个组件，他们的请求ID都是一致的，你可以根据这个ID在日志中进行快速定位进行排查。\n\n在后面会跟着一个[O]或者[X]，[O]代表了执行了这个组件的主要逻辑，[X]代表因为isAccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，LiteFlow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件ID<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件A]<100>==>b[组件B]<0>==>m[组件M]<256>\n\n\n这里的表达形式为：组件ID[组件别名]<耗时毫秒>",normalizedContent:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[acmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[bcmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[x]start component[ccmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[dcmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求id，一个请求无论经历了多少个组件，他们的请求id都是一致的，你可以根据这个id在日志中进行快速定位进行排查。\n\n在后面会跟着一个[o]或者[x]，[o]代表了执行了这个组件的主要逻辑，[x]代表因为isaccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，liteflow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件id<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件a]<100>==>b[组件b]<0>==>m[组件m]<256>\n\n\n这里的表达形式为：组件id[组件别名]<耗时毫秒>",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍿自定义组件执行器",frontmatter:{title:"🍿自定义组件执行器",date:"2022-07-03T11:24:54.000Z",permalink:"/pages/v2.8.X/46bbed/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/170.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/170.自定义组件执行器.md",key:"v-fa6898ec",path:"/pages/v2.8.X/46bbed/",headers:[{level:2,title:"全局组件执行器",slug:"全局组件执行器",normalizedTitle:"全局组件执行器",charIndex:130},{level:2,title:"单个组件配置特殊的执行器",slug:"单个组件配置特殊的执行器",normalizedTitle:"单个组件配置特殊的执行器",charIndex:757},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1149},{level:2,title:"自定义执行器对于重试功能的影响",slug:"自定义执行器对于重试功能的影响",normalizedTitle:"自定义执行器对于重试功能的影响",charIndex:1198}],headersStr:"全局组件执行器 单个组件配置特殊的执行器 优先级 自定义执行器对于重试功能的影响",content:'LiteFlow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.entity.executor.DefaultNodeExecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeExecutor.CustomerDefaultNodeExecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.NodeExecutor。\n\npublic class CustomerDefaultNodeExecutor extends NodeExecutor {\n    @Override\n    public void execute(NodeComponent instance) throws Exception {\n        LOG.info("使用customerDefaultNodeExecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getNodeExecutorClass 方法：\n\n@LiteflowComponent("d")\npublic class DCmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        System.out.println("DCmp executed!");\n    }\n\n    @Override\n    public Class<? extends NodeExecutor> getNodeExecutorClass() {\n        return CustomerNodeExecutorAndCustomRetry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@LiteflowRetry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',normalizedContent:'liteflow允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.entity.executor.defaultnodeexecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeexecutor.customerdefaultnodeexecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.nodeexecutor。\n\npublic class customerdefaultnodeexecutor extends nodeexecutor {\n    @override\n    public void execute(nodecomponent instance) throws exception {\n        log.info("使用customerdefaultnodeexecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getnodeexecutorclass 方法：\n\n@liteflowcomponent("d")\npublic class dcmp extends nodecomponent {\n\n    @override\n    public void process() {\n        system.out.println("dcmp executed!");\n    }\n\n    @override\n    public class<? extends nodeexecutor> getnodeexecutorclass() {\n        return customernodeexecutorandcustomretry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@liteflowretry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🧁自定义请求Id",frontmatter:{title:"🧁自定义请求Id",date:"2022-07-03T11:12:53.000Z",permalink:"/pages/v2.8.X/47e8f5/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/140.%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82Id.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/140.自定义请求Id.md",key:"v-1033fec4",path:"/pages/v2.8.X/47e8f5/",headersStr:null,content:"LiteFlow支持让你自定义你的请求Id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[a] execution\n2022-07-03 11:15:00.204  INFO 71275 --- [           main] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[b] execution\n2022-07-03 11:15:00.218  INFO 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[c] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.Node   : [067a0baa6d434de3a8ccafa4b1506562]:[O]start component[d] execution\n2022-07-03 11:15:00.220  INFO 71275 --- [           main] com.yomahub.liteflow.slot.Slot           : [067a0baa6d434de3a8ccafa4b1506562]:CHAIN_NAME[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  INFO 71275 --- [           main] com.yomahub.liteflow.slot.DataBus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是RequestId，一个请求中的requestId都是相同的，方便你进行日志查找。\n\n这个requestId的形式也是可以自定义的。\n\n你只需要要声明一个类，然后实现RequestIdGenerator接口即可：\n\npublic class CustomRequestIdGenerator implements RequestIdGenerator {\n\n    @Override\n    public String generate() {\n        return System.nanoTime();\n    }\n}\n\n\n然后在LiteFlow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestId.config.CustomRequestIdGenerator\n\n\n一般情况下，LiteFlow有自己默认的Id生成规则。所以大多数情况下你并不需要去特别自定义这个Id生成器。",normalizedContent:"liteflow支持让你自定义你的请求id。\n\n大家在执行一条流程的时候，往往可以在日志信息中看到以下类似的信息：\n\n2022-07-03 11:15:00.196  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[a] execution\n2022-07-03 11:15:00.204  info 71275 --- [           main] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[b] execution\n2022-07-03 11:15:00.218  info 71275 --- [lf-when-thead-0] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[c] execution\n2022-07-03 11:15:00.220  info 71275 --- [lf-when-thead-1] com.yomahub.liteflow.flow.element.node   : [067a0baa6d434de3a8ccafa4b1506562]:[o]start component[d] execution\n2022-07-03 11:15:00.220  info 71275 --- [           main] com.yomahub.liteflow.slot.slot           : [067a0baa6d434de3a8ccafa4b1506562]:chain_name[chain1]\na<1>==>b<0>==>c<0>==>d<0>\n2022-07-03 11:15:00.221  info 71275 --- [           main] com.yomahub.liteflow.slot.databus        : [067a0baa6d434de3a8ccafa4b1506562]:slot[0] released\n\n\n其中日志主体中最前面的就是requestid，一个请求中的requestid都是相同的，方便你进行日志查找。\n\n这个requestid的形式也是可以自定义的。\n\n你只需要要声明一个类，然后实现requestidgenerator接口即可：\n\npublic class customrequestidgenerator implements requestidgenerator {\n\n    @override\n    public string generate() {\n        return system.nanotime();\n    }\n}\n\n\n然后在liteflow的配置文件里声明下你这个类即可：\n\nliteflow.request-id-generator-class=com.yomahub.liteflow.test.requestid.config.customrequestidgenerator\n\n\n一般情况下，liteflow有自己默认的id生成规则。所以大多数情况下你并不需要去特别自定义这个id生成器。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🍥简单监控",frontmatter:{title:"🍥简单监控",date:"2022-07-03T11:25:52.000Z",permalink:"/pages/v2.8.X/e59f3a/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/180.%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/180.简单监控.md",key:"v-f71c780a",path:"/pages/v2.8.X/e59f3a/",headersStr:null,content:"LiteFlow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",normalizedContent:"liteflow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🥗异步线程池自定义",frontmatter:{title:"🥗异步线程池自定义",date:"2022-07-03T11:21:39.000Z",permalink:"/pages/v2.8.X/7280ea/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/100.%F0%9F%8E%A8%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/160.%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%87%AA%E5%AE%9A%E4%B9%89.html",relativePath:"15.v2.8.X文档/100.🎨高级特性/160.异步线程池自定义.md",key:"v-121f0e7c",path:"/pages/v2.8.X/7280ea/",headers:[{level:2,title:"默认全局线程池",slug:"默认全局线程池",normalizedTitle:"默认全局线程池",charIndex:2},{level:2,title:"自定义全局线程池",slug:"自定义全局线程池",normalizedTitle:"自定义全局线程池",charIndex:157},{level:2,title:"WHEN级别的单独线程池",slug:"when级别的单独线程池",normalizedTitle:"when级别的单独线程池",charIndex:1136},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1942}],headersStr:"默认全局线程池 自定义全局线程池 WHEN级别的单独线程池 优先级",content:'# 默认全局线程池\n\nLiteFlow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，LiteFlow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的Builder：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n\n\n然后把你的Builder加入LiteFlow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadExecutor\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n\t<property name="ruleSource" value="customThreadPool/flow.el.xml"/>\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.test.customThreadPool.CustomThreadExecutor"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n  <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n这样，LiteFlow在启动的时候就会自动通过你声明的Builder加载到自定义的线程池了。\n\n\n# WHEN级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    WHEN(a, b);\n</chain>\n\n<chain name="chain2">\n    WHEN(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class CustomThreadExecutor1 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class CustomThreadExecutor2 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    WHEN(a, b).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor1");\n</chain>\n<chain name="chain2">\n    WHEN(c, d).threadPool("com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和Condition都配置自定义线程池的情况下，优先使用Condition上配置的线程池。',normalizedContent:'# 默认全局线程池\n\nliteflow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，liteflow也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的builder：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n\n\n然后把你的builder加入liteflow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadexecutor\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n\t<property name="rulesource" value="customthreadpool/flow.el.xml"/>\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.test.customthreadpool.customthreadexecutor"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n  <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n这样，liteflow在启动的时候就会自动通过你声明的builder加载到自定义的线程池了。\n\n\n# when级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n    when(a, b);\n</chain>\n\n<chain name="chain2">\n    when(c, d);\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class customthreadexecutor1 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class customthreadexecutor2 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n    when(a, b).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor1");\n</chain>\n<chain name="chain2">\n    when(c, d).threadpool("com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor2");\n</chain>\n\n\n\n# 优先级\n\n如果全局和condition都配置自定义线程池的情况下，优先使用condition上配置的线程池。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪁测试用例",frontmatter:{title:"🪁测试用例",date:"2022-07-03T11:28:26.000Z",permalink:"/pages/v2.8.X/81cdce/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/010.%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",relativePath:"15.v2.8.X文档/110.⛱测试用例以及示例/010.测试用例.md",key:"v-df54096c",path:"/pages/v2.8.X/81cdce/",headersStr:null,content:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有860多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解LiteFlow的同学可以去看看测试用例来学会如何在细节点上的配置和使用。在新版本上你只需看EL规则表达式就可以了。\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例(基于EL规则表达式)\n\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例(基于EL规则表达式)\n\n * liteflow-testcase-el-nospring: 非spring体系的测试用例(基于EL规则表达式)\n\n * liteflow-testcase-el-declare-component: 声明式组件场景下的测试用例(基于EL规则表达式)\n\n * liteflow-testcase-el-script-qlexpress: 基于QLExpress脚本框架的测试用例(基于EL规则表达式)\n\n * liteflow-testcase-el-script-groovy: 基于Groovy脚本框架的测试用例(基于EL规则表达式)\n\n * liteflow-testcase-springboot: springboot环境下的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-springnative: spring原生环境下的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-nospring: 非spring体系的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-declare-component: 声明式组件场景下的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-script-qlexpress: 基于QLExpress脚本框架的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-script-groovy: 基于Groovy脚本框架的测试用例(基于旧的规则表达式)",normalizedContent:"项目提供了丰富的测试用例，截止到目前版本，项目内一共有860多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解liteflow的同学可以去看看测试用例来学会如何在细节点上的配置和使用。在新版本上你只需看el规则表达式就可以了。\n\n * liteflow-testcase-el-springboot: springboot环境下的测试用例(基于el规则表达式)\n\n * liteflow-testcase-el-springnative: spring原生环境下的测试用例(基于el规则表达式)\n\n * liteflow-testcase-el-nospring: 非spring体系的测试用例(基于el规则表达式)\n\n * liteflow-testcase-el-declare-component: 声明式组件场景下的测试用例(基于el规则表达式)\n\n * liteflow-testcase-el-script-qlexpress: 基于qlexpress脚本框架的测试用例(基于el规则表达式)\n\n * liteflow-testcase-el-script-groovy: 基于groovy脚本框架的测试用例(基于el规则表达式)\n\n * liteflow-testcase-springboot: springboot环境下的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-springnative: spring原生环境下的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-nospring: 非spring体系的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-declare-component: 声明式组件场景下的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-script-qlexpress: 基于qlexpress脚本框架的测试用例(基于旧的规则表达式)\n\n * liteflow-testcase-script-groovy: 基于groovy脚本框架的测试用例(基于旧的规则表达式)",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"2.12.0升级指南",frontmatter:{title:"2.12.0升级指南",date:"2024-04-14T12:43:18.000Z",permalink:"/pages/88c2f2/"},regularPath:"/2.12.0%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97.html",relativePath:"2.12.0升级指南.md",key:"v-7537d280",path:"/pages/88c2f2/",headersStr:null,content:'v2.12.0并不是向下兼容的版本。需要使用者改一些东西，但是这不会花费使用者太多的时间。\n\nv2.12.0最大的不兼容点在于去除了NodeWhileComponent，NodeIfComponent，NodeBreakComponent三个组件，全部合并成为了布尔组件，即NodeBooleanComponent。\n\n也就是说，使用者涉及到的这三个组件，都需要把超类换成NodeBooleanComponent。\n\n既然是合三为一了，那现在你定义一个布尔组件：\n\n@LiteflowComponent("x")\npublic class ECmp extends NodeBooleanComponent {\n    @Override\n    public boolean processBoolean() throws Exception {\n        // do your biz\n        return true;\n    }\n}\n\n\n这个组件可以用在IF，WHILE，BREAK中了\n\n<chain id="chain1">\n    IF(x, a, b);\n</chain>\n\n<chain id="chain2">\n    WHILE(x).DO(THEN(a,b));\n</chain>\n\n<chain id="chain3">\n    FOR(f).DO(THEN(a,b)).BREAK(x);\n</chain>\n\n\n\n\n\n\n如果你用了声明式组件，那么相应的@LiteflowMethod标注里的一些枚举都需要改变：\n\n类声明式：\n\n@LiteflowComponent("a")\npublic class DeclECmp{\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BOOLEAN, nodeType = NodeTypeEnum.BOOLEAN)\n    public boolean yourMethodName(NodeComponent bindCmp) throws Exception {\n        //do your biz\n    }\n}\n\n\n方法级别声明式：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    ...\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BOOLEAN, nodeId = "a", nodeType = NodeTypeEnum.BOOLEAN)\n    public boolean yourMethodName1(NodeComponent bindCmp) throws Exception {\n        //do your biz\n    }\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BOOLEAN, nodeId = "b", nodeType = NodeTypeEnum.BOOLEAN)\n    public boolean yourMethodName2(NodeComponent bindCmp) throws Exception {\n        //do your biz\n    }\n    \n    ...\n}\n\n\n\n\n\n\n如果你用了脚本组件，那么相应的script中的type类型也要改：\n\n<flow>\n    <nodes>\n        <node id="s1" type="boolean_script" language="groovy">\n            <![CDATA[\n                // do your biz\n            ]]>\n        </node>\n\n    </nodes>\n\n    <chain id="chain1">\n        THEN(a, b, s1);\n    </chain>\n\n    \n</flow>\n\n\n提示\n\n如果你把脚本存在存储器中，比如db，etcd中，那么相应的type都需要变更。\n\n值得注意的是，zk，etcd，apollo，redis这种存储插件中由于type是写在节点的key中的，所以type的变动，意味着key的变动。大家在升级时，如果符合这种情况的，千万不要忘掉这点。\n\n\n\n\n\n全局参数中去除了parse-on-start这个参数，这个参数现在被parse-mode给取代了。\n\n这个parse-mode一共有三种值：\n\n设置值                       含义\nPARSE_ALL_ON_START        启动时解析所有的规则，不配置默认就是这个值\nPARSE_ALL_ON_FIRST_EXEC   启动时不解析规则，但是第一次执行任意规则时，解析所有的\nPARSE_ONE_ON_FIRST_EXEC   启动时不解析规则，但是第一次执行相关规则时，只解析对应的规则\n\n原先的parse-on-start=true就相当于parse-mode=PARSE_ALL_ON_FIRST_EXEC，新版其实推荐用PARSE_ONE_ON_FIRST_EXEC。\n\n关于这部分的详细解释，请看官网文档中的元数据管理 -> 启动不检查规则。\n\n\n\n\n\n如果你使用了链路继承特性，那么原先的占位符是单花括弧{x}，现在变成了双花括弧{{x}}，此改动目的是为了和开发者自有的占位符不冲突。\n\n具体使用方式可以参考官网文档中的高级特性 -> 链路继承。',normalizedContent:'v2.12.0并不是向下兼容的版本。需要使用者改一些东西，但是这不会花费使用者太多的时间。\n\nv2.12.0最大的不兼容点在于去除了nodewhilecomponent，nodeifcomponent，nodebreakcomponent三个组件，全部合并成为了布尔组件，即nodebooleancomponent。\n\n也就是说，使用者涉及到的这三个组件，都需要把超类换成nodebooleancomponent。\n\n既然是合三为一了，那现在你定义一个布尔组件：\n\n@liteflowcomponent("x")\npublic class ecmp extends nodebooleancomponent {\n    @override\n    public boolean processboolean() throws exception {\n        // do your biz\n        return true;\n    }\n}\n\n\n这个组件可以用在if，while，break中了\n\n<chain id="chain1">\n    if(x, a, b);\n</chain>\n\n<chain id="chain2">\n    while(x).do(then(a,b));\n</chain>\n\n<chain id="chain3">\n    for(f).do(then(a,b)).break(x);\n</chain>\n\n\n\n\n\n\n如果你用了声明式组件，那么相应的@liteflowmethod标注里的一些枚举都需要改变：\n\n类声明式：\n\n@liteflowcomponent("a")\npublic class declecmp{\n\n    @liteflowmethod(value = liteflowmethodenum.process_boolean, nodetype = nodetypeenum.boolean)\n    public boolean yourmethodname(nodecomponent bindcmp) throws exception {\n        //do your biz\n    }\n}\n\n\n方法级别声明式：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    ...\n\n    @liteflowmethod(value = liteflowmethodenum.process_boolean, nodeid = "a", nodetype = nodetypeenum.boolean)\n    public boolean yourmethodname1(nodecomponent bindcmp) throws exception {\n        //do your biz\n    }\n\n    @liteflowmethod(value = liteflowmethodenum.process_boolean, nodeid = "b", nodetype = nodetypeenum.boolean)\n    public boolean yourmethodname2(nodecomponent bindcmp) throws exception {\n        //do your biz\n    }\n    \n    ...\n}\n\n\n\n\n\n\n如果你用了脚本组件，那么相应的script中的type类型也要改：\n\n<flow>\n    <nodes>\n        <node id="s1" type="boolean_script" language="groovy">\n            <![cdata[\n                // do your biz\n            ]]>\n        </node>\n\n    </nodes>\n\n    <chain id="chain1">\n        then(a, b, s1);\n    </chain>\n\n    \n</flow>\n\n\n提示\n\n如果你把脚本存在存储器中，比如db，etcd中，那么相应的type都需要变更。\n\n值得注意的是，zk，etcd，apollo，redis这种存储插件中由于type是写在节点的key中的，所以type的变动，意味着key的变动。大家在升级时，如果符合这种情况的，千万不要忘掉这点。\n\n\n\n\n\n全局参数中去除了parse-on-start这个参数，这个参数现在被parse-mode给取代了。\n\n这个parse-mode一共有三种值：\n\n设置值                       含义\nparse_all_on_start        启动时解析所有的规则，不配置默认就是这个值\nparse_all_on_first_exec   启动时不解析规则，但是第一次执行任意规则时，解析所有的\nparse_one_on_first_exec   启动时不解析规则，但是第一次执行相关规则时，只解析对应的规则\n\n原先的parse-on-start=true就相当于parse-mode=parse_all_on_first_exec，新版其实推荐用parse_one_on_first_exec。\n\n关于这部分的详细解释，请看官网文档中的元数据管理 -> 启动不检查规则。\n\n\n\n\n\n如果你使用了链路继承特性，那么原先的占位符是单花括弧{x}，现在变成了双花括弧{{x}}，此改动目的是为了和开发者自有的占位符不冲突。\n\n具体使用方式可以参考官网文档中的高级特性 -> 链路继承。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"2.12.4升级指南",frontmatter:{title:"2.12.4升级指南",date:"2024-10-13T23:53:00.000Z",permalink:"/pages/88c2f1/"},regularPath:"/2.12.4%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97.html",relativePath:"2.12.4升级指南.md",key:"v-d0b41b10",path:"/pages/88c2f1/",headersStr:null,content:"如果你从2.12.X升级到2.12.4，那是非常平滑的。2.12.4是一个向下兼容的版本。\n\n之所以要写这个升级指南。是因为在2.12.4中增加了Javax脚本，此脚本虽说是原来Java脚本的升级，但是并未覆盖原来的插件，而是独立创建了一个脚本插件。\n\n开发者如果想把Java插件升级成Javax插件，只需要变更脚本中的接口类即可。详情可以查看：Java脚本引擎。",normalizedContent:"如果你从2.12.x升级到2.12.4，那是非常平滑的。2.12.4是一个向下兼容的版本。\n\n之所以要写这个升级指南。是因为在2.12.4中增加了javax脚本，此脚本虽说是原来java脚本的升级，但是并未覆盖原来的插件，而是独立创建了一个脚本插件。\n\n开发者如果想把java插件升级成javax插件，只需要变更脚本中的接口类即可。详情可以查看：java脚本引擎。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪀DEMO案例",frontmatter:{title:"🪀DEMO案例",date:"2022-07-03T11:32:24.000Z",permalink:"/pages/v2.8.X/0a8188/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/110.%E2%9B%B1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%BB%A5%E5%8F%8A%E7%A4%BA%E4%BE%8B/020.DEMO%E6%A1%88%E4%BE%8B.html",relativePath:"15.v2.8.X文档/110.⛱测试用例以及示例/020.DEMO案例.md",key:"v-6e38463e",path:"/pages/v2.8.X/0a8188/",headersStr:null,content:"如果你想看一个实际的案例，加深对LiteFlow的理解。可以查看：\n\n> DEMO案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的Java业务！\n\n> DEMO案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n",normalizedContent:"如果你想看一个实际的案例，加深对liteflow的理解。可以查看：\n\n> demo案例1\n\n这个案例为一个短信系统选取供应商的案例。相关配套文章链接如下：\n\n> 写出个灵活的系统竟然可以如此简单！小白也能写出高级的java业务！\n\n> demo案例2\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算。\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"🪂性能表现",frontmatter:{title:"🪂性能表现",date:"2022-07-03T11:32:51.000Z",permalink:"/pages/v2.8.X/9bf839/"},regularPath:"/15.v2.8.X%E6%96%87%E6%A1%A3/120.%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0.html",relativePath:"15.v2.8.X文档/120.性能表现.md",key:"v-28e6e97a",path:"/pages/v2.8.X/9bf839/",headersStr:null,content:"LiteFlow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，LiteFlow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的TPS，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然LiteFlow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求IO，或者有bad sql，又或者有大量的rpc同步调用。那实际TPS也不会很高。但是这是业务组件的的问题，而不是LiteFlow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的TPS/QPS，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nLiteFlow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库IO。\n\n基于这个Demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",normalizedContent:"liteflow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，liteflow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的tps，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然liteflow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求io，或者有bad sql，又或者有大量的rpc同步调用。那实际tps也不会很高。但是这是业务组件的的问题，而不是liteflow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的tps/qps，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nliteflow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库io。\n\n基于这个demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，容器为springboot自带的tomcat，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"项目特性",frontmatter:{title:"项目特性",date:"2022-05-31T23:38:54.000Z",permalink:"/pages/v2.7.X/e0508d/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/020.%E9%A1%B9%E7%9B%AE%E7%89%B9%E6%80%A7.html",relativePath:"20.v2.7.X文档/020.项目特性.md",key:"v-b6cb569e",path:"/pages/v2.7.X/e0508d/",headersStr:null,content:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 同步异步混编，再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则能从任意地方加载： 框架中提供本地文件配置源和zk配置源的实现，也提供了扩展接口，您可以把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持QLExpress和Groovy两种脚本。未来还会支持更多的脚本语言。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",normalizedContent:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 同步异步混编，再复杂的逻辑过程，利用liteflow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则能从任意地方加载： 框架中提供本地文件配置源和zk配置源的实现，也提供了扩展接口，您可以把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持qlexpress和groovy两种脚本。未来还会支持更多的脚本语言。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行",frontmatter:{title:"执行",date:"2022-05-31T23:45:57.000Z",permalink:"/pages/v2.7.X/ad3883/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.Springboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/010.Springboot场景安装运行/030.执行.md",key:"v-dd9b6e5c",path:"/pages/v2.7.X/ad3883/",headersStr:null,content:'然后你就可以在任意的类中拿到flowExecutor，进行执行链路\n\n@Component\npublic class MainTest{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse<DefaultContext> response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看流程上下文这一章节。',normalizedContent:'然后你就可以在任意的类中拿到flowexecutor，进行执行链路\n\n@component\npublic class maintest{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse<defaultcontext> response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看流程上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"LiteFlow简介",frontmatter:{title:"LiteFlow简介",date:"2022-05-31T19:54:08.000Z",permalink:"/pages/v2.7.X/967466/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/010.LiteFlow%E7%AE%80%E4%BB%8B.html",relativePath:"20.v2.7.X文档/010.LiteFlow简介.md",key:"v-392abc59",path:"/pages/v2.7.X/967466/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"LiteFlow框架的作用",slug:"liteflow框架的作用",normalizedTitle:"liteflow框架的作用",charIndex:275},{level:2,title:"LiteFlow的设计原则",slug:"liteflow的设计原则",normalizedTitle:"liteflow的设计原则",charIndex:497},{level:2,title:"LiteFlow不适用于哪些场景",slug:"liteflow不适用于哪些场景",normalizedTitle:"liteflow不适用于哪些场景",charIndex:1087},{level:2,title:"LiteFlow适用于哪些场景",slug:"liteflow适用于哪些场景",normalizedTitle:"liteflow适用于哪些场景",charIndex:1261},{level:2,title:"LiteFlow相比于Flowable和Activiti",slug:"liteflow相比于flowable和activiti",normalizedTitle:"liteflow相比于flowable和activiti",charIndex:1429}],headersStr:"前言 LiteFlow框架的作用 LiteFlow的设计原则 LiteFlow不适用于哪些场景 LiteFlow适用于哪些场景 LiteFlow相比于Flowable和Activiti",content:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护的成本得就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n\n# LiteFlow框架的作用\n\nLiteFlow就是为解耦复杂逻辑而生，如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个轻量，快速的组件式流程引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。\n\n使用LiteFlow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，就能按照你的规则配置去进行复杂的流转。\n\n\n# LiteFlow的设计原则\n\nLiteFlow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。\n\n\n# LiteFlow不适用于哪些场景\n\nLiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。\n\n提示\n\n这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# LiteFlow适用于哪些场景\n\nLiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也也可以避免改一处而动全身的这样的风险。\n\n\n# LiteFlow相比于Flowable和Activiti\n\nFlowable和Activiti都是极为优秀的流程引擎框架，其中Flowable的底层也是Activiti，他们除了能做基于任务角色的流程，也能做基于逻辑的流程，并且他们的基于BPM协议，很多基于BPM协议的编辑工具都能为他们可视化编辑流程。\n\nLiteFlow和他们相比，虽然功能不如他们那么多，但是胜在轻量，高性能和极少学习成本上。而且这2款都是国外开源，集成起来比较重，而且文档本地化做的也不够好。LiteFlow拥有完善的本地化文档和使用范例。在大部分的场景可以帮助你改善你的系统。",normalizedContent:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统rpc调用等等。时间一长，项目几经易手，维护的成本得就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n\n# liteflow框架的作用\n\nliteflow就是为解耦复杂逻辑而生，如果你要对复杂业务逻辑进行新写或者重构，用liteflow最合适不过。它是一个轻量，快速的组件式流程引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。\n\n使用liteflow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，就能按照你的规则配置去进行复杂的流转。\n\n\n# liteflow的设计原则\n\nliteflow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到liteflow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以liteflow能做到统一解耦的组件和灵活的装配。\n\n\n# liteflow不适用于哪些场景\n\nliteflow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，a审批完应该是b审批，然后再流转到c角色。\n\n提示\n\n这里申明下，liteflow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# liteflow适用于哪些场景\n\nliteflow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用liteflow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也也可以避免改一处而动全身的这样的风险。\n\n\n# liteflow相比于flowable和activiti\n\nflowable和activiti都是极为优秀的流程引擎框架，其中flowable的底层也是activiti，他们除了能做基于任务角色的流程，也能做基于逻辑的流程，并且他们的基于bpm协议，很多基于bpm协议的编辑工具都能为他们可视化编辑流程。\n\nliteflow和他们相比，虽然功能不如他们那么多，但是胜在轻量，高性能和极少学习成本上。而且这2款都是国外开源，集成起来比较重，而且文档本地化做的也不够好。liteflow拥有完善的本地化文档和使用范例。在大部分的场景可以帮助你改善你的系统。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"依赖",frontmatter:{title:"依赖",date:"2022-05-31T23:52:51.000Z",permalink:"/pages/v2.7.X/fe8369/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.Springboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/010.Springboot场景安装运行/010.依赖.md",key:"v-3a9e92c8",path:"/pages/v2.7.X/fe8369/",headersStr:null,content:"LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n  <groupId>com.yomahub</groupId>\n  <artifactId>liteflow-spring-boot-starter</artifactId>\n  <version>2.7.3</version>\n</dependency>\n",normalizedContent:"liteflow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n  <groupid>com.yomahub</groupid>\n  <artifactid>liteflow-spring-boot-starter</artifactid>\n  <version>2.7.3</version>\n</dependency>\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置",frontmatter:{title:"配置",date:"2022-05-31T23:45:30.000Z",permalink:"/pages/v2.7.X/36c961/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/010.Springboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/010.Springboot场景安装运行/020.配置.md",key:"v-16d7e605",path:"/pages/v2.7.X/36c961/",headers:[{level:2,title:"组件的定义",slug:"组件的定义",normalizedTitle:"组件的定义",charIndex:2},{level:2,title:"SpringBoot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:211},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:375}],headersStr:"组件的定义 SpringBoot配置文件 规则文件的定义",content:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文。\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c,d,e组件。\n\n\n# SpringBoot配置文件\n\n然后，在你的SpringBoot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.xml中定义规则：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nSpringBoot在启动时会自动装载规则文件。',normalizedContent:'# 组件的定义\n\n在依赖了以上jar包后，你需要定义并实现一些组件，确保springboot会扫描到这些组件并注册进上下文。\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n以此类推再分别定义b,c,d,e组件。\n\n\n# springboot配置文件\n\n然后，在你的springboot的application.properties或者application.yml里添加配置(这里以properties为例，yaml也是一样的)\n\n更多配置项请参考配置项章节。\n\nliteflow.rule-source=config/flow.xml\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.xml中定义规则：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nspringboot在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置",frontmatter:{title:"配置",date:"2022-06-01T00:12:52.000Z",permalink:"/pages/v2.7.X/ecc62a/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/020.Spring场景安装运行/020.配置.md",key:"v-04a8ea25",path:"/pages/v2.7.X/ecc62a/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"Spring xml中的配置",slug:"spring-xml中的配置",normalizedTitle:"spring xml中的配置",charIndex:210},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:903}],headersStr:"定义你的组件 Spring xml中的配置 规则文件的定义",content:'# 定义你的组件\n\n你需要定义并实现一些组件，确保Spring会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c,d,e组件。\n\n\n# Spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springAware" class="com.yomahub.liteflow.util.SpringAware"/>\n\n<bean class="com.yomahub.liteflow.spring.ComponentScaner"/>\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.xml"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\x3c!-- 如果上述enableLog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.MonitorBus">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.xml中如下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nSpring在启动时会自动装载规则文件。',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件，确保spring会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c,d,e组件。\n\n\n# spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springaware" class="com.yomahub.liteflow.util.springaware"/>\n\n<bean class="com.yomahub.liteflow.spring.componentscaner"/>\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.xml"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\x3c!-- 如果上述enablelog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.monitorbus">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n更多配置项请参考配置项章节。\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.xml中如下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nspring在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"依赖",frontmatter:{title:"依赖",date:"2022-06-01T00:12:34.000Z",permalink:"/pages/v2.7.X/314fee/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/020.Spring场景安装运行/010.依赖.md",key:"v-b5fc8b30",path:"/pages/v2.7.X/314fee/",headersStr:null,content:"针对于使用了Spring但没有使用SpringBoot的项目\n\n<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring</artifactId>\n\t<version>2.7.3</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"针对于使用了spring但没有使用springboot的项目\n\n<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring</artifactid>\n\t<version>2.7.3</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行",frontmatter:{title:"执行",date:"2022-06-01T00:13:07.000Z",permalink:"/pages/v2.7.X/646cb4/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/020.Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/020.Spring场景安装运行/030.执行.md",key:"v-7f0c511c",path:"/pages/v2.7.X/646cb4/",headersStr:null,content:'和SpringBoot的执行方式一样，没有任何区别\n\n@Component\npublic class MainTest{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse<DefaultContext> response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看流程上下文这一章节。',normalizedContent:'和springboot的执行方式一样，没有任何区别\n\n@component\npublic class maintest{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse<defaultcontext> response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看流程上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"说明",frontmatter:{title:"说明",date:"2022-06-01T00:14:46.000Z",permalink:"/pages/v2.7.X/c5d947/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E8%AF%B4%E6%98%8E.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/010.说明.md",key:"v-64da3635",path:"/pages/v2.7.X/c5d947/",headersStr:null,content:"LiteFlow在2.6.11版本中对模块进行了彻底的拆分，重新开始支持了非spring的场景。\n\n虽说Springboot/Spring已经成为了Java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合Spring我始终觉得是瑕疵，有点代码洁癖），现在在非Spring体系的环境中也能使用LiteFlow框架带来的便捷和高效。\n\nLiteFlow文档中提到的98%以上的特性功能都能在非Spring体系中生效。其中不生效的特性和功能有：\n\n * ruleSource的模糊路径匹配特性在非Spring体系下不生效\n * LiteflowComponent在非Spring体系下无法使用\n * 监控功能在非Spring体系中无法使用",normalizedContent:"liteflow在2.6.11版本中对模块进行了彻底的拆分，重新开始支持了非spring的场景。\n\n虽说springboot/spring已经成为了java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合spring我始终觉得是瑕疵，有点代码洁癖），现在在非spring体系的环境中也能使用liteflow框架带来的便捷和高效。\n\nliteflow文档中提到的98%以上的特性功能都能在非spring体系中生效。其中不生效的特性和功能有：\n\n * rulesource的模糊路径匹配特性在非spring体系下不生效\n * liteflowcomponent在非spring体系下无法使用\n * 监控功能在非spring体系中无法使用",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置",frontmatter:{title:"配置",date:"2022-06-01T00:15:35.000Z",permalink:"/pages/v2.7.X/2c4a45/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E9%85%8D%E7%BD%AE.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/030.配置.md",key:"v-5e9bd66a",path:"/pages/v2.7.X/2c4a45/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"规则文件的配置",slug:"规则文件的配置",normalizedTitle:"规则文件的配置",charIndex:171}],headersStr:"定义你的组件 规则文件的配置",content:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c,d,e组件。\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.AComponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.BComponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.CComponent"/>\n\t\t<node id="d" class="com.yomahub.liteflow.test.component.DComponent"/>\n\t\t<node id="e" class="com.yomahub.liteflow.test.component.EComponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\t<then value="a,b,c"/> \x3c!-- then表示串行 --\x3e\n\t\t<when value="d,e"/> \x3c!-- when表示并行 --\x3e\n\t</chain>\n</flow>\n',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件。\n\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n以此类推再分别定义b,c,d,e组件。\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.acomponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.bcomponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.ccomponent"/>\n\t\t<node id="d" class="com.yomahub.liteflow.test.component.dcomponent"/>\n\t\t<node id="e" class="com.yomahub.liteflow.test.component.ecomponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\t<then value="a,b,c"/> \x3c!-- then表示串行 --\x3e\n\t\t<when value="d,e"/> \x3c!-- when表示并行 --\x3e\n\t</chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"依赖",frontmatter:{title:"依赖",date:"2022-06-01T00:15:10.000Z",permalink:"/pages/v2.7.X/83cb46/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E4%BE%9D%E8%B5%96.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/020.依赖.md",key:"v-62977c2d",path:"/pages/v2.7.X/83cb46/",headersStr:null,content:"<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-core</artifactId>\n\t<version>2.7.3</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-core</artifactid>\n\t<version>2.7.3</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行",frontmatter:{title:"执行",date:"2022-06-01T00:15:56.000Z",permalink:"/pages/v2.7.X/ac3dc2/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/030.%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B(Hello%20world)/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/040.%E6%89%A7%E8%A1%8C.html",relativePath:"20.v2.7.X文档/030.快速开始(Hello world)/030.其他场景安装运行/040.执行.md",key:"v-3144e437",path:"/pages/v2.7.X/ac3dc2/",headers:[{level:2,title:"初始化你的FlowExecutor执行器",slug:"初始化你的flowexecutor执行器",normalizedTitle:"初始化你的flowexecutor执行器",charIndex:2},{level:2,title:"用FlowExecutor执行",slug:"用flowexecutor执行",normalizedTitle:"用flowexecutor执行",charIndex:326}],headersStr:"初始化你的FlowExecutor执行器 用FlowExecutor执行",content:'# 初始化你的FlowExecutor执行器\n\n通过以下代码你可以轻易的初始化FlowExecutor处理器：\n\nLiteflowConfig config = new LiteflowConfig();\nconfig.setRuleSource("base/flow.xml");\nFlowExecutor flowExecutor = FlowExecutorHolder.loadInstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化FlowExecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用FlowExecutor执行\n\nLiteflowResponse<DefaultContext> response = flowExecutor.execute2Resp("chain1", "arg");\n\n\n提示\n\n这个DefaultContext是默认的上下文，用户可以用最自己的任意Bean当做上下文传入，如果需要传入自己的上下文，则需要传用户Bean的Class属性，具体请看流程上下文这一章节。',normalizedContent:'# 初始化你的flowexecutor执行器\n\n通过以下代码你可以轻易的初始化flowexecutor处理器：\n\nliteflowconfig config = new liteflowconfig();\nconfig.setrulesource("base/flow.xml");\nflowexecutor flowexecutor = flowexecutorholder.loadinstance(config);\n\n\n更多配置项请参考配置项章节。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化flowexecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用flowexecutor执行\n\nliteflowresponse<defaultcontext> response = flowexecutor.execute2resp("chain1", "arg");\n\n\n提示\n\n这个defaultcontext是默认的上下文，用户可以用最自己的任意bean当做上下文传入，如果需要传入自己的上下文，则需要传用户bean的class属性，具体请看流程上下文这一章节。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"说明",frontmatter:{title:"说明",date:"2022-06-06T21:36:19.000Z",permalink:"/pages/v2.7.X/82459b/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/035.%E9%85%8D%E7%BD%AE%E9%A1%B9/010.%E8%AF%B4%E6%98%8E.html",relativePath:"20.v2.7.X文档/035.配置项/010.说明.md",key:"v-44799627",path:"/pages/v2.7.X/82459b/",headersStr:null,content:"LiteFlow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",normalizedContent:"liteflow有诸多配置项，但在大多数情况下，你都不是必须得配置，因为系统有默认值。\n\n如果你不明白此配置项是干什么用的，那么希望不要改变其默认值。\n\n你也可以跳过此大章节，继续看下面的，如果碰到某个配置项的意义时，再来查阅此大章节。\n\n提示\n\n以下三章所涵盖的配置项完全一样，只是在不同的架构环境下表现形式不同，为了方便你查看，可以选择你所熟悉的章节进行查看。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"其他场景代码设置配置项",frontmatter:{title:"其他场景代码设置配置项",date:"2022-06-06T23:02:23.000Z",permalink:"/pages/v2.7.X/e9ec4f/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/035.%E9%85%8D%E7%BD%AE%E9%A1%B9/040.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"20.v2.7.X文档/035.配置项/040.其他场景代码设置配置项.md",key:"v-1ef5f67a",path:"/pages/v2.7.X/e9ec4f/",headersStr:null,content:'LiteflowConfig config = new LiteflowConfig();\n//规则文件路径\nconfig.setRuleSource("base/flow.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setEnable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setPrintBanner(true);\n//zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setZkNode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setSlotSize(1024);\n//FlowExecutor的execute2Future的线程数，默认为64\nconfig.setMainExecutorWorks(64);\n//FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nconfig.setMainExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder");\n//并行节点的线程池Builder，LiteFlow提供了默认的Builder\nconfig.setThreadExecutorClass("com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder");\n//异步线程最长的等待时间秒(只用于when)，默认值为15\nconfig.setWhenMaxWaitSeconds(15);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setWhenMaxWorkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setWhenQueueLimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setParseOnStart(true);\n//全局重试次数，默认为0\nconfig.setRetryCount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setSupportMultipleType(false);\n//全局默认节点执行器\nconfig.setNodeExecutorClass("com.yomahub.liteflow.flow.executor.DefaultNodeExecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setPrintExecutionLog(true);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setEnableLog(false);\n//监控队列存储大小，默认值为200\nconfig.setQueueLimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setDelay(300000L);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setPeriod(300000L);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'liteflowconfig config = new liteflowconfig();\n//规则文件路径\nconfig.setrulesource("base/flow.xml");\n//-----------------以下非必须-----------------\n//liteflow是否开启，默认为true\nconfig.setenable(true);\n//liteflow的banner打印是否开启，默认为true\nconfig.setprintbanner(true);\n//zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\nconfig.setzknode("/lite-flow/flow");\n//上下文的最大数量槽，默认值为1024\nconfig.setslotsize(1024);\n//flowexecutor的execute2future的线程数，默认为64\nconfig.setmainexecutorworks(64);\n//flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nconfig.setmainexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder");\n//并行节点的线程池builder，liteflow提供了默认的builder\nconfig.setthreadexecutorclass("com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder");\n//异步线程最长的等待时间秒(只用于when)，默认值为15\nconfig.setwhenmaxwaitseconds(15);\n//when节点全局异步线程池最大线程数，默认为16\nconfig.setwhenmaxworkers(16);\n//when节点全局异步线程池等待队列数，默认为512\nconfig.setwhenqueuelimit(512);\n//是否在启动的时候就解析规则，默认为true\nconfig.setparseonstart(true);\n//全局重试次数，默认为0\nconfig.setretrycount(0);\n//是否支持不同类型的加载方式混用，默认为false\nconfig.setsupportmultipletype(false);\n//全局默认节点执行器\nconfig.setnodeexecutorclass("com.yomahub.liteflow.flow.executor.defaultnodeexecutor");\n//是否打印执行中过程中的日志，默认为true\nconfig.setprintexecutionlog(true);\n//简易监控配置选项\n//监控是否开启，默认不开启\nconfig.setenablelog(false);\n//监控队列存储大小，默认值为200\nconfig.setqueuelimit(200);\n//监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nconfig.setdelay(300000l);\n//监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nconfig.setperiod(300000l);\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"Springboot下的配置项",frontmatter:{title:"Springboot下的配置项",date:"2022-06-06T21:42:55.000Z",permalink:"/pages/v2.7.X/3bc025/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/035.%E9%85%8D%E7%BD%AE%E9%A1%B9/020.Springboot%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"20.v2.7.X文档/035.配置项/020.Springboot下的配置项.md",key:"v-3e2ff606",path:"/pages/v2.7.X/3bc025/",headersStr:null,content:"#规则文件路径\nliteflow.rule-source=config/flow.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zkNode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#FlowExecutor的execute2Future的线程数，默认为64\nliteflow.main-executor-works=64\n#FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n#并行节点的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为15\nliteflow.when-max-wait-seconds=15\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zkNode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #FlowExecutor的execute2Future的线程数，默认为64\n  main-executor-works: 64\n  #FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\n  main-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n  #并行节点的线程池Builder，LiteFlow提供了默认的Builder\n  thread-executor-class: com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n  #异步线程最长的等待时间秒(只用于when)，默认值为15\n  when-max-wait-seconds: 15\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.DefaultNodeExecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",normalizedContent:"#规则文件路径\nliteflow.rule-source=config/flow.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zknode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#上下文的最大数量槽，默认值为1024\nliteflow.slot-size=1024\n#flowexecutor的execute2future的线程数，默认为64\nliteflow.main-executor-works=64\n#flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n#并行节点的线程池builder，liteflow提供了默认的builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为15\nliteflow.when-max-wait-seconds=15\n#when节点全局异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#when节点全局异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#全局默认节点执行器\nliteflow.node-executor-class=com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n#是否打印执行中过程中的日志，默认为true\nliteflow.print-execution-log=true\n#监控是否开启，默认不开启\nliteflow.monitor.enable-log=false\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=200\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=300000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=300000\n\n\nliteflow:\n  #规则文件路径\n  rule-source: config/flow.xml\n  #-----------------以下非必须-----------------\n  #liteflow是否开启，默认为true\n  enable: true\n  #liteflow的banner打印是否开启，默认为true\n  print-banner: true\n  #zknode的节点，只有使用zk作为配置源的时候才起作用，默认为/lite-flow/flow\n  zk-node: /lite-flow/flow\n  #上下文的最大数量槽，默认值为1024\n  slot-size: 1024\n  #flowexecutor的execute2future的线程数，默认为64\n  main-executor-works: 64\n  #flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\n  main-executor-class: com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n  #并行节点的线程池builder，liteflow提供了默认的builder\n  thread-executor-class: com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n  #异步线程最长的等待时间秒(只用于when)，默认值为15\n  when-max-wait-seconds: 15\n  #when节点全局异步线程池最大线程数，默认为16\n  when-max-workers: 16\n  #when节点全局异步线程池等待队列数，默认为512\n  when-queue-limit: 512\n  #是否在启动的时候就解析规则，默认为true\n  parse-on-start: true\n  #全局重试次数，默认为0\n  retry-count: 0\n  #是否支持不同类型的加载方式混用，默认为false\n  support-multiple-type: false\n  #全局默认节点执行器\n  node-executor-class: com.yomahub.liteflow.flow.executor.defaultnodeexecutor\n  #是否打印执行中过程中的日志，默认为true\n  print-execution-log: true\n  #简易监控配置选项\n  monitor:\n    #监控是否开启，默认不开启\n    enable-log: false\n    #监控队列存储大小，默认值为200\n    queue-limit: 200\n    #监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\n    delay: 300000\n    #监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\n    period: 300000\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"Spring下的配置项",frontmatter:{title:"Spring下的配置项",date:"2022-06-06T22:54:14.000Z",permalink:"/pages/v2.7.X/dc0673/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/035.%E9%85%8D%E7%BD%AE%E9%A1%B9/030.Spring%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9.html",relativePath:"20.v2.7.X文档/035.配置项/030.Spring下的配置项.md",key:"v-3d3e29c6",path:"/pages/v2.7.X/dc0673/",headersStr:null,content:'<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printBanner" value="true"/> \n    \x3c!-- zkNode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zkNode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotSize" value="1024"/> \n    \x3c!-- FlowExecutor的execute2Future的线程数，默认为64 --\x3e\n    <property name="mainExecutorWorks" value="64"/> \n    \x3c!-- FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="mainExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder"/> \n    \x3c!-- 并行节点的线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder"/> \n    \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为15 --\x3e\n    <property name="whenMaxWaitSeconds" value="15"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenMaxWorkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenQueueLimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseOnStart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retryCount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportMultipleType" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeExecutorClass" value="com.yomahub.liteflow.flow.executor.DefaultNodeExecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printExecutionLog" value="true"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enableLog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queueLimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',normalizedContent:'<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.xml"/>\n    \x3c!-- ***********以下都不是必须的，都有默认值*********** --\x3e\n    \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="enable" value="true"/> \n    \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="printbanner" value="true"/> \n    \x3c!-- zknode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="zknode" value="/lite-flow/flow.xml"/> \n    \x3c!-- 上下文的最大数量槽，默认值为1024 --\x3e\n    <property name="slotsize" value="1024"/> \n    \x3c!-- flowexecutor的execute2future的线程数，默认为64 --\x3e\n    <property name="mainexecutorworks" value="64"/> \n    \x3c!-- flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="mainexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder"/> \n    \x3c!-- 并行节点的线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder"/> \n    \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为15 --\x3e\n    <property name="whenmaxwaitseconds" value="15"/>\n    \x3c!-- when节点全局异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenmaxworkers" value="16"/> \n    \x3c!-- when节点全局异步线程池等待队列数，默认为512 --\x3e\n    <property name="whenqueuelimit" value="512"/>\n    \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="parseonstart" value="true"/>\n    \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="retrycount" value="0"/>\n    \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="supportmultipletype" value="false"/>\n    \x3c!-- 全局默认节点执行器 --\x3e\n    <property name="nodeexecutorclass" value="com.yomahub.liteflow.flow.executor.defaultnodeexecutor"/>\n    \x3c!-- 是否打印执行中过程中的日志，默认为true --\x3e\n    <property name="printexecutionlog" value="true"/>\n    \x3c!-- 监控是否开启，默认不开启 --\x3e\n    <property name="enablelog" value="false"/>\n    \x3c!-- 监控队列存储大小，默认值为200 --\x3e\n    <property name="queuelimit" value="200"/>\n    \x3c!-- 监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="period" value="300000"/>\n    \x3c!-- 监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟 --\x3e\n    <property name="delay" value="300000"/> \n</bean>\n\n\n提示\n\n只要使用了规则，那么rule-source必须得有。\n\n但是如果你是用代码动态构造规则，那么rule-source配置自动失效。因为代码构造是用代码来装配规则，不需要规则文件。详情请参考用代码动态构造规则。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"自定义配置源",frontmatter:{title:"自定义配置源",date:"2022-06-01T13:17:59.000Z",permalink:"/pages/v2.7.X/3dd60b/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/040.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"20.v2.7.X文档/040.规则文件/040.自定义配置源.md",key:"v-70cdd20a",path:"/pages/v2.7.X/3dd60b/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:609}],headersStr:"说明 配置路径",content:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。LiteFlow支持自定义的配置源的扩展点。\n\nXML形式的规则文件请继承ClassXmlFlowParser\n\nJSON形式的规则文件请继承ClassJsonFlowParser\n\nYML形式的规则文件请继承ClassYmlFlowParser\n\n以下以XML形式的自定义源配置类举例：\n\npublic class TestCustomParser extends ClassXmlFlowParser {\n\n\t@Override\n\tpublic String parseCustom() {\n\t\tSystem.out.println("进入自定义parser");\n\t\tString xmlContent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlContent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@Autowired和@Resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=xml:com.yomahub.liteflow.test.TestCustomParser\n\n\n关于xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这章。',normalizedContent:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。liteflow支持自定义的配置源的扩展点。\n\nxml形式的规则文件请继承classxmlflowparser\n\njson形式的规则文件请继承classjsonflowparser\n\nyml形式的规则文件请继承classymlflowparser\n\n以下以xml形式的自定义源配置类举例：\n\npublic class testcustomparser extends classxmlflowparser {\n\n\t@override\n\tpublic string parsecustom() {\n\t\tsystem.out.println("进入自定义parser");\n\t\tstring xmlcontent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlcontent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@autowired和@resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=xml:com.yomahub.liteflow.test.testcustomparser\n\n\n关于xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"ZK规则文件配置",frontmatter:{title:"ZK规则文件配置",date:"2022-06-01T11:43:56.000Z",permalink:"/pages/v2.7.X/b527e6/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/030.ZK%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"20.v2.7.X文档/040.规则文件/030.ZK规则文件配置.md",key:"v-966ef4de",path:"/pages/v2.7.X/b527e6/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:527}],headersStr:"依赖 配置路径",content:"# 依赖\n\n提示\n\nLiteFlow支持把配置放在zk集群中，基于zk的通知机制，LiteFlow支持实时修改流程\n\n你只需在原来配置流程的地方，把本地xml路径换成zk地址就ok了，当然ZK里存放的内容还是以xml/json/yml存储的，具体请请参考规则文件格式这章。\n\n如果需要用到zk，需要加以下依赖，LiteFlow在2.6.3之后不再传递依赖：\n\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-framework</artifactId>\n    <version>${curator.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>${curator.version}</version>\n</dependency>\n\n\n${curator.version}建议为5.1.0\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n只需要改变rule-source变成zk的地址就可以了，集群用逗号分隔。\n\nliteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n\n关于xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这一章。",normalizedContent:"# 依赖\n\n提示\n\nliteflow支持把配置放在zk集群中，基于zk的通知机制，liteflow支持实时修改流程\n\n你只需在原来配置流程的地方，把本地xml路径换成zk地址就ok了，当然zk里存放的内容还是以xml/json/yml存储的，具体请请参考规则文件格式这章。\n\n如果需要用到zk，需要加以下依赖，liteflow在2.6.3之后不再传递依赖：\n\n<dependency>\n    <groupid>org.apache.curator</groupid>\n    <artifactid>curator-framework</artifactid>\n    <version>${curator.version}</version>\n</dependency>\n<dependency>\n    <groupid>org.apache.curator</groupid>\n    <artifactid>curator-recipes</artifactid>\n    <version>${curator.version}</version>\n</dependency>\n\n\n${curator.version}建议为5.1.0\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n只需要改变rule-source变成zk的地址就可以了，集群用逗号分隔。\n\nliteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n\n关于xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这一章。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"本地规则文件配置",frontmatter:{title:"本地规则文件配置",date:"2022-06-01T11:37:46.000Z",permalink:"/pages/v2.7.X/a6fd84/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/020.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"20.v2.7.X文档/040.规则文件/020.本地规则文件配置.md",key:"v-268cceea",path:"/pages/v2.7.X/a6fd84/",headers:[{level:2,title:"常规配置",slug:"常规配置",normalizedTitle:"常规配置",charIndex:173},{level:2,title:"指定多个路径",slug:"指定多个路径",normalizedTitle:"指定多个路径",charIndex:221}],headersStr:"常规配置 指定多个路径",content:"在LiteFlow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是LiteFlow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.xml\n\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.xml,config/flow2.xml,config/flow3.xml\n\n\n你也可以使用Spring EL表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.xml\n\n\n提示\n\n模糊匹配只限于Springboot/Spring体系中，非Spring环境，模糊匹配不生效",normalizedContent:"在liteflow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是liteflow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读配置项这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.xml\n\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.xml,config/flow2.xml,config/flow3.xml\n\n\n你也可以使用spring el表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.xml\n\n\n提示\n\n模糊匹配只限于springboot/spring体系中，非spring环境，模糊匹配不生效",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"规则文件格式",frontmatter:{title:"规则文件格式",date:"2022-06-01T00:20:06.000Z",permalink:"/pages/v2.7.X/7e3166/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/010.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html",relativePath:"20.v2.7.X文档/040.规则文件/010.规则文件格式.md",key:"v-b353778c",path:"/pages/v2.7.X/7e3166/",headers:[{level:2,title:"规则组成部分",slug:"规则组成部分",normalizedTitle:"规则组成部分",charIndex:157},{level:2,title:"xml格式",slug:"xml格式",normalizedTitle:"xml格式",charIndex:389},{level:2,title:"json格式",slug:"json格式",normalizedTitle:"json格式",charIndex:1432},{level:2,title:"yml格式",slug:"yml格式",normalizedTitle:"yml格式",charIndex:2845}],headersStr:"规则组成部分 xml格式 json格式 yml格式",content:'LiteFlow从2.5.0版本开始支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nLiteFlow的规则文件非常轻量，非常容易上手。主要由Node节点和Chain节点组成。\n\n而Node节点在Springboot/Spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到Spring上下文中。\n\n在非Spring环境体系中，Node节点是必须的。如果不配置Node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\n\n# xml格式\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.xml\n\nzk方式：liteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=xml:com.yomahub.liteflow.test.TestCustomParser\n\nxml的完整形式举例：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.ACmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.BCmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.CCmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.DCmp"/>\n        <node id="e" class="com.yomahub.liteflow.test.parser.cmp.ECmp"/>\n        <node id="f" class="com.yomahub.liteflow.test.parser.cmp.FCmp"/>\n        <node id="g" class="com.yomahub.liteflow.test.parser.cmp.GCmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,c"/>\n        <when value="b,d,e(f|g)"/>\n        <then value="chain2"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="c,g,f"/>\n    </chain>\n</flow>\n\n\n\n# json格式\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.json\n\nzk方式：liteflow.rule-source=json:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=json:com.yomahub.liteflow.test.TestCustomParser\n\njson的完整形式举例：\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ACmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.BCmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.CCmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.DCmp"\n        },\n        {\n          "id": "e",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ECmp"\n        },\n        {\n          "id": "f",\n          "class": "com.yomahub.liteflow.test.parser.cmp.FCmp"\n        },\n        {\n          "id": "g",\n          "class": "com.yomahub.liteflow.test.parser.cmp.GCmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain2",\n        "condition": [\n          {"type": "then", "value": "c,g,f"}\n        ]\n      },\n      {\n        "name": "chain1",\n        "condition": [\n          {"type": "then", "value": "a,c"},\n          {"type": "when", "value": "b,d,e(f|g)"},\n          {"type": "then", "value": "chain2"}\n        ]\n      }\n    ]\n  }\n}\n\n\n\n# yml格式\n\n在yml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.yml\n\nzk方式：liteflow.rule-source=yml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=yml:com.yomahub.liteflow.test.TestCustomParser\n\nyml的完整形式举例：\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.ACmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.BCmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.CCmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.DCmp\n      - id: e\n        class: com.yomahub.liteflow.test.parser.cmp.ECmp\n      - id: f\n        class: com.yomahub.liteflow.test.parser.cmp.FCmp\n      - id: g\n        class: com.yomahub.liteflow.test.parser.cmp.GCmp\n  chain:\n    - name: chain1\n      condition:\n        - type: then\n          value: \'a,c\'\n        - type: when\n          value: \'b,d,e(f|g)\'\n        - type: then\n          value: \'chain2\'\n    - name: chain2\n      condition:\n        - type: then\n          value: \'c,g,f\'\n\n',normalizedContent:'liteflow从2.5.0版本开始支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nliteflow的规则文件非常轻量，非常容易上手。主要由node节点和chain节点组成。\n\n而node节点在springboot/spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到spring上下文中。\n\n在非spring环境体系中，node节点是必须的。如果不配置node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\n\n# xml格式\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.xml\n\nzk方式：liteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=xml:com.yomahub.liteflow.test.testcustomparser\n\nxml的完整形式举例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.acmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.bcmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.ccmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.dcmp"/>\n        <node id="e" class="com.yomahub.liteflow.test.parser.cmp.ecmp"/>\n        <node id="f" class="com.yomahub.liteflow.test.parser.cmp.fcmp"/>\n        <node id="g" class="com.yomahub.liteflow.test.parser.cmp.gcmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,c"/>\n        <when value="b,d,e(f|g)"/>\n        <then value="chain2"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="c,g,f"/>\n    </chain>\n</flow>\n\n\n\n# json格式\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.json\n\nzk方式：liteflow.rule-source=json:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=json:com.yomahub.liteflow.test.testcustomparser\n\njson的完整形式举例：\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.acmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.bcmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ccmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.dcmp"\n        },\n        {\n          "id": "e",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ecmp"\n        },\n        {\n          "id": "f",\n          "class": "com.yomahub.liteflow.test.parser.cmp.fcmp"\n        },\n        {\n          "id": "g",\n          "class": "com.yomahub.liteflow.test.parser.cmp.gcmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain2",\n        "condition": [\n          {"type": "then", "value": "c,g,f"}\n        ]\n      },\n      {\n        "name": "chain1",\n        "condition": [\n          {"type": "then", "value": "a,c"},\n          {"type": "when", "value": "b,d,e(f|g)"},\n          {"type": "then", "value": "chain2"}\n        ]\n      }\n    ]\n  }\n}\n\n\n\n# yml格式\n\n在yml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.yml\n\nzk方式：liteflow.rule-source=yml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=yml:com.yomahub.liteflow.test.testcustomparser\n\nyml的完整形式举例：\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.acmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.bcmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.ccmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.dcmp\n      - id: e\n        class: com.yomahub.liteflow.test.parser.cmp.ecmp\n      - id: f\n        class: com.yomahub.liteflow.test.parser.cmp.fcmp\n      - id: g\n        class: com.yomahub.liteflow.test.parser.cmp.gcmp\n  chain:\n    - name: chain1\n      condition:\n        - type: then\n          value: \'a,c\'\n        - type: when\n          value: \'b,d,e(f|g)\'\n        - type: then\n          value: \'chain2\'\n    - name: chain2\n      condition:\n        - type: then\n          value: \'c,g,f\'\n\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"开启和关闭",frontmatter:{title:"开启和关闭",date:"2022-06-01T13:06:23.000Z",permalink:"/pages/v2.7.X/202997/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/010.%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD.html",relativePath:"20.v2.7.X文档/060.使用详细指南/010.开启和关闭.md",key:"v-a37aca76",path:"/pages/v2.7.X/202997/",headersStr:null,content:"对于springboot的项目来说，LiteFLow提供了自动装配功能，在启动时会进行加载规则，扫描组件等初始化行为\n\n如果你依赖了，但是不希望生效LiteFlow。则需要在配置文件中配置如下(这里以springboot的配置为例)：\n\nliteflow.enable=false\n\n\n这个默认为true，所以希望LiteFlow生效的用户不用关心这个参数。\n\n提示\n\n这里说明下，如果enable为false的话，spring上下文中不会去加载FlowExecutor，那你自己的类中如果@Autowire了这个，启动时仍会报错。\n\nenable为false，只是代表不初始化LiteFlow的一些元数据，但并不意味着你设为false了，你项目仍能正常启动。还需要做点变动的。",normalizedContent:"对于springboot的项目来说，liteflow提供了自动装配功能，在启动时会进行加载规则，扫描组件等初始化行为\n\n如果你依赖了，但是不希望生效liteflow。则需要在配置文件中配置如下(这里以springboot的配置为例)：\n\nliteflow.enable=false\n\n\n这个默认为true，所以希望liteflow生效的用户不用关心这个参数。\n\n提示\n\n这里说明下，如果enable为false的话，spring上下文中不会去加载flowexecutor，那你自己的类中如果@autowire了这个，启动时仍会报错。\n\nenable为false，只是代表不初始化liteflow的一些元数据，但并不意味着你设为false了，你项目仍能正常启动。还需要做点变动的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"同步异步编排",frontmatter:{title:"同步异步编排",date:"2022-06-01T13:09:37.000Z",permalink:"/pages/v2.7.X/e8e603/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/020.%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92.html",relativePath:"20.v2.7.X文档/060.使用详细指南/020.同步异步编排.md",key:"v-bff5a9be",path:"/pages/v2.7.X/e8e603/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"同步流程块",slug:"同步流程块",normalizedTitle:"同步流程块",charIndex:75},{level:2,title:"异步流程块",slug:"异步流程块",normalizedTitle:"异步流程块",charIndex:99},{level:2,title:"异步线程池",slug:"异步线程池",normalizedTitle:"异步线程池",charIndex:351},{level:2,title:"异步并行组",slug:"异步并行组",normalizedTitle:"异步并行组",charIndex:499},{level:2,title:"相同异步并行组之间的抛错",slug:"相同异步并行组之间的抛错",normalizedTitle:"相同异步并行组之间的抛错",charIndex:728},{level:2,title:"不同异步并行组之间的抛错",slug:"不同异步并行组之间的抛错",normalizedTitle:"不同异步并行组之间的抛错",charIndex:851},{level:2,title:"相同异步并行组之间的抛错",slug:"相同异步并行组之间的抛错-2",normalizedTitle:"相同异步并行组之间的抛错",charIndex:728},{level:2,title:"异步任一线程结束即继续",slug:"异步任一线程结束即继续",normalizedTitle:"异步任一线程结束即继续",charIndex:1432}],headersStr:"概述 同步流程块 异步流程块 异步线程池 异步并行组 相同异步并行组之间的抛错 不同异步并行组之间的抛错 相同异步并行组之间的抛错 异步任一线程结束即继续",content:'# 概述\n\n提示\n\n同步和异步节点的编排在LiteFlow是一个核心概念，这章建议学习LiteFlow的小伙伴仔细看看。涉及了大量核心概念。\n\n\n# 同步流程块\n\nLiteFlow提供了同步流程块和异步流程块，配置起来非常简单\n\n以下为同步流程块，表示a,b,c,d四个组件会挨个同步执行\n\n<then value="a,b,c,d"/>\n\n\n下面的方式和上面等价\n\n<then value="a,b"/>\n<then value="c,d"/>\n\n\n\n# 异步流程块\n\n以下为异步流程块，表示a,b,c,d四个组件会并行执行\n\n<when value="a,b,c,d"/>\n\n\n当然下面的方式也和上面等价\n\n<when value="a,b"/>\n<when value="c,d"/>\n\n\n\n# 异步线程池\n\nLiteFlow从2.5.0开始引入了异步流程块的线程池设定\n\n你可以通过这样配置线程池大小以及等待队列\n\n#异步线程池最大线程数\nliteflow.when-max-workers=4\n#异步线程池等待队列数\nliteflow.when-queue-limit=100\n\n\n\n# 异步并行组\n\n如果有同学想并行执行a,b，等执行好了，再并行执行c,d，该怎么办呢？\n\n从2.5.0版本开始，引入了group的概念，你只需这么配置就行了\n\n<when group="g1" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\nLiteFlow规定，2个不同组的when是按照配置的顺序执行的，相同组的when是完全并行的。如果不配，默认组是default，所以不配置组默认就是在同一组内的\n\n\n# 相同异步并行组之间的抛错\n\n不配置group或者配成一样的，那无论有多少个<when>还是你一个<when>里有配置了多个组件，都是等价的。都会并行执行。\n\n那么有一个组件抛错，其他组件依旧会执行。等到整个when结束后，才会抛错出来。\n\n\n# 不同异步并行组之间的抛错\n\n如果2个并行组之间，有一组任一节点报错。不想执行下一个并行组怎么办，从2.5.0版本开始，引入了一个参数errorResume,你可以这样配置\n\n<when group="g1" errorResume="false" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\n上面的配置表示，默认就是false，所以不配置也行，如果g1并行组件a和b有一个执行报错，则第二个<when>不会执行\n\n如果设为true，如果并行组g1中任意一个节点抛出异常，则g2并行组，依旧执行\n\n\n# 相同异步并行组之间的抛错\n\n思考以下问题，如果有以下流程，第一个并行组出错还继续，第二个出错不继续。那么如果c报错，会走到e么\n\n<when errorResume="true" value="a,b"/>\n<when errorResume="false" value="c,d"/>\n<then value="e"/>\n\n\n应该是会走到e，因为他们是相通并行组，LiteFlow会进行合并，合并的话，errorResume会参照第一个来进行。也就等价于：\n\n<when errorResume="true" value="a,b,c,d"/>\n<then value="e"/>\n\n\n所以会走到e\n\n\n# 异步任一线程结束即继续\n\nLiteFlow从2.6.4开始，支持了异步组件任意一个结束即继续的特性。\n\n如果有以下流程：\n\n<chain name="chain1">\n    <when value="a,b,c"/>\n    <then value="d"/>\n</chain>\n\n\n表示a,b,c三个并行，但是要等到a,b,c都执行完了，才能执行d。\n\n如果要达成a,b,c任意一个执行完，即执行d，你需要这么配置\n\n<chain name="chain1">\n    <when value="a,b,c" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n这样就可以达成了。是不是很简单。\n\n思考如下的场景：\n\n<chain name="chain1">\n    <when value="a1,b1,c1" any="true"/>\n    <when value="a2,b2,c2"/>\n    <then value="d"/>\n</chain>\n\n\n如果b1最先执行完，那么会不会接下去执行a2,b2,c2中的某一个？\n\n答案是不会，有可能b1会先执行完，然后直接执行d，然后再进行执行后续的其他节点。\n\n为什么会跳过第二个when呢，因为上面说过了。相同并行组会合并的，并以第一个when上的参数为准，以上就等价于：\n\n<chain name="chain1">\n    <when value="a1,b1,c1,a2,b2,c2" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n所以换成以上这种形式，是不是就好理解点了？',normalizedContent:'# 概述\n\n提示\n\n同步和异步节点的编排在liteflow是一个核心概念，这章建议学习liteflow的小伙伴仔细看看。涉及了大量核心概念。\n\n\n# 同步流程块\n\nliteflow提供了同步流程块和异步流程块，配置起来非常简单\n\n以下为同步流程块，表示a,b,c,d四个组件会挨个同步执行\n\n<then value="a,b,c,d"/>\n\n\n下面的方式和上面等价\n\n<then value="a,b"/>\n<then value="c,d"/>\n\n\n\n# 异步流程块\n\n以下为异步流程块，表示a,b,c,d四个组件会并行执行\n\n<when value="a,b,c,d"/>\n\n\n当然下面的方式也和上面等价\n\n<when value="a,b"/>\n<when value="c,d"/>\n\n\n\n# 异步线程池\n\nliteflow从2.5.0开始引入了异步流程块的线程池设定\n\n你可以通过这样配置线程池大小以及等待队列\n\n#异步线程池最大线程数\nliteflow.when-max-workers=4\n#异步线程池等待队列数\nliteflow.when-queue-limit=100\n\n\n\n# 异步并行组\n\n如果有同学想并行执行a,b，等执行好了，再并行执行c,d，该怎么办呢？\n\n从2.5.0版本开始，引入了group的概念，你只需这么配置就行了\n\n<when group="g1" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\nliteflow规定，2个不同组的when是按照配置的顺序执行的，相同组的when是完全并行的。如果不配，默认组是default，所以不配置组默认就是在同一组内的\n\n\n# 相同异步并行组之间的抛错\n\n不配置group或者配成一样的，那无论有多少个<when>还是你一个<when>里有配置了多个组件，都是等价的。都会并行执行。\n\n那么有一个组件抛错，其他组件依旧会执行。等到整个when结束后，才会抛错出来。\n\n\n# 不同异步并行组之间的抛错\n\n如果2个并行组之间，有一组任一节点报错。不想执行下一个并行组怎么办，从2.5.0版本开始，引入了一个参数errorresume,你可以这样配置\n\n<when group="g1" errorresume="false" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\n上面的配置表示，默认就是false，所以不配置也行，如果g1并行组件a和b有一个执行报错，则第二个<when>不会执行\n\n如果设为true，如果并行组g1中任意一个节点抛出异常，则g2并行组，依旧执行\n\n\n# 相同异步并行组之间的抛错\n\n思考以下问题，如果有以下流程，第一个并行组出错还继续，第二个出错不继续。那么如果c报错，会走到e么\n\n<when errorresume="true" value="a,b"/>\n<when errorresume="false" value="c,d"/>\n<then value="e"/>\n\n\n应该是会走到e，因为他们是相通并行组，liteflow会进行合并，合并的话，errorresume会参照第一个来进行。也就等价于：\n\n<when errorresume="true" value="a,b,c,d"/>\n<then value="e"/>\n\n\n所以会走到e\n\n\n# 异步任一线程结束即继续\n\nliteflow从2.6.4开始，支持了异步组件任意一个结束即继续的特性。\n\n如果有以下流程：\n\n<chain name="chain1">\n    <when value="a,b,c"/>\n    <then value="d"/>\n</chain>\n\n\n表示a,b,c三个并行，但是要等到a,b,c都执行完了，才能执行d。\n\n如果要达成a,b,c任意一个执行完，即执行d，你需要这么配置\n\n<chain name="chain1">\n    <when value="a,b,c" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n这样就可以达成了。是不是很简单。\n\n思考如下的场景：\n\n<chain name="chain1">\n    <when value="a1,b1,c1" any="true"/>\n    <when value="a2,b2,c2"/>\n    <then value="d"/>\n</chain>\n\n\n如果b1最先执行完，那么会不会接下去执行a2,b2,c2中的某一个？\n\n答案是不会，有可能b1会先执行完，然后直接执行d，然后再进行执行后续的其他节点。\n\n为什么会跳过第二个when呢，因为上面说过了。相同并行组会合并的，并以第一个when上的参数为准，以上就等价于：\n\n<chain name="chain1">\n    <when value="a1,b1,c1,a2,b2,c2" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n所以换成以上这种形式，是不是就好理解点了？',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"说明",frontmatter:{title:"说明",date:"2022-06-01T13:18:18.000Z",permalink:"/pages/v2.7.X/182a88/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/050.%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/010.%E8%AF%B4%E6%98%8E.html",relativePath:"20.v2.7.X文档/050.用代码动态构造规则/010.说明.md",key:"v-549e4cb6",path:"/pages/v2.7.X/182a88/",headersStr:null,content:"LiteFlow从2.6.8版本开始支持基于方法链的代码构造链路的特性。\n\n提示\n\n通过代码构造模式，你可以不用写xml/json/yaml的规则文件。用代码来构建规则。\n\n事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的API意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造API去构造链路。\n\nLiteFlow在2.6.8中设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",normalizedContent:"liteflow从2.6.8版本开始支持基于方法链的代码构造链路的特性。\n\n提示\n\n通过代码构造模式，你可以不用写xml/json/yaml的规则文件。用代码来构建规则。\n\n事实上，liteflow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的api意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造api去构造链路。\n\nliteflow在2.6.8中设计了非常简单的构造方法链式api，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"如何构造",frontmatter:{title:"如何构造",date:"2022-06-01T12:19:26.000Z",permalink:"/pages/v2.7.X/e0eebf/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/050.%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/020.%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0.html",relativePath:"20.v2.7.X文档/050.用代码动态构造规则/020.如何构造.md",key:"v-81fe0ba2",path:"/pages/v2.7.X/e0eebf/",headers:[{level:2,title:"什么时候构造",slug:"什么时候构造",normalizedTitle:"什么时候构造",charIndex:93},{level:2,title:"构造Node",slug:"构造node",normalizedTitle:"构造node",charIndex:145},{level:2,title:"构建一个Chain",slug:"构建一个chain",normalizedTitle:"构建一个chain",charIndex:1418},{level:2,title:"销毁一个Chain",slug:"销毁一个chain",normalizedTitle:"销毁一个chain",charIndex:2057}],headersStr:"什么时候构造 构造Node 构建一个Chain 销毁一个Chain",content:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造Node\n\n提示\n\n你可以像以下那样构造一个普通的Node，当然在spring/springboot环境，大多数情况你无需去构建一个Node，因为只要你的组件上标有@Component/@LiteflowComponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件\n\n//构建一个普通组件\nLiteFlowNodeBuilder.createCommonNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个普通条件组件\nLiteFlowNodeBuilder.createCommonCondNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个脚本组件\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nLiteFlowNodeBuilder.createScriptCondNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setFile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@LiteflowComponent或者@Component，如果项目是spring体系的话，LiteFlow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@Autowired和@Resource等等之类的spring任何注解。\n\n\n# 构建一个Chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nLiteFlowChainBuilder.createChain().setChainName("chain2").setCondition(\n  LiteFlowConditionBuilder.createThenCondition().setValue("c,d").build()\n).build();\n\nLiteFlowChainBuilder.createChain().setChainName("chain1").setCondition(\n  LiteFlowConditionBuilder.createThenCondition().setValue("a,b").build()\n).setCondition(\n  LiteFlowConditionBuilder.createWhenCondition().setValue("e(f|g|chain2)").build()\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你的链路之间有依赖关系，比如上面的代码，chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n如果使用规则文件，那顺序无所谓，因为规则文件是统一解析好的。用构造模式，如果有依赖，顺序问题要注意下。\n\n\n# 销毁一个Chain\n\nLiteFlow从2.6.13开始支持了流程的销毁，你可以手动运行以下代码来销毁一个流程：\n\nFlowBus.removeChain("你的流程ID")\n',normalizedContent:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 什么时候构造\n\n建议在项目启动时构造，以下只需要构造一次。千万不要每次执行的时候都去构造！！！\n\n\n# 构造node\n\n提示\n\n你可以像以下那样构造一个普通的node，当然在spring/springboot环境，大多数情况你无需去构建一个node，因为只要你的组件上标有@component/@liteflowcomponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件\n\n//构建一个普通组件\nliteflownodebuilder.createcommonnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个普通条件组件\nliteflownodebuilder.createcommoncondnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个脚本组件\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nliteflownodebuilder.createscriptcondnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setfile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@liteflowcomponent或者@component，如果项目是spring体系的话，liteflow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@autowired和@resource等等之类的spring任何注解。\n\n\n# 构建一个chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nliteflowchainbuilder.createchain().setchainname("chain2").setcondition(\n  liteflowconditionbuilder.createthencondition().setvalue("c,d").build()\n).build();\n\nliteflowchainbuilder.createchain().setchainname("chain1").setcondition(\n  liteflowconditionbuilder.createthencondition().setvalue("a,b").build()\n).setcondition(\n  liteflowconditionbuilder.createwhencondition().setvalue("e(f|g|chain2)").build()\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你的链路之间有依赖关系，比如上面的代码，chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n如果使用规则文件，那顺序无所谓，因为规则文件是统一解析好的。用构造模式，如果有依赖，顺序问题要注意下。\n\n\n# 销毁一个chain\n\nliteflow从2.6.13开始支持了流程的销毁，你可以手动运行以下代码来销毁一个流程：\n\nflowbus.removechain("你的流程id")\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"规则文件路径",frontmatter:{title:"规则文件路径",date:"2022-06-03T23:27:24.000Z",permalink:"/pages/v2.7.X/9c7367/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/015.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.html",relativePath:"20.v2.7.X文档/060.使用详细指南/015.规则文件路径.md",key:"v-eaf4644a",path:"/pages/v2.7.X/9c7367/",headers:[{level:2,title:"单个文件指定",slug:"单个文件指定",normalizedTitle:"单个文件指定",charIndex:87},{level:2,title:"多个文件指定",slug:"多个文件指定",normalizedTitle:"多个文件指定",charIndex:237},{level:2,title:"SpringEL表达式支持",slug:"springel表达式支持",normalizedTitle:"springel表达式支持",charIndex:352}],headersStr:"单个文件指定 多个文件指定 SpringEL表达式支持",content:"提示\n\n如果你是用规则文件编排的方式，则需要指定规则文件路径。如果你是用动态代码构建的方式编排，则无需指定规则文件路径，关于动态代码编排，请参照用代码动态构造规则。\n\n\n# 单个文件指定\n\n在开始编排之前，首先你要指定规则文件路径，就像这样：\n\nliteflow.rule-source=config/flow.xml\n\n\n以上是springboot的properties格式，同理，springboot的yaml格式也一样。自己试几下就知道了，这里不做过多说明。\n\n\n# 多个文件指定\n\n如果你不止一个规则文件，可以用逗号或者分号进行隔开添加：\n\nliteflow.rule-source=config/flow1.xml,config/flow2.xml,config/flow3.xml\n\n\n\n# SpringEL表达式支持\n\n在Spring体系下，你还可以用SPEL表达式去定义规则文件的路径，比如\n\nliteflow.rule-source=config/**/flow*.xml\n\n\n这段就表示在config目录下任意目录里(包含不同层级的子目录)只要含有flow开头的xml文件都会被加载。\n\n除了*的用法之外，SPEL的其他表达式全部都支持。具体可以自行查下SPEL的用法。这里不作过多说明。",normalizedContent:"提示\n\n如果你是用规则文件编排的方式，则需要指定规则文件路径。如果你是用动态代码构建的方式编排，则无需指定规则文件路径，关于动态代码编排，请参照用代码动态构造规则。\n\n\n# 单个文件指定\n\n在开始编排之前，首先你要指定规则文件路径，就像这样：\n\nliteflow.rule-source=config/flow.xml\n\n\n以上是springboot的properties格式，同理，springboot的yaml格式也一样。自己试几下就知道了，这里不做过多说明。\n\n\n# 多个文件指定\n\n如果你不止一个规则文件，可以用逗号或者分号进行隔开添加：\n\nliteflow.rule-source=config/flow1.xml,config/flow2.xml,config/flow3.xml\n\n\n\n# springel表达式支持\n\n在spring体系下，你还可以用spel表达式去定义规则文件的路径，比如\n\nliteflow.rule-source=config/**/flow*.xml\n\n\n这段就表示在config目录下任意目录里(包含不同层级的子目录)只要含有flow开头的xml文件都会被加载。\n\n除了*的用法之外，spel的其他表达式全部都支持。具体可以自行查下spel的用法。这里不作过多说明。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"数据上下文",frontmatter:{title:"数据上下文",date:"2022-06-01T13:16:58.000Z",permalink:"/pages/v2.7.X/16f927/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/040.%E6%95%B0%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87.html",relativePath:"20.v2.7.X文档/060.使用详细指南/040.数据上下文.md",key:"v-59a5790e",path:"/pages/v2.7.X/16f927/",headers:[{level:2,title:"默认上下文",slug:"默认上下文",normalizedTitle:"默认上下文",charIndex:242},{level:2,title:"自定义上下文",slug:"自定义上下文",normalizedTitle:"自定义上下文",charIndex:464},{level:2,title:"上下文的数量",slug:"上下文的数量",normalizedTitle:"上下文的数量",charIndex:965}],headersStr:"默认上下文 自定义上下文 上下文的数量",content:'概念\n\n在执行器执行流程时会分配唯一的一个数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n笔记\n\n在之前的2.6.X版本中有一个数据槽(SLOT)的概念，在2.7.X中你无需关心数据槽的概念了。你只需要关注上下文的概念就可以了。\n\n事实上，SLOT依旧存在，只不过里面包了上下文这个概念。如果你不是从2.6.X迁移过来的用户，不用关心这一条笔记。\n\n\n# 默认上下文\n\nLiteFlow提供了一个默认的数据上下文的实现：DefaultContext。这个默认的实现其实里面主要存储数据的容器就是一个Map。\n\n你可以通过DefaultContext中的setData方法放入数据，通过getData方法获得数据。\n\n建议\n\nDefaultContext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的Bean当做上下文进行传入。LiteFlow对上下文的Bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nLiteflowResponse<CustomContext> response = flowExecutor.execute("chain1", "初始参数", CustomContext.class);\n\n\n传入之后， LiteFlow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@Component("yourCmpName")\npublic class YourCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tYourContextBean context = this.getContextBean();\n\t\t//do your biz\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 上下文的数量\n\n在LiteFlow的配置中，会提供一个slotSize的参数可以去配置上下文初始化数量，但是这个默认值就是1024，从2.6.0版本开始，当上下文数量不够时，会按照0.75的因子去进行自动扩容。所以这个值不推荐主动配置。除非有特殊情况。',normalizedContent:'概念\n\n在执行器执行流程时会分配唯一的一个数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。\n\n笔记\n\n在之前的2.6.x版本中有一个数据槽(slot)的概念，在2.7.x中你无需关心数据槽的概念了。你只需要关注上下文的概念就可以了。\n\n事实上，slot依旧存在，只不过里面包了上下文这个概念。如果你不是从2.6.x迁移过来的用户，不用关心这一条笔记。\n\n\n# 默认上下文\n\nliteflow提供了一个默认的数据上下文的实现：defaultcontext。这个默认的实现其实里面主要存储数据的容器就是一个map。\n\n你可以通过defaultcontext中的setdata方法放入数据，通过getdata方法获得数据。\n\n建议\n\ndefaultcontext虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的数据上下文。\n\n\n# 自定义上下文\n\n你可以用你自己的任意的bean当做上下文进行传入。liteflow对上下文的bean没有任何要求。\n\n自己定义的上下文实质上就是一个最简单的值对象，自己定义的上下文因为是强类型，更加贴合业务。\n\n你可以像这样进行传入：\n\nliteflowresponse<customcontext> response = flowexecutor.execute("chain1", "初始参数", customcontext.class);\n\n\n传入之后， liteflow会在调用时进行初始化，给这个上下文分配唯一的实例。你在组件之中可以这样去获得这个上下文实例：\n\n@component("yourcmpname")\npublic class yourcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tyourcontextbean context = this.getcontextbean();\n\t\t//do your biz\n\t}\n}\n\n\n关于组件之中还可以获得哪些默认的参数，请参考普通组件。\n\n\n# 上下文的数量\n\n在liteflow的配置中，会提供一个slotsize的参数可以去配置上下文初始化数量，但是这个默认值就是1024，从2.6.0版本开始，当上下文数量不够时，会按照0.75的因子去进行自动扩容。所以这个值不推荐主动配置。除非有特殊情况。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行器",frontmatter:{title:"执行器",date:"2022-06-01T13:15:14.000Z",permalink:"/pages/v2.7.X/375299/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/030.%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"20.v2.7.X文档/060.使用详细指南/030.执行器.md",key:"v-3164109e",path:"/pages/v2.7.X/375299/",headers:[{level:2,title:"返回类型为LiteflowResponse",slug:"返回类型为liteflowresponse",normalizedTitle:"返回类型为liteflowresponse",charIndex:34},{level:2,title:"返回类型为上下文Bean",slug:"返回类型为上下文bean",normalizedTitle:"返回类型为上下文bean",charIndex:848},{level:2,title:"返回类型为Future",slug:"返回类型为future",normalizedTitle:"返回类型为future",charIndex:1297}],headersStr:"返回类型为LiteflowResponse 返回类型为上下文Bean 返回类型为Future",content:"执行器FlowExecutor用来执行一个流程，三种用法。\n\n\n# 返回类型为LiteflowResponse\n\n其中最经常用到的有3个方法：\n\n//参数为流程ID，无初始流程入参，返回类型为默认上下文泛型的Response\npublic LiteflowResponse<DefaultContext> execute2Resp(String chainId)\n//第一个参数为流程ID，第二个参数为流程入参。其中流程入参可以在组件中通过this.getRequestData()来获得。\npublic LiteflowResponse<DefaultContext> execute2Resp(String chainId, Object param);\n//第一个参数为流程ID，第二个参数为流程入参，第三个参数为自定义的上下文Bean类型\npublic <T> LiteflowResponse<T> execute2Resp(String chainId, Object param, Class<T> contextBeanClazz)\n\n\n如果你不定义自己的上下文Bean，那么前2个能满足，LiteFlow提供了默认的上下文DefaultContext。但是这个上下文是弱类型的。所以对于正常的业务，请使用第三个接口。前2个在一些简单的场景和测试场景中可以使用。\n\n第三个适用于你定义了自己的上下文Bean的场景。适用于大多数的业务，推荐使用。\n\n并且这里强烈推荐在业务系统中实现属于自己的上下文Bean。详情请参考数据上下文。\n\n提示\n\n你可以通过LiteflowResponse中的isSuccess()方法来判断链路是否执行成功。\n\n这三个执行方法是不会抛出异常的，如果执行的链路有错误，你可以通过LiteflowResponse的getCause方法来获得。如要抛出异常，请自行抛出。\n\n关于LiteflowResponse的详细描述请参考Response对象。\n\n\n# 返回类型为上下文Bean\n\n同样的，经常用到的也有3个接口\n\n//参数为流程ID，无初始流程入参\npublic DefaultContext execute(String chainId) throws Exception;\n//第一个参数为流程ID，第二个参数为流程入参。其中流程入参可以在组件中通过this.getRequestData()来获得。\npublic DefaultContext execute(String chainId,Object param) throws Exception;\n//第一个参数为流程ID，第二个参数为流程入参，第三个参数为自定义的上下文类型\npublic <T> T execute(String chainId, Object param, Class<T> contextBeanClazz) throws Exception\n\n\n在这种执行接口中，如果链路有错，会直接抛出错误来。\n\n关于上下文Bean，想要了解更多，请参考数据上下文。\n\n\n# 返回类型为Future\n\nLiteFlow从2.6.13开始支持了执行器层面的异步，支持返回future。\n\n//第一个参数为流程ID，第二个参数为流程入参，第三个参数为自定义的上下文Bean类型\npublic <T> Future<LiteflowResponse<T>> execute2Future(String chainId, Object param, Class<T> contextBeanClazz)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到reponse，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，LiteFlow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现ExecutorBuilder接口：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n",normalizedContent:"执行器flowexecutor用来执行一个流程，三种用法。\n\n\n# 返回类型为liteflowresponse\n\n其中最经常用到的有3个方法：\n\n//参数为流程id，无初始流程入参，返回类型为默认上下文泛型的response\npublic liteflowresponse<defaultcontext> execute2resp(string chainid)\n//第一个参数为流程id，第二个参数为流程入参。其中流程入参可以在组件中通过this.getrequestdata()来获得。\npublic liteflowresponse<defaultcontext> execute2resp(string chainid, object param);\n//第一个参数为流程id，第二个参数为流程入参，第三个参数为自定义的上下文bean类型\npublic <t> liteflowresponse<t> execute2resp(string chainid, object param, class<t> contextbeanclazz)\n\n\n如果你不定义自己的上下文bean，那么前2个能满足，liteflow提供了默认的上下文defaultcontext。但是这个上下文是弱类型的。所以对于正常的业务，请使用第三个接口。前2个在一些简单的场景和测试场景中可以使用。\n\n第三个适用于你定义了自己的上下文bean的场景。适用于大多数的业务，推荐使用。\n\n并且这里强烈推荐在业务系统中实现属于自己的上下文bean。详情请参考数据上下文。\n\n提示\n\n你可以通过liteflowresponse中的issuccess()方法来判断链路是否执行成功。\n\n这三个执行方法是不会抛出异常的，如果执行的链路有错误，你可以通过liteflowresponse的getcause方法来获得。如要抛出异常，请自行抛出。\n\n关于liteflowresponse的详细描述请参考response对象。\n\n\n# 返回类型为上下文bean\n\n同样的，经常用到的也有3个接口\n\n//参数为流程id，无初始流程入参\npublic defaultcontext execute(string chainid) throws exception;\n//第一个参数为流程id，第二个参数为流程入参。其中流程入参可以在组件中通过this.getrequestdata()来获得。\npublic defaultcontext execute(string chainid,object param) throws exception;\n//第一个参数为流程id，第二个参数为流程入参，第三个参数为自定义的上下文类型\npublic <t> t execute(string chainid, object param, class<t> contextbeanclazz) throws exception\n\n\n在这种执行接口中，如果链路有错，会直接抛出错误来。\n\n关于上下文bean，想要了解更多，请参考数据上下文。\n\n\n# 返回类型为future\n\nliteflow从2.6.13开始支持了执行器层面的异步，支持返回future。\n\n//第一个参数为流程id，第二个参数为流程入参，第三个参数为自定义的上下文bean类型\npublic <t> future<liteflowresponse<t>> execute2future(string chainid, object param, class<t> contextbeanclazz)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到reponse，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，liteflow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现executorbuilder接口：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"Response对象",frontmatter:{title:"Response对象",date:"2022-06-03T00:51:00.000Z",permalink:"/pages/v2.7.X/db0fab/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/045.Response%E5%AF%B9%E8%B1%A1.html",relativePath:"20.v2.7.X文档/060.使用详细指南/045.Response对象.md",key:"v-22de3825",path:"/pages/v2.7.X/db0fab/",headers:[{level:2,title:"流程执行是否成功",slug:"流程执行是否成功",normalizedTitle:"流程执行是否成功",charIndex:69},{level:2,title:"获取异常信息",slug:"获取异常信息",normalizedTitle:"获取异常信息",charIndex:255},{level:2,title:"获得执行步骤详细信息",slug:"获得执行步骤详细信息",normalizedTitle:"获得执行步骤详细信息",charIndex:487},{level:2,title:"上下文数据",slug:"上下文数据",normalizedTitle:"上下文数据",charIndex:723},{level:2,title:"获得步骤字符串信息",slug:"获得步骤字符串信息",normalizedTitle:"获得步骤字符串信息",charIndex:976}],headersStr:"流程执行是否成功 获取异常信息 获得执行步骤详细信息 上下文数据 获得步骤字符串信息",content:'在执行器返回中，用的最多的就是返回一个LiteFlowResponse<T>对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nLiteflowResponse<CustomContext> response = flowExecutor.execute("chain1", "初始参数", CustomContext.class);\nboolean isSuccess = response.isSuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程isSuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nLiteflowResponse<CustomContext> response = flowExecutor.execute("chain1", "初始参数", CustomContext.class);\nif (!response.isSuccess()){\n  Exception e = response.getCause();\n}\n\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过以下方法来获取：\n\nLiteflowResponse<CustomContext> response = flowExecutor.execute("chain1", "初始参数", CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n\n\n关于步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了LiteFlowResponse对象之后，可以这样获得上下文Bean：\n\nLiteflowResponse<CustomContext> response = flowExecutor.execute("chain1", "初始参数", CustomContext.class);\nCustomContext context = response.getContextBean();\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nLiteflowResponse<CustomContext> response = flowExecutor.execute("chain1", "初始参数", CustomContext.class);\nString stepStr = response.getExecuteStepStr();\n\n\n这个字符串打印出来结果如下：\n\na[组件A]<201>==>b[组件B]<300>==>m[组件M]<1205>\n\n\n这里的表达形式为组件ID[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getExecuteStepStrWithoutTime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',normalizedContent:'在执行器返回中，用的最多的就是返回一个liteflowresponse<t>对象。\n\n这个对象里面包含了很多结果数据和过程数据。\n\n\n# 流程执行是否成功\n\n你可以通过以下方法来判断一个流程是否执行成功：\n\nliteflowresponse<customcontext> response = flowexecutor.execute("chain1", "初始参数", customcontext.class);\nboolean issuccess = response.issuccess();\n\n\n\n# 获取异常信息\n\n如果一个流程issuccess为false，则必然有异常信息，你可以通过以下方法来获得异常：\n\nliteflowresponse<customcontext> response = flowexecutor.execute("chain1", "初始参数", customcontext.class);\nif (!response.issuccess()){\n  exception e = response.getcause();\n}\n\n\n\n# 获得执行步骤详细信息\n\n结果信息中也封装了流程执行每一步的详细信息，你可以通过以下方法来获取：\n\nliteflowresponse<customcontext> response = flowexecutor.execute("chain1", "初始参数", customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n\n\n关于步骤信息的详细请参考步骤信息。\n\n\n# 上下文数据\n\n流程在执行过程中，会对上下文数据进行读写操作。一个流程的返回数据也应当包含在上下文中。\n\n你获得了liteflowresponse对象之后，可以这样获得上下文bean：\n\nliteflowresponse<customcontext> response = flowexecutor.execute("chain1", "初始参数", customcontext.class);\ncustomcontext context = response.getcontextbean();\n\n\n\n# 获得步骤字符串信息\n\n获得一个简单易懂的组件步骤的字符串拼装信息：\n\nliteflowresponse<customcontext> response = flowexecutor.execute("chain1", "初始参数", customcontext.class);\nstring stepstr = response.getexecutestepstr();\n\n\n这个字符串打印出来结果如下：\n\na[组件a]<201>==>b[组件b]<300>==>m[组件m]<1205>\n\n\n这里的表达形式为组件id[组件别名]<耗时毫秒>。关于如何设置组件别名可以参考组件别名。\n\n同时，response对象里还提供了getexecutestepstrwithouttime这个方法，用于返回不带有耗时时间的步骤字符串。\n\n提示\n\n事实上，在每一个流程执行结束后，框架会自动打印这个步骤字符串，所以无需你自己获取打印。\n\n这里只是说明如何获取，如果你要持久化下来，可以这样获取。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"条件组件",frontmatter:{title:"条件组件",date:"2022-06-01T13:22:11.000Z",permalink:"/pages/v2.7.X/c284f7/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/060.%E6%9D%A1%E4%BB%B6%E7%BB%84%E4%BB%B6.html",relativePath:"20.v2.7.X文档/060.使用详细指南/060.条件组件.md",key:"v-706f6f58",path:"/pages/v2.7.X/c284f7/",headersStr:null,content:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点\n\n<chain name="chain1">\n    <then value="a,c(b|d)"/> \x3c!-- c是路由节点，根据c里的逻辑决定路由到b节点还是d节点,可以配置多个 --\x3e\n    <then value="e,f,g"/>\n</chain>\n\n\n利用表达式可以很方便的进行条件的判断\n\nc节点是用来路由的，被称为条件节点，这种节点需要继承NodeCondComponent类\n\n需要实现方法processCond，这个方法需要返回String类型，就是具体的结果节点\n\n@LiteflowComponent("e")\npublic class ECmp extends NodeCondComponent {\n\n    @Override\n    public String processCond() throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n提示\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点\n\n<chain name="chain1">\n    <then value="a,c(b|d)"/> \x3c!-- c是路由节点，根据c里的逻辑决定路由到b节点还是d节点,可以配置多个 --\x3e\n    <then value="e,f,g"/>\n</chain>\n\n\n利用表达式可以很方便的进行条件的判断\n\nc节点是用来路由的，被称为条件节点，这种节点需要继承nodecondcomponent类\n\n需要实现方法processcond，这个方法需要返回string类型，就是具体的结果节点\n\n@liteflowcomponent("e")\npublic class ecmp extends nodecondcomponent {\n\n    @override\n    public string processcond() throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n提示\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"普通组件",frontmatter:{title:"普通组件",date:"2022-06-01T13:19:34.000Z",permalink:"/pages/v2.7.X/aab3f7/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/050.%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6.html",relativePath:"20.v2.7.X文档/060.使用详细指南/050.普通组件.md",key:"v-14aed509",path:"/pages/v2.7.X/aab3f7/",headers:[{level:2,title:"可以覆盖的方法",slug:"可以覆盖的方法",normalizedTitle:"可以覆盖的方法",charIndex:192},{level:3,title:"isAccess",slug:"isaccess",normalizedTitle:"isaccess",charIndex:226},{level:3,title:"isContinueOnError",slug:"iscontinueonerror",normalizedTitle:"iscontinueonerror",charIndex:279},{level:3,title:"isEnd",slug:"isend",normalizedTitle:"isend",charIndex:329},{level:3,title:"beforeProcess和afterProcess",slug:"beforeprocess和afterprocess",normalizedTitle:"beforeprocess和afterprocess",charIndex:524},{level:3,title:"onSuccess和onError",slug:"onsuccess和onerror",normalizedTitle:"onsuccess和onerror",charIndex:654},{level:2,title:"This关键字可以调用的方法",slug:"this关键字可以调用的方法",normalizedTitle:"this关键字可以调用的方法",charIndex:702},{level:3,title:"获取上下文",slug:"获取上下文",normalizedTitle:"获取上下文",charIndex:721},{level:3,title:"getNodeId",slug:"getnodeid",normalizedTitle:"getnodeid",charIndex:792},{level:3,title:"getName",slug:"getname",normalizedTitle:"getname",charIndex:815},{level:3,title:"getChainName",slug:"getchainname",normalizedTitle:"getchainname",charIndex:836},{level:3,title:"getRequestData",slug:"getrequestdata",normalizedTitle:"getrequestdata",charIndex:867},{level:3,title:"setIsEnd",slug:"setisend",normalizedTitle:"setisend",charIndex:470},{level:3,title:"getTag",slug:"gettag",normalizedTitle:"gettag",charIndex:1098},{level:2,title:"@LiteflowComponent",slug:"liteflowcomponent",normalizedTitle:"@liteflowcomponent",charIndex:39}],headersStr:"可以覆盖的方法 isAccess isContinueOnError isEnd beforeProcess和afterProcess onSuccess和onError This关键字可以调用的方法 获取上下文 getNodeId getName getChainName getRequestData setIsEnd getTag @LiteflowComponent",content:'组件节点需要继承NodeComponent类\n\n需要实现process方法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isAccess\n\n推荐实现isAccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# isContinueOnError\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isEnd\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# beforeProcess和afterProcess\n\n流程的前置和后置处理器，其中前置处理器，在isAccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onSuccess和onError\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# This关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getContextBean获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getNodeId\n\n获取组件ID。\n\n\n# getName\n\n获取组件别名。\n\n\n# getChainName\n\n获取当前执行的流程名称。\n\n\n# getRequestData\n\n获取流程的初始参数。\n\n\n# setIsEnd\n\n表示是否立即结束整个流程 ，用法为this.setIsEnd(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的isSuccess是为true的。\n\n提示\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# getTag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签;\n\n\n# @LiteflowComponent\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'组件节点需要继承nodecomponent类\n\n需要实现process方法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 可以覆盖的方法\n\n对于组件来说，可以覆盖超类中的以下方法。\n\n\n# isaccess\n\n推荐实现isaccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# iscontinueonerror\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isend\n\n如果覆盖后，返回true，则表示在这个组件执行完之后立马终止整个流程。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# beforeprocess和afterprocess\n\n流程的前置和后置处理器，其中前置处理器，在isaccess 之后执行。\n\n用于执行一些前置和后置处理，但是一般这个用不上。如果是统一做组件前置和后置，推荐用切面去完成。关于切面可以参考组件切面;\n\n\n# onsuccess和onerror\n\n流程的成功失败事件回调，详情请参考组件事件回调。\n\n\n# this关键字可以调用的方法\n\n\n# 获取上下文\n\n在组件节点里，随时可以通过方法this.getcontextbean获取当前你自己定义的上下文，从而可以获取任何数据。\n\n\n# getnodeid\n\n获取组件id。\n\n\n# getname\n\n获取组件别名。\n\n\n# getchainname\n\n获取当前执行的流程名称。\n\n\n# getrequestdata\n\n获取流程的初始参数。\n\n\n# setisend\n\n表示是否立即结束整个流程 ，用法为this.setisend(true)。对于这种方式，由于是用户主动结束的流程，属于正常结束，所以最终的issuccess是为true的。\n\n提示\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# gettag\n\n获取这个组件的标签信息，关于标签的定义和使用，请参照组件标签;\n\n\n# @liteflowcomponent\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看打印信息详解章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"脚本组件",frontmatter:{title:"脚本组件",date:"2022-06-01T13:23:44.000Z",permalink:"/pages/v2.7.X/504b45/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/070.%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6.html",relativePath:"20.v2.7.X文档/060.使用详细指南/070.脚本组件.md",key:"v-ddcfc118",path:"/pages/v2.7.X/504b45/",headers:[{level:2,title:"如何定义",slug:"如何定义",normalizedTitle:"如何定义",charIndex:129},{level:2,title:"文件脚本的定义",slug:"文件脚本的定义",normalizedTitle:"文件脚本的定义",charIndex:1045},{level:2,title:"如何与java变量进行交互",slug:"如何与java变量进行交互",normalizedTitle:"如何与java变量进行交互",charIndex:1643},{level:2,title:"如何选择脚本框架",slug:"如何选择脚本框架",normalizedTitle:"如何选择脚本框架",charIndex:1870},{level:2,title:"脚本运行性能如何",slug:"脚本运行性能如何",normalizedTitle:"脚本运行性能如何",charIndex:2296},{level:2,title:"如何动态刷新脚本",slug:"如何动态刷新脚本",normalizedTitle:"如何动态刷新脚本",charIndex:2366}],headersStr:"如何定义 文件脚本的定义 如何与java变量进行交互 如何选择脚本框架 脚本运行性能如何 如何动态刷新脚本",content:'LiteFlow从v2.6.0开始支持脚本节点的创建。支持热刷新脚本，支持QLExpress和Groovy两种脚本的编写。\n\n关于这两种脚本语言的语法，可能提前大家要稍加熟悉，这里给出两个教程：\n\nGroovy语法教程\n\nQLExpress语法教程\n\n\n# 如何定义\n\n脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script">\n            <![CDATA[\n                a=3;\n                b=2;\n                context.setData("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="条件脚本" type="cond_script">\n            <![CDATA[\n                count = context.getData("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n要注意的是，type分为两种：script 和cond_script，分别对应普通脚本组件和条件脚本组件。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n这里示例是传入的上下文bean是默认的DefaultContext，如果是你自定义的上下文Bean，请调用相应的方法来设置和获取数据。\n\n\n# 文件脚本的定义\n\nLiteFlow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟IDE对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前LiteFlow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="条件脚本" type="cond_script" file="xml-script-file/s2.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n\n# 如何与java变量进行交互\n\n因为LiteFlow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，内置了关键字context，你可以通过这个关键字来获取，设值任何数据。甚至于是调用你上下文中的一些方法都可以。\n\n普通脚本组件，脚本中无需返回值。只需要把结果设置到context即可（这和普通的java编写的组件是一致的）\n\n而条件脚本节点，则需要在脚本中返回条件路由到的节点ID，返回String类型（这也和java编写的组件是一致的）\n\n\n# 如何选择脚本框架\n\nLiteFlow采用SPI机制进行选择脚本框架来动态编译你的脚本。\n\nQLExpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-qlexpress</artifactId>\n    <version>2.7.3</version>\n</dependency>\n\n\nGroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-groovy</artifactId>\n    <version>2.7.3</version>\n</dependency>\n\n\n你只需要依赖相应的脚本框架即可，SPI会动态选择你依赖的脚本框架进行编译解析你的脚本\n\n\n# 脚本运行性能如何\n\nLiteFlow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。\n\n\n# 如何动态刷新脚本\n\n提供了编码形式的刷新，刷新后可以重新编译脚本\n\nScriptExecutorFactory.loadInstance().getScriptExecutor().load(nodeId, script);\n',normalizedContent:'liteflow从v2.6.0开始支持脚本节点的创建。支持热刷新脚本，支持qlexpress和groovy两种脚本的编写。\n\n关于这两种脚本语言的语法，可能提前大家要稍加熟悉，这里给出两个教程：\n\ngroovy语法教程\n\nqlexpress语法教程\n\n\n# 如何定义\n\n脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script">\n            <![cdata[\n                a=3;\n                b=2;\n                context.setdata("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="条件脚本" type="cond_script">\n            <![cdata[\n                count = context.getdata("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n要注意的是，type分为两种：script 和cond_script，分别对应普通脚本组件和条件脚本组件。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n提示\n\n这里示例是传入的上下文bean是默认的defaultcontext，如果是你自定义的上下文bean，请调用相应的方法来设置和获取数据。\n\n\n# 文件脚本的定义\n\nliteflow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟ide对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前liteflow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="条件脚本" type="cond_script" file="xml-script-file/s2.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n\n# 如何与java变量进行交互\n\n因为liteflow组件与组件之间的数据交互都在上下文中，所以在脚本语言中，内置了关键字context，你可以通过这个关键字来获取，设值任何数据。甚至于是调用你上下文中的一些方法都可以。\n\n普通脚本组件，脚本中无需返回值。只需要把结果设置到context即可（这和普通的java编写的组件是一致的）\n\n而条件脚本节点，则需要在脚本中返回条件路由到的节点id，返回string类型（这也和java编写的组件是一致的）\n\n\n# 如何选择脚本框架\n\nliteflow采用spi机制进行选择脚本框架来动态编译你的脚本。\n\nqlexpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-qlexpress</artifactid>\n    <version>2.7.3</version>\n</dependency>\n\n\ngroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-groovy</artifactid>\n    <version>2.7.3</version>\n</dependency>\n\n\n你只需要依赖相应的脚本框架即可，spi会动态选择你依赖的脚本框架进行编译解析你的脚本\n\n\n# 脚本运行性能如何\n\nliteflow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。\n\n\n# 如何动态刷新脚本\n\n提供了编码形式的刷新，刷新后可以重新编译脚本\n\nscriptexecutorfactory.loadinstance().getscriptexecutor().load(nodeid, script);\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件标签",frontmatter:{title:"组件标签",date:"2022-06-01T13:31:50.000Z",permalink:"/pages/v2.7.X/c7d5f3/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/100.%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE.html",relativePath:"20.v2.7.X文档/060.使用详细指南/100.组件标签.md",key:"v-3b6e0af2",path:"/pages/v2.7.X/c7d5f3/",headersStr:null,content:'你可以在流程xml/json/yml里为每个组件加上单独的标签，如这样：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],b[tag2],c[tag3]"/>\n    </chain>\n</flow>\n\n\n这样，你在代码里可以通过this.getTag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到当前执行到哪里。或者根据tag标签来给相同的组件作不同的判断。\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        String tag = this.getTag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],a[tag2],a[tag3],b[tag4](c[tag5]|d[tag6])"/>\n    </chain>\n</flow>\n',normalizedContent:'你可以在流程xml/json/yml里为每个组件加上单独的标签，如这样：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],b[tag2],c[tag3]"/>\n    </chain>\n</flow>\n\n\n这样，你在代码里可以通过this.gettag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到当前执行到哪里。或者根据tag标签来给相同的组件作不同的判断。\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n    @override\n    public void process() {\n        string tag = this.gettag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],a[tag2],a[tag3],b[tag4](c[tag5]|d[tag6])"/>\n    </chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"声明式组件",frontmatter:{title:"声明式组件",date:"2022-06-01T13:28:37.000Z",permalink:"/pages/v2.7.X/9a30d2/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/080.%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6.html",relativePath:"20.v2.7.X文档/060.使用详细指南/080.声明式组件.md",key:"v-67ee27c8",path:"/pages/v2.7.X/9a30d2/",headers:[{level:2,title:"普通组件的声明",slug:"普通组件的声明",normalizedTitle:"普通组件的声明",charIndex:232},{level:2,title:"条件组件的声明",slug:"条件组件的声明",normalizedTitle:"条件组件的声明",charIndex:1667},{level:2,title:"关于实现",slug:"关于实现",normalizedTitle:"关于实现",charIndex:1962}],headersStr:"普通组件的声明 条件组件的声明 关于实现",content:'LiteFlow从2.6.14起开始支持声明式的组件。\n\n何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承NodeComponent或者NodeCondComponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成LiteFlow组件的声明。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@LiteflowComponent("a")\n@LiteflowCmpDefine\npublic class ACmp{\n  \n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS)\n\tpublic void processAcmp(NodeComponent bindCmp) {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)\n\tpublic boolean isAcmpAccess(NodeComponent bindCmp){\n\t\treturn true;\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.BEFORE_PROCESS)\n\tpublic void beforeAcmp(String nodeId, Slot<DefaultContext> slot){\n\t\tSystem.out.println("before A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.AFTER_PROCESS)\n\tpublic void afterAcmp(String nodeId, Slot<DefaultContext> slot){\n\t\tSystem.out.println("after A");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_SUCCESS)\n\tpublic void onAcmpSuccess(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp success");\n\t}\n\n\t@LiteflowMethod(LiteFlowMethodEnum.ON_ERROR)\n\tpublic void onAcmpError(NodeComponent bindCmp){\n\t\tSystem.out.println("Acmp error");\n\t}\n\t\n\t@LiteflowMethod(LiteFlowMethodEnum.IS_END)\n\tpublic boolean isAcmpEnd(NodeComponent bindCmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承NodeCondComponent了，在你定义的类上，只要类上加上LiteflowCmpDefine注解，相应的方法上加上LiteflowMethod注解，即可完成对任意自定义类的组件化工作。\n\n其中LiteFlowMethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n提示\n\n这里注意的是，大部分方法上参数必须传入NodeComponent bindCmp这个参数，而且必须只有一个参数，否则会报错，而beforeProcess和afterProcess还是按照以前的参数定义。这点要注意下，可以查看上面的示例。\n\n以前获取上下文Bean是用this关键字，现在只需从bindCmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n\n# 条件组件的声明\n\n声明条件组件和普通组件差不多，如下所示：\n\n@Component("e")\n@LiteflowCondCmpDefine\npublic class ECmp{\n\n    @LiteflowMethod(LiteFlowMethodEnum.PROCESS_COND)\n    public String processCond(NodeComponent bindCmp) throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 关于实现\n\n声明式组件依靠动态代理来实现，底层用的动态代理框架为ByteBuddy。\n\n所有的动态代理类在注册时类名均做了处理，所以你会看到如下的日志打印\n\n2022-05-16 13:05:56.492  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$a$JLWBAK   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$a$JLWBAK] execution\n2022-05-16 13:05:56.496  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$b$JZXUWG   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$b$JZXUWG] execution\n2022-05-16 13:05:56.505  INFO 73054 --- [lf-when-thead-0] c.y.l.test.base.cmp.ByteBuddy$c$RWWUCJ   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$c$RWWUCJ] execution\n2022-05-16 13:05:56.506  INFO 73054 --- [lf-when-thead-1] c.y.l.test.base.cmp.ByteBuddy$d$RECNPY   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$d$RECNPY] execution\n\n\n仔细看会发现，所有的动态代理后的类名的格式为：ByteBuddy$你的组件名$随机6位字符串。\n\n所以在看日志时，对于声明式组件而言，你只需要看两个$中间的那个，即为你的组件ID。这点怕有人有疑惑，特地说明一下。',normalizedContent:'liteflow从2.6.14起开始支持声明式的组件。\n\n何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承nodecomponent或者nodecondcomponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成liteflow组件的声明。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@liteflowcomponent("a")\n@liteflowcmpdefine\npublic class acmp{\n  \n\t@liteflowmethod(liteflowmethodenum.process)\n\tpublic void processacmp(nodecomponent bindcmp) {\n\t\tsystem.out.println("acmp executed!");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.is_access)\n\tpublic boolean isacmpaccess(nodecomponent bindcmp){\n\t\treturn true;\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.before_process)\n\tpublic void beforeacmp(string nodeid, slot<defaultcontext> slot){\n\t\tsystem.out.println("before a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.after_process)\n\tpublic void afteracmp(string nodeid, slot<defaultcontext> slot){\n\t\tsystem.out.println("after a");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_success)\n\tpublic void onacmpsuccess(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp success");\n\t}\n\n\t@liteflowmethod(liteflowmethodenum.on_error)\n\tpublic void onacmperror(nodecomponent bindcmp){\n\t\tsystem.out.println("acmp error");\n\t}\n\t\n\t@liteflowmethod(liteflowmethodenum.is_end)\n\tpublic boolean isacmpend(nodecomponent bindcmp) {\n\t\treturn false;\n\t}\n}\n\n\n使用者无需继承nodecondcomponent了，在你定义的类上，只要类上加上liteflowcmpdefine注解，相应的方法上加上liteflowmethod注解，即可完成对任意自定义类的组件化工作。\n\n其中liteflowmethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n提示\n\n这里注意的是，大部分方法上参数必须传入nodecomponent bindcmp这个参数，而且必须只有一个参数，否则会报错，而beforeprocess和afterprocess还是按照以前的参数定义。这点要注意下，可以查看上面的示例。\n\n以前获取上下文bean是用this关键字，现在只需从bindcmp中获取就可以了。\n\n方法的名称可以定义成你想要的任何方式。这个并无限制。\n\n\n# 条件组件的声明\n\n声明条件组件和普通组件差不多，如下所示：\n\n@component("e")\n@liteflowcondcmpdefine\npublic class ecmp{\n\n    @liteflowmethod(liteflowmethodenum.process_cond)\n    public string processcond(nodecomponent bindcmp) throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 关于实现\n\n声明式组件依靠动态代理来实现，底层用的动态代理框架为bytebuddy。\n\n所有的动态代理类在注册时类名均做了处理，所以你会看到如下的日志打印\n\n2022-05-16 13:05:56.492  info 73054 --- [           main] c.y.l.test.base.cmp.bytebuddy$a$jlwbak   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$a$jlwbak] execution\n2022-05-16 13:05:56.496  info 73054 --- [           main] c.y.l.test.base.cmp.bytebuddy$b$jzxuwg   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$b$jzxuwg] execution\n2022-05-16 13:05:56.505  info 73054 --- [lf-when-thead-0] c.y.l.test.base.cmp.bytebuddy$c$rwwucj   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$c$rwwucj] execution\n2022-05-16 13:05:56.506  info 73054 --- [lf-when-thead-1] c.y.l.test.base.cmp.bytebuddy$d$recnpy   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$d$recnpy] execution\n\n\n仔细看会发现，所有的动态代理后的类名的格式为：bytebuddy$你的组件名$随机6位字符串。\n\n所以在看日志时，对于声明式组件而言，你只需要看两个$中间的那个，即为你的组件id。这点怕有人有疑惑，特地说明一下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"前置后置组件",frontmatter:{title:"前置后置组件",date:"2022-06-01T13:30:51.000Z",permalink:"/pages/v2.7.X/bedc2a/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/090.%E5%89%8D%E7%BD%AE%E5%90%8E%E7%BD%AE%E7%BB%84%E4%BB%B6.html",relativePath:"20.v2.7.X文档/060.使用详细指南/090.前置后置组件.md",key:"v-57a40646",path:"/pages/v2.7.X/bedc2a/",headers:[{level:2,title:"前置组件",slug:"前置组件",normalizedTitle:"前置组件",charIndex:20},{level:2,title:"后置节点",slug:"后置节点",normalizedTitle:"后置节点",charIndex:273},{level:2,title:"顺序问题",slug:"顺序问题",normalizedTitle:"顺序问题",charIndex:460}],headersStr:"前置组件 后置节点 顺序问题",content:'LiteFlow从2.6.4开始，支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点。表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain1">\n    <pre value="p1,p2"/>\n    <then value="a,b,c"/>\n    <when value="d,e"/>\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受Exception影响，即便节点出错，后置节点依旧会执行。\n\n表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain3">\n    <then value="a,d,c"/>\n    <finally value="f1,f2"/>\n</chain>\n\n\n\n# 顺序问题\n\n为了方便阅读，推荐大家<pre>写在最前面，而<finally>写在最后面。\n\n但是从逻辑上来说，LiteFlow会自动进行排序处理，无论你<pre>和<finally>写在哪里，总会优先执行<pre>，最后执行<finally>。',normalizedContent:'liteflow从2.6.4开始，支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点。表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain1">\n    <pre value="p1,p2"/>\n    <then value="a,b,c"/>\n    <when value="d,e"/>\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受exception影响，即便节点出错，后置节点依旧会执行。\n\n表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain3">\n    <then value="a,d,c"/>\n    <finally value="f1,f2"/>\n</chain>\n\n\n\n# 顺序问题\n\n为了方便阅读，推荐大家<pre>写在最前面，而<finally>写在最后面。\n\n但是从逻辑上来说，liteflow会自动进行排序处理，无论你<pre>和<finally>写在哪里，总会优先执行<pre>，最后执行<finally>。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件别名",frontmatter:{title:"组件别名",date:"2022-06-03T19:00:33.000Z",permalink:"/pages/v2.7.X/4c74f0/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/095.%E7%BB%84%E4%BB%B6%E5%88%AB%E5%90%8D.html",relativePath:"20.v2.7.X文档/060.使用详细指南/095.组件别名.md",key:"v-235f254c",path:"/pages/v2.7.X/4c74f0/",headers:[{level:2,title:"Springboot & Spring 扫描方式",slug:"springboot-spring-扫描方式",normalizedTitle:"springboot &amp; spring 扫描方式",charIndex:null},{level:2,title:"规则文件方式定义组件",slug:"规则文件方式定义组件",normalizedTitle:"规则文件方式定义组件",charIndex:381},{level:2,title:"打印",slug:"打印",normalizedTitle:"打印",charIndex:49}],headersStr:"Springboot & Spring 扫描方式 规则文件方式定义组件 打印",content:'LiteFlow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# Springboot & Spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@Component换成@LiteflowComponent，并做如下定义：\n\n@LiteflowComponent(id = "a", name = "组件A")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件A" class="com.yomahub.liteflow.test.config.cmp.ACmp"/>\n<node id="b" name="组件B" class="com.yomahub.liteflow.test.config.cmp.BCmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',normalizedContent:'liteflow支持了组件别名的设置，一般用来填写中文名称，方便记忆的名称。\n\n设置了组件别名，在打印出步骤信息的时候，会带上相应别名。\n\n组件别名的设置分两种情况\n\n\n# springboot & spring 扫描方式\n\n大多数情况下，很多人使用的都是springboot/spring框架，那么只需要做如下改变\n\n你定义的组件中，把@component换成@liteflowcomponent，并做如下定义：\n\n@liteflowcomponent(id = "a", name = "组件a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n在非spring体系的工程里，组件是需要定义在规则文件里的，那么需要做如下添加\n\n需要在<node>节点中加入name的属性\n\n<node id="a" name="组件a" class="com.yomahub.liteflow.test.config.cmp.acmp"/>\n<node id="b" name="组件b" class="com.yomahub.liteflow.test.config.cmp.bcmp"/>\n\n\n\n# 打印\n\n关于别名的打印请参照打印信息详解。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件事件回调",frontmatter:{title:"组件事件回调",date:"2022-06-07T00:24:41.000Z",permalink:"/pages/v2.7.X/d22f8f/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/105.%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83.html",relativePath:"20.v2.7.X文档/060.使用详细指南/105.组件事件回调.md",key:"v-cdd68b34",path:"/pages/v2.7.X/d22f8f/",headers:[{level:2,title:"成功事件",slug:"成功事件",normalizedTitle:"成功事件",charIndex:42},{level:2,title:"失败事件",slug:"失败事件",normalizedTitle:"失败事件",charIndex:47},{level:3,title:"注意点1",slug:"注意点1",normalizedTitle:"注意点1",charIndex:782},{level:3,title:"注意点2",slug:"注意点2",normalizedTitle:"注意点2",charIndex:852},{level:3,title:"注意点3",slug:"注意点3",normalizedTitle:"注意点3",charIndex:1322}],headersStr:"成功事件 失败事件 注意点1 注意点2 注意点3",content:'LiteFlow从2.7.1版本开始，支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onSuccess方法，那么组件成功后会回调这个方法。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tDefaultContext context = this.getContextBean();\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void onSuccess() throws Exception {\n\t\tDefaultContext context = this.getContextBean();\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onError方法，那么组件发生异常后会回调这个方法。\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError() throws Exception {\n\t\tDefaultContext context = this.getContextBean();\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonError方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onError方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onError方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@Component("d")\npublic class DCmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() throws Exception{\n\t\t//mock throw exception\n\t\tthrow new NullPointerException();\n\t}\n\n\t@Override\n\tpublic void onError() throws Exception {\n\t\tthrow new IllegalAccessException("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是NullPointerException而不是IllegalAccessException，但是IllegalAccessException这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonError方法执行后，afterProcess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterProcess方法都会被执行。',normalizedContent:'liteflow从2.7.1版本开始，支持了组件事件回调。目前支持的事件有2个，组件成功事件和失败事件。\n\n\n# 成功事件\n\n如果你在组件里覆盖了onsuccess方法，那么组件成功后会回调这个方法。\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tdefaultcontext context = this.getcontextbean();\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void onsuccess() throws exception {\n\t\tdefaultcontext context = this.getcontextbean();\n\t\t//do your biz\n\t}\n}\n\n\n在成功事件里，你可以通过同样的方法获取到上下文。\n\n\n# 失败事件\n\n如果你在组件中覆盖了onerror方法，那么组件发生异常后会回调这个方法。\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror() throws exception {\n\t\tdefaultcontext context = this.getcontextbean();\n\t\t//do your biz\n\t}\n}\n\n\n\n# 注意点1\n\nonerror方法执行后，因为主方法抛出异常，所以整个流程依旧是失败状态。response对象里依旧是主方法抛出的错。\n\n\n# 注意点2\n\n如果onerror方法本身抛错，那么最终抛到最外面的错，是主方法里的错，而onerror方法所产生的异常会被打出堆栈，但不会抛出。比如：\n\n@component("d")\npublic class dcmp extends nodecomponent {\n\n\t@override\n\tpublic void process() throws exception{\n\t\t//mock throw exception\n\t\tthrow new nullpointerexception();\n\t}\n\n\t@override\n\tpublic void onerror() throws exception {\n\t\tthrow new illegalaccessexception("错误事件回调本身抛出异常");\n\t}\n}\n\n\n那么最终response里的异常会是nullpointerexception而不是illegalaccessexception，但是illegalaccessexception这个异常会被打出堆栈信息。\n\n\n# 注意点3\n\nonerror方法执行后，afterprocess方法还会执行吗（假设都有实现）？\n\n会的，无论是否抛出错，afterprocess方法都会被执行。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"隐式子流程",frontmatter:{title:"隐式子流程",date:"2022-06-01T13:36:12.000Z",permalink:"/pages/v2.7.X/d36e61/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/120.%E9%9A%90%E5%BC%8F%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"20.v2.7.X文档/060.使用详细指南/120.隐式子流程.md",key:"v-54b99ca9",path:"/pages/v2.7.X/d36e61/",headersStr:null,content:'LiteFlow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用：\n\n@Component("h")\npublic class HComponent extends NodeComponent {\n\n\t@Resource\n\tprivate FlowExecutor flowExecutor;\n\t\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("Hcomponent executed!");\n        for(int i=0;i<10;i++){\n            flowExecutor.invoke("strategy1","隐式流程的初始参数，可为null", this.getSlotIndex());\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n同样，隐式子流程也支持返回LiteFlowResponse对象，需要调用invoke2Resp方法，关于返回对象为LiteFlowResponse的说明，请参照Response对象。\n\n注意\n\n隐式流程在组件中拿到传入的请求参数，通过this.getSubChainReqData()去拿，用this.getRequestData()是拿不到的！',normalizedContent:'liteflow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个上下文的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用：\n\n@component("h")\npublic class hcomponent extends nodecomponent {\n\n\t@resource\n\tprivate flowexecutor flowexecutor;\n\t\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("hcomponent executed!");\n        for(int i=0;i<10;i++){\n            flowexecutor.invoke("strategy1","隐式流程的初始参数，可为null", this.getslotindex());\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内循环调用另外一个流程链的方法。\n\n同样，隐式子流程也支持返回liteflowresponse对象，需要调用invoke2resp方法，关于返回对象为liteflowresponse的说明，请参照response对象。\n\n注意\n\n隐式流程在组件中拿到传入的请求参数，通过this.getsubchainreqdata()去拿，用this.getrequestdata()是拿不到的！',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件重试",frontmatter:{title:"组件重试",date:"2022-06-01T13:38:52.000Z",permalink:"/pages/v2.7.X/3f6ca1/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/140.%E7%BB%84%E4%BB%B6%E9%87%8D%E8%AF%95.html",relativePath:"20.v2.7.X文档/060.使用详细指南/140.组件重试.md",key:"v-696430cb",path:"/pages/v2.7.X/3f6ca1/",headers:[{level:2,title:"全局重试",slug:"全局重试",normalizedTitle:"全局重试",charIndex:31},{level:2,title:"单个组件重试",slug:"单个组件重试",normalizedTitle:"单个组件重试",charIndex:36},{level:2,title:"全局重试和单个组件重试都定义的情况下",slug:"全局重试和单个组件重试都定义的情况下",normalizedTitle:"全局重试和单个组件重试都定义的情况下",charIndex:986}],headersStr:"全局重试 单个组件重试 全局重试和单个组件重试都定义的情况下",content:'LiteFLow从v2.6.0起开始支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了isContinueOnError，设为true的话，那流程会继续。\n\n异步流程的话，如果<when>上配置了errorResume="true"的话(默认就是true)，则下一个不同并行组会继续。关于errorResume的定义和使用，可以查看同步异步编排章节\n\n\n# 单个组件重试\n\nLiteFlow还提供了基于单个组件，指定Exception的重试特性，LiteFlow从2.6.0开始提供了@LiteflowRetry标注\n\n你可以在指定的组件上进行标注：\n\n@LiteflowComponent("c")\n@LiteflowRetry(5)\npublic class CCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@LiteflowComponent("e")\n@LiteflowRetry(retry = 5, forExceptions = {NullPointerException.class,IllegalArgumentException.class})\npublic class ECmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是NullPointerException或者IllegalArgumentException（或者是这两个Exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',normalizedContent:'liteflow从v2.6.0起开始支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了iscontinueonerror，设为true的话，那流程会继续。\n\n异步流程的话，如果<when>上配置了errorresume="true"的话(默认就是true)，则下一个不同并行组会继续。关于errorresume的定义和使用，可以查看同步异步编排章节\n\n\n# 单个组件重试\n\nliteflow还提供了基于单个组件，指定exception的重试特性，liteflow从2.6.0开始提供了@liteflowretry标注\n\n你可以在指定的组件上进行标注：\n\n@liteflowcomponent("c")\n@liteflowretry(5)\npublic class ccmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@liteflowcomponent("e")\n@liteflowretry(retry = 5, forexceptions = {nullpointerexception.class,illegalargumentexception.class})\npublic class ecmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是nullpointerexception或者illegalargumentexception（或者是这两个exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"子流程",frontmatter:{title:"子流程",date:"2022-06-01T13:34:32.000Z",permalink:"/pages/v2.7.X/5821d4/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/110.%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"20.v2.7.X文档/060.使用详细指南/110.子流程.md",key:"v-c5da7924",path:"/pages/v2.7.X/5821d4/",headersStr:null,content:'LiteFlow从2.3.0开始支持显式子流程，在xml里配置的节点，可以是节点，也可以是流程id。比如，你可以这么配置\n\n<chain name="chain3">\n    <then value="a,c,strategy1,g"/>\n</chain>\n<chain name="strategy1">\n    <then value="m(m1|m2|strategy2)"/>\n</chain>\n<chain name="strategy2">\n    <then value="q,p(p1|p2)"/>\n</chain>\n\n\n这样是不是很清晰\n\nLiteFlow支持无穷的嵌套结构，只要你想的出。可以完成相对复杂的流程。\n\n提示\n\n如果存在相同名字的节点和流程，优先节点。',normalizedContent:'liteflow从2.3.0开始支持显式子流程，在xml里配置的节点，可以是节点，也可以是流程id。比如，你可以这么配置\n\n<chain name="chain3">\n    <then value="a,c,strategy1,g"/>\n</chain>\n<chain name="strategy1">\n    <then value="m(m1|m2|strategy2)"/>\n</chain>\n<chain name="strategy2">\n    <then value="q,p(p1|p2)"/>\n</chain>\n\n\n这样是不是很清晰\n\nliteflow支持无穷的嵌套结构，只要你想的出。可以完成相对复杂的流程。\n\n提示\n\n如果存在相同名字的节点和流程，优先节点。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"平滑热刷新",frontmatter:{title:"平滑热刷新",date:"2022-06-01T13:43:41.000Z",permalink:"/pages/v2.7.X/19c886/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/150.%E5%B9%B3%E6%BB%91%E7%83%AD%E5%88%B7%E6%96%B0.html",relativePath:"20.v2.7.X文档/060.使用详细指南/150.平滑热刷新.md",key:"v-16b5c4e2",path:"/pages/v2.7.X/19c886/",headers:[{level:2,title:"基于规则文件-主动刷新",slug:"基于规则文件-主动刷新",normalizedTitle:"基于规则文件-主动刷新",charIndex:263},{level:2,title:"基于规则文件-被动刷新",slug:"基于规则文件-被动刷新",normalizedTitle:"基于规则文件-被动刷新",charIndex:385},{level:2,title:"基于动态代码构建-刷新",slug:"基于动态代码构建-刷新",normalizedTitle:"基于动态代码构建-刷新",charIndex:658}],headersStr:"基于规则文件-主动刷新 基于规则文件-被动刷新 基于动态代码构建-刷新",content:"LiteFlow从2.6.4开始支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nLiteFlow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，LiteFlow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到FlowExecutor对象后，调用以下接口：\n\nflowExecutor.reloadRule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nFlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_JSON, newContent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",normalizedContent:"liteflow从2.6.4开始支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nliteflow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，liteflow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到flowexecutor对象后，调用以下接口：\n\nflowexecutor.reloadrule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nflowbus.refreshflowmetadata(flowparsertypeenum.type_json, newcontent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"私有投递",frontmatter:{title:"私有投递",date:"2022-06-01T13:38:09.000Z",permalink:"/pages/v2.7.X/7aa497/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/130.%E7%A7%81%E6%9C%89%E6%8A%95%E9%80%92.html",relativePath:"20.v2.7.X文档/060.使用详细指南/130.私有投递.md",key:"v-52983ae0",path:"/pages/v2.7.X/7aa497/",headers:[{level:2,title:"什么叫私有投递",slug:"什么叫私有投递",normalizedTitle:"什么叫私有投递",charIndex:34},{level:2,title:"解决方式",slug:"解决方式",normalizedTitle:"解决方式",charIndex:686}],headersStr:"什么叫私有投递 解决方式",content:'LiteFlow从2.6.0版本开始，开始支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个LiteFLow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n\n\n\n\n\n\n \n\n\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a"/>\n        \x3c!-- 5个相同的b组件并发执行 --\x3e\n        <when value="b,b,b,b,b"/>\n        <then value="c"/>\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，LiteFlow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t\tDefaultContext context = this.getContextBean();\n\t\tcontext.setData("testSet", new HashSet<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendPrivateDeliveryData("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendPrivateDeliveryData方法，指定了b组件\n\n然后我们再来看b组件：\n\n\n\n\n\n\n\n \n\n\n\n\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("BCmp executed!");\n\t\tInteger value = this.getPrivateDeliveryData();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getPrivateDeliveryData()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',normalizedContent:'liteflow从2.6.0版本开始，开始支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个liteflow的组件都共享同一个上下文。\n\n在一个请求中，上下文里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n\n\n\n\n\n\n \n\n\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a"/>\n        \x3c!-- 5个相同的b组件并发执行 --\x3e\n        <when value="b,b,b,b,b"/>\n        <then value="c"/>\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往上下文里放数据，其他组件可以取到a组件往上下文放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，liteflow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t\tdefaultcontext context = this.getcontextbean();\n\t\tcontext.setdata("testset", new hashset<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendprivatedeliverydata("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendprivatedeliverydata方法，指定了b组件\n\n然后我们再来看b组件：\n\n\n\n\n\n\n\n \n\n\n\n\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("bcmp executed!");\n\t\tinteger value = this.getprivatedeliverydata();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getprivatedeliverydata()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"打印信息详解",frontmatter:{title:"打印信息详解",date:"2022-06-01T13:53:58.000Z",permalink:"/pages/v2.7.X/85ae47/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/180.%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3.html",relativePath:"20.v2.7.X文档/060.使用详细指南/180.打印信息详解.md",key:"v-4a680961",path:"/pages/v2.7.X/85ae47/",headers:[{level:2,title:"流程执行中打印",slug:"流程执行中打印",normalizedTitle:"流程执行中打印",charIndex:2},{level:2,title:"打印步骤信息",slug:"打印步骤信息",normalizedTitle:"打印步骤信息",charIndex:558}],headersStr:"流程执行中打印 打印步骤信息",content:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[ACmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[BCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[X]start component[CCmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[O]start component[DCmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求ID，一个请求无论经历了多少个组件，他们的请求ID都是一致的，你可以根据这个ID在日志中进行快速定位进行排查。\n\n在后面会跟着一个[O]或者[X]，[O]代表了执行了这个组件的主要逻辑，[X]代表因为isAccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，LiteFlow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件ID<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件A]<100>==>b[组件B]<0>==>m[组件M]<256>\n\n\n这里的表达形式为：组件ID[组件别名]<耗时毫秒>",normalizedContent:"# 流程执行中打印\n\n在执行一条流程时，你在日志中会看到诸如以下的日志：\n\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[acmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[bcmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[x]start component[ccmp] execution\n[ea1af4810cc849d58948d091d858b29a]:[o]start component[dcmp] execution\n\n\n其中最前面的一串序号，代表这个请求的请求id，一个请求无论经历了多少个组件，他们的请求id都是一致的，你可以根据这个id在日志中进行快速定位进行排查。\n\n在后面会跟着一个[o]或者[x]，[o]代表了执行了这个组件的主要逻辑，[x]代表因为isaccess()返回了false所以没进入这个组件的主要逻辑。\n\n如果你不希望打印这种中间执行信息，liteflow提供了配置项，你需要作如下设置：\n\nliteflow.print-execution-log=false\n\n\n\n# 打印步骤信息\n\n在执行完一个链路之后，框架会自动打出这一条流程的执行步骤顺序，如下所示：\n\na<100>==>c<10>==>m<0>==>q<200>==>p<300>==>p1<0>==>g<305>\n\n\n这里的表达形式为：组件id<耗时毫秒>\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性，具体请参照组件别名。\n\n增加了别名之后，执行步骤信息的打印会变成以下样子：\n\na[组件a]<100>==>b[组件b]<0>==>m[组件m]<256>\n\n\n这里的表达形式为：组件id[组件别名]<耗时毫秒>",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"步骤信息",frontmatter:{title:"步骤信息",date:"2022-06-08T23:58:18.000Z",permalink:"/pages/v2.7.X/a5728b/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/170.%E6%AD%A5%E9%AA%A4%E4%BF%A1%E6%81%AF.html",relativePath:"20.v2.7.X文档/060.使用详细指南/170.步骤信息.md",key:"v-15448875",path:"/pages/v2.7.X/a5728b/",headersStr:null,content:'LiteFlow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过response对象来获取的：\n\nLiteflowResponse<CustomContext> response = flowExecutor.execute("chain1", "初始参数", CustomContext.class);\nMap<String, CmpStep> stepMap = response.getExecuteSteps();\n\n\n获取到的是一个KV的数据结构，key就是你的组件ID，value则是一个CmpStep对象。\n\n在这个对象里，你可以通过以下方法获得你要的数据：\n\n * isSuccess：此组件是否执行成功\n * getNodeId：获得组件Id\n * getNodeName：获得组件名称\n * getTimeSpent：获得组件的耗时，单位为毫秒\n * getException：获取此组件抛出的异常，如果isSuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getCause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',normalizedContent:'liteflow为执行的过程提供了详细的步骤信息。\n\n获取一条流程执行的步骤信息是通过response对象来获取的：\n\nliteflowresponse<customcontext> response = flowexecutor.execute("chain1", "初始参数", customcontext.class);\nmap<string, cmpstep> stepmap = response.getexecutesteps();\n\n\n获取到的是一个kv的数据结构，key就是你的组件id，value则是一个cmpstep对象。\n\n在这个对象里，你可以通过以下方法获得你要的数据：\n\n * issuccess：此组件是否执行成功\n * getnodeid：获得组件id\n * getnodename：获得组件名称\n * gettimespent：获得组件的耗时，单位为毫秒\n * getexception：获取此组件抛出的异常，如果issuccess为false的话。但是这里要注意下：有exception，success一定为false，但是success为false，不一定有exception，因为有可能没执行到，或者没执行结束(any的情况)。\n\n提示\n\n如果你的某一个组件抛出了异常，在默认配置情况下，流程会中断。那么response.getcause()和相应组件步骤里的exception都是一致的。且没执行的组件不会有相应步骤信息。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件切面",frontmatter:{title:"组件切面",date:"2022-06-01T13:45:03.000Z",permalink:"/pages/v2.7.X/feb764/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/160.%E7%BB%84%E4%BB%B6%E5%88%87%E9%9D%A2.html",relativePath:"20.v2.7.X文档/060.使用详细指南/160.组件切面.md",key:"v-5729ccfc",path:"/pages/v2.7.X/feb764/",headers:[{level:2,title:"全局切面",slug:"全局切面",normalizedTitle:"全局切面",charIndex:47},{level:2,title:"Aspect的切面",slug:"aspect的切面",normalizedTitle:"aspect的切面",charIndex:518}],headersStr:"全局切面 Aspect的切面",content:'LiteFlow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\npublic class CmpAspect implements ICmpAroundAspect<YourContextBean> {\n    @Override\n    public void beforeProcess(String nodeId, Slot<YourContextBean> slot) {\n        YourContextBean context = slot.getContextBean();\n        //before business\n    }\n\n    @Override\n    public void afterProcess(String nodeId, Slot<YourContextBean> slot) {\n        YourContextBean context = slot.getContextBean();\n        //after business\n    }\n}\n\n\n\n# Aspect的切面\n\nLiteFlow同时也支持了Spring Aspect的切面，你可以用@Aspect标注对任意包，任意规则内的组件进行切面\n\n@Aspect\npublic class CustomAspect {\n\n    @Pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @Around("cut()")\n    public Object around(ProceedingJoinPoint jp) throws Throwable {\n        //do before business\n        Object returnObj = jp.proceed();\n        //do after business\n        return returnObj;\n    }\n}\n',normalizedContent:'liteflow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\npublic class cmpaspect implements icmparoundaspect<yourcontextbean> {\n    @override\n    public void beforeprocess(string nodeid, slot<yourcontextbean> slot) {\n        yourcontextbean context = slot.getcontextbean();\n        //before business\n    }\n\n    @override\n    public void afterprocess(string nodeid, slot<yourcontextbean> slot) {\n        yourcontextbean context = slot.getcontextbean();\n        //after business\n    }\n}\n\n\n\n# aspect的切面\n\nliteflow同时也支持了spring aspect的切面，你可以用@aspect标注对任意包，任意规则内的组件进行切面\n\n@aspect\npublic class customaspect {\n\n    @pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @around("cut()")\n    public object around(proceedingjoinpoint jp) throws throwable {\n        //do before business\n        object returnobj = jp.proceed();\n        //do after business\n        return returnobj;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"不同格式规则加载",frontmatter:{title:"不同格式规则加载",date:"2022-06-01T13:56:19.000Z",permalink:"/pages/v2.7.X/decf9a/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/190.%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99%E5%8A%A0%E8%BD%BD.html",relativePath:"20.v2.7.X文档/060.使用详细指南/190.不同格式规则加载.md",key:"v-c063c074",path:"/pages/v2.7.X/decf9a/",headersStr:null,content:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipleType/flow.xml,multipleType/flow.json\n\n\n这种模式在正常下会解析失败，但是LiteFLow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",normalizedContent:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipletype/flow.xml,multipletype/flow.json\n\n\n这种模式在正常下会解析失败，但是liteflow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"When异步线程池",frontmatter:{title:"When异步线程池",date:"2022-06-01T13:57:15.000Z",permalink:"/pages/v2.7.X/2b3b21/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/200.When%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",relativePath:"20.v2.7.X文档/060.使用详细指南/200.When异步线程池.md",key:"v-8f248be2",path:"/pages/v2.7.X/2b3b21/",headers:[{level:2,title:"默认全局线程池",slug:"默认全局线程池",normalizedTitle:"默认全局线程池",charIndex:2},{level:2,title:"自定义全局线程池",slug:"自定义全局线程池",normalizedTitle:"自定义全局线程池",charIndex:157},{level:2,title:"Condition级别的单独线程池",slug:"condition级别的单独线程池",normalizedTitle:"condition级别的单独线程池",charIndex:1141},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1992}],headersStr:"默认全局线程池 自定义全局线程池 Condition级别的单独线程池 优先级",content:'# 默认全局线程池\n\nLiteFlow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，LiteFlow从2.6.6版本开始也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的Builder：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n\n\n然后把你的Builder加入LiteFlow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadExecutor\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n\t<property name="ruleSource" value="customThreadPool/flow.xml"/>\n  <property name="threadExecutorClass" value="com.yomahub.liteflow.test.customThreadPool.CustomThreadExecutor"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n  <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n这样，LiteFlow在启动的时候就会自动通过你声明的Builder加载到自定义的线程池了。\n\n\n# Condition级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n  <when value="a,b"/>\n</chain>\n\n<chain name="chain2">\n  <when value="c,d"/>\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class CustomThreadExecutor1 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class CustomThreadExecutor2 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n  <when value="a,b" threadExecutorClass="com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor1"/>\n</chain>\n<chain name="chain2">\n  <when value="c,d" threadExecutorClass="com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor2"/>\n</chain>\n\n\n\n# 优先级\n\n如果全局和Condition都配置自定义线程池的情况下，优先使用Condition上配置的线程池。',normalizedContent:'# 默认全局线程池\n\nliteflow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，liteflow从2.6.6版本开始也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的builder：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n\n\n然后把你的builder加入liteflow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadexecutor\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n\t<property name="rulesource" value="customthreadpool/flow.xml"/>\n  <property name="threadexecutorclass" value="com.yomahub.liteflow.test.customthreadpool.customthreadexecutor"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n  <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n这样，liteflow在启动的时候就会自动通过你声明的builder加载到自定义的线程池了。\n\n\n# condition级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n  <when value="a,b"/>\n</chain>\n\n<chain name="chain2">\n  <when value="c,d"/>\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class customthreadexecutor1 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class customthreadexecutor2 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n  <when value="a,b" threadexecutorclass="com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor1"/>\n</chain>\n<chain name="chain2">\n  <when value="c,d" threadexecutorclass="com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor2"/>\n</chain>\n\n\n\n# 优先级\n\n如果全局和condition都配置自定义线程池的情况下，优先使用condition上配置的线程池。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"简单监控",frontmatter:{title:"简单监控",date:"2022-06-01T14:00:20.000Z",permalink:"/pages/v2.7.X/9ec64b/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/220.%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7.html",relativePath:"20.v2.7.X文档/060.使用详细指南/220.简单监控.md",key:"v-5f412447",path:"/pages/v2.7.X/9ec64b/",headersStr:null,content:"LiteFlow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",normalizedContent:"liteflow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"自定义组件执行器",frontmatter:{title:"自定义组件执行器",date:"2022-06-01T13:58:15.000Z",permalink:"/pages/v2.7.X/1a7d84/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/210.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"20.v2.7.X文档/060.使用详细指南/210.自定义组件执行器.md",key:"v-a44aed54",path:"/pages/v2.7.X/1a7d84/",headers:[{level:2,title:"全局组件执行器",slug:"全局组件执行器",normalizedTitle:"全局组件执行器",charIndex:140},{level:2,title:"单个组件配置特殊的执行器",slug:"单个组件配置特殊的执行器",normalizedTitle:"单个组件配置特殊的执行器",charIndex:767},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1159},{level:2,title:"自定义执行器对于重试功能的影响",slug:"自定义执行器对于重试功能的影响",normalizedTitle:"自定义执行器对于重试功能的影响",charIndex:1208}],headersStr:"全局组件执行器 单个组件配置特殊的执行器 优先级 自定义执行器对于重试功能的影响",content:'LiteFlow从2.6.10起开始允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.entity.executor.DefaultNodeExecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeExecutor.CustomerDefaultNodeExecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.NodeExecutor。\n\npublic class CustomerDefaultNodeExecutor extends NodeExecutor {\n    @Override\n    public void execute(NodeComponent instance) throws Exception {\n        LOG.info("使用customerDefaultNodeExecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getNodeExecutorClass 方法：\n\n@LiteflowComponent("d")\npublic class DCmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        System.out.println("DCmp executed!");\n    }\n\n    @Override\n    public Class<? extends NodeExecutor> getNodeExecutorClass() {\n        return CustomerNodeExecutorAndCustomRetry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@LiteflowRetry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',normalizedContent:'liteflow从2.6.10起开始允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.entity.executor.defaultnodeexecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeexecutor.customerdefaultnodeexecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.nodeexecutor。\n\npublic class customerdefaultnodeexecutor extends nodeexecutor {\n    @override\n    public void execute(nodecomponent instance) throws exception {\n        log.info("使用customerdefaultnodeexecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getnodeexecutorclass 方法：\n\n@liteflowcomponent("d")\npublic class dcmp extends nodecomponent {\n\n    @override\n    public void process() {\n        system.out.println("dcmp executed!");\n    }\n\n    @override\n    public class<? extends nodeexecutor> getnodeexecutorclass() {\n        return customernodeexecutorandcustomretry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@liteflowretry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"测试用例",frontmatter:{title:"测试用例",date:"2022-06-01T14:02:31.000Z",permalink:"/pages/v2.7.X/beadb0/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/070.%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B/010.%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",relativePath:"20.v2.7.X文档/070.示例工程/010.测试用例.md",key:"v-72e418fb",path:"/pages/v2.7.X/beadb0/",headersStr:null,content:"项目提供了丰富的测试用例，截止到2.7.1版本，项目内一共有接近400多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解LiteFlow的同学可以去看看测试用例来学会如何在细节点上的配置和使用。\n\n * liteflow-testcase-nospring: 非spring体系的测试用例\n * liteflow-testcase-springboot: springboot环境下的测试用例\n * liteflow-testcase-springnative: spring原生环境下的测试用例\n * liteflow-testcase-declare-component: 声明式组件场景下的测试用例\n * liteflow-testcase-script-qlexpress: 基于QLExpress脚本框架的测试用例\n * liteflow-testcase-script-groovy: 基于Groovy脚本框架的测试用例",normalizedContent:"项目提供了丰富的测试用例，截止到2.7.1版本，项目内一共有接近400多个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解liteflow的同学可以去看看测试用例来学会如何在细节点上的配置和使用。\n\n * liteflow-testcase-nospring: 非spring体系的测试用例\n * liteflow-testcase-springboot: springboot环境下的测试用例\n * liteflow-testcase-springnative: spring原生环境下的测试用例\n * liteflow-testcase-declare-component: 声明式组件场景下的测试用例\n * liteflow-testcase-script-qlexpress: 基于qlexpress脚本框架的测试用例\n * liteflow-testcase-script-groovy: 基于groovy脚本框架的测试用例",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"DEMO案例",frontmatter:{title:"DEMO案例",date:"2022-06-01T14:04:06.000Z",permalink:"/pages/v2.7.X/73272c/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/070.%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B/020.DEMO%E6%A1%88%E4%BE%8B.html",relativePath:"20.v2.7.X文档/070.示例工程/020.DEMO案例.md",key:"v-436fb586",path:"/pages/v2.7.X/73272c/",headersStr:null,content:"如果你想看一个实际的案例，加深对LiteFlow的理解。可以查看：\n\n> 完整的带简单业务的案例\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算，建议大家去pull下来，仔细阅读下，这个业务用到了LiteFlow的大部分特性\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n",normalizedContent:"如果你想看一个实际的案例，加深对liteflow的理解。可以查看：\n\n> 完整的带简单业务的案例\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算，建议大家去pull下来，仔细阅读下，这个业务用到了liteflow的大部分特性\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"性能表现",frontmatter:{title:"性能表现",date:"2022-06-01T14:07:57.000Z",permalink:"/pages/v2.7.X/cdfa53/"},regularPath:"/20.v2.7.X%E6%96%87%E6%A1%A3/080.%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0.html",relativePath:"20.v2.7.X文档/080.性能表现.md",key:"v-415eb07f",path:"/pages/v2.7.X/cdfa53/",headersStr:null,content:"LiteFlow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，LiteFlow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的TPS，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然LiteFlow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求IO，或者有bad sql，又或者有大量的rpc同步调用。那实际TPS也不会很高。但是这是业务组件的的问题，而不是LiteFlow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的TPS/QPS，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nLiteFlow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库IO。\n\n基于这个Demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",normalizedContent:"liteflow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，liteflow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的tps，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然liteflow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求io，或者有bad sql，又或者有大量的rpc同步调用。那实际tps也不会很高。但是这是业务组件的的问题，而不是liteflow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的tps/qps，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nliteflow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库io。\n\n基于这个demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"项目特性",frontmatter:{title:"项目特性",date:"2022-05-31T18:48:14.000Z",permalink:"/pages/v2.6.X/8c0b63/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/020.%E9%A1%B9%E7%9B%AE%E7%89%B9%E6%80%A7.html",relativePath:"30.v2.6.X文档/020.项目特性.md",key:"v-0d1d299e",path:"/pages/v2.6.X/8c0b63/",headersStr:null,content:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 同步异步混编，再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则能从任意地方加载： 框架中提供本地文件配置源和zk配置源的实现，也提供了扩展接口，您可以把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。\n * JDK支持： 从JDK8到JDK17，统统支持。无需担心JDK版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持QLExpress和Groovy两种脚本。未来还会支持更多的脚本语言。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",normalizedContent:" * 组件定义统一： 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。\n * 规则轻量： 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。\n * 规则多样化： 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。\n * 任意编排： 同步异步混编，再复杂的逻辑过程，利用liteflow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。\n * 规则能从任意地方加载： 框架中提供本地文件配置源和zk配置源的实现，也提供了扩展接口，您可以把规则存储在任何地方。\n * 优雅热刷新机制： 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。\n * 支持广泛： 不管你的项目是不是基于springboot，spring还是任何其他java框架构建，liteflow都能游刃有余。\n * jdk支持： 从jdk8到jdk17，统统支持。无需担心jdk版本。\n * 脚本语言支持： 可以定义脚本语言节点，支持qlexpress和groovy两种脚本。未来还会支持更多的脚本语言。\n * 规则嵌套支持： 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。\n * 组件重试支持： 组件可以支持重试，每个组件均可自定义重试配置和指定异常。\n * 上下文隔离机制： 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。\n * 声明式组件支持： 你可以让你的任意类秒变组件。\n * 详细的步骤信息： 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。\n * 稳定可靠： 历时2年多的迭代，在各大公司的核心系统上稳定运行。\n * 性能卓越： 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。\n * 自带简单监控： 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"依赖",frontmatter:{title:"依赖",date:"2022-05-31T23:43:33.000Z",permalink:"/pages/v2.6.X/2d57d5/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/010.Springboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"30.v2.6.X文档/030.安装和集成/010.Springboot场景安装运行/010.依赖.md",key:"v-64a7d354",path:"/pages/v2.6.X/2d57d5/",headersStr:null,content:"LiteFlow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n  <groupId>com.yomahub</groupId>\n  <artifactId>liteflow-spring-boot-starter</artifactId>\n  <version>2.6.14</version>\n</dependency>\n",normalizedContent:"liteflow提供了liteflow-spring-boot-starter依赖包，提供自动装配功能\n\n<dependency>\n  <groupid>com.yomahub</groupid>\n  <artifactid>liteflow-spring-boot-starter</artifactid>\n  <version>2.6.14</version>\n</dependency>\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"LiteFlow介绍",frontmatter:{title:"LiteFlow介绍",date:"2022-05-31T18:36:04.000Z",permalink:"/pages/v2.6.X/dfd970/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/010.LiteFlow%E4%BB%8B%E7%BB%8D.html",relativePath:"30.v2.6.X文档/010.LiteFlow介绍.md",key:"v-79399e30",path:"/pages/v2.6.X/dfd970/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"LiteFlow框架的作用",slug:"liteflow框架的作用",normalizedTitle:"liteflow框架的作用",charIndex:275},{level:2,title:"LiteFlow的设计原则",slug:"liteflow的设计原则",normalizedTitle:"liteflow的设计原则",charIndex:497},{level:2,title:"LiteFlow不适用于哪些场景",slug:"liteflow不适用于哪些场景",normalizedTitle:"liteflow不适用于哪些场景",charIndex:1087},{level:2,title:"LiteFlow适用于哪些场景",slug:"liteflow适用于哪些场景",normalizedTitle:"liteflow适用于哪些场景",charIndex:1261},{level:2,title:"LiteFlow相比于Flowable和Activiti",slug:"liteflow相比于flowable和activiti",normalizedTitle:"liteflow相比于flowable和activiti",charIndex:1429}],headersStr:"前言 LiteFlow框架的作用 LiteFlow的设计原则 LiteFlow不适用于哪些场景 LiteFlow适用于哪些场景 LiteFlow相比于Flowable和Activiti",content:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统RPC调用等等。时间一长，项目几经易手，维护的成本得就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n\n# LiteFlow框架的作用\n\nLiteFlow就是为解耦复杂逻辑而生，如果你要对复杂业务逻辑进行新写或者重构，用LiteFlow最合适不过。它是一个轻量，快速的组件式流程引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。\n\n使用LiteFlow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，就能按照你的规则配置去进行复杂的流转。\n\n\n# LiteFlow的设计原则\n\nLiteFlow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到LiteFlow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以LiteFlow能做到统一解耦的组件和灵活的装配。\n\n\n# LiteFlow不适用于哪些场景\n\nLiteFlow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，A审批完应该是B审批，然后再流转到C角色。\n\n提示\n\n这里申明下，LiteFlow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# LiteFlow适用于哪些场景\n\nLiteFlow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用LiteFlow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也也可以避免改一处而动全身的这样的风险。\n\n\n# LiteFlow相比于Flowable和Activiti\n\nFlowable和Activiti都是极为优秀的流程引擎框架，其中Flowable的底层也是Activiti，他们除了能做基于任务角色的流程，也能做基于逻辑的流程，并且他们的基于BPM协议，很多基于BPM协议的编辑工具都能为他们可视化编辑流程。\n\nLiteFlow和他们相比，虽然功能不如他们那么多，但是胜在轻量，高性能和极少学习成本上。而且这2款都是国外开源，集成起来比较重，而且文档本地化做的也不够好。LiteFlow拥有完善的本地化文档和使用范例。在大部分的场景可以帮助你改善你的系统。",normalizedContent:"# 前言\n\n在每个公司的系统中，总有一些拥有复杂业务逻辑的系统，这些系统承载着核心业务逻辑，几乎每个需求都和这些核心业务有关，这些核心业务业务逻辑冗长，涉及内部逻辑运算，缓存操作，持久化操作，外部资源调取，内部其他系统rpc调用等等。时间一长，项目几经易手，维护的成本得就会越来越高。各种硬代码判断，分支条件越来越多。代码的抽象，复用率也越来越低，各个模块之间的耦合度很高。一小段逻辑的变动，会影响到其他模块，需要进行完整回归测试来验证。如要灵活改变业务流程的顺序，则要进行代码大改动进行抽象，重新写方法。实时热变更业务流程，几乎很难实现。\n\n\n# liteflow框架的作用\n\nliteflow就是为解耦复杂逻辑而生，如果你要对复杂业务逻辑进行新写或者重构，用liteflow最合适不过。它是一个轻量，快速的组件式流程引擎框架，组件编排，帮助解耦业务代码，让每一个业务片段都是一个组件，并支持热加载规则配置，实现即时修改。\n\n使用liteflow，你需要去把复杂的业务逻辑按代码片段拆分成一个个小组件，并定义一个规则流程配置。这样，所有的组件，就能按照你的规则配置去进行复杂的流转。\n\n\n# liteflow的设计原则\n\nliteflow是基于工作台模式进行设计的，何谓工作台模式？\n\nn个工人按照一定顺序围着一张工作台，按顺序各自生产零件，生产的零件最终能组装成一个机器，每个工人只需要完成自己手中零件的生产，而无需知道其他工人生产的内容。每一个工人生产所需要的资源都从工作台上拿取，如果工作台上有生产所必须的资源，则就进行生产，若是没有，就等到有这个资源。每个工人所做好的零件，也都放在工作台上。\n\n这个模式有几个好处：\n\n * 每个工人无需和其他工人进行沟通。工人只需要关心自己的工作内容和工作台上的资源。这样就做到了每个工人之间的解耦和无差异性。\n * 即便是工人之间调换位置，工人的工作内容和关心的资源没有任何变化。这样就保证了每个工人的稳定性。\n * 如果是指派某个工人去其他的工作台，工人的工作内容和需要的资源依旧没有任何变化，这样就做到了工人的可复用性。\n * 因为每个工人不需要和其他工人沟通，所以可以在生产任务进行时进行实时工位更改：替换，插入，撤掉一些工人，这样生产任务也能实时的被更改。这样就保证了整个生产任务的灵活性。\n\n这个模式映射到liteflow框架里，工人就是组件，工人坐的顺序就是流程配置，工作台就是上下文，资源就是参数，最终组装的这个机器就是这个业务。正因为有这些特性，所以liteflow能做到统一解耦的组件和灵活的装配。\n\n\n# liteflow不适用于哪些场景\n\nliteflow自开源来，经常有一些小伙伴来问我，如何做角色任务之间的流转，类似于审批流，a审批完应该是b审批，然后再流转到c角色。\n\n提示\n\n这里申明下，liteflow只做基于逻辑的流转，而不做基于角色任务的流转。如果你想做基于角色任务的流转，推荐使用flowable，activiti这2个框架。\n\n\n# liteflow适用于哪些场景\n\nliteflow适用于拥有复杂逻辑的业务，比如说价格引擎，下单流程等，这些业务往往都拥有很多步骤，这些步骤完全可以按照业务粒度拆分成一个个独立的组件，进行装配复用变更。使用liteflow，你会得到一个灵活度高，扩展性很强的系统。因为组件之间相互独立，也也可以避免改一处而动全身的这样的风险。\n\n\n# liteflow相比于flowable和activiti\n\nflowable和activiti都是极为优秀的流程引擎框架，其中flowable的底层也是activiti，他们除了能做基于任务角色的流程，也能做基于逻辑的流程，并且他们的基于bpm协议，很多基于bpm协议的编辑工具都能为他们可视化编辑流程。\n\nliteflow和他们相比，虽然功能不如他们那么多，但是胜在轻量，高性能和极少学习成本上。而且这2款都是国外开源，集成起来比较重，而且文档本地化做的也不够好。liteflow拥有完善的本地化文档和使用范例。在大部分的场景可以帮助你改善你的系统。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置",frontmatter:{title:"配置",date:"2022-05-31T23:43:49.000Z",permalink:"/pages/v2.6.X/f50478/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/010.Springboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"30.v2.6.X文档/030.安装和集成/010.Springboot场景安装运行/020.配置.md",key:"v-461d0c53",path:"/pages/v2.6.X/f50478/",headers:[{level:2,title:"组件的定义",slug:"组件的定义",normalizedTitle:"组件的定义",charIndex:2},{level:2,title:"SpringBoot配置文件",slug:"springboot配置文件",normalizedTitle:"springboot配置文件",charIndex:190},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:1491}],headersStr:"组件的定义 SpringBoot配置文件 规则文件的定义",content:'# 组件的定义\n\n在依赖了以上jar包后。 你需要定义并实现一些组件，确保SpringBoot会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# SpringBoot配置文件\n\n然后，在你的SpringBoot的application.properties或者application.yml里添加配置(这里以properties为例，yml也是一样的)\n\nliteflow.rule-source=config/flow.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zkNode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#slot的数量，默认值为1024\nliteflow.slot-size=1024\n#FlowExecutor的execute2Future的线程数，默认为64\nliteflow.main-executor-works=64\n#FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n#并行节点的线程池Builder，LiteFlow提供了默认的Builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为16\nliteflow.when-max-wait-seconds=20\n#异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#是否开启监控log打印，默认值为false\nliteflow.monitor.enable-log=true\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=300\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=10000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=10000\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.xml中定义规则：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nSpringBoot在启动时会自动装载规则文件。',normalizedContent:'# 组件的定义\n\n在依赖了以上jar包后。 你需要定义并实现一些组件，确保springboot会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your business\n\t}\n}\n\n\n\n# springboot配置文件\n\n然后，在你的springboot的application.properties或者application.yml里添加配置(这里以properties为例，yml也是一样的)\n\nliteflow.rule-source=config/flow.xml\n#-----------------以下非必须-----------------\n#liteflow是否开启，默认为true\nliteflow.enable=true\n#liteflow的banner是否开启，默认为true\nliteflow.print-banner=true\n#zknode的节点，只有使用zk作为配置源的时候才起作用\nliteflow.zk-node=/lite-flow/flow\n#slot的数量，默认值为1024\nliteflow.slot-size=1024\n#flowexecutor的execute2future的线程数，默认为64\nliteflow.main-executor-works=64\n#flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n#并行节点的线程池builder，liteflow提供了默认的builder\nliteflow.thread-executor-class=com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder\n#异步线程最长的等待时间秒(只用于when)，默认值为16\nliteflow.when-max-wait-seconds=20\n#异步线程池最大线程数，默认为16\nliteflow.when-max-workers=16\n#异步线程池等待队列数，默认为512\nliteflow.when-queue-limit=512\n#是否在启动的时候就解析规则，默认为true\nliteflow.parse-on-start=true\n#全局重试次数，默认为0\nliteflow.retry-count=0\n#是否支持不同类型的加载方式混用，默认为false\nliteflow.support-multiple-type=false\n#是否开启监控log打印，默认值为false\nliteflow.monitor.enable-log=true\n#监控队列存储大小，默认值为200\nliteflow.monitor.queue-limit=300\n#监控一开始延迟多少执行，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.delay=10000\n#监控日志打印每过多少时间执行一次，默认值为300000毫秒，也就是5分钟\nliteflow.monitor.period=10000\n\n\n\n# 规则文件的定义\n\n同时，你得在resources下的config/flow.xml中定义规则：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nspringboot在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行",frontmatter:{title:"执行",date:"2022-05-31T23:44:10.000Z",permalink:"/pages/v2.6.X/73a9e7/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/010.Springboot%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"30.v2.6.X文档/030.安装和集成/010.Springboot场景安装运行/030.执行.md",key:"v-12d6b6e0",path:"/pages/v2.6.X/73a9e7/",headersStr:null,content:'然后你就可以在任意的类中拿到flowExecutor，进行执行链路\n\n@Component\npublic class MainTest{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse<DefaultSlot> response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n',normalizedContent:'然后你就可以在任意的类中拿到flowexecutor，进行执行链路\n\n@component\npublic class maintest{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse<defaultslot> response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"依赖",frontmatter:{title:"依赖",date:"2022-06-01T00:11:44.000Z",permalink:"/pages/v2.6.X/165d6f/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/020.Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E4%BE%9D%E8%B5%96.html",relativePath:"30.v2.6.X文档/030.安装和集成/020.Spring场景安装运行/010.依赖.md",key:"v-667a2bb6",path:"/pages/v2.6.X/165d6f/",headersStr:null,content:"针对于使用了Spring但没有使用SpringBoot的项目\n\n<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-spring</artifactId>\n\t<version>2.6.14</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"针对于使用了spring但没有使用springboot的项目\n\n<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-spring</artifactid>\n\t<version>2.6.14</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置",frontmatter:{title:"配置",date:"2022-06-01T00:11:55.000Z",permalink:"/pages/v2.6.X/4e34ba/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/020.Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E9%85%8D%E7%BD%AE.html",relativePath:"30.v2.6.X文档/030.安装和集成/020.Spring场景安装运行/020.配置.md",key:"v-e1cf439a",path:"/pages/v2.6.X/4e34ba/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"Spring xml中的配置",slug:"spring-xml中的配置",normalizedTitle:"spring xml中的配置",charIndex:189},{level:2,title:"规则文件的定义",slug:"规则文件的定义",normalizedTitle:"规则文件的定义",charIndex:2423}],headersStr:"定义你的组件 Spring xml中的配置 规则文件的定义",content:'# 定义你的组件\n\n你需要定义并实现一些组件，确保Spring会扫描到这些组件并注册进上下文\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n\n# Spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springAware" class="com.yomahub.liteflow.util.SpringAware"/>\n\n<bean class="com.yomahub.liteflow.spring.ComponentScaner"/>\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n    <property name="ruleSource" value="config/flow.xml"/>\n    \x3c!-- 以下都不是必须的，都有默认值 --\x3e\n    <property name="enable" value="true"/> \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="printBanner" value="true"/> \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="zkNode" value="/lite-flow/flow.xml"/> \x3c!-- zkNode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="slotSize" value="1024"/> \x3c!-- slot的初始数量，默认为1024，此属性基本不用设置，因为满了之后会自动扩容 --\x3e\n    <property name="mainExecutorWorks" value="64"/> \x3c!-- FlowExecutor的execute2Future的线程数，默认为64 --\x3e\n    <property name="mainExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder"/> \x3c!-- FlowExecutor的execute2Future的自定义线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="threadExecutorClass" value="com.yomahub.liteflow.thread.LiteFlowDefaultWhenExecutorBuilder"/> \x3c!-- 并行节点的线程池Builder，LiteFlow提供了默认的Builder --\x3e\n    <property name="whenMaxWaitSeconds" value="20"/> \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为16 --\x3e\n    <property name="whenMaxWorkers" value="16"/> \x3c!-- 异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenQueueLimit" value="512"/> \x3c!-- 异步线程池等待队列数，默认为512 --\x3e\n    <property name="parseOnStart" value="true"/> \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="retryCount" value="0"/> \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="supportMultipleType" value="false"/> \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="enableLog" value="true"/> \x3c!-- 默认为false --\x3e\n    <property name="queueLimit" value="100"/> \x3c!-- 默认为200 --\x3e\n    <property name="period" value="5000"/> \x3c!-- 默认为300000,5分钟 --\x3e\n    <property name="delay" value="5000"/> \x3c!-- 默认为300000,5分钟 --\x3e\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\x3c!-- 如果上述enableLog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.MonitorBus">\n    <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.xml中如下配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nSpring在启动时会自动装载规则文件。',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件，确保spring会扫描到这些组件并注册进上下文\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n\n# spring xml中的配置\n\n<context:component-scan base-package="com.yomahub.flowtest.components" />\n\n<bean id="springaware" class="com.yomahub.liteflow.util.springaware"/>\n\n<bean class="com.yomahub.liteflow.spring.componentscaner"/>\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n    <property name="rulesource" value="config/flow.xml"/>\n    \x3c!-- 以下都不是必须的，都有默认值 --\x3e\n    <property name="enable" value="true"/> \x3c!-- liteflow是否开启,默认为true --\x3e\n    <property name="printbanner" value="true"/> \x3c!-- liteflow的banner是否开启，默认为true --\x3e\n    <property name="zknode" value="/lite-flow/flow.xml"/> \x3c!-- zknode的节点，只有使用zk作为配置源的时候才起作用 --\x3e\n    <property name="slotsize" value="1024"/> \x3c!-- slot的初始数量，默认为1024，此属性基本不用设置，因为满了之后会自动扩容 --\x3e\n    <property name="mainexecutorworks" value="64"/> \x3c!-- flowexecutor的execute2future的线程数，默认为64 --\x3e\n    <property name="mainexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder"/> \x3c!-- flowexecutor的execute2future的自定义线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="threadexecutorclass" value="com.yomahub.liteflow.thread.liteflowdefaultwhenexecutorbuilder"/> \x3c!-- 并行节点的线程池builder，liteflow提供了默认的builder --\x3e\n    <property name="whenmaxwaitseconds" value="20"/> \x3c!-- 异步线程最长的等待时间秒(只用于when)，默认值为16 --\x3e\n    <property name="whenmaxworkers" value="16"/> \x3c!-- 异步线程池最大线程数，默认为16 --\x3e\n    <property name="whenqueuelimit" value="512"/> \x3c!-- 异步线程池等待队列数，默认为512 --\x3e\n    <property name="parseonstart" value="true"/> \x3c!-- 是否在启动的时候就解析规则，默认为true --\x3e\n    <property name="retrycount" value="0"/> \x3c!-- 全局重试次数，默认为0 --\x3e\n    <property name="supportmultipletype" value="false"/> \x3c!-- 是否支持不同类型的加载方式混用，默认为false --\x3e\n    <property name="enablelog" value="true"/> \x3c!-- 默认为false --\x3e\n    <property name="queuelimit" value="100"/> \x3c!-- 默认为200 --\x3e\n    <property name="period" value="5000"/> \x3c!-- 默认为300000,5分钟 --\x3e\n    <property name="delay" value="5000"/> \x3c!-- 默认为300000,5分钟 --\x3e\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\x3c!-- 如果上述enablelog为false，下面这段也可以省略 --\x3e\n<bean class="com.yomahub.liteflow.monitor.monitorbus">\n    <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n\n# 规则文件的定义\n\n同时，你得在resources的config/flow.xml中如下配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a,b,c"/>\n        <when value="d,e"/>\n    </chain>\n</flow>\n\n\nspring在启动时会自动装载规则文件。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行",frontmatter:{title:"执行",date:"2022-06-01T00:12:08.000Z",permalink:"/pages/v2.6.X/47ef69/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/020.Spring%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E6%89%A7%E8%A1%8C.html",relativePath:"30.v2.6.X文档/030.安装和集成/020.Spring场景安装运行/030.执行.md",key:"v-71a27340",path:"/pages/v2.6.X/47ef69/",headersStr:null,content:'和SpringBoot的执行方式一样，没有任何区别\n\n@Component\npublic class MainTest{\n    \n    @Resource\n    private FlowExecutor flowExecutor;\n    \n    @Test\n    public void testConfig(){\n        LiteflowResponse<DefaultSlot> response = flowExecutor.execute2Resp("chain1", "arg");\n    }\n}\n',normalizedContent:'和springboot的执行方式一样，没有任何区别\n\n@component\npublic class maintest{\n    \n    @resource\n    private flowexecutor flowexecutor;\n    \n    @test\n    public void testconfig(){\n        liteflowresponse<defaultslot> response = flowexecutor.execute2resp("chain1", "arg");\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"说明",frontmatter:{title:"说明",date:"2022-06-01T00:14:28.000Z",permalink:"/pages/v2.6.X/d53ad2/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/010.%E8%AF%B4%E6%98%8E.html",relativePath:"30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/010.说明.md",key:"v-cd30b37a",path:"/pages/v2.6.X/d53ad2/",headersStr:null,content:"LiteFlow在2.6.11版本中对模块进行了彻底的拆分，重新开始支持了非spring的场景。\n\n虽说Springboot/Spring已经成为了Java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合Spring我始终觉得是瑕疵，有点代码洁癖），现在在非Spring体系的环境中也能使用LiteFlow框架带来的便捷和高效。\n\nLiteFlow文档中提到的98%以上的特性功能都能在非Spring体系中生效。其中不生效的特性和功能有：\n\n * ruleSource的模糊路径匹配特性在非Spring体系下不生效\n * LiteflowComponent在非Spring体系下无法使用\n * 监控功能在非Spring体系中无法使用",normalizedContent:"liteflow在2.6.11版本中对模块进行了彻底的拆分，重新开始支持了非spring的场景。\n\n虽说springboot/spring已经成为了java项目中的标配，但是为了照顾到启用其他框架的小伙伴（其更重要的原因是强耦合spring我始终觉得是瑕疵，有点代码洁癖），现在在非spring体系的环境中也能使用liteflow框架带来的便捷和高效。\n\nliteflow文档中提到的98%以上的特性功能都能在非spring体系中生效。其中不生效的特性和功能有：\n\n * rulesource的模糊路径匹配特性在非spring体系下不生效\n * liteflowcomponent在非spring体系下无法使用\n * 监控功能在非spring体系中无法使用",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"依赖",frontmatter:{title:"依赖",date:"2022-06-01T00:14:55.000Z",permalink:"/pages/v2.6.X/9191fb/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/020.%E4%BE%9D%E8%B5%96.html",relativePath:"30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/020.依赖.md",key:"v-7dae1c3b",path:"/pages/v2.6.X/9191fb/",headersStr:null,content:"<dependency>\n\t<groupId>com.yomahub</groupId>\n    <artifactId>liteflow-core</artifactId>\n\t<version>2.6.14</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",normalizedContent:"<dependency>\n\t<groupid>com.yomahub</groupid>\n    <artifactid>liteflow-core</artifactid>\n\t<version>2.6.14</version>\n</dependency>\n\n\n为稳定版本，目前jar包已上传中央仓库，可以直接依赖到",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行",frontmatter:{title:"执行",date:"2022-06-01T00:15:45.000Z",permalink:"/pages/v2.6.X/81d136/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/040.%E6%89%A7%E8%A1%8C.html",relativePath:"30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/040.执行.md",key:"v-16c02276",path:"/pages/v2.6.X/81d136/",headers:[{level:2,title:"初始化你的FlowExecutor执行器",slug:"初始化你的flowexecutor执行器",normalizedTitle:"初始化你的flowexecutor执行器",charIndex:2},{level:2,title:"用FlowExecutor执行",slug:"用flowexecutor执行",normalizedTitle:"用flowexecutor执行",charIndex:378}],headersStr:"初始化你的FlowExecutor执行器 用FlowExecutor执行",content:'# 初始化你的FlowExecutor执行器\n\n通过以下代码你可以轻易的初始化FlowExecutor处理器：\n\nLiteflowConfig config = new LiteflowConfig();\nconfig.setRuleSource("base/flow.xml");\nFlowExecutor flowExecutor = FlowExecutorHolder.loadInstance(config);\n\n\nLiteFlow有很多其他的配置，但非必须，想知道有哪些可以参考Springboot和Spring那两章节的配置一章，有详细的说明。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化FlowExecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用FlowExecutor执行\n\nLiteflowResponse<DefaultSlot> response = flowExecutor.execute2Resp("chain1", "arg");\n',normalizedContent:'# 初始化你的flowexecutor执行器\n\n通过以下代码你可以轻易的初始化flowexecutor处理器：\n\nliteflowconfig config = new liteflowconfig();\nconfig.setrulesource("base/flow.xml");\nflowexecutor flowexecutor = flowexecutorholder.loadinstance(config);\n\n\nliteflow有很多其他的配置，但非必须，想知道有哪些可以参考springboot和spring那两章节的配置一章，有详细的说明。\n\n提示\n\n要注意的是，不建议每次执行流程都去初始化flowexecutor，这个对象的初始化工作相对比较重，全局只需要初始化一次就好了。建议在项目启动时初始化或者第一次执行的时候初始化。\n\n\n# 用flowexecutor执行\n\nliteflowresponse<defaultslot> response = flowexecutor.execute2resp("chain1", "arg");\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"配置",frontmatter:{title:"配置",date:"2022-06-01T00:15:21.000Z",permalink:"/pages/v2.6.X/80afec/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/030.%E5%AE%89%E8%A3%85%E5%92%8C%E9%9B%86%E6%88%90/030.%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/030.%E9%85%8D%E7%BD%AE.html",relativePath:"30.v2.6.X文档/030.安装和集成/030.其他场景安装运行/030.配置.md",key:"v-707b5938",path:"/pages/v2.6.X/80afec/",headers:[{level:2,title:"定义你的组件",slug:"定义你的组件",normalizedTitle:"定义你的组件",charIndex:2},{level:2,title:"规则文件的配置",slug:"规则文件的配置",normalizedTitle:"规则文件的配置",charIndex:149}],headersStr:"定义你的组件 规则文件的配置",content:'# 定义你的组件\n\n你需要定义并实现一些组件\n\npublic class ACmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        //do your business\n    }\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.AComponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.BComponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.CComponent"/>\n\t\t<node id="d" class="com.yomahub.liteflow.test.component.DComponent"/>\n\t\t<node id="e" class="com.yomahub.liteflow.test.component.EComponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\t<then value="a,b,c"/> \x3c!-- then表示串行 --\x3e\n\t\t<when value="d,e"/> \x3c!-- when表示并行 --\x3e\n\t</chain>\n</flow>\n',normalizedContent:'# 定义你的组件\n\n你需要定义并实现一些组件\n\npublic class acmp extends nodecomponent {\n\n    @override\n    public void process() {\n        //do your business\n    }\n}\n\n\n\n# 规则文件的配置\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n\t<nodes>\n\t\t<node id="a" class="com.yomahub.liteflow.test.component.acomponent"/>\n\t\t<node id="b" class="com.yomahub.liteflow.test.component.bcomponent"/>\n\t\t<node id="c" class="com.yomahub.liteflow.test.component.ccomponent"/>\n\t\t<node id="d" class="com.yomahub.liteflow.test.component.dcomponent"/>\n\t\t<node id="e" class="com.yomahub.liteflow.test.component.ecomponent"/>\n\t</nodes>\n\t\n\t<chain name="chain1">\n\t\t<then value="a,b,c"/> \x3c!-- then表示串行 --\x3e\n\t\t<when value="d,e"/> \x3c!-- when表示并行 --\x3e\n\t</chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"规则文件格式",frontmatter:{title:"规则文件格式",date:"2022-06-01T00:18:53.000Z",permalink:"/pages/v2.6.X/c10d7e/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/010.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html",relativePath:"30.v2.6.X文档/040.规则文件/010.规则文件格式.md",key:"v-67f50c3a",path:"/pages/v2.6.X/c10d7e/",headers:[{level:2,title:"规则组成部分",slug:"规则组成部分",normalizedTitle:"规则组成部分",charIndex:157},{level:2,title:"xml格式",slug:"xml格式",normalizedTitle:"xml格式",charIndex:389},{level:2,title:"json格式",slug:"json格式",normalizedTitle:"json格式",charIndex:1432},{level:2,title:"yml格式",slug:"yml格式",normalizedTitle:"yml格式",charIndex:2845}],headersStr:"规则组成部分 xml格式 json格式 yml格式",content:'LiteFlow从2.5.0版本开始支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nLiteFlow的规则文件非常轻量，非常容易上手。主要由Node节点和Chain节点组成。\n\n而Node节点在Springboot/Spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到Spring上下文中。\n\n在非Spring环境体系中，Node节点是必须的。如果不配置Node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\n\n# xml格式\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.xml\n\nzk方式：liteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=xml:com.yomahub.liteflow.test.TestCustomParser\n\nxml的完整形式举例：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.ACmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.BCmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.CCmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.DCmp"/>\n        <node id="e" class="com.yomahub.liteflow.test.parser.cmp.ECmp"/>\n        <node id="f" class="com.yomahub.liteflow.test.parser.cmp.FCmp"/>\n        <node id="g" class="com.yomahub.liteflow.test.parser.cmp.GCmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,c"/>\n        <when value="b,d,e(f|g)"/>\n        <then value="chain2"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="c,g,f"/>\n    </chain>\n</flow>\n\n\n\n# json格式\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.json\n\nzk方式：liteflow.rule-source=json:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=json:com.yomahub.liteflow.test.TestCustomParser\n\njson的完整形式举例：\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ACmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.BCmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.CCmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.DCmp"\n        },\n        {\n          "id": "e",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ECmp"\n        },\n        {\n          "id": "f",\n          "class": "com.yomahub.liteflow.test.parser.cmp.FCmp"\n        },\n        {\n          "id": "g",\n          "class": "com.yomahub.liteflow.test.parser.cmp.GCmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain2",\n        "condition": [\n          {"type": "then", "value": "c,g,f"}\n        ]\n      },\n      {\n        "name": "chain1",\n        "condition": [\n          {"type": "then", "value": "a,c"},\n          {"type": "when", "value": "b,d,e(f|g)"},\n          {"type": "then", "value": "chain2"}\n        ]\n      }\n    ]\n  }\n}\n\n\n\n# yml格式\n\n在yml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.yml\n\nzk方式：liteflow.rule-source=yml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=yml:com.yomahub.liteflow.test.TestCustomParser\n\nyml的完整形式举例：\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.ACmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.BCmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.CCmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.DCmp\n      - id: e\n        class: com.yomahub.liteflow.test.parser.cmp.ECmp\n      - id: f\n        class: com.yomahub.liteflow.test.parser.cmp.FCmp\n      - id: g\n        class: com.yomahub.liteflow.test.parser.cmp.GCmp\n  chain:\n    - name: chain1\n      condition:\n        - type: then\n          value: \'a,c\'\n        - type: when\n          value: \'b,d,e(f|g)\'\n        - type: then\n          value: \'chain2\'\n    - name: chain2\n      condition:\n        - type: then\n          value: \'c,g,f\'\n\n',normalizedContent:'liteflow从2.5.0版本开始支持3种配置方式\n\n * xml\n * json\n * yml\n\njson，yml，xml配置起来都差不多，不会增加你额外的学习负担。只是形式不同而已。\n\n提示\n\n在后面的章节中，示例基本都是以xml配置来进行，如要换成json和yml，则自行参考这章给出的配置范本。\n\n\n# 规则组成部分\n\nliteflow的规则文件非常轻量，非常容易上手。主要由node节点和chain节点组成。\n\n而node节点在springboot/spring环境体系中是非必须的，只要将相应的组件注册到上下文中即可。当然如果配置在规则文件中，框架也会将节点注册到spring上下文中。\n\n在非spring环境体系中，node节点是必须的。如果不配置node，系统会报找不到节点的错误。这点要务必注意下。\n\n以下的格式是只作为一个范本，提供给使用者参考。\n\n\n# xml格式\n\n在xml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.xml\n\nzk方式：liteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=xml:com.yomahub.liteflow.test.testcustomparser\n\nxml的完整形式举例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="a" class="com.yomahub.liteflow.test.parser.cmp.acmp"/>\n        <node id="b" class="com.yomahub.liteflow.test.parser.cmp.bcmp"/>\n        <node id="c" class="com.yomahub.liteflow.test.parser.cmp.ccmp"/>\n        <node id="d" class="com.yomahub.liteflow.test.parser.cmp.dcmp"/>\n        <node id="e" class="com.yomahub.liteflow.test.parser.cmp.ecmp"/>\n        <node id="f" class="com.yomahub.liteflow.test.parser.cmp.fcmp"/>\n        <node id="g" class="com.yomahub.liteflow.test.parser.cmp.gcmp"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,c"/>\n        <when value="b,d,e(f|g)"/>\n        <then value="chain2"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="c,g,f"/>\n    </chain>\n</flow>\n\n\n\n# json格式\n\n在json形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.json\n\nzk方式：liteflow.rule-source=json:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=json:com.yomahub.liteflow.test.testcustomparser\n\njson的完整形式举例：\n\n{\n  "flow": {\n    "nodes": {\n      "node": [\n        {\n          "id": "a",\n          "class": "com.yomahub.liteflow.test.parser.cmp.acmp"\n        },\n        {\n          "id": "b",\n          "class": "com.yomahub.liteflow.test.parser.cmp.bcmp"\n        },\n        {\n          "id": "c",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ccmp"\n        },\n        {\n          "id": "d",\n          "class": "com.yomahub.liteflow.test.parser.cmp.dcmp"\n        },\n        {\n          "id": "e",\n          "class": "com.yomahub.liteflow.test.parser.cmp.ecmp"\n        },\n        {\n          "id": "f",\n          "class": "com.yomahub.liteflow.test.parser.cmp.fcmp"\n        },\n        {\n          "id": "g",\n          "class": "com.yomahub.liteflow.test.parser.cmp.gcmp"\n        }\n      ]\n    },\n    "chain": [\n      {\n        "name": "chain2",\n        "condition": [\n          {"type": "then", "value": "c,g,f"}\n        ]\n      },\n      {\n        "name": "chain1",\n        "condition": [\n          {"type": "then", "value": "a,c"},\n          {"type": "when", "value": "b,d,e(f|g)"},\n          {"type": "then", "value": "chain2"}\n        ]\n      }\n    ]\n  }\n}\n\n\n\n# yml格式\n\n在yml形式下的rule-source的配置方式如下：\n\n本地文件：liteflow.rule-source=config/flow.yml\n\nzk方式：liteflow.rule-source=yml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n自定义配置源：liteflow.rule-source=yml:com.yomahub.liteflow.test.testcustomparser\n\nyml的完整形式举例：\n\nflow:\n  nodes:\n    node:\n      - id: a\n        class: com.yomahub.liteflow.test.parser.cmp.acmp\n      - id: b\n        class: com.yomahub.liteflow.test.parser.cmp.bcmp\n      - id: c\n        class: com.yomahub.liteflow.test.parser.cmp.ccmp\n      - id: d\n        class: com.yomahub.liteflow.test.parser.cmp.dcmp\n      - id: e\n        class: com.yomahub.liteflow.test.parser.cmp.ecmp\n      - id: f\n        class: com.yomahub.liteflow.test.parser.cmp.fcmp\n      - id: g\n        class: com.yomahub.liteflow.test.parser.cmp.gcmp\n  chain:\n    - name: chain1\n      condition:\n        - type: then\n          value: \'a,c\'\n        - type: when\n          value: \'b,d,e(f|g)\'\n        - type: then\n          value: \'chain2\'\n    - name: chain2\n      condition:\n        - type: then\n          value: \'c,g,f\'\n\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"本地规则文件配置",frontmatter:{title:"本地规则文件配置",date:"2022-06-01T11:34:52.000Z",permalink:"/pages/v2.6.X/23d0c3/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/020.%E6%9C%AC%E5%9C%B0%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"30.v2.6.X文档/040.规则文件/020.本地规则文件配置.md",key:"v-677bc6ea",path:"/pages/v2.6.X/23d0c3/",headers:[{level:2,title:"常规配置",slug:"常规配置",normalizedTitle:"常规配置",charIndex:175},{level:2,title:"指定多个路径",slug:"指定多个路径",normalizedTitle:"指定多个路径",charIndex:223}],headersStr:"常规配置 指定多个路径",content:"在LiteFlow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是LiteFlow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读安装和集成这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.xml\n\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.xml,config/flow2.xml,config/flow3.xml\n\n\n你也可以使用Spring EL表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.xml\n\n\n提示\n\n模糊匹配只限于Springboot/Spring体系中，非Spring环境，模糊匹配不生效",normalizedContent:"在liteflow框架中，规则文件是驱动/编排整个流程的关键，用户通过指定rule-source来定位规则文件的本地路径。而rule-source也是liteflow框架中必须配置的参数，而其他参数都不是必须的（都有默认值）。\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读安装和集成这章节。\n\n\n# 常规配置\n\nliteflow.rule-source=config/flow.xml\n\n\n\n# 指定多个路径\n\n规则文件之间可以用,或者;隔开：\n\nliteflow.rule-source=config/flow1.xml,config/flow2.xml,config/flow3.xml\n\n\n你也可以使用spring el表达式进行模糊匹配，加载多个配置文件：\n\nliteflow.rule-source=config/**/*.xml\n\n\n提示\n\n模糊匹配只限于springboot/spring体系中，非spring环境，模糊匹配不生效",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"说明",frontmatter:{title:"说明",date:"2022-06-01T11:54:31.000Z",permalink:"/pages/v2.6.X/b2143d/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/050.%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/010.%E8%AF%B4%E6%98%8E.html",relativePath:"30.v2.6.X文档/050.用代码动态构造规则/010.说明.md",key:"v-78a45fb6",path:"/pages/v2.6.X/b2143d/",headersStr:null,content:"LiteFlow从2.6.8版本开始支持基于方法链的代码构造链路的特性。\n\n提示\n\n通过代码构造模式，你可以不用写xml/json/yaml的规则文件。用代码来构建规则。\n\n事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的API意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造API去构造链路。\n\nLiteFlow在2.6.8中设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",normalizedContent:"liteflow从2.6.8版本开始支持基于方法链的代码构造链路的特性。\n\n提示\n\n通过代码构造模式，你可以不用写xml/json/yaml的规则文件。用代码来构建规则。\n\n事实上，liteflow的规则无论是什么格式的，最终底层也是由构造链去构造的。\n\n意义\n\n提供动态代码构造的api意义在于以下两点：\n\n * 有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。\n * 如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造api去构造链路。\n\nliteflow在2.6.8中设计了非常简单的构造方法链式api，让你可以很轻松的构造一条链路。\n\n并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考平滑热刷新。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"ZK规则文件配置",frontmatter:{title:"ZK规则文件配置",date:"2022-06-01T11:40:29.000Z",permalink:"/pages/v2.6.X/2adc0f/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/030.ZK%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE.html",relativePath:"30.v2.6.X文档/040.规则文件/030.ZK规则文件配置.md",key:"v-3ab104de",path:"/pages/v2.6.X/2adc0f/",headers:[{level:2,title:"依赖",slug:"依赖",normalizedTitle:"依赖",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:527}],headersStr:"依赖 配置路径",content:"# 依赖\n\n提示\n\nLiteFlow支持把配置放在zk集群中，基于zk的通知机制，LiteFlow支持实时修改流程\n\n你只需在原来配置流程的地方，把本地xml路径换成zk地址就ok了，当然ZK里存放的内容还是以xml/json/yml存储的，具体请请参考规则文件格式这章。\n\n如果需要用到zk，需要加以下依赖，LiteFlow在2.6.3之后不再传递依赖：\n\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-framework</artifactId>\n    <version>${curator.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-recipes</artifactId>\n    <version>${curator.version}</version>\n</dependency>\n\n\n${curator.version}建议为5.1.0\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读安装和集成这章节。\n\n只需要改变rule-source变成zk的地址就可以了，集群用逗号分隔。\n\nliteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n\n关于xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这一章。",normalizedContent:"# 依赖\n\n提示\n\nliteflow支持把配置放在zk集群中，基于zk的通知机制，liteflow支持实时修改流程\n\n你只需在原来配置流程的地方，把本地xml路径换成zk地址就ok了，当然zk里存放的内容还是以xml/json/yml存储的，具体请请参考规则文件格式这章。\n\n如果需要用到zk，需要加以下依赖，liteflow在2.6.3之后不再传递依赖：\n\n<dependency>\n    <groupid>org.apache.curator</groupid>\n    <artifactid>curator-framework</artifactid>\n    <version>${curator.version}</version>\n</dependency>\n<dependency>\n    <groupid>org.apache.curator</groupid>\n    <artifactid>curator-recipes</artifactid>\n    <version>${curator.version}</version>\n</dependency>\n\n\n${curator.version}建议为5.1.0\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读安装和集成这章节。\n\n只需要改变rule-source变成zk的地址就可以了，集群用逗号分隔。\n\nliteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n\n\n关于xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这一章。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"自定义配置源",frontmatter:{title:"自定义配置源",date:"2022-06-01T11:47:33.000Z",permalink:"/pages/v2.6.X/240fe8/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/040.%E8%A7%84%E5%88%99%E6%96%87%E4%BB%B6/040.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%BA%90.html",relativePath:"30.v2.6.X文档/040.规则文件/040.自定义配置源.md",key:"v-ed90420a",path:"/pages/v2.6.X/240fe8/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"配置路径",slug:"配置路径",normalizedTitle:"配置路径",charIndex:609}],headersStr:"说明 配置路径",content:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。LiteFlow支持自定义的配置源的扩展点。\n\nXML形式的规则文件请继承ClassXmlFlowParser\n\nJSON形式的规则文件请继承ClassJsonFlowParser\n\nYML形式的规则文件请继承ClassYmlFlowParser\n\n以下以XML形式的自定义源配置类举例：\n\npublic class TestCustomParser extends ClassXmlFlowParser {\n\n\t@Override\n\tpublic String parseCustom() {\n\t\tSystem.out.println("进入自定义parser");\n\t\tString xmlContent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlContent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@Autowired和@Resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以Springboot的配置做例子，Spring以及非Spring的环境配置可以详细阅读安装和集成这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=xml:com.yomahub.liteflow.test.TestCustomParser\n\n\n关于xml这种标签头\n\nLiteFlow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这章。',normalizedContent:'# 说明\n\n如果你不想用本地的配置，也不打算使用zk作为配置持久化工具。liteflow支持自定义的配置源的扩展点。\n\nxml形式的规则文件请继承classxmlflowparser\n\njson形式的规则文件请继承classjsonflowparser\n\nyml形式的规则文件请继承classymlflowparser\n\n以下以xml形式的自定义源配置类举例：\n\npublic class testcustomparser extends classxmlflowparser {\n\n\t@override\n\tpublic string parsecustom() {\n\t\tsystem.out.println("进入自定义parser");\n\t\tstring xmlcontent = null;\n\t\t//这里需要自己扩展从自定义的地方获取配置\n\t\treturn xmlcontent;\n\t}\n}\n\n\n提示一\n\n自定义配置源这个类也会自动注入到spring的上下文中，所以在这个类里可以随意注入spring上下文中的bean，可以使用@autowired和@resources等标签\n\n提示二\n\n自定义配置源实现类里需要你返回所有的配置文件文本内容。这样也也意味着如果你存于数据库中，要存储所有的规则文件文本。\n\n如果你想把规则细节都存于数据库中，而不是存整段规则文本的话 ，请参考用代码动态构造规则这章节。\n\n\n# 配置路径\n\n以下以springboot的配置做例子，spring以及非spring的环境配置可以详细阅读安装和集成这章节。\n\n你只需要把rule-source改成你自定义规则配置源的类即可\n\nliteflow.rule-source=xml:com.yomahub.liteflow.test.testcustomparser\n\n\n关于xml这种标签头\n\nliteflow不光支持xml配置方式，还支持json，yml的配置方式，这里xml:开头是表明这里读取的内容是xml形式的配置。关于规则文件支持格式请详细阅读规则文件格式这章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"开启和关闭",frontmatter:{title:"开启和关闭",date:"2022-06-01T13:03:03.000Z",permalink:"/pages/v2.6.X/1f47ae/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/010.%E5%BC%80%E5%90%AF%E5%92%8C%E5%85%B3%E9%97%AD.html",relativePath:"30.v2.6.X文档/060.使用详细指南/010.开启和关闭.md",key:"v-c780dd76",path:"/pages/v2.6.X/1f47ae/",headersStr:null,content:"对于springboot的项目来说，LiteFLow提供了自动装配功能，在启动时会进行加载规则，扫描组件等初始化行为\n\n如果你依赖了，但是不希望生效LiteFlow。则需要在配置文件中配置如下(这里以springboot的配置为例)：\n\nliteflow.enable=false\n\n\n这个默认为true，所以希望LiteFlow生效的用户不用关心这个参数。\n\n提示\n\n这里说明下，如果enable为false的话，spring上下文中不会去加载FlowExecutor，那你自己的类中如果@Autowire了这个，启动时仍会报错。\n\nenable为false，只是代表不初始化LiteFlow的一些元数据，但并不意味着你设为false了，你项目仍能正常启动。还需要做点变动的。",normalizedContent:"对于springboot的项目来说，liteflow提供了自动装配功能，在启动时会进行加载规则，扫描组件等初始化行为\n\n如果你依赖了，但是不希望生效liteflow。则需要在配置文件中配置如下(这里以springboot的配置为例)：\n\nliteflow.enable=false\n\n\n这个默认为true，所以希望liteflow生效的用户不用关心这个参数。\n\n提示\n\n这里说明下，如果enable为false的话，spring上下文中不会去加载flowexecutor，那你自己的类中如果@autowire了这个，启动时仍会报错。\n\nenable为false，只是代表不初始化liteflow的一些元数据，但并不意味着你设为false了，你项目仍能正常启动。还需要做点变动的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"如何构造",frontmatter:{title:"如何构造",date:"2022-06-01T12:04:40.000Z",permalink:"/pages/v2.6.X/933342/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/050.%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8A%A8%E6%80%81%E6%9E%84%E9%80%A0%E8%A7%84%E5%88%99/020.%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0.html",relativePath:"30.v2.6.X文档/050.用代码动态构造规则/020.如何构造.md",key:"v-7e9380af",path:"/pages/v2.6.X/933342/",headers:[{level:2,title:"构造Node",slug:"构造node",normalizedTitle:"构造node",charIndex:93},{level:2,title:"构建一个Chain",slug:"构建一个chain",normalizedTitle:"构建一个chain",charIndex:1363},{level:2,title:"销毁一个Chain",slug:"销毁一个chain",normalizedTitle:"销毁一个chain",charIndex:2002}],headersStr:"构造Node 构建一个Chain 销毁一个Chain",content:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 构造Node\n\n你可以像以下那样构造一个普通的Node，当然在spring/springboot环境，大多数情况你无需去构建一个Node，因为只要你的组件上标有@Component/@LiteflowComponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件。\n\n//构建一个普通组件\nLiteFlowNodeBuilder.createCommonNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个普通条件组件\nLiteFlowNodeBuilder.createCommonCondNode().setId("a")\n                .setName("组件A")\n                .setClazz("com.yomahub.liteflow.test.builder.cmp.ACmp")\n                .build();\n\n//构建一个脚本组件\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nLiteFlowNodeBuilder.createScriptCondNode().setId("a")\n                .setName("组件A")\n                .setScript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nLiteFlowNodeBuilder.createScriptNode().setId("a")\n                .setName("组件A")\n                .setFile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@LiteflowComponent或者@Component，如果项目是spring体系的话，LiteFlow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@Autowired和@Resource等等之类的spring任何注解。\n\n\n# 构建一个Chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nLiteFlowChainBuilder.createChain().setChainName("chain2").setCondition(\n  LiteFlowConditionBuilder.createThenCondition().setValue("c,d").build()\n).build();\n\nLiteFlowChainBuilder.createChain().setChainName("chain1").setCondition(\n  LiteFlowConditionBuilder.createThenCondition().setValue("a,b").build()\n).setCondition(\n  LiteFlowConditionBuilder.createWhenCondition().setValue("e(f|g|chain2)").build()\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你的链路之间有依赖关系，比如上面的代码，chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n如果使用规则文件，那顺序无所谓，因为规则文件是统一解析好的。用构造模式，如果有依赖，顺序问题要注意下。\n\n\n# 销毁一个Chain\n\nLiteFlow从2.6.13开始支持了流程的销毁，你可以手动运行以下代码来销毁一个流程：\n\nFlowBus.removeChain("你的流程ID")\n',normalizedContent:'要说明的是，构造模式和规则配置模式，其实并不是只能二选一。他们既可以单独使用，也可以结合起来使用，并不冲突。事实上，即便是规则配置模式，底层也使用了构造模式。所以，您随意就是。\n\n\n# 构造node\n\n你可以像以下那样构造一个普通的node，当然在spring/springboot环境，大多数情况你无需去构建一个node，因为只要你的组件上标有@component/@liteflowcomponent，并且被scan到的话，组件会自动注册。\n\n我这里只是告诉您，可以这样去通过代码去构造，如果你的组件是动态代理类而不是一个静态存在的java类，或是脚本节点，这样的构建就显得很有意义了。\n\n关于脚本节点的概念，可以查看脚本组件。\n\n//构建一个普通组件\nliteflownodebuilder.createcommonnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个普通条件组件\nliteflownodebuilder.createcommoncondnode().setid("a")\n                .setname("组件a")\n                .setclazz("com.yomahub.liteflow.test.builder.cmp.acmp")\n                .build();\n\n//构建一个脚本组件\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本条件组件\nliteflownodebuilder.createscriptcondnode().setid("a")\n                .setname("组件a")\n                .setscript("你的脚本")\n                .build();\n\n//构建一个脚本组件，从file载入脚本\nliteflownodebuilder.createscriptnode().setid("a")\n                .setname("组件a")\n                .setfile("xml-script-file/s1.groovy")\n                .build();\n\n\n提示\n\n这里的节点类，不需要你去声明@liteflowcomponent或者@component，如果项目是spring体系的话，liteflow框架会自动的把节点类注入到spring上下文中。\n\n所以你仍旧可以在这个类里使用@autowired和@resource等等之类的spring任何注解。\n\n\n# 构建一个chain\n\n你可以像以下那样构造一个chain，由于和规则定义的没冲突。你也可以和规则文件结合起来用。当build的时候，如果没有则添加，如果有则修改。\n\nliteflowchainbuilder.createchain().setchainname("chain2").setcondition(\n  liteflowconditionbuilder.createthencondition().setvalue("c,d").build()\n).build();\n\nliteflowchainbuilder.createchain().setchainname("chain1").setcondition(\n  liteflowconditionbuilder.createthencondition().setvalue("a,b").build()\n).setcondition(\n  liteflowconditionbuilder.createwhencondition().setvalue("e(f|g|chain2)").build()\n).build();\n\n\n值得提一下的是，由于用构造模式是一个链路一个链路的添加，如果你的链路之间有依赖关系，比如上面的代码，chain1依赖chain2，那么chain2要先构建。否则会报错。\n\n如果使用规则文件，那顺序无所谓，因为规则文件是统一解析好的。用构造模式，如果有依赖，顺序问题要注意下。\n\n\n# 销毁一个chain\n\nliteflow从2.6.13开始支持了流程的销毁，你可以手动运行以下代码来销毁一个流程：\n\nflowbus.removechain("你的流程id")\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"执行器",frontmatter:{title:"执行器",date:"2022-06-01T13:12:28.000Z",permalink:"/pages/v2.6.X/07dc9a/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/030.%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"30.v2.6.X文档/060.使用详细指南/030.执行器.md",key:"v-44e111c4",path:"/pages/v2.6.X/07dc9a/",headers:[{level:2,title:"返回类型为LiteflowResponse",slug:"返回类型为liteflowresponse",normalizedTitle:"返回类型为liteflowresponse",charIndex:34},{level:2,title:"返回类型为Slot接口的子类",slug:"返回类型为slot接口的子类",normalizedTitle:"返回类型为slot接口的子类",charIndex:651},{level:2,title:"返回类型为Future",slug:"返回类型为future",normalizedTitle:"返回类型为future",charIndex:1106}],headersStr:"返回类型为LiteflowResponse 返回类型为Slot接口的子类 返回类型为Future",content:"执行器FlowExecutor用来执行一个流程，三种用法。\n\n\n# 返回类型为LiteflowResponse\n\n其中最经常用到的有3个方法：\n\n//参数为流程ID，无初始流程入参\npublic LiteflowResponse<DefaultSlot> execute2Resp(String chainId)\n//第一个参数为流程ID，第二个参数为流程入参。其中流程入参可以在组件中通过this.getSlot().getRequestData()来获得。\npublic LiteflowResponse<DefaultSlot> execute2Resp(String chainId, Object param);\n//第一个参数为流程ID，第二个参数为流程入参，第三个参数为自定义的Slot类型\npublic LiteflowResponse<T> execute2Resp(String chainId, Object param, Class<T> slotClazz)\n\n\n如果你不定义自己的Slot，那么前2个能满足，第三个适用于你定义了自己的Slot类型的场景。\n\n这里强烈推荐在业务系统中实现属于自己的Slot。具体原因和详情请参考数据槽。\n\n你可以通过LiteflowResponse中的isSuccess()方法来判断链路是否执行成功。\n\n这三个执行方法是不会抛出异常的，如果执行的链路有错误，你可以通过LiteflowResponse的getCause方法来获得。\n\n\n# 返回类型为Slot接口的子类\n\n同样的，经常用到的也有3个接口\n\n//参数为流程ID，无初始流程入参\npublic DefaultSlot execute(String chainId) throws Exception;\n//第一个参数为流程ID，第二个参数为流程入参。其中流程入参可以在组件中通过this.getSlot().getRequestData()来获得。\npublic DefaultSlot execute(String chainId,Object param) throws Exception;\n//第一个参数为流程ID，第二个参数为流程入参，第三个参数为自定义的Slot类型\npublic <T extends Slot> T execute(String chainId, Object param, Class<T> slotClazz) throws Exception\n\n\n在这种执行接口中，如果链路有错，会直接抛出来。\n\n关于Slot，想要了解更多，请参考数据槽。\n\n\n# 返回类型为Future\n\nLiteFlow从2.6.13开始支持了执行器层面的异步，支持返回future。\n\n//第一个参数为流程ID，第二个参数为流程入参，第三个参数为自定义的Slot类型\npublic <T extends Slot> Future<LiteflowResponse<T>> execute2Future(String chainId, Object param, Class<T> slotClazz)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到reponse，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，LiteFlow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.LiteFlowDefaultMainExecutorBuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现ExecutorBuilder接口：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n",normalizedContent:"执行器flowexecutor用来执行一个流程，三种用法。\n\n\n# 返回类型为liteflowresponse\n\n其中最经常用到的有3个方法：\n\n//参数为流程id，无初始流程入参\npublic liteflowresponse<defaultslot> execute2resp(string chainid)\n//第一个参数为流程id，第二个参数为流程入参。其中流程入参可以在组件中通过this.getslot().getrequestdata()来获得。\npublic liteflowresponse<defaultslot> execute2resp(string chainid, object param);\n//第一个参数为流程id，第二个参数为流程入参，第三个参数为自定义的slot类型\npublic liteflowresponse<t> execute2resp(string chainid, object param, class<t> slotclazz)\n\n\n如果你不定义自己的slot，那么前2个能满足，第三个适用于你定义了自己的slot类型的场景。\n\n这里强烈推荐在业务系统中实现属于自己的slot。具体原因和详情请参考数据槽。\n\n你可以通过liteflowresponse中的issuccess()方法来判断链路是否执行成功。\n\n这三个执行方法是不会抛出异常的，如果执行的链路有错误，你可以通过liteflowresponse的getcause方法来获得。\n\n\n# 返回类型为slot接口的子类\n\n同样的，经常用到的也有3个接口\n\n//参数为流程id，无初始流程入参\npublic defaultslot execute(string chainid) throws exception;\n//第一个参数为流程id，第二个参数为流程入参。其中流程入参可以在组件中通过this.getslot().getrequestdata()来获得。\npublic defaultslot execute(string chainid,object param) throws exception;\n//第一个参数为流程id，第二个参数为流程入参，第三个参数为自定义的slot类型\npublic <t extends slot> t execute(string chainid, object param, class<t> slotclazz) throws exception\n\n\n在这种执行接口中，如果链路有错，会直接抛出来。\n\n关于slot，想要了解更多，请参考数据槽。\n\n\n# 返回类型为future\n\nliteflow从2.6.13开始支持了执行器层面的异步，支持返回future。\n\n//第一个参数为流程id，第二个参数为流程入参，第三个参数为自定义的slot类型\npublic <t extends slot> future<liteflowresponse<t>> execute2future(string chainid, object param, class<t> slotclazz)\n\n\n如果调用这个方法，那就是无阻塞的，想要拿到reponse，请用得到的future.get()就可以了。\n\n同时，主执行器在这个模式下的线程数和线程池也可以自定义，具体配置如下，liteflow已经设置了预设值，你也可自己定义。\n\nliteflow.main-executor-works=64\nliteflow.main-executor-class=com.yomahub.liteflow.thread.liteflowdefaultmainexecutorbuilder\n\n\n如果你定义了自定义线程池，你需新建一个类，然后实现executorbuilder接口：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"同步异步编排",frontmatter:{title:"同步异步编排",date:"2022-06-01T13:07:09.000Z",permalink:"/pages/v2.6.X/25d803/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/020.%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92.html",relativePath:"30.v2.6.X文档/060.使用详细指南/020.同步异步编排.md",key:"v-3e17b9be",path:"/pages/v2.6.X/25d803/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"同步流程块",slug:"同步流程块",normalizedTitle:"同步流程块",charIndex:75},{level:2,title:"异步流程块",slug:"异步流程块",normalizedTitle:"异步流程块",charIndex:99},{level:2,title:"异步线程池",slug:"异步线程池",normalizedTitle:"异步线程池",charIndex:351},{level:2,title:"异步并行组",slug:"异步并行组",normalizedTitle:"异步并行组",charIndex:499},{level:2,title:"相同异步并行组之间的抛错",slug:"相同异步并行组之间的抛错",normalizedTitle:"相同异步并行组之间的抛错",charIndex:728},{level:2,title:"不同异步并行组之间的抛错",slug:"不同异步并行组之间的抛错",normalizedTitle:"不同异步并行组之间的抛错",charIndex:851},{level:2,title:"相同异步并行组之间的抛错",slug:"相同异步并行组之间的抛错-2",normalizedTitle:"相同异步并行组之间的抛错",charIndex:728},{level:2,title:"异步任一线程结束即继续",slug:"异步任一线程结束即继续",normalizedTitle:"异步任一线程结束即继续",charIndex:1432}],headersStr:"概述 同步流程块 异步流程块 异步线程池 异步并行组 相同异步并行组之间的抛错 不同异步并行组之间的抛错 相同异步并行组之间的抛错 异步任一线程结束即继续",content:'# 概述\n\n提示\n\n同步和异步节点的编排在LiteFlow是一个核心概念，这章建议学习LiteFlow的小伙伴仔细看看。涉及了大量核心概念。\n\n\n# 同步流程块\n\nLiteFlow提供了同步流程块和异步流程块，配置起来非常简单\n\n以下为同步流程块，表示a,b,c,d四个组件会挨个同步执行\n\n<then value="a,b,c,d"/>\n\n\n下面的方式和上面等价\n\n<then value="a,b"/>\n<then value="c,d"/>\n\n\n\n# 异步流程块\n\n以下为异步流程块，表示a,b,c,d四个组件会并行执行\n\n<when value="a,b,c,d"/>\n\n\n当然下面的方式也和上面等价\n\n<when value="a,b"/>\n<when value="c,d"/>\n\n\n\n# 异步线程池\n\nLiteFlow从2.5.0开始引入了异步流程块的线程池设定\n\n你可以通过这样配置线程池大小以及等待队列\n\n#异步线程池最大线程数\nliteflow.when-max-workers=4\n#异步线程池等待队列数\nliteflow.when-queue-limit=100\n\n\n\n# 异步并行组\n\n如果有同学想并行执行a,b，等执行好了，再并行执行c,d，该怎么办呢？\n\n从2.5.0版本开始，引入了group的概念，你只需这么配置就行了\n\n<when group="g1" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\nLiteFlow规定，2个不同组的when是按照配置的顺序执行的，相同组的when是完全并行的。如果不配，默认组是default，所以不配置组默认就是在同一组内的\n\n\n# 相同异步并行组之间的抛错\n\n不配置group或者配成一样的，那无论有多少个<when>还是你一个<when>里有配置了多个组件，都是等价的。都会并行执行。\n\n那么有一个组件抛错，其他组件依旧会执行。等到整个when结束后，才会抛错出来。\n\n\n# 不同异步并行组之间的抛错\n\n如果2个并行组之间，有一组任一节点报错。不想执行下一个并行组怎么办，从2.5.0版本开始，引入了一个参数errorResume,你可以这样配置\n\n<when group="g1" errorResume="false" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\n上面的配置表示，默认就是false，所以不配置也行，如果g1并行组件a和b有一个执行报错，则第二个<when>不会执行\n\n如果设为true，如果并行组g1中任意一个节点抛出异常，则g2并行组，依旧执行\n\n\n# 相同异步并行组之间的抛错\n\n思考以下问题，如果有以下流程，第一个并行组出错还继续，第二个出错不继续。那么如果c报错，会走到e么\n\n<when errorResume="true" value="a,b"/>\n<when errorResume="false" value="c,d"/>\n<then value="e"/>\n\n\n应该是会走到e，因为他们是相通并行组，LiteFlow会进行合并，合并的话，errorResume会参照第一个来进行。也就等价于：\n\n<when errorResume="true" value="a,b,c,d"/>\n<then value="e"/>\n\n\n所以会走到e\n\n\n# 异步任一线程结束即继续\n\nLiteFlow从2.6.4开始，支持了异步组件任意一个结束即继续的特性。\n\n如果有以下流程：\n\n<chain name="chain1">\n    <when value="a,b,c"/>\n    <then value="d"/>\n</chain>\n\n\n表示a,b,c三个并行，但是要等到a,b,c都执行完了，才能执行d。\n\n如果要达成a,b,c任意一个执行完，即执行d，你需要这么配置\n\n<chain name="chain1">\n    <when value="a,b,c" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n这样就可以达成了。是不是很简单。\n\n思考如下的场景：\n\n<chain name="chain1">\n    <when value="a1,b1,c1" any="true"/>\n    <when value="a2,b2,c2"/>\n    <then value="d"/>\n</chain>\n\n\n如果b1最先执行完，那么会不会接下去执行a2,b2,c2中的某一个？\n\n答案是不会，有可能b1会先执行完，然后直接执行d，然后再进行执行后续的其他节点。\n\n为什么会跳过第二个when呢，因为上面说过了。相同并行组会合并的，并以第一个when上的参数为准，以上就等价于：\n\n<chain name="chain1">\n    <when value="a1,b1,c1,a2,b2,c2" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n所以换成以上这种形式，是不是就好理解点了？',normalizedContent:'# 概述\n\n提示\n\n同步和异步节点的编排在liteflow是一个核心概念，这章建议学习liteflow的小伙伴仔细看看。涉及了大量核心概念。\n\n\n# 同步流程块\n\nliteflow提供了同步流程块和异步流程块，配置起来非常简单\n\n以下为同步流程块，表示a,b,c,d四个组件会挨个同步执行\n\n<then value="a,b,c,d"/>\n\n\n下面的方式和上面等价\n\n<then value="a,b"/>\n<then value="c,d"/>\n\n\n\n# 异步流程块\n\n以下为异步流程块，表示a,b,c,d四个组件会并行执行\n\n<when value="a,b,c,d"/>\n\n\n当然下面的方式也和上面等价\n\n<when value="a,b"/>\n<when value="c,d"/>\n\n\n\n# 异步线程池\n\nliteflow从2.5.0开始引入了异步流程块的线程池设定\n\n你可以通过这样配置线程池大小以及等待队列\n\n#异步线程池最大线程数\nliteflow.when-max-workers=4\n#异步线程池等待队列数\nliteflow.when-queue-limit=100\n\n\n\n# 异步并行组\n\n如果有同学想并行执行a,b，等执行好了，再并行执行c,d，该怎么办呢？\n\n从2.5.0版本开始，引入了group的概念，你只需这么配置就行了\n\n<when group="g1" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\nliteflow规定，2个不同组的when是按照配置的顺序执行的，相同组的when是完全并行的。如果不配，默认组是default，所以不配置组默认就是在同一组内的\n\n\n# 相同异步并行组之间的抛错\n\n不配置group或者配成一样的，那无论有多少个<when>还是你一个<when>里有配置了多个组件，都是等价的。都会并行执行。\n\n那么有一个组件抛错，其他组件依旧会执行。等到整个when结束后，才会抛错出来。\n\n\n# 不同异步并行组之间的抛错\n\n如果2个并行组之间，有一组任一节点报错。不想执行下一个并行组怎么办，从2.5.0版本开始，引入了一个参数errorresume,你可以这样配置\n\n<when group="g1" errorresume="false" value="a,b"/>\n<when group="g2" value="c,d"/>\n\n\n上面的配置表示，默认就是false，所以不配置也行，如果g1并行组件a和b有一个执行报错，则第二个<when>不会执行\n\n如果设为true，如果并行组g1中任意一个节点抛出异常，则g2并行组，依旧执行\n\n\n# 相同异步并行组之间的抛错\n\n思考以下问题，如果有以下流程，第一个并行组出错还继续，第二个出错不继续。那么如果c报错，会走到e么\n\n<when errorresume="true" value="a,b"/>\n<when errorresume="false" value="c,d"/>\n<then value="e"/>\n\n\n应该是会走到e，因为他们是相通并行组，liteflow会进行合并，合并的话，errorresume会参照第一个来进行。也就等价于：\n\n<when errorresume="true" value="a,b,c,d"/>\n<then value="e"/>\n\n\n所以会走到e\n\n\n# 异步任一线程结束即继续\n\nliteflow从2.6.4开始，支持了异步组件任意一个结束即继续的特性。\n\n如果有以下流程：\n\n<chain name="chain1">\n    <when value="a,b,c"/>\n    <then value="d"/>\n</chain>\n\n\n表示a,b,c三个并行，但是要等到a,b,c都执行完了，才能执行d。\n\n如果要达成a,b,c任意一个执行完，即执行d，你需要这么配置\n\n<chain name="chain1">\n    <when value="a,b,c" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n这样就可以达成了。是不是很简单。\n\n思考如下的场景：\n\n<chain name="chain1">\n    <when value="a1,b1,c1" any="true"/>\n    <when value="a2,b2,c2"/>\n    <then value="d"/>\n</chain>\n\n\n如果b1最先执行完，那么会不会接下去执行a2,b2,c2中的某一个？\n\n答案是不会，有可能b1会先执行完，然后直接执行d，然后再进行执行后续的其他节点。\n\n为什么会跳过第二个when呢，因为上面说过了。相同并行组会合并的，并以第一个when上的参数为准，以上就等价于：\n\n<chain name="chain1">\n    <when value="a1,b1,c1,a2,b2,c2" any="true"/>\n    <then value="d"/>\n</chain>\n\n\n所以换成以上这种形式，是不是就好理解点了？',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"数据槽",frontmatter:{title:"数据槽",date:"2022-06-01T13:15:54.000Z",permalink:"/pages/v2.6.X/eb758e/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/040.%E6%95%B0%E6%8D%AE%E6%A7%BD.html",relativePath:"30.v2.6.X文档/060.使用详细指南/040.数据槽.md",key:"v-c23e6ee8",path:"/pages/v2.6.X/eb758e/",headers:[{level:2,title:"Slot中的一些方法",slug:"slot中的一些方法",normalizedTitle:"slot中的一些方法",charIndex:488},{level:2,title:"Slot的数量",slug:"slot的数量",normalizedTitle:"slot的数量",charIndex:807}],headersStr:"Slot中的一些方法 Slot的数量",content:"概念\n\n在执行器执行流程时会分配唯一的一个数据槽给这个请求。不同请求的数据槽是完全隔离的。你可以理解为数据槽就是这个请求中的上下文，里面存放着此请求所有的数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据槽来实现的。\n\nLiteFlow提供了一个默认的SLOT实现：DefaultSlot。这个默认的实现其实里面主要存储数据的容器就是一个Map。\n\n比如可以通过getRequestData获得流程的初始参数，通过getChainName获取流程的命名，通过setInput,getInput,setOutput,getOutput设置和获取属于某个组件专有的数据对象。当然也提供了最通用的方法setData和getData用来设置和获取业务的数据。\n\n建议\n\nDefaultSlot虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的Slot。\n\n自己定义的Slot实质上就是一个最简单的值对象，只需继承AbsSlot就可以了。自己定义的Slot因为是强类型，更加贴合业务。\n\n\n# Slot中的一些方法\n\n无论你使用DefaultSlot还是自定义的Slot，Slot会有一些元方法供大家调用：\n\ngetRequestId()：每一个链路在执行初期都会生成这个链路的唯一ID，同时这个ID也会打印在日志中。方便于追踪。这个方法能得到这个链路追踪ID。\n\ngetRequestData()：获取链路的初始参数。\n\ngetChainName()：获取链路的名称。\n\ngetException()：得到链路中的异常信息，如果没有就为null。\n\ngetExecuteStepStr()：得到链路中的执行步骤信息。\n\nsetData(K,V)：往slot中设置一个值。\n\ngetData(K)：从Slot里得到一个值。\n\n\n# Slot的数量\n\n在LiteFlow的配置中，提供一个slotSize的参数可以去配置初始化数量，但是这个默认值就是1024，在2.6.0版本中，当slot容量不够时，会按照0.75的因子去进行自动扩容。所以这个值不推荐主动配置。除非有特殊情况。",normalizedContent:"概念\n\n在执行器执行流程时会分配唯一的一个数据槽给这个请求。不同请求的数据槽是完全隔离的。你可以理解为数据槽就是这个请求中的上下文，里面存放着此请求所有的数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据槽来实现的。\n\nliteflow提供了一个默认的slot实现：defaultslot。这个默认的实现其实里面主要存储数据的容器就是一个map。\n\n比如可以通过getrequestdata获得流程的初始参数，通过getchainname获取流程的命名，通过setinput,getinput,setoutput,getoutput设置和获取属于某个组件专有的数据对象。当然也提供了最通用的方法setdata和getdata用来设置和获取业务的数据。\n\n建议\n\ndefaultslot虽然可以用，但是在实际业务中，用这个会存在大量的弱类型，存取数据的时候都要进行强转，颇为不方便。所以官方建议你自己去实现自己的slot。\n\n自己定义的slot实质上就是一个最简单的值对象，只需继承absslot就可以了。自己定义的slot因为是强类型，更加贴合业务。\n\n\n# slot中的一些方法\n\n无论你使用defaultslot还是自定义的slot，slot会有一些元方法供大家调用：\n\ngetrequestid()：每一个链路在执行初期都会生成这个链路的唯一id，同时这个id也会打印在日志中。方便于追踪。这个方法能得到这个链路追踪id。\n\ngetrequestdata()：获取链路的初始参数。\n\ngetchainname()：获取链路的名称。\n\ngetexception()：得到链路中的异常信息，如果没有就为null。\n\ngetexecutestepstr()：得到链路中的执行步骤信息。\n\nsetdata(k,v)：往slot中设置一个值。\n\ngetdata(k)：从slot里得到一个值。\n\n\n# slot的数量\n\n在liteflow的配置中，提供一个slotsize的参数可以去配置初始化数量，但是这个默认值就是1024，在2.6.0版本中，当slot容量不够时，会按照0.75的因子去进行自动扩容。所以这个值不推荐主动配置。除非有特殊情况。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"条件组件",frontmatter:{title:"条件组件",date:"2022-06-01T13:20:11.000Z",permalink:"/pages/v2.6.X/381ed2/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/060.%E6%9D%A1%E4%BB%B6%E7%BB%84%E4%BB%B6.html",relativePath:"30.v2.6.X文档/060.使用详细指南/060.条件组件.md",key:"v-ed31df58",path:"/pages/v2.6.X/381ed2/",headersStr:null,content:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点\n\n<chain name="chain1">\n    <then value="a,c(b|d)"/> \x3c!-- c是路由节点，根据c里的逻辑决定路由到b节点还是d节点,可以配置多个 --\x3e\n    <then value="e,f,g"/>\n</chain>\n\n\n利用表达式可以很方便的进行条件的判断\n\nc节点是用来路由的，被称为条件节点，这种节点需要继承NodeCondComponent类\n\n需要实现方法processCond，这个方法需要返回String类型，就是具体的结果节点\n\n@LiteflowComponent("e")\npublic class ECmp extends NodeCondComponent {\n\n    @Override\n    public String processCond() throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n提示\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看步骤打印章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'在实际业务中，往往要通过动态的业务逻辑判断到底接下去该执行哪一个节点\n\n<chain name="chain1">\n    <then value="a,c(b|d)"/> \x3c!-- c是路由节点，根据c里的逻辑决定路由到b节点还是d节点,可以配置多个 --\x3e\n    <then value="e,f,g"/>\n</chain>\n\n\n利用表达式可以很方便的进行条件的判断\n\nc节点是用来路由的，被称为条件节点，这种节点需要继承nodecondcomponent类\n\n需要实现方法processcond，这个方法需要返回string类型，就是具体的结果节点\n\n@liteflowcomponent("e")\npublic class ecmp extends nodecondcomponent {\n\n    @override\n    public string processcond() throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n提示\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看步骤打印章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"普通组件",frontmatter:{title:"普通组件",date:"2022-06-01T13:19:11.000Z",permalink:"/pages/v2.6.X/43f09b/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/050.%E6%99%AE%E9%80%9A%E7%BB%84%E4%BB%B6.html",relativePath:"30.v2.6.X文档/060.使用详细指南/050.普通组件.md",key:"v-5364c5ee",path:"/pages/v2.6.X/43f09b/",headers:[{level:2,title:"isAccess",slug:"isaccess",normalizedTitle:"isaccess",charIndex:192},{level:2,title:"isContinueOnError",slug:"iscontinueonerror",normalizedTitle:"iscontinueonerror",charIndex:245},{level:2,title:"isEnd",slug:"isend",normalizedTitle:"isend",charIndex:295},{level:2,title:"Slot的获取",slug:"slot的获取",normalizedTitle:"slot的获取",charIndex:508},{level:2,title:"@LiteflowComponent",slug:"liteflowcomponent",normalizedTitle:"@liteflowcomponent",charIndex:39}],headersStr:"isAccess isContinueOnError isEnd Slot的获取 @LiteflowComponent",content:'组件节点需要继承NodeComponent类\n\n需要实现process方法\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# isAccess\n\n推荐实现isAccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# isContinueOnError\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isEnd\n\n表示是否立即结束整个流程 ，默认为false，也可以在业务日志里根据业务判断来调用this.setIsEnd(true)来结束整个流程。对于这种方式，最终的isSuccess是为true的(2.6.0版本修复)。\n\n需要注意的是，如果isContinueOnError为true的情况下，调用了this.setIsEnd(true)，那么依旧会终止。response里的isSuccess还是true。\n\n\n# Slot的获取\n\n在组件节点里，随时可以通过方法getSlot获取当前的数据槽，从而可以获取任何数据。\n\n\n# @LiteflowComponent\n\n从v2.6.0开始，新增了@LiteflowComponent标签，它是继承于Spring的@Component标签的，所以从作用上来说，和@Component标签并没有什么区别，但是@LiteflowComponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看步骤打印章节，新版本开始，推荐大家使用@LiteflowComponent，当然@Component也同样可以继续沿用。',normalizedContent:'组件节点需要继承nodecomponent类\n\n需要实现process方法\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# isaccess\n\n推荐实现isaccess方法，表示是否进入该节点，可以用于业务参数的预先判断\n\n\n# iscontinueonerror\n\n表示出错是否继续往下执行下一个组件，默认为false\n\n\n# isend\n\n表示是否立即结束整个流程 ，默认为false，也可以在业务日志里根据业务判断来调用this.setisend(true)来结束整个流程。对于这种方式，最终的issuccess是为true的(2.6.0版本修复)。\n\n需要注意的是，如果iscontinueonerror为true的情况下，调用了this.setisend(true)，那么依旧会终止。response里的issuccess还是true。\n\n\n# slot的获取\n\n在组件节点里，随时可以通过方法getslot获取当前的数据槽，从而可以获取任何数据。\n\n\n# @liteflowcomponent\n\n从v2.6.0开始，新增了@liteflowcomponent标签，它是继承于spring的@component标签的，所以从作用上来说，和@component标签并没有什么区别，但是@liteflowcomponent新增加了name属性，用于给组件起别名，在打印调用链的时候会体现。具体请查看步骤打印章节，新版本开始，推荐大家使用@liteflowcomponent，当然@component也同样可以继续沿用。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"声明式组件",frontmatter:{title:"声明式组件",date:"2022-06-01T13:28:33.000Z",permalink:"/pages/v2.6.X/6f8b42/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/080.%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BB%84%E4%BB%B6.html",relativePath:"30.v2.6.X文档/060.使用详细指南/080.声明式组件.md",key:"v-55eb1e48",path:"/pages/v2.6.X/6f8b42/",headers:[{level:2,title:"普通组件的声明",slug:"普通组件的声明",normalizedTitle:"普通组件的声明",charIndex:232},{level:2,title:"条件组件的声明",slug:"条件组件的声明",normalizedTitle:"条件组件的声明",charIndex:1029},{level:2,title:"关于实现",slug:"关于实现",normalizedTitle:"关于实现",charIndex:1324}],headersStr:"普通组件的声明 条件组件的声明 关于实现",content:'LiteFlow从2.6.14起开始支持声明式的组件。\n\n何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承NodeComponent或者NodeCondComponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成LiteFlow组件的声明。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@LiteflowComponent("a")\n@LiteflowCmpDefine\npublic class ACmp{\n    @LiteflowMethod(LiteFlowMethodEnum.PROCESS)\n    public void process(NodeComponent bindCmp) {\n        System.out.println("A Comp executed!");\n        Slot slot = bindCmp.getSlot();\n      \t//do your biz\n    }\n\n    @LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)\n    public boolean isAccess(NodeComponent bindCmp) {\n        Slot slot = bindCmp.getSlot();\n      \t//do your biz\n    }\n\n}\n\n\n使用者无需继承NodeCondComponent了，在你定义的类上，只要类上加上LiteflowCmpDefine注解，相应的方法上加上LiteflowMethod注解，即可完成对任意自定义类的组件化工作。\n\n其中LiteFlowMethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n这里注意的是，方法上参数必须传入NodeComponent bindCmp这个参数，而且必须只有一个参数，否则会报错，以前获取slot是用this关键字，现在只需从bindCmp中获取就可以了。\n\n这里方法名示例上是和以前一致，但你也可自己定义任意的方法名。这个并无限制。\n\n\n# 条件组件的声明\n\n声明条件组件和普通组件差不多，如下所示：\n\n@Component("e")\n@LiteflowCondCmpDefine\npublic class ECmp{\n\n    @LiteflowMethod(LiteFlowMethodEnum.PROCESS_COND)\n    public String processCond(NodeComponent bindCmp) throws Exception {\n        System.out.println("Ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 关于实现\n\n声明式组件依靠动态代理来实现，底层用的动态代理框架为ByteBuddy。\n\n所有的动态代理类在注册时类名均做了处理，所以你会看到如下的日志打印\n\n2022-05-16 13:05:56.492  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$a$JLWBAK   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$a$JLWBAK] execution\n2022-05-16 13:05:56.496  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$b$JZXUWG   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$b$JZXUWG] execution\n2022-05-16 13:05:56.505  INFO 73054 --- [lf-when-thead-0] c.y.l.test.base.cmp.ByteBuddy$c$RWWUCJ   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$c$RWWUCJ] execution\n2022-05-16 13:05:56.506  INFO 73054 --- [lf-when-thead-1] c.y.l.test.base.cmp.ByteBuddy$d$RECNPY   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$d$RECNPY] execution\n\n\n仔细看会发现，所有的动态代理后的类名的格式为：ByteBuddy$你的组件名$随机6位字符串。\n\n所以在看日志时，对于声明式组件而言，你只需要看两个$中间的那个，即为你的组件ID。这点怕有人有疑惑，特地说明一下。',normalizedContent:'liteflow从2.6.14起开始支持声明式的组件。\n\n何谓声明式组件？\n\n之前章节介绍的普通组件和条件组件，在写法上需要你自己去定义一个类去继承nodecomponent或者nodecondcomponent。这样一方面造成了耦合，另一方面由于java是单继承制，所以使用者就无法再去继承自己的类了，在自由度上就少了很多玩法。\n\n声明式组件这一特性允许你自定义的组件不继承任何类和实现任何接口，普通的类也可以依靠注解来完成liteflow组件的声明。\n\n\n# 普通组件的声明\n\n你可以如下去进行一个普通组件的声明：\n\n@liteflowcomponent("a")\n@liteflowcmpdefine\npublic class acmp{\n    @liteflowmethod(liteflowmethodenum.process)\n    public void process(nodecomponent bindcmp) {\n        system.out.println("a comp executed!");\n        slot slot = bindcmp.getslot();\n      \t//do your biz\n    }\n\n    @liteflowmethod(liteflowmethodenum.is_access)\n    public boolean isaccess(nodecomponent bindcmp) {\n        slot slot = bindcmp.getslot();\n      \t//do your biz\n    }\n\n}\n\n\n使用者无需继承nodecondcomponent了，在你定义的类上，只要类上加上liteflowcmpdefine注解，相应的方法上加上liteflowmethod注解，即可完成对任意自定义类的组件化工作。\n\n其中liteflowmethod的作用是把你自己的定义的方法映射成组件的方法。除了有示例上的值外，还有其他的映射方法。具体可以看下普通组件章节。\n\n这里注意的是，方法上参数必须传入nodecomponent bindcmp这个参数，而且必须只有一个参数，否则会报错，以前获取slot是用this关键字，现在只需从bindcmp中获取就可以了。\n\n这里方法名示例上是和以前一致，但你也可自己定义任意的方法名。这个并无限制。\n\n\n# 条件组件的声明\n\n声明条件组件和普通组件差不多，如下所示：\n\n@component("e")\n@liteflowcondcmpdefine\npublic class ecmp{\n\n    @liteflowmethod(liteflowmethodenum.process_cond)\n    public string processcond(nodecomponent bindcmp) throws exception {\n        system.out.println("ecomp executed!");\n        return "g";\n    }\n}\n\n\n\n# 关于实现\n\n声明式组件依靠动态代理来实现，底层用的动态代理框架为bytebuddy。\n\n所有的动态代理类在注册时类名均做了处理，所以你会看到如下的日志打印\n\n2022-05-16 13:05:56.492  info 73054 --- [           main] c.y.l.test.base.cmp.bytebuddy$a$jlwbak   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$a$jlwbak] execution\n2022-05-16 13:05:56.496  info 73054 --- [           main] c.y.l.test.base.cmp.bytebuddy$b$jzxuwg   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$b$jzxuwg] execution\n2022-05-16 13:05:56.505  info 73054 --- [lf-when-thead-0] c.y.l.test.base.cmp.bytebuddy$c$rwwucj   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$c$rwwucj] execution\n2022-05-16 13:05:56.506  info 73054 --- [lf-when-thead-1] c.y.l.test.base.cmp.bytebuddy$d$recnpy   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[o]start component[bytebuddy$d$recnpy] execution\n\n\n仔细看会发现，所有的动态代理后的类名的格式为：bytebuddy$你的组件名$随机6位字符串。\n\n所以在看日志时，对于声明式组件而言，你只需要看两个$中间的那个，即为你的组件id。这点怕有人有疑惑，特地说明一下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"前置后置组件",frontmatter:{title:"前置后置组件",date:"2022-06-01T13:30:35.000Z",permalink:"/pages/v2.6.X/1e7143/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/090.%E5%89%8D%E7%BD%AE%E5%90%8E%E7%BD%AE%E7%BB%84%E4%BB%B6.html",relativePath:"30.v2.6.X文档/060.使用详细指南/090.前置后置组件.md",key:"v-ceda0374",path:"/pages/v2.6.X/1e7143/",headers:[{level:2,title:"前置组件",slug:"前置组件",normalizedTitle:"前置组件",charIndex:20},{level:2,title:"后置节点",slug:"后置节点",normalizedTitle:"后置节点",charIndex:273},{level:2,title:"顺序问题",slug:"顺序问题",normalizedTitle:"顺序问题",charIndex:460}],headersStr:"前置组件 后置节点 顺序问题",content:'LiteFlow从2.6.4开始，支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点。表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain1">\n    <pre value="p1,p2"/>\n    <then value="a,b,c"/>\n    <when value="d,e"/>\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受Exception影响，即便节点出错，后置节点依旧会执行。\n\n表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain3">\n    <then value="a,d,c"/>\n    <finally value="f1,f2"/>\n</chain>\n\n\n\n# 顺序问题\n\n为了方便阅读，推荐大家<pre>写在最前面，而<finally>写在最后面。\n\n但是从逻辑上来说，LiteFlow会自动进行排序处理，无论你<pre>和<finally>写在哪里，总会优先执行<pre>，最后执行<finally>。',normalizedContent:'liteflow从2.6.4开始，支持了前置组件和后置组件特性。\n\n此特性针对整个链路，在链路之前之后固定执行某些组件。用于业务的前置处理和后置处理。\n\n前置组件和后置组件，均为串行节点，目前不支持异步。\n\n\n# 前置组件\n\n固定在一个流程开始之前执行某些节点。表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain1">\n    <pre value="p1,p2"/>\n    <then value="a,b,c"/>\n    <when value="d,e"/>\n</chain>\n\n\n\n# 后置节点\n\n固定在一个流程结束后执行某些节点，要注意的是后置节点不受exception影响，即便节点出错，后置节点依旧会执行。\n\n表达方式为(这里仅以xml样式来举例，其他格式都差不多):\n\n<chain name="chain3">\n    <then value="a,d,c"/>\n    <finally value="f1,f2"/>\n</chain>\n\n\n\n# 顺序问题\n\n为了方便阅读，推荐大家<pre>写在最前面，而<finally>写在最后面。\n\n但是从逻辑上来说，liteflow会自动进行排序处理，无论你<pre>和<finally>写在哪里，总会优先执行<pre>，最后执行<finally>。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"脚本组件",frontmatter:{title:"脚本组件",date:"2022-06-01T12:19:06.000Z",permalink:"/pages/v2.6.X/8f6247/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/070.%E8%84%9A%E6%9C%AC%E7%BB%84%E4%BB%B6.html",relativePath:"30.v2.6.X文档/060.使用详细指南/070.脚本组件.md",key:"v-52b6e774",path:"/pages/v2.6.X/8f6247/",headers:[{level:2,title:"如何定义",slug:"如何定义",normalizedTitle:"如何定义",charIndex:66},{level:2,title:"文件脚本的定义",slug:"文件脚本的定义",normalizedTitle:"文件脚本的定义",charIndex:903},{level:2,title:"如何与java变量进行交互",slug:"如何与java变量进行交互",normalizedTitle:"如何与java变量进行交互",charIndex:1501},{level:2,title:"如何选择脚本框架",slug:"如何选择脚本框架",normalizedTitle:"如何选择脚本框架",charIndex:1707},{level:2,title:"脚本运行性能如何",slug:"脚本运行性能如何",normalizedTitle:"脚本运行性能如何",charIndex:2135},{level:2,title:"如何动态刷新脚本",slug:"如何动态刷新脚本",normalizedTitle:"如何动态刷新脚本",charIndex:2205}],headersStr:"如何定义 文件脚本的定义 如何与java变量进行交互 如何选择脚本框架 脚本运行性能如何 如何动态刷新脚本",content:'LiteFlow从v2.6.0开始支持脚本节点的创建。支持热刷新脚本，支持QLExpress和Groovy两种脚本的编写。\n\n\n# 如何定义\n\n脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script">\n            <![CDATA[\n                a=3;\n                b=2;\n                slot.setData("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="条件脚本" type="cond_script">\n            <![CDATA[\n                count = slot.getData("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n要注意的是，type分为两种：script 和cond_script，分别对应普通脚本组件和条件脚本组件。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n\n# 文件脚本的定义\n\nLiteFlow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟IDE对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前LiteFlow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="条件脚本" type="cond_script" file="xml-script-file/s2.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n\n# 如何与java变量进行交互\n\n因为LiteFlow组件与组件之间的数据交互都在SLOT中，所以在脚本语言中，内置了关键字slot，你可以通过slot这个关键字来获取，设值任何数据。\n\n普通脚本组件，脚本中无需返回值。只需要把结果设置到SLOT即可（这和普通的java编写的组件是一致的）\n\n而条件脚本节点，则需要在脚本中返回条件路由到的节点ID，返回String类型（这也和java编写的组件是一致的）\n\n\n# 如何选择脚本框架\n\nLiteFlow采用SPI机制进行选择脚本框架来动态编译你的脚本。\n\nQLExpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-qlexpress</artifactId>\n    <version>2.6.14</version>\n</dependency>\n\n\nGroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupId>com.yomahub</groupId>\n    <artifactId>liteflow-script-groovy</artifactId>\n    <version>2.6.14</version>\n</dependency>\n\n\n你只需要依赖相应的脚本框架即可，SPI会动态选择你依赖的脚本框架进行编译解析你的脚本\n\n\n# 脚本运行性能如何\n\nLiteFlow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。\n\n\n# 如何动态刷新脚本\n\n提供了编码形式的刷新，刷新后可以重新编译脚本\n\nScriptExecutorFactory.loadInstance().getScriptExecutor().load(nodeId, script);\n',normalizedContent:'liteflow从v2.6.0开始支持脚本节点的创建。支持热刷新脚本，支持qlexpress和groovy两种脚本的编写。\n\n\n# 如何定义\n\n脚本节点定义是在规则文件中，你需要做如下定义（这里以xml文件格式举例）：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script">\n            <![cdata[\n                a=3;\n                b=2;\n                slot.setdata("s1",a*b);\n            ]]>\n        </node>\n\n        <node id="s2" name="条件脚本" type="cond_script">\n            <![cdata[\n                count = slot.getdata("count");\n                if(count > 100){\n                    return "a";\n                }else{\n                    return "b";\n                }\n            ]]>\n        </node>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n要注意的是，type分为两种：script 和cond_script，分别对应普通脚本组件和条件脚本组件。\n\n你可以在示例的位置进行编写动态脚本来处理业务逻辑。\n\n\n# 文件脚本的定义\n\nliteflow从2.6.4开始支持了脚本文件的定义。你除了可以把脚本内容写在配置文件中，也可以写在文件中。如果大的脚本就推荐写在文件中。毕竟ide对文件的语法高亮和代码提示做的也相对友好。编写脚本会更加方便。\n\n要注意的是，目前liteflow仅支持classpath内的脚本文件，这里无法定义绝对路径。以后可能会支持。\n\n你可以这样定义（这里以xml文件格式举例）:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本" type="script" file="xml-script-file/s1.groovy"/>\n        <node id="s2" name="条件脚本" type="cond_script" file="xml-script-file/s2.groovy"/>\n    </nodes>\n\n    <chain name="chain1">\n        <then value="a,b,c,s1"/>\n    </chain>\n\n    <chain name="chain2">\n        <then value="d,s2(a|b)"/>\n    </chain>\n</flow>\n\n\n\n# 如何与java变量进行交互\n\n因为liteflow组件与组件之间的数据交互都在slot中，所以在脚本语言中，内置了关键字slot，你可以通过slot这个关键字来获取，设值任何数据。\n\n普通脚本组件，脚本中无需返回值。只需要把结果设置到slot即可（这和普通的java编写的组件是一致的）\n\n而条件脚本节点，则需要在脚本中返回条件路由到的节点id，返回string类型（这也和java编写的组件是一致的）\n\n\n# 如何选择脚本框架\n\nliteflow采用spi机制进行选择脚本框架来动态编译你的脚本。\n\nqlexpress脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-qlexpress</artifactid>\n    <version>2.6.14</version>\n</dependency>\n\n\ngroovy脚本，你需要额外依赖：\n\n<dependency>\n    <groupid>com.yomahub</groupid>\n    <artifactid>liteflow-script-groovy</artifactid>\n    <version>2.6.14</version>\n</dependency>\n\n\n你只需要依赖相应的脚本框架即可，spi会动态选择你依赖的脚本框架进行编译解析你的脚本\n\n\n# 脚本运行性能如何\n\nliteflow对所有的脚本在启动时就进行了预编译，所以每次执行时无需编译的，运行性能和java不会差别太多。\n\n\n# 如何动态刷新脚本\n\n提供了编码形式的刷新，刷新后可以重新编译脚本\n\nscriptexecutorfactory.loadinstance().getscriptexecutor().load(nodeid, script);\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件标签",frontmatter:{title:"组件标签",date:"2022-06-01T13:31:32.000Z",permalink:"/pages/v2.6.X/87e386/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/100.%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE.html",relativePath:"30.v2.6.X文档/060.使用详细指南/100.组件标签.md",key:"v-05e65a1c",path:"/pages/v2.6.X/87e386/",headersStr:null,content:'你可以在流程xml/json/yml里为每个组件加上单独的标签，如这样：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],b[tag2],c[tag3]"/>\n    </chain>\n</flow>\n\n\n这样，你在代码里可以通过this.getTag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到当前执行到哪里。或者根据tag标签来给相同的组件作不同的判断。\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n    @Override\n    public void process() {\n        String tag = this.getTag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],a[tag2],a[tag3],b[tag4](c[tag5]|d[tag6])"/>\n    </chain>\n</flow>\n',normalizedContent:'你可以在流程xml/json/yml里为每个组件加上单独的标签，如这样：\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],b[tag2],c[tag3]"/>\n    </chain>\n</flow>\n\n\n这样，你在代码里可以通过this.gettag()获取到当前的标签，这在有些时候非常有用，尤其是当多个相同组件编排时，你可以根据tag来获知到当前执行到哪里。或者根据tag标签来给相同的组件作不同的判断。\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n    @override\n    public void process() {\n        string tag = this.gettag();\n        ...\n    }\n}\n\n\n当然，以下这种例子也是可以的:\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a[tag1],a[tag2],a[tag3],b[tag4](c[tag5]|d[tag6])"/>\n    </chain>\n</flow>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"子流程",frontmatter:{title:"子流程",date:"2022-06-01T13:34:12.000Z",permalink:"/pages/v2.6.X/2be4e2/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/110.%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"30.v2.6.X文档/060.使用详细指南/110.子流程.md",key:"v-493e29ee",path:"/pages/v2.6.X/2be4e2/",headersStr:null,content:'LiteFlow从2.3.0开始支持显式子流程，在xml里配置的节点，可以是节点，也可以是流程id。比如，你可以这么配置\n\n<chain name="chain3">\n    <then value="a,c,strategy1,g"/>\n</chain>\n<chain name="strategy1">\n    <then value="m(m1|m2|strategy2)"/>\n</chain>\n<chain name="strategy2">\n    <then value="q,p(p1|p2)"/>\n</chain>\n\n\n这样是不是很清晰\n\nLiteFlow支持无穷的嵌套结构，只要你想的出。可以完成相对复杂的流程。\n\n提示\n\n如果存在相同名字的节点和流程，优先节点。',normalizedContent:'liteflow从2.3.0开始支持显式子流程，在xml里配置的节点，可以是节点，也可以是流程id。比如，你可以这么配置\n\n<chain name="chain3">\n    <then value="a,c,strategy1,g"/>\n</chain>\n<chain name="strategy1">\n    <then value="m(m1|m2|strategy2)"/>\n</chain>\n<chain name="strategy2">\n    <then value="q,p(p1|p2)"/>\n</chain>\n\n\n这样是不是很清晰\n\nliteflow支持无穷的嵌套结构，只要你想的出。可以完成相对复杂的流程。\n\n提示\n\n如果存在相同名字的节点和流程，优先节点。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件重试",frontmatter:{title:"组件重试",date:"2022-06-01T13:38:38.000Z",permalink:"/pages/v2.6.X/e441ee/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/140.%E7%BB%84%E4%BB%B6%E9%87%8D%E8%AF%95.html",relativePath:"30.v2.6.X文档/060.使用详细指南/140.组件重试.md",key:"v-2b02f8cb",path:"/pages/v2.6.X/e441ee/",headers:[{level:2,title:"全局重试",slug:"全局重试",normalizedTitle:"全局重试",charIndex:31},{level:2,title:"单个组件重试",slug:"单个组件重试",normalizedTitle:"单个组件重试",charIndex:36},{level:2,title:"全局重试和单个组件重试都定义的情况下",slug:"全局重试和单个组件重试都定义的情况下",normalizedTitle:"全局重试和单个组件重试都定义的情况下",charIndex:987}],headersStr:"全局重试 单个组件重试 全局重试和单个组件重试都定义的情况下",content:'LiteFLow从v2.6.0起开始支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了isContinueOnError，设为true的话，那流程会继续。\n\n异步流程的话，如果<when>上配置了errorResume="true"的话(默认就是true)，则下一个不同并行组会继续。关于errorResume的定义和使用，可以查看同步异步编排章节。\n\n\n# 单个组件重试\n\nLiteFlow还提供了基于单个组件，指定Exception的重试特性，LiteFlow从2.6.0开始提供了@LiteflowRetry标注\n\n你可以在指定的组件上进行标注：\n\n@LiteflowComponent("c")\n@LiteflowRetry(5)\npublic class CCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@LiteflowComponent("e")\n@LiteflowRetry(retry = 5, forExceptions = {NullPointerException.class,IllegalArgumentException.class})\npublic class ECmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是NullPointerException或者IllegalArgumentException（或者是这两个Exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',normalizedContent:'liteflow从v2.6.0起开始支持组件的重试\n\n其中又分全局重试和单个组件重试，下面一一说明\n\n\n# 全局重试\n\n如果需要全局重试，你需要做如下配置：\n\nliteflow.retry-count=3\n\n\n这表明，如果组件抛出任何异常，会重试3次，如果3次之后依旧异常，那么整条流程结束。\n\n以下几种情况流程会继续：\n\n如果组件里覆盖了iscontinueonerror，设为true的话，那流程会继续。\n\n异步流程的话，如果<when>上配置了errorresume="true"的话(默认就是true)，则下一个不同并行组会继续。关于errorresume的定义和使用，可以查看同步异步编排章节。\n\n\n# 单个组件重试\n\nliteflow还提供了基于单个组件，指定exception的重试特性，liteflow从2.6.0开始提供了@liteflowretry标注\n\n你可以在指定的组件上进行标注：\n\n@liteflowcomponent("c")\n@liteflowretry(5)\npublic class ccmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n}\n\n\n那么，这样就表明，如果这个组件有任何异常抛出，则最多重试5遍。如果第5遍重试再不成功，那就会真正抛出你的业务异常\n\n同样，还可以在这个标注上指定一个或者多个异常：\n\n@liteflowcomponent("e")\n@liteflowretry(retry = 5, forexceptions = {nullpointerexception.class,illegalargumentexception.class})\npublic class ecmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n        //do your biz\n\t}\n}\n\n\n这样就表明，如果这个组件抛出的异常是nullpointerexception或者illegalargumentexception（或者是这两个exception类的子类），则会进行最多5次的尝试，最后一遍再不成功，那就会真正抛出异常。\n\n\n# 全局重试和单个组件重试都定义的情况下\n\n如果在2者都定义的情况下，优先取单个组件的重试配置。没有的情况下，再取全局配置。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"隐式子流程",frontmatter:{title:"隐式子流程",date:"2022-06-01T13:35:04.000Z",permalink:"/pages/v2.6.X/2777ec/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/120.%E9%9A%90%E5%BC%8F%E5%AD%90%E6%B5%81%E7%A8%8B.html",relativePath:"30.v2.6.X文档/060.使用详细指南/120.隐式子流程.md",key:"v-42b69329",path:"/pages/v2.6.X/2777ec/",headersStr:null,content:'LiteFlow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个SLOT的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用：\n\n@Component("h")\npublic class HComponent extends NodeComponent {\n\n\t@Resource\n\tprivate FlowExecutor flowExecutor;\n\t\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("Hcomponent executed!");\n        for(int i=0;i<10;i++){\n            flowExecutor.invoke("strategy1",3, DefaultSlot.class, this.getSlotIndex());\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内调用另外一个流程链的方法',normalizedContent:'liteflow支持在一个节点里通过代码调用另外一条流程， 这个流程关系在规则文件中并不会显示。所以这里称之为隐式调用。\n\n主流程和隐式子流程共同享有同一个slot的数据。所以隐式子流程里也完全可以拿到这个请求中的所有数据。\n\n隐式调用可以完成更为复杂的子流程，比如循环调用：\n\n@component("h")\npublic class hcomponent extends nodecomponent {\n\n\t@resource\n\tprivate flowexecutor flowexecutor;\n\t\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("hcomponent executed!");\n        for(int i=0;i<10;i++){\n            flowexecutor.invoke("strategy1",3, defaultslot.class, this.getslotindex());\n        }\n\t}\n}\n\n\n这段代码演示了在某个业务节点内调用另外一个流程链的方法',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"平滑热刷新",frontmatter:{title:"平滑热刷新",date:"2022-06-01T12:16:39.000Z",permalink:"/pages/v2.6.X/d0e86d/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/150.%E5%B9%B3%E6%BB%91%E7%83%AD%E5%88%B7%E6%96%B0.html",relativePath:"30.v2.6.X文档/060.使用详细指南/150.平滑热刷新.md",key:"v-04b2bb62",path:"/pages/v2.6.X/d0e86d/",headers:[{level:2,title:"基于规则文件-主动刷新",slug:"基于规则文件-主动刷新",normalizedTitle:"基于规则文件-主动刷新",charIndex:263},{level:2,title:"基于规则文件-被动刷新",slug:"基于规则文件-被动刷新",normalizedTitle:"基于规则文件-被动刷新",charIndex:385},{level:2,title:"基于动态代码构建-刷新",slug:"基于动态代码构建-刷新",normalizedTitle:"基于动态代码构建-刷新",charIndex:658}],headersStr:"基于规则文件-主动刷新 基于规则文件-被动刷新 基于动态代码构建-刷新",content:"LiteFlow从2.6.4开始支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nLiteFlow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，LiteFlow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到FlowExecutor对象后，调用以下接口：\n\nflowExecutor.reloadRule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nFlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_JSON, newContent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",normalizedContent:"liteflow从2.6.4开始支持了优雅平滑热刷新的特性。\n\n即你可以在不重启服务的情况下，进行规则的重载。并且在高并发下刷新的时候，正在执行流程的线程是完全平滑的，不会因为刷新的过程而出现中断的现象。\n\n在刷新时，正在执行的流程还是走的旧的流程，刷新好。后续request会自动切换到新的流程。\n\nliteflow原生支持的zookeeper配置源，不需要你做任何事，只要zk上的规则更改了之后，会自动热平滑刷新。\n\n但是对于自定义配置源来说，liteflow提供了主动刷新和被动刷新2个接口，根据需要自行选择。\n\n\n# 基于规则文件-主动刷新\n\n你可以在spring容器中拿到flowexecutor对象后，调用以下接口：\n\nflowexecutor.reloadrule();\n\n\n这个方法会按照启动时的方式去拉取你最新的流程配置信息，进行平滑热刷新。\n\n\n# 基于规则文件-被动刷新\n\n所谓被动刷新，适用于使用了诸如配置中心，nacos，etcd等自定配置源，这类配置源可以反向推送最新的数据。对于java客户端这边，一定会有一个诸如listener的监听器去监听数据的变更。\n\n如果你监听到了变更，你可以通过调用这个方法去实现平滑热刷新：\n\nflowbus.refreshflowmetadata(flowparsertypeenum.type_json, newcontent);\n\n\n其中第一个参数是指文件格式什么，支持xml/json/yml\n\n第二个参数指的是推送过来的最新配置文本数据\n\n\n# 基于动态代码构建-刷新\n\n如果你是基于动态代码构建的规则，则意味着没有规则文件，以上两种方式是基于规则文件的。\n\n其实基于动态代码构建的，建议你把动态代码构建的代码封装成一个方法。有变动时，再重新执行一遍构建就可以了。会重新覆盖的。并且这一过程，也是平滑的。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"组件切面",frontmatter:{title:"组件切面",date:"2022-06-01T13:44:59.000Z",permalink:"/pages/v2.6.X/21d500/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/160.%E7%BB%84%E4%BB%B6%E5%88%87%E9%9D%A2.html",relativePath:"30.v2.6.X文档/060.使用详细指南/160.组件切面.md",key:"v-18c894fc",path:"/pages/v2.6.X/21d500/",headers:[{level:2,title:"全局切面",slug:"全局切面",normalizedTitle:"全局切面",charIndex:47},{level:2,title:"Aspect的切面",slug:"aspect的切面",normalizedTitle:"aspect的切面",charIndex:353}],headersStr:"全局切面 Aspect的切面",content:'LiteFlow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(String nodeId, Slot slot) {\n        //before business\n    }\n\n    @Override\n    public void afterProcess(String nodeId, Slot slot) {\n        //after business\n    }\n}\n\n\n\n# Aspect的切面\n\nLiteFlow同时也支持了Spring Aspect的切面，你可以用@Aspect标注对任意包，任意规则内的组件进行切面\n\n@Aspect\npublic class CustomAspect {\n\n    @Pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @Around("cut()")\n    public Object around(ProceedingJoinPoint jp) throws Throwable {\n        //do before business\n        Object returnObj = jp.proceed();\n        //do after business\n        return returnObj;\n    }\n}\n',normalizedContent:'liteflow从2.5.0版本开始，开始支持组件的切面功能，你可以通过2种方式进行\n\n\n# 全局切面\n\n全局切面是针对于所有的组件，进行切面。你只需要做如下实现即可：\n\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(string nodeid, slot slot) {\n        //before business\n    }\n\n    @override\n    public void afterprocess(string nodeid, slot slot) {\n        //after business\n    }\n}\n\n\n\n# aspect的切面\n\nliteflow同时也支持了spring aspect的切面，你可以用@aspect标注对任意包，任意规则内的组件进行切面\n\n@aspect\npublic class customaspect {\n\n    @pointcut("execution(* com.yomahub.liteflow.test.aop.cmp1.*.process())")\n    public void cut() {\n    }\n\n    @around("cut()")\n    public object around(proceedingjoinpoint jp) throws throwable {\n        //do before business\n        object returnobj = jp.proceed();\n        //do after business\n        return returnobj;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"私有投递",frontmatter:{title:"私有投递",date:"2022-06-01T13:36:50.000Z",permalink:"/pages/v2.6.X/5466e5/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/130.%E7%A7%81%E6%9C%89%E6%8A%95%E9%80%92.html",relativePath:"30.v2.6.X文档/060.使用详细指南/130.私有投递.md",key:"v-cf5aaae0",path:"/pages/v2.6.X/5466e5/",headers:[{level:2,title:"什么叫私有投递",slug:"什么叫私有投递",normalizedTitle:"什么叫私有投递",charIndex:34},{level:2,title:"解决方式",slug:"解决方式",normalizedTitle:"解决方式",charIndex:704}],headersStr:"什么叫私有投递 解决方式",content:'LiteFlow从2.6.0版本开始，开始支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个LiteFLow的组件都共享同一个slot(相当于同一个上下文的概念)。\n\n在一个请求中，slot里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n\n\n\n\n\n\n \n\n\n\n\n\n<?xml version="1.0" encoding="UTF-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a"/>\n        \x3c!-- 5个相同的b组件并发执行 --\x3e\n        <when value="b,b,b,b,b"/>\n        <then value="c"/>\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往slot里放数据，其他组件可以取到a组件往slot放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，LiteFlow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t\tSlot slot = getSlot();\n\t\tslot.setData("testSet", new HashSet<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendPrivateDeliveryData("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendPrivateDeliveryData方法，指定了b组件\n\n然后我们再来看b组件：\n\n\n\n\n\n\n\n \n\n\n\n\n\n@LiteflowComponent("b")\npublic class BCmp extends NodeComponent {\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("BCmp executed!");\n\t\tInteger value = this.getPrivateDeliveryData();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getPrivateDeliveryData()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',normalizedContent:'liteflow从2.6.0版本开始，开始支持私有投递特性\n\n\n# 什么叫私有投递\n\n在之前的介绍中已经阐述了在一个请求中，各个liteflow的组件都共享同一个slot(相当于同一个上下文的概念)。\n\n在一个请求中，slot里的所有数据对这个请求链路中所有的节点都是公开的。每个组件都可以存取数据。\n\n但是存在这样一个情况，比如我的规则是这样定义的：\n\n\n\n\n\n\n\n \n\n\n\n\n\n<?xml version="1.0" encoding="utf-8"?>\n<flow>\n    <chain name="chain1">\n        <then value="a"/>\n        \x3c!-- 5个相同的b组件并发执行 --\x3e\n        <when value="b,b,b,b,b"/>\n        <then value="c"/>\n    </chain>\n</flow>\n\n\n在执行完组件a之后，进行了同样的5个b组件的并发。在b组件上逻辑是同一套，但是要接收5个不同的参数。\n\n我们知道，在之前的描述中，a组件可以往slot里放数据，其他组件可以取到a组件往slot放的东西，但是在这个场景中，普通的存放数据是无法让b组件取到5个不同的参数来进行并发处理的。\n\n概念\n\n所以为此，liteflow特地设计了私有投递的概念，指的是：一个组件可以显示的声明为某个特定的组件去投递1个或多个参数，而投递的参数，也只有这个特定的组件才能获取到，其他组件是获取不到的。并且这个投递的参数(一个或多个)只能被取一次。\n\n有了这个特性，那上述的场景就可以利用私有投递的特性去解决了。\n\n\n# 解决方式\n\n我们先定义组件a：\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t\tslot slot = getslot();\n\t\tslot.setdata("testset", new hashset<>());\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tthis.sendprivatedeliverydata("b",i+1);\n\t\t}\n\t}\n}\n\n\n可以看到我们为b组件进行了私有投递，调用了this.sendprivatedeliverydata方法，指定了b组件\n\n然后我们再来看b组件：\n\n\n\n\n\n\n\n \n\n\n\n\n\n@liteflowcomponent("b")\npublic class bcmp extends nodecomponent {\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("bcmp executed!");\n\t\tinteger value = this.getprivatedeliverydata();\n\t\t//do your biz\n\t}\n}\n\n\nb组件调用了this.getprivatedeliverydata()方法，获取了a组件投递的参数。因为参数只能被获取一次（内部用队列来实现），所以保证了每个b组件获取到的参数都是不一样的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"步骤打印",frontmatter:{title:"步骤打印",date:"2022-06-01T13:21:31.000Z",permalink:"/pages/v2.6.X/ce6352/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/180.%E6%AD%A5%E9%AA%A4%E6%89%93%E5%8D%B0.html",relativePath:"30.v2.6.X文档/060.使用详细指南/180.步骤打印.md",key:"v-5b6866c4",path:"/pages/v2.6.X/ce6352/",headers:[{level:2,title:"普通打印",slug:"普通打印",normalizedTitle:"普通打印",charIndex:43},{level:2,title:"别名打印",slug:"别名打印",normalizedTitle:"别名打印",charIndex:103},{level:3,title:"Springboot & Spring 扫描方式",slug:"springboot-spring-扫描方式",normalizedTitle:"springboot &amp; spring 扫描方式",charIndex:null},{level:3,title:"规则文件方式定义组件",slug:"规则文件方式定义组件",normalizedTitle:"规则文件方式定义组件",charIndex:457}],headersStr:"普通打印 别名打印 Springboot & Spring 扫描方式 规则文件方式定义组件",content:'LiteFlow在执行每一条流程链后会打印步骤，这个步骤是程序实际执行的顺序\n\n\n# 普通打印\n\n普通打印只会打印nodeId，样例如下：\n\na==>c==>m==>q==>p==>p1==>g\n\n\n\n# 别名打印\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性\n\n最终样例为：\n\na[组件A]==>b[组件B]==>m[组件M]\n\n\n如何进行别名打印？分以下两种情况说明\n\n\n# Springboot & Spring 扫描方式\n\n你定义的组件中，把@Component换成@LiteflowComponent，并做如下定义：\n\n@LiteflowComponent(id = "a", name = "组件A")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n如果你的组件是在规则文件中定义，则需要在<node>节点中加入name的属性\n\n<node id="a" name="组件A" class="com.yomahub.liteflow.test.config.cmp.ACmp"/>\n<node id="b" name="组件B" class="com.yomahub.liteflow.test.config.cmp.BCmp"/>\n',normalizedContent:'liteflow在执行每一条流程链后会打印步骤，这个步骤是程序实际执行的顺序\n\n\n# 普通打印\n\n普通打印只会打印nodeid，样例如下：\n\na==>c==>m==>q==>p==>p1==>g\n\n\n\n# 别名打印\n\n如果你希望在打印流程链的时候增加别名描述，那你需要在定义组件的时候设置name属性\n\n最终样例为：\n\na[组件a]==>b[组件b]==>m[组件m]\n\n\n如何进行别名打印？分以下两种情况说明\n\n\n# springboot & spring 扫描方式\n\n你定义的组件中，把@component换成@liteflowcomponent，并做如下定义：\n\n@liteflowcomponent(id = "a", name = "组件a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n\n# 规则文件方式定义组件\n\n如果你的组件是在规则文件中定义，则需要在<node>节点中加入name的属性\n\n<node id="a" name="组件a" class="com.yomahub.liteflow.test.config.cmp.acmp"/>\n<node id="b" name="组件b" class="com.yomahub.liteflow.test.config.cmp.bcmp"/>\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"异常处理机制",frontmatter:{title:"异常处理机制",date:"2022-06-01T13:50:03.000Z",permalink:"/pages/v2.6.X/d61011/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/170.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6.html",relativePath:"30.v2.6.X文档/060.使用详细指南/170.异常处理机制.md",key:"v-f3b66e04",path:"/pages/v2.6.X/d61011/",headersStr:null,content:"LiteFlow中执行器FlowExecutor支持两种方式来执行一个流程,\n\n 1. execute方法,返回Slot实现类对象，直接抛出异常信息，业务系统自行处理异常；\n\npublic <T extends Slot> T execute(String chainId, Object param, Class<T> slotClazz,\n                                     Integer slotIndex, boolean isInnerChain) throws Exception\n\n\n 2. execute2Resp方法，返回LiteflowResponse类对象，异常信息包装在LiteflowResponse类中。\n\n public <T extends Slot> LiteflowResponse<T> execute2Resp(String chainId, Object param, Class<T> slotClazz, Integer slotIndex,\n                                        boolean isInnerChain)\n",normalizedContent:"liteflow中执行器flowexecutor支持两种方式来执行一个流程,\n\n 1. execute方法,返回slot实现类对象，直接抛出异常信息，业务系统自行处理异常；\n\npublic <t extends slot> t execute(string chainid, object param, class<t> slotclazz,\n                                     integer slotindex, boolean isinnerchain) throws exception\n\n\n 2. execute2resp方法，返回liteflowresponse类对象，异常信息包装在liteflowresponse类中。\n\n public <t extends slot> liteflowresponse<t> execute2resp(string chainid, object param, class<t> slotclazz, integer slotindex,\n                                        boolean isinnerchain)\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"不同格式规则加载",frontmatter:{title:"不同格式规则加载",date:"2022-06-01T13:56:16.000Z",permalink:"/pages/v2.6.X/f67d92/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/190.%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E8%A7%84%E5%88%99%E5%8A%A0%E8%BD%BD.html",relativePath:"30.v2.6.X文档/060.使用详细指南/190.不同格式规则加载.md",key:"v-1f6947c6",path:"/pages/v2.6.X/f67d92/",headersStr:null,content:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipleType/flow.xml,multipleType/flow.json\n\n\n这种模式在正常下会解析失败，但是LiteFLow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",normalizedContent:"有些小伙伴在配置规则时，因为特殊原因，需要同时加载2种不同的配置，甚至是配置源，比如：\n\nliteflow.rule-source=multipletype/flow.xml,multipletype/flow.json\n\n\n这种模式在正常下会解析失败，但是liteflow提供了一个参数去支持这个特性，如果出现不同的类型的配置，需要加上这个属性：\n\nliteflow.support-multiple-type=true\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"When异步线程池",frontmatter:{title:"When异步线程池",date:"2022-06-01T13:57:11.000Z",permalink:"/pages/v2.6.X/8c4aba/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/200.When%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",relativePath:"30.v2.6.X文档/060.使用详细指南/200.When异步线程池.md",key:"v-83585ee2",path:"/pages/v2.6.X/8c4aba/",headers:[{level:2,title:"默认全局线程池",slug:"默认全局线程池",normalizedTitle:"默认全局线程池",charIndex:2},{level:2,title:"自定义全局线程池",slug:"自定义全局线程池",normalizedTitle:"自定义全局线程池",charIndex:157},{level:2,title:"Condition级别的单独线程池",slug:"condition级别的单独线程池",normalizedTitle:"condition级别的单独线程池",charIndex:1141},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1992}],headersStr:"默认全局线程池 自定义全局线程池 Condition级别的单独线程池 优先级",content:'# 默认全局线程池\n\nLiteFlow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，LiteFlow从2.6.6版本开始也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的Builder：\n\npublic class CustomThreadBuilder implements ExecutorBuilder {\n    @Override\n    public ExecutorService buildExecutor() {\n        return Executors.newCachedThreadPool();\n    }\n}\n\n\n然后把你的Builder加入LiteFlow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customThreadPool.CustomThreadExecutor\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowConfig" class="com.yomahub.liteflow.property.LiteflowConfig">\n\t<property name="ruleSource" value="customThreadPool/flow.xml"/>\n  <property name="threadExecutorClass" value="com.yomahub.liteflow.test.customThreadPool.CustomThreadExecutor"/>\n</bean>\n\n<bean id="flowExecutor" class="com.yomahub.liteflow.core.FlowExecutor">\n  <property name="liteflowConfig" ref="liteflowConfig"/>\n</bean>\n\n\n这样，LiteFlow在启动的时候就会自动通过你声明的Builder加载到自定义的线程池了。\n\n\n# Condition级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n  <when value="a,b"/>\n</chain>\n\n<chain name="chain2">\n  <when value="c,d"/>\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class CustomThreadExecutor1 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class CustomThreadExecutor2 implements ExecutorBuilder {\n\n    @Override\n    public ExecutorService buildExecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n  <when value="a,b" threadExecutorClass="com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor1"/>\n</chain>\n<chain name="chain2">\n  <when value="c,d" threadExecutorClass="com.yomahub.liteflow.test.customWhenThreadPool.CustomThreadExecutor2"/>\n</chain>\n\n\n\n# 优先级\n\n如果全局和Condition都配置自定义线程池的情况下，优先使用Condition上配置的线程池。',normalizedContent:'# 默认全局线程池\n\nliteflow自己默认有全局线程池，并且线程池的大小等参数可以通过设置以下参数来进行设置：\n\nliteflow.when-max-wait-seconds=15\nliteflow.when-max-workers=16\nliteflow.when-queue-limit=512\n\n\n\n# 自定义全局线程池\n\n但是如果你要对线程池有特殊化的要求，liteflow从2.6.6版本开始也支持自定义线程池的设置。\n\n需要注意的是，自定义线程池只适用于并行组件，这个参数对于同步组件来说并无作用。而且一旦设置了你自定义的线程池，那么以上参数将不会再有用。对于线程池的所有参数的定义，都取决于你自己了。\n\n首先你可以这样定义一个线程池的builder：\n\npublic class customthreadbuilder implements executorbuilder {\n    @override\n    public executorservice buildexecutor() {\n        return executors.newcachedthreadpool();\n    }\n}\n\n\n然后把你的builder加入liteflow的配置中，springboot的话，你可以这样配置：\n\nliteflow.thread-executor-class=com.yomahub.liteflow.test.customthreadpool.customthreadexecutor\n\n\n如果是spring的话，你可以这样配置：\n\n<bean id="liteflowconfig" class="com.yomahub.liteflow.property.liteflowconfig">\n\t<property name="rulesource" value="customthreadpool/flow.xml"/>\n  <property name="threadexecutorclass" value="com.yomahub.liteflow.test.customthreadpool.customthreadexecutor"/>\n</bean>\n\n<bean id="flowexecutor" class="com.yomahub.liteflow.core.flowexecutor">\n  <property name="liteflowconfig" ref="liteflowconfig"/>\n</bean>\n\n\n这样，liteflow在启动的时候就会自动通过你声明的builder加载到自定义的线程池了。\n\n\n# condition级别的单独线程池\n\n在某些场景下，你的异步节点可能不需要一个全局的线程池，希望对每组异步节点进行单独的线程池设定。\n\n比如我现在想对以下2个流程异步节点进行设置不同的线程池:\n\n<chain name="chain1">\n  <when value="a,b"/>\n</chain>\n\n<chain name="chain2">\n  <when value="c,d"/>\n</chain>\n\n\n那么现在你可以这么做\n\n首先实现2个自己的线程池：\n\npublic class customthreadexecutor1 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\npublic class customthreadexecutor2 implements executorbuilder {\n\n    @override\n    public executorservice buildexecutor() {\n        //构造你自定义的线程池\n    }\n}\n\n\n然后你如下声明就ok了：\n\n<chain name="chain1">\n  <when value="a,b" threadexecutorclass="com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor1"/>\n</chain>\n<chain name="chain2">\n  <when value="c,d" threadexecutorclass="com.yomahub.liteflow.test.customwhenthreadpool.customthreadexecutor2"/>\n</chain>\n\n\n\n# 优先级\n\n如果全局和condition都配置自定义线程池的情况下，优先使用condition上配置的线程池。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"DEMO案例",frontmatter:{title:"DEMO案例",date:"2022-06-01T14:03:11.000Z",permalink:"/pages/v2.6.X/3ae932/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/070.%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B/020.DEMO%E6%A1%88%E4%BE%8B.html",relativePath:"30.v2.6.X文档/070.示例工程/020.DEMO案例.md",key:"v-1ba304f4",path:"/pages/v2.6.X/3ae932/",headersStr:null,content:"如果你想看一个实际的案例，加深对LiteFlow的理解。可以查看：\n\n> 完整的带简单业务的案例\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算，建议大家去pull下来，仔细阅读下，这个业务用到了LiteFlow的大部分特性\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n",normalizedContent:"如果你想看一个实际的案例，加深对liteflow的理解。可以查看：\n\n> 完整的带简单业务的案例\n\n这个案例为一个价格计算引擎，其目的是模拟了电商中对订单价格的计算，建议大家去pull下来，仔细阅读下，这个业务用到了liteflow的大部分特性\n\n这个示例工程提供了一个简单的界面，供大家测试之用\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"简单监控",frontmatter:{title:"简单监控",date:"2022-06-01T13:59:52.000Z",permalink:"/pages/v2.6.X/4b18be/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/220.%E7%AE%80%E5%8D%95%E7%9B%91%E6%8E%A7.html",relativePath:"30.v2.6.X文档/060.使用详细指南/220.简单监控.md",key:"v-20dfec47",path:"/pages/v2.6.X/4b18be/",headersStr:null,content:"LiteFlow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",normalizedContent:"liteflow提供了简单的监控，目前只统计一个指标：每个组件的平均耗时\n\n默认每5分钟会打印一次(可以自己调整)，并且是根据耗时时长倒序排的。\n\n关于监控配置默认的参数如下：\n\n#是否启用监控\nliteflow.monitor.enable-log=false\n#监控队列的大小\nliteflow.monitor.queue-limit=200\n#监控延迟多少毫秒打印\nliteflow.monitor.delay=300000\n#监控每隔多少毫秒打印\nliteflow.monitor.period=300000\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"LiteFlowX快速开发插件",frontmatter:{title:"LiteFlowX快速开发插件",date:"2022-07-12T00:57:00.000Z",permalink:"/pages/liteflowx/",author:{name:"Timothy Lau",link:"https://gitee.com/liupeiqiang/"},titleTag:"✨ V1.2.3"},regularPath:"/LiteFlowX.html",relativePath:"LiteFlowX.md",key:"v-24597525",path:"/pages/liteflowx/",headers:[{level:2,title:"🍬 LiteFlowX 特性",slug:"🍬-liteflowx-特性",normalizedTitle:"🍬 liteflowx 特性",charIndex:468},{level:2,title:"🎉 安装LiteFlowX",slug:"🎉-安装liteflowx",normalizedTitle:"🎉 安装liteflowx",charIndex:1051},{level:3,title:"方法一：点击这里安装（推荐）",slug:"方法一-点击这里安装-推荐",normalizedTitle:"方法一：点击这里安装（推荐）",charIndex:1266},{level:3,title:"方法二：从 Marketplace 安装插件（推荐）",slug:"方法二-从-marketplace-安装插件-推荐",normalizedTitle:"方法二：从 marketplace 安装插件（推荐）",charIndex:1304},{level:3,title:"方法三：导入JAR包进行安装",slug:"方法三-导入jar包进行安装",normalizedTitle:"方法三：导入jar包进行安装",charIndex:1434},{level:2,title:"🌈 功能演示",slug:"🌈-功能演示",normalizedTitle:"🌈 功能演示",charIndex:1630},{level:3,title:"智能提示Component和Chain",slug:"智能提示component和chain",normalizedTitle:"智能提示component和chain",charIndex:1642},{level:3,title:"预检测Chain未命名或重复",slug:"预检测chain未命名或重复",normalizedTitle:"预检测chain未命名或重复",charIndex:1668},{level:3,title:"自定义elf语法关键字颜色",slug:"自定义elf语法关键字颜色",normalizedTitle:"自定义elf语法关键字颜色",charIndex:1689},{level:3,title:"支持Component和Chain跳转",slug:"支持component和chain跳转",normalizedTitle:"支持component和chain跳转",charIndex:1709},{level:3,title:"支持局部变量",slug:"支持局部变量",normalizedTitle:"支持局部变量",charIndex:1735},{level:3,title:"LiteFlow 工具箱",slug:"liteflow-工具箱",normalizedTitle:"liteflow 工具箱",charIndex:545},{level:2,title:"💬 疑难解答",slug:"💬-疑难解答",normalizedTitle:"💬 疑难解答",charIndex:1767},{level:3,title:"Q：为什么安装 LiteFlowX 插件，相关ELF表达式仍然无法高亮？",slug:"q-为什么安装-liteflowx-插件-相关elf表达式仍然无法高亮",normalizedTitle:"q：为什么安装 liteflowx 插件，相关elf表达式仍然无法高亮？",charIndex:1779},{level:3,title:"Q：在XML文件里面使用脚本组件，node标签的脚本语言无法高亮？",slug:"q-在xml文件里面使用脚本组件-node标签的脚本语言无法高亮",normalizedTitle:"q：在xml文件里面使用脚本组件，node标签的脚本语言无法高亮？",charIndex:2028},{level:3,title:"Q：为什么我使用Python语言或LUA语言进行脚本组件编写时并没有高亮显示和智能提示？",slug:"q-为什么我使用python语言或lua语言进行脚本组件编写时并没有高亮显示和智能提示",normalizedTitle:"q：为什么我使用python语言或lua语言进行脚本组件编写时并没有高亮显示和智能提示？",charIndex:2164},{level:3,title:"Q：没有在疑难解答解决我的问题，怎么办？",slug:"q-没有在疑难解答解决我的问题-怎么办",normalizedTitle:"q：没有在疑难解答解决我的问题，怎么办？",charIndex:2366},{level:2,title:"📕 更新日志",slug:"📕-更新日志",normalizedTitle:"📕 更新日志",charIndex:2489},{level:2,title:"💖 特别鸣谢",slug:"💖-特别鸣谢",normalizedTitle:"💖 特别鸣谢",charIndex:5865}],headersStr:"🍬 LiteFlowX 特性 🎉 安装LiteFlowX 方法一：点击这里安装（推荐） 方法二：从 Marketplace 安装插件（推荐） 方法三：导入JAR包进行安装 🌈 功能演示 智能提示Component和Chain 预检测Chain未命名或重复 自定义elf语法关键字颜色 支持Component和Chain跳转 支持局部变量 LiteFlow 工具箱 💬 疑难解答 Q：为什么安装 LiteFlowX 插件，相关ELF表达式仍然无法高亮？ Q：在XML文件里面使用脚本组件，node标签的脚本语言无法高亮？ Q：为什么我使用Python语言或LUA语言进行脚本组件编写时并没有高亮显示和智能提示？ Q：没有在疑难解答解决我的问题，怎么办？ 📕 更新日志 💖 特别鸣谢",content:"插件版本须知\n\n * LiteFlowX 插件版本自 v1.1.0 起，全面适配 LiteFlow v2.9.0 并且 部分功能不再向下兼容 LiteFlow v2.8.X。\n * 若您仍在使用 LiteFlow 2.8.X 及以下版本，可自行下载 LiteFlowX v1.0.4 Jar包 进行安装\n * 若您仍在使用 LiteFlow 2.7.X 及以下版本，可自行下载 LiteFlowX v0.1.1 Jar包 进行安装\n * 插件将来会致力于 LiteFlow 框架的最新版本特性做出更改和完善，使用本插件前请确保您使用的是最新的 LiteFlow 框架。\n\n\n\nLiteFlowX 是一款 IDEA 插件，它能够大幅度提高你在使用 LiteFlow 框架进行开发时的工作效率。\n\n\n\n😋 支持项目\n\nLiteFlowX 插件完全免费并开源，为了让各位小伙伴能使用到更优质的插件功能，可到仓库提issues哦！\n\n如果插件觉得好用，请为这个插件打个五分好评！\n\n如果插件源码对你开发有帮助，请为这个仓库点个星星！\n\n\n# 🍬 LiteFlowX 特性\n\n支持 ELF 语法\n\n自动完成、语法高亮、词法分析\n\n语法注入\n\nELF 语法自动向 .xml 的 chain 注入\n\nLiteFlow 工具箱\n\n项目工程的组件、链路一目了然\n\n- name: 支持 ELF 语法\n  desc: 自动完成、语法高亮、词法分析\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: 语法注入\n  desc: ELF 语法自动向 .xml 的 chain 注入\n  bgColor: '#718971'\n  textColor: '#fff'\n- name: LiteFlow 工具箱\n  desc: 项目工程的组件、链路一目了然\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n\n\n * 全面适配 LiteFlow v2.9.x 的所有特性\n * 支持 ELF 规则表达式（自动提示、语法高亮、语法检测）\n * 能够识别组件、链路\n * 细分化的组件类型图标，让组件一目了然\n * 更加智能的自动提示，可细分化后的组件、链路\n * 提供LiteFlow工具箱，整个工程的组件、链路，并且支持双击跳转\n * 支持对 liteflow.ruleSource 属性的文件跳转\n * ...更多特性敬请期待\n\n\n# 🎉 安装LiteFlowX\n\n有三种方式可安装LiteFlowX插件到IDEA中\n\n提示\n\n支持 LiteFlowX 插件的版本有：\n\n * IntelliJ IDEA Educational — 2021.1 — 2022.2.2\n * IntelliJ IDEA Community — 2021.1 — 2023.2.2\n * IntelliJ IDEA Ultimate — 2021.1 — 2023.2.2\n\n\n# 方法一：点击这里安装（推荐）\n\n页面加载完毕后，下方会出现安装按钮\n\n\n# 方法二：从 Marketplace 安装插件（推荐）\n\n 1. 按下组合键 Ctrl + Alt + S，打开 IDE settings 并选择 Plugins\n 2. 在 Marketplace 搜索 LiteFlowX 并点击 install\n\n\n\n\n# 方法三：导入JAR包进行安装\n\n 1. 在 Releases 下载最新的插件Jar包\n 2. 按下组合键 Ctrl+Alt+S，打开 IDE settings 并选择 Plugins\n 3. 在插件页面, 点击 ⚙ 然后再点击 Install Plugin from Disk...\n 4. 选择在第一步下载好的插件并点击 OK\n 5. 如果提示重启IDE，点击 OK 应用更改即可\n\n\n# 🌈 功能演示\n\n\n# 智能提示Component和Chain\n\n\n\n\n# 预检测Chain未命名或重复\n\n\n\n\n# 自定义elf语法关键字颜色\n\n\n\n\n# 支持Component和Chain跳转\n\n\n\n\n# 支持局部变量\n\n\n\n\n# LiteFlow 工具箱\n\n\n\n\n# 💬 疑难解答\n\n\n# Q：为什么安装 LiteFlowX 插件，相关ELF表达式仍然无法高亮？\n\nA：首先请确保您安装的是最新版本的 LiteFlowX 插件，并且安装完成后务必重启 IDEA。若以上操作仍无法解决问题，考虑您安装的第三方主题影响了高亮，请到 File -> Settings -> Editor -> Color Scheme -> General -> Code -> Injected language fragment 将右侧勾选框的 Foreground 取消勾选，并按确认更改。\n\n\n\n\n# Q：在XML文件里面使用脚本组件，node标签的脚本语言无法高亮？\n\nA：需要在<node>标签上使用属性language并给定语言才可进行高亮，如:<node id=\"xxx\" type=\"script\" language=\"groovy\"></node>\n\n\n\n\n# Q：为什么我使用Python语言或LUA语言进行脚本组件编写时并没有高亮显示和智能提示？\n\nA：原因是Python与LUA语法本身IDEA是不支持，所以当你在使用 <node type=\"script\" language=\"python\"> 或 <node type=\"script\" language=\"lua\">之前，请确保你已经安装第三方的相关插件如Python或EmmyLua插件。\n\n\n\n\n# Q：没有在疑难解答解决我的问题，怎么办？\n\nA：LiteFlowX 插件仍在茁壮成长中，使用过程中难免会遇见奇奇怪怪的事，不过没有关系，您可以随时联系作者或在Gitee仓库内提出您宝贵的意见或ISSUES，我会第一时间解答您的疑问。💖\n\n\n# 📕 更新日志\n\n[1.2.3] - 2023-08-30\n\n * 新增对 xml 文件的自动注入 JAVA 语言\n\n[1.2.2] - 2023-08-08\n\n * 新增 支持.parallel() 关键词\n * 新增 支持.maxWaitSeconds() 关键词\n * 修复 ToolBox 会被关闭问题\n * 兼容 IDEA-2023.2.* 版本\n\n[1.2.1] - 2023-04-11\n\n * 新增 支持表达式结尾键入.tag()和.id()\n * 兼容 WHILE() 括号表达式内使用AND、OR、NOT逻辑表达式\n\n[1.2.0] - 2023-04-01\n\n * 新增 支持AND()、OR()、NOT()逻辑表达式\n * 兼容 IDEA-2023.* 版本\n\n[1.1.6] - 2023-03-16\n\n * 新增 CATCH().DO() 表达式\n\n[1.1.5] - 2023-02-01\n\n * 修复 ITERATOR 关键字组件图标无法正常显示问题\n * 修复 .el.xml 文件中 domChain 标签无法识别 id 属性问题\n\n[1.1.4] - 2023-01-18\n\n * 新增 #I6AY1G 对 ITERATOR 关键字的支持\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I6AY1G\n\n[1.1.3] - 2022-12-11\n\n * 新增 #I65E2V SWITCH表达式的DEFAULT用法\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I65E2V\n * 新增 #I65E31 脚本组件对Python语言以及Lua语言的支持\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I65E31\n * 兼容 IDEA-2022.3 版本\n\n[1.1.2] - 2022-11-23\n\n * 修复 #I5X8XV com/intellij/psi/impl/source/PsiClassImpl.isInheritor must not be null 的问题\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5X8XV\n * 修复 com.intellij.psi.impl.source.xml.XmlElementContentGroupImpl cannot be cast to class com.intellij.psi.xml.XmlTag 的问题\n\n[1.1.1] - 2022-10-24\n\n * 新增 #I5VMP4 在xml中新增对groovy以及javascript语法的支持\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5VMP4\n * 修复 #I5WQME 无法识别多行注释问题\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5WQME\n\n[1.1.0] - 2022-10-09\n\n * 新增 #I5TUH1 LiteFlow 2.9.0 的 data 属性特性的适配\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5TUH1\n * 新增 #I5TU26 LiteFlow 2.9.0 循环组件语法的适配\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5TU26\n * 新增 #I5U36H LiteFlow 2.9.0 版本中EL对*.xml检测生效\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5U36H\n * 新增 #I5UA9R LiteFlow 2.9.0 重构后的声明式组件的适配\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5UA9R\n * 新增 #I5TU3E 细分化Component类型的特性\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5TU3E\n * 修复 #I5Q35D ELF语法无法正常解析注释的问题\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5Q35D\n * 修复 #I5U3QH 核心源码不应该显示组件图标的问题\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5U3QH\n * 修复 #I5O84M 不能正常识别node的XML标签的问题\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5O84M\n * 优化 插件内核源码架构\n * 优化 插件内的所有图标，简洁清爽！\n * 优化 LiteFlowTool 工具箱的副标题显示内容\n * 修复 LiteFlowTool 工具箱双击无法跳转对应Chain的问题\n\n[1.0.4] - 2022-08-25\n\n * 新增 #I5NWWJ 支持 LiteFlow v2.8.5 的IF关键字特性\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5NWWJ\n * 修复 SWITCH() 允许输入多个表达式的问题\n\n[1.0.3] - 2022-08-02\n\n * 新增 #I5K13V 支持 liteflow v2.8.3 的替补组件特性\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5K13V\n * 新增 #I5JQXV 支持 liteflow v2.8.3 的组件名包装\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5JQXV\n\n[1.0.2] - 2022-07-21\n\n * 新增 #I5HPMC 支持EL中的注释\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5HPMC\n * 新增 #I5H8RL 新增 IDEA-222.* 的支持\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5H8RL\n * 新增 识别括号并高亮\n * 新增 自动缩进\n * 修复 抛出 java.lang.NullPointerException 异常的问题\n\n[1.0.1] - 2022-07-14\n\n * 修复 因旧表达式存在而导致的报错\n * 修复 因qualifiedName参数为null而导致的IllegalArgumentException\n * 优化 部分代码的对Null值得判断\n\n[1.0.0] - 2022-07-11\n\n🎉 适配 LiteFlow 2.8.x 全新规则表达式语法\n\n * 支持elf语法高亮\n * 支持component、chain、local variables自动提示\n * 支持语法预检测\n * 支持.el.xml的chain标签注入elf语法\n * 更多功能等你挖掘...\n\n[0.1.1] - 2022-06-15\n\n * 修复 #I5BW1N 关于java代码编辑器中的chain错误跳转问题\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5BW1N\n * 修复 #I5BPP6 修复组件多层继承而无法正确跳转问题\n   * https://gitee.com/liupeiqiang/LiteFlowX/issues/I5BPP6\n\n\n# 💖 特别鸣谢\n\n铂赛东\n\nLiteFlow 开源作者\n\nTimothy Lau\n\nLiteFlowX 开源作者\n\nchenglitao521\n\n贡献者\n\n- name: 铂赛东\n  desc: LiteFlow 开源作者\n  avatar: /img/liteflowx/avator/bryan31.webp\n  link: https://gitee.com/bryan31\n  bgColor: '#d7d7d7'\n  textColor: '#000000'\n- name: Timothy Lau\n  desc: LiteFlowX 开源作者\n  avatar: /img/liteflowx/avator/liupeiqiang.webp\n  link: https://gitee.com/liupeiqiang\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n- name: chenglitao521\n  desc: 贡献者\n  avatar: /img/liteflowx/avator/chenglitao521.jpg\n  link: https://github.com/chenglitao521\n  bgColor: '#f5efbd'\n  textColor: '#3d6328'\n",normalizedContent:"插件版本须知\n\n * liteflowx 插件版本自 v1.1.0 起，全面适配 liteflow v2.9.0 并且 部分功能不再向下兼容 liteflow v2.8.x。\n * 若您仍在使用 liteflow 2.8.x 及以下版本，可自行下载 liteflowx v1.0.4 jar包 进行安装\n * 若您仍在使用 liteflow 2.7.x 及以下版本，可自行下载 liteflowx v0.1.1 jar包 进行安装\n * 插件将来会致力于 liteflow 框架的最新版本特性做出更改和完善，使用本插件前请确保您使用的是最新的 liteflow 框架。\n\n\n\nliteflowx 是一款 idea 插件，它能够大幅度提高你在使用 liteflow 框架进行开发时的工作效率。\n\n\n\n😋 支持项目\n\nliteflowx 插件完全免费并开源，为了让各位小伙伴能使用到更优质的插件功能，可到仓库提issues哦！\n\n如果插件觉得好用，请为这个插件打个五分好评！\n\n如果插件源码对你开发有帮助，请为这个仓库点个星星！\n\n\n# 🍬 liteflowx 特性\n\n支持 elf 语法\n\n自动完成、语法高亮、词法分析\n\n语法注入\n\nelf 语法自动向 .xml 的 chain 注入\n\nliteflow 工具箱\n\n项目工程的组件、链路一目了然\n\n- name: 支持 elf 语法\n  desc: 自动完成、语法高亮、词法分析\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: 语法注入\n  desc: elf 语法自动向 .xml 的 chain 注入\n  bgcolor: '#718971'\n  textcolor: '#fff'\n- name: liteflow 工具箱\n  desc: 项目工程的组件、链路一目了然\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n\n\n * 全面适配 liteflow v2.9.x 的所有特性\n * 支持 elf 规则表达式（自动提示、语法高亮、语法检测）\n * 能够识别组件、链路\n * 细分化的组件类型图标，让组件一目了然\n * 更加智能的自动提示，可细分化后的组件、链路\n * 提供liteflow工具箱，整个工程的组件、链路，并且支持双击跳转\n * 支持对 liteflow.rulesource 属性的文件跳转\n * ...更多特性敬请期待\n\n\n# 🎉 安装liteflowx\n\n有三种方式可安装liteflowx插件到idea中\n\n提示\n\n支持 liteflowx 插件的版本有：\n\n * intellij idea educational — 2021.1 — 2022.2.2\n * intellij idea community — 2021.1 — 2023.2.2\n * intellij idea ultimate — 2021.1 — 2023.2.2\n\n\n# 方法一：点击这里安装（推荐）\n\n页面加载完毕后，下方会出现安装按钮\n\n\n# 方法二：从 marketplace 安装插件（推荐）\n\n 1. 按下组合键 ctrl + alt + s，打开 ide settings 并选择 plugins\n 2. 在 marketplace 搜索 liteflowx 并点击 install\n\n\n\n\n# 方法三：导入jar包进行安装\n\n 1. 在 releases 下载最新的插件jar包\n 2. 按下组合键 ctrl+alt+s，打开 ide settings 并选择 plugins\n 3. 在插件页面, 点击 ⚙ 然后再点击 install plugin from disk...\n 4. 选择在第一步下载好的插件并点击 ok\n 5. 如果提示重启ide，点击 ok 应用更改即可\n\n\n# 🌈 功能演示\n\n\n# 智能提示component和chain\n\n\n\n\n# 预检测chain未命名或重复\n\n\n\n\n# 自定义elf语法关键字颜色\n\n\n\n\n# 支持component和chain跳转\n\n\n\n\n# 支持局部变量\n\n\n\n\n# liteflow 工具箱\n\n\n\n\n# 💬 疑难解答\n\n\n# q：为什么安装 liteflowx 插件，相关elf表达式仍然无法高亮？\n\na：首先请确保您安装的是最新版本的 liteflowx 插件，并且安装完成后务必重启 idea。若以上操作仍无法解决问题，考虑您安装的第三方主题影响了高亮，请到 file -> settings -> editor -> color scheme -> general -> code -> injected language fragment 将右侧勾选框的 foreground 取消勾选，并按确认更改。\n\n\n\n\n# q：在xml文件里面使用脚本组件，node标签的脚本语言无法高亮？\n\na：需要在<node>标签上使用属性language并给定语言才可进行高亮，如:<node id=\"xxx\" type=\"script\" language=\"groovy\"></node>\n\n\n\n\n# q：为什么我使用python语言或lua语言进行脚本组件编写时并没有高亮显示和智能提示？\n\na：原因是python与lua语法本身idea是不支持，所以当你在使用 <node type=\"script\" language=\"python\"> 或 <node type=\"script\" language=\"lua\">之前，请确保你已经安装第三方的相关插件如python或emmylua插件。\n\n\n\n\n# q：没有在疑难解答解决我的问题，怎么办？\n\na：liteflowx 插件仍在茁壮成长中，使用过程中难免会遇见奇奇怪怪的事，不过没有关系，您可以随时联系作者或在gitee仓库内提出您宝贵的意见或issues，我会第一时间解答您的疑问。💖\n\n\n# 📕 更新日志\n\n[1.2.3] - 2023-08-30\n\n * 新增对 xml 文件的自动注入 java 语言\n\n[1.2.2] - 2023-08-08\n\n * 新增 支持.parallel() 关键词\n * 新增 支持.maxwaitseconds() 关键词\n * 修复 toolbox 会被关闭问题\n * 兼容 idea-2023.2.* 版本\n\n[1.2.1] - 2023-04-11\n\n * 新增 支持表达式结尾键入.tag()和.id()\n * 兼容 while() 括号表达式内使用and、or、not逻辑表达式\n\n[1.2.0] - 2023-04-01\n\n * 新增 支持and()、or()、not()逻辑表达式\n * 兼容 idea-2023.* 版本\n\n[1.1.6] - 2023-03-16\n\n * 新增 catch().do() 表达式\n\n[1.1.5] - 2023-02-01\n\n * 修复 iterator 关键字组件图标无法正常显示问题\n * 修复 .el.xml 文件中 domchain 标签无法识别 id 属性问题\n\n[1.1.4] - 2023-01-18\n\n * 新增 #i6ay1g 对 iterator 关键字的支持\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i6ay1g\n\n[1.1.3] - 2022-12-11\n\n * 新增 #i65e2v switch表达式的default用法\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i65e2v\n * 新增 #i65e31 脚本组件对python语言以及lua语言的支持\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i65e31\n * 兼容 idea-2022.3 版本\n\n[1.1.2] - 2022-11-23\n\n * 修复 #i5x8xv com/intellij/psi/impl/source/psiclassimpl.isinheritor must not be null 的问题\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5x8xv\n * 修复 com.intellij.psi.impl.source.xml.xmlelementcontentgroupimpl cannot be cast to class com.intellij.psi.xml.xmltag 的问题\n\n[1.1.1] - 2022-10-24\n\n * 新增 #i5vmp4 在xml中新增对groovy以及javascript语法的支持\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5vmp4\n * 修复 #i5wqme 无法识别多行注释问题\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5wqme\n\n[1.1.0] - 2022-10-09\n\n * 新增 #i5tuh1 liteflow 2.9.0 的 data 属性特性的适配\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5tuh1\n * 新增 #i5tu26 liteflow 2.9.0 循环组件语法的适配\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5tu26\n * 新增 #i5u36h liteflow 2.9.0 版本中el对*.xml检测生效\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5u36h\n * 新增 #i5ua9r liteflow 2.9.0 重构后的声明式组件的适配\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5ua9r\n * 新增 #i5tu3e 细分化component类型的特性\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5tu3e\n * 修复 #i5q35d elf语法无法正常解析注释的问题\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5q35d\n * 修复 #i5u3qh 核心源码不应该显示组件图标的问题\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5u3qh\n * 修复 #i5o84m 不能正常识别node的xml标签的问题\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5o84m\n * 优化 插件内核源码架构\n * 优化 插件内的所有图标，简洁清爽！\n * 优化 liteflowtool 工具箱的副标题显示内容\n * 修复 liteflowtool 工具箱双击无法跳转对应chain的问题\n\n[1.0.4] - 2022-08-25\n\n * 新增 #i5nwwj 支持 liteflow v2.8.5 的if关键字特性\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5nwwj\n * 修复 switch() 允许输入多个表达式的问题\n\n[1.0.3] - 2022-08-02\n\n * 新增 #i5k13v 支持 liteflow v2.8.3 的替补组件特性\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5k13v\n * 新增 #i5jqxv 支持 liteflow v2.8.3 的组件名包装\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5jqxv\n\n[1.0.2] - 2022-07-21\n\n * 新增 #i5hpmc 支持el中的注释\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5hpmc\n * 新增 #i5h8rl 新增 idea-222.* 的支持\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5h8rl\n * 新增 识别括号并高亮\n * 新增 自动缩进\n * 修复 抛出 java.lang.nullpointerexception 异常的问题\n\n[1.0.1] - 2022-07-14\n\n * 修复 因旧表达式存在而导致的报错\n * 修复 因qualifiedname参数为null而导致的illegalargumentexception\n * 优化 部分代码的对null值得判断\n\n[1.0.0] - 2022-07-11\n\n🎉 适配 liteflow 2.8.x 全新规则表达式语法\n\n * 支持elf语法高亮\n * 支持component、chain、local variables自动提示\n * 支持语法预检测\n * 支持.el.xml的chain标签注入elf语法\n * 更多功能等你挖掘...\n\n[0.1.1] - 2022-06-15\n\n * 修复 #i5bw1n 关于java代码编辑器中的chain错误跳转问题\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5bw1n\n * 修复 #i5bpp6 修复组件多层继承而无法正确跳转问题\n   * https://gitee.com/liupeiqiang/liteflowx/issues/i5bpp6\n\n\n# 💖 特别鸣谢\n\n铂赛东\n\nliteflow 开源作者\n\ntimothy lau\n\nliteflowx 开源作者\n\nchenglitao521\n\n贡献者\n\n- name: 铂赛东\n  desc: liteflow 开源作者\n  avatar: /img/liteflowx/avator/bryan31.webp\n  link: https://gitee.com/bryan31\n  bgcolor: '#d7d7d7'\n  textcolor: '#000000'\n- name: timothy lau\n  desc: liteflowx 开源作者\n  avatar: /img/liteflowx/avator/liupeiqiang.webp\n  link: https://gitee.com/liupeiqiang\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n- name: chenglitao521\n  desc: 贡献者\n  avatar: /img/liteflowx/avator/chenglitao521.jpg\n  link: https://github.com/chenglitao521\n  bgcolor: '#f5efbd'\n  textcolor: '#3d6328'\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"自定义组件执行器",frontmatter:{title:"自定义组件执行器",date:"2022-06-01T13:58:01.000Z",permalink:"/pages/v2.6.X/48258b/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/060.%E4%BD%BF%E7%94%A8%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/210.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8.html",relativePath:"30.v2.6.X文档/060.使用详细指南/210.自定义组件执行器.md",key:"v-2d75b156",path:"/pages/v2.6.X/48258b/",headers:[{level:2,title:"全局组件执行器",slug:"全局组件执行器",normalizedTitle:"全局组件执行器",charIndex:140},{level:2,title:"单个组件配置特殊的执行器",slug:"单个组件配置特殊的执行器",normalizedTitle:"单个组件配置特殊的执行器",charIndex:829},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:1221},{level:2,title:"自定义执行器对于重试功能的影响",slug:"自定义执行器对于重试功能的影响",normalizedTitle:"自定义执行器对于重试功能的影响",charIndex:1270}],headersStr:"全局组件执行器 单个组件配置特殊的执行器 优先级 自定义执行器对于重试功能的影响",content:'LiteFlow从2.6.10起开始允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.entity.executor.DefaultNodeExecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeExecutor.CustomerDefaultNodeExecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.NodeExecutor。\n\npublic class CustomerDefaultNodeExecutor extends NodeExecutor {\n    @Override\n    public void execute(NodeComponent instance) throws Exception {\n        Slot slot = DataBus.getSlot(instance.getSlotIndex());\n        LOG.info("使用customerDefaultNodeExecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getNodeExecutorClass 方法：\n\n@LiteflowComponent("d")\npublic class DCmp extends NodeComponent {\n\n    @Override\n    public void process() {\n        System.out.println("DCmp executed!");\n    }\n\n    @Override\n    public Class<? extends NodeExecutor> getNodeExecutorClass() {\n        return CustomerNodeExecutorAndCustomRetry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@LiteflowRetry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',normalizedContent:'liteflow从2.6.10起开始允许用户定义自定义组件执行器，通过这个可以在执行组件时，加入自定义代码，重写重试策略。当然其他方式也可以达到相同的目的，比如说组件切面功能。\n\n如果你没有非常明确这个功能是干什么的，建议还是用默认的方式。(其实就是不用看此章节的意思)\n\n\n# 全局组件执行器\n\n对于自定义组件执行器，你可以在全局上进行替换。默认的组件执行器为：com.yomahub.liteflow.entity.executor.defaultnodeexecutor\n\n你可以通过以下方式替换全局默认组件执行器：\n\nliteflow.node-executor-class=com.yomahub.liteflow.test.nodeexecutor.customerdefaultnodeexecutor\n\n\n自定义组件执行器需要继承com.yomahub.liteflow.entity.executor.nodeexecutor。\n\npublic class customerdefaultnodeexecutor extends nodeexecutor {\n    @override\n    public void execute(nodecomponent instance) throws exception {\n        slot slot = databus.getslot(instance.getslotindex());\n        log.info("使用customerdefaultnodeexecutor进行执行");\n        super.execute(instance);\n      \n      \t//在这里你可以加入自己的代码，包括上面的代码都可以去掉\n      \t//但是要确保至少要调用instance.execute()，否组件就真的无法被正确执行了\n    }\n}\n\n\n\n# 单个组件配置特殊的执行器\n\n除了全局执行器，单个组件也支持配置自定义执行器。\n\n你需要在定义组件的时候，实现getnodeexecutorclass 方法：\n\n@liteflowcomponent("d")\npublic class dcmp extends nodecomponent {\n\n    @override\n    public void process() {\n        system.out.println("dcmp executed!");\n    }\n\n    @override\n    public class<? extends nodeexecutor> getnodeexecutorclass() {\n        return customernodeexecutorandcustomretry.class;\n    }\n}\n\n\n\n# 优先级\n\n如果全局和单个组件都配置自定义执行器的情况下，优先使用单个组件上配置的执行器。\n\n\n# 自定义执行器对于重试功能的影响\n\n因为重试的逻辑是在默认执行器里面实现的。所以如果你自己配置了自定义执行器，那么重试的功能需要你自己去实现。并且全局重试参数配置还有@liteflowretry功能标签将失效。\n\n当然你自己实现的自定义执行器，还是可以拿到重试参数，自己写特殊的重试策略的。只不过这一切都需要自己去完成。这点要注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"测试用例",frontmatter:{title:"测试用例",date:"2022-06-01T14:01:20.000Z",permalink:"/pages/v2.6.X/45096f/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/070.%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B/010.%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.html",relativePath:"30.v2.6.X文档/070.示例工程/010.测试用例.md",key:"v-b0e29e0a",path:"/pages/v2.6.X/45096f/",headersStr:null,content:"项目提供了丰富的测试用例，截止到2.6.14版本，项目内一共有接近400个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解LiteFlow的同学可以去看看测试用例来学会如何在细节点上的配置和使用。\n\n * liteflow-testcase-nospring: 非spring体系的测试用例\n * liteflow-testcase-springboot: springboot环境下的测试用例\n * liteflow-testcase-springnative: spring原生环境下的测试用例\n * liteflow-testcase-declare-component: 声明式组件场景下的测试用例\n * liteflow-testcase-script-qlexpress: 基于QLExpress脚本框架的测试用例\n * liteflow-testcase-script-groovy: 基于Groovy脚本框架的测试用例",normalizedContent:"项目提供了丰富的测试用例，截止到2.6.14版本，项目内一共有接近400个测试用例。几乎涵盖了文档内所有提到的功能点和场景。\n\n强烈建议想了解liteflow的同学可以去看看测试用例来学会如何在细节点上的配置和使用。\n\n * liteflow-testcase-nospring: 非spring体系的测试用例\n * liteflow-testcase-springboot: springboot环境下的测试用例\n * liteflow-testcase-springnative: spring原生环境下的测试用例\n * liteflow-testcase-declare-component: 声明式组件场景下的测试用例\n * liteflow-testcase-script-qlexpress: 基于qlexpress脚本框架的测试用例\n * liteflow-testcase-script-groovy: 基于groovy脚本框架的测试用例",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"性能表现",frontmatter:{title:"性能表现",date:"2022-06-01T14:05:52.000Z",permalink:"/pages/v2.6.X/dfd1af/"},regularPath:"/30.v2.6.X%E6%96%87%E6%A1%A3/080.%E6%80%A7%E8%83%BD%E8%A1%A8%E7%8E%B0.html",relativePath:"30.v2.6.X文档/080.性能表现.md",key:"v-d3947202",path:"/pages/v2.6.X/dfd1af/",headersStr:null,content:"LiteFlow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，LiteFlow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的TPS，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然LiteFlow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求IO，或者有bad sql，又或者有大量的rpc同步调用。那实际TPS也不会很高。但是这是业务组件的的问题，而不是LiteFlow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的TPS/QPS，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nLiteFlow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库IO。\n\n基于这个Demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",normalizedContent:"liteflow绝大部分工作都是在启动时完成，包括解析规则，注册组件，组装元信息。而执行链路时几乎对系统没有额外的消耗。框架在设计之初就是为公司的核心业务量身打造，在性能表现问题上格外注意。所以也对核心代码进行了性能方面的优化。\n\n实际表现中，liteflow执行效率很高，在公司级核心业务上面，50多个业务组件组成的链路，在实际压测中单点达到了1500的tps，也经历过双11，明星顶流带货等大流量的考验。\n\n虽然liteflow框架本身性能很好，但是整体执行效率却依赖实际业务组件的快慢，如果你的组件有大量的循环数据库请求io，或者有bad sql，又或者有大量的rpc同步调用。那实际tps也不会很高。但是这是业务组件的的问题，而不是liteflow框架本身的性能问题。如果你的业务代码很糟糕，那么任何一个框架都无法提高整体系统的tps/qps，一个系统整体吞吐量的快慢，不是仅依靠某一款框架能改善的。这点希望大家能明白。\n\nliteflow提供了一个实际业务的测试案例，地址为：\n\n> 测试案例\n\n这个业务为一个价格计算引擎，有11个业务节点，业务逻辑丰富，只不过数据为mock，不走数据库io。\n\n基于这个demo业务进行了压测，压测机器为mac m1 pro ，压测工具为apache jmeter，压测结果为：\n\n100并发\n\n\n\n300并发\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"PPT获取",frontmatter:{title:"PPT获取",date:"2022-07-18T00:54:47.000Z",permalink:"/pages/8d6666/"},regularPath:"/PPT.html",relativePath:"PPT.md",key:"v-0d95a0b6",path:"/pages/8d6666/",headers:[{level:2,title:"获取方法",slug:"获取方法",normalizedTitle:"获取方法",charIndex:2},{level:2,title:"PPT部分页数动图预览",slug:"ppt部分页数动图预览",normalizedTitle:"ppt部分页数动图预览",charIndex:285}],headersStr:"获取方法 PPT部分页数动图预览",content:"# 获取方法\n\n做PPT的初衷是考虑到社区内的小伙伴都想在公司内部进行培训分享，但是要从文档中总结出一个PPT，需要一定的时间。作者亲自给你们做了PPT。\n\n不过要注意的是，PPT注重让大家了解LiteFlow的特性和简单使用，不会深入到实现层面去分析。并且所有的页数都是精心设计。建议40分钟内讲完。整体也不会把每一部分都讲细，需要演讲者自己去补充一些旁白和理解，并结合一些demo案例进行演示，demo案例和测试用例在文档中有提到。\n\n分享者可以自己新增一些内容，但是为了版权，请尽量保留作者的署名。\n\n领取方法：关注公众号，在公众号内回复ppt获取！\n\n\n\n\n# PPT部分页数动图预览\n\nPPT中含有大量的动态效果，推荐用播放按钮观看或者进行演讲，效果最佳。\n\n\n\n\n\n",normalizedContent:"# 获取方法\n\n做ppt的初衷是考虑到社区内的小伙伴都想在公司内部进行培训分享，但是要从文档中总结出一个ppt，需要一定的时间。作者亲自给你们做了ppt。\n\n不过要注意的是，ppt注重让大家了解liteflow的特性和简单使用，不会深入到实现层面去分析。并且所有的页数都是精心设计。建议40分钟内讲完。整体也不会把每一部分都讲细，需要演讲者自己去补充一些旁白和理解，并结合一些demo案例进行演示，demo案例和测试用例在文档中有提到。\n\n分享者可以自己新增一些内容，但是为了版权，请尽量保留作者的署名。\n\n领取方法：关注公众号，在公众号内回复ppt获取！\n\n\n\n\n# ppt部分页数动图预览\n\nppt中含有大量的动态效果，推荐用播放按钮观看或者进行演讲，效果最佳。\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-f495d4f6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.12.4?",frontmatter:{title:"What's New In LiteFlow v2.12.4?",date:"2024-10-13T23:00:00.000Z",permalink:"/pages/8ff021/"},regularPath:"/whats%20new/080.whats%20new%20in%20v2.12.4.html",relativePath:"whats new/080.whats new in v2.12.4.md",key:"v-719004fe",path:"/pages/8ff021/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"JavaX脚本",slug:"javax脚本",normalizedTitle:"javax脚本",charIndex:85},{level:2,title:"全新的生命周期体系",slug:"全新的生命周期体系",normalizedTitle:"全新的生命周期体系",charIndex:435},{level:2,title:"数据库插件支持配置自定义SQL",slug:"数据库插件支持配置自定义sql",normalizedTitle:"数据库插件支持配置自定义sql",charIndex:582},{level:2,title:"其他的更新",slug:"其他的更新",normalizedTitle:"其他的更新",charIndex:712},{level:2,title:"完整更新列表",slug:"完整更新列表",normalizedTitle:"完整更新列表",charIndex:774}],headersStr:"前言 JavaX脚本 全新的生命周期体系 数据库插件支持配置自定义SQL 其他的更新 完整更新列表",content:"# 前言\n\nLiteFlow的最新版本2.12.4发布了！\n\n在这个版本里，我们带来了2个大特性和诸多的升级。同时这个版本也是向下兼容2.12.X系列的版本的。\n\n\n# JavaX脚本\n\nLF从很早就开始支持Java脚本，让java代码可以像一种脚本语言那样运作，使用java语言编写可以随时热刷新的代码成为了现实，这个脚本很酷，但是社区里一直诟病的就是LF的java脚本竟然不支持lambda和泛型。\n\n这是因为之前java脚本底层用的是Janino框架，这个框架是个老外写的，这个项目已经很久没更新过了并且作者表示不高兴去支持lambda和泛型了。所以我也是没辙。\n\n这次新的Javax采用Liquor框架的方案，支持了java8到java21中所有的用法，多谢solon作者提供Liquor底层的技术支持，才得以让LF解决了一个困扰多时的问题。使得Java脚本得到了一次大的升级！\n\n如果开发者想要从Java脚本更新到Javax脚本，请看官网的升级指南。\n\n\n# 全新的生命周期体系\n\n在2.12.4版本中，LF提供了生命周期体系。开发者可以很方便的实现一些既定的生命周期接口，从而在特定的生命周期织入自定义逻辑。\n\nLF这次提供了5个大的生命周期阶段的接口，扩展LF，让自己的逻辑变得灵活成为了可能。\n\n具体如何使用请参考官网的生命周期全新章节。\n\n\n# 数据库插件支持配置自定义SQL\n\n这也是为开发者提供了更加灵活自由的选择，现在开发者可以忽视掉applicationName，enable等字段，自己去定义SQL来返回系统所需要加载的规则/脚本。\n\n具体如何使用请参考官网文档中的SQL数据库配置源。\n\n\n# 其他的更新\n\n另外这个版本，我们还修复了一直以来困扰开发者的异步循环中的并发问题。\n\n提供了域名版本的dtd文件。\n\n\n# 完整更新列表\n\n特性 #IASS9Z 新的JavaX脚本插件，支持java8~java17的所有语法特性\n\nhttps://gitee.com/dromara/liteFlow/issues/IASS9Z\n\n特性 #IAJD9H 期望liteflow 有自己的生命周期扩展\n\nhttps://gitee.com/dromara/liteFlow/issues/IAJD9H\n\n增强 #IASYI0 提供脚本初始化生命周期的扩展点\n\nhttps://gitee.com/dromara/liteFlow/issues/IASYI0\n\n增强 #I9H6GY SQL脚本在配置上支持用户自定义的过滤条件\n\nhttps://gitee.com/dromara/liteFlow/issues/I9H6GY\n\n增强 #IAVH8O 把scanner当中的步骤抽象出来，形成一套小的体系，方便的扩展\n\nhttps://gitee.com/dromara/liteFlow/issues/IAVH8O\n\n增强 #IANY4U 组件中提供getCmpDataList接口\n\nhttps://gitee.com/dromara/liteFlow/issues/IANY4U\n\n增强 #I5XB03 提供带域名的dtd文件地址，加强xml的提示\n\nhttps://gitee.com/dromara/liteFlow/issues/I5XB03\n\n修复 #IASW3I 异步循环迭代组件中迭代对象以及迭代下标存在并发问题\n\nhttps://gitee.com/dromara/liteFlow/issues/IASW3I\n\n",normalizedContent:"# 前言\n\nliteflow的最新版本2.12.4发布了！\n\n在这个版本里，我们带来了2个大特性和诸多的升级。同时这个版本也是向下兼容2.12.x系列的版本的。\n\n\n# javax脚本\n\nlf从很早就开始支持java脚本，让java代码可以像一种脚本语言那样运作，使用java语言编写可以随时热刷新的代码成为了现实，这个脚本很酷，但是社区里一直诟病的就是lf的java脚本竟然不支持lambda和泛型。\n\n这是因为之前java脚本底层用的是janino框架，这个框架是个老外写的，这个项目已经很久没更新过了并且作者表示不高兴去支持lambda和泛型了。所以我也是没辙。\n\n这次新的javax采用liquor框架的方案，支持了java8到java21中所有的用法，多谢solon作者提供liquor底层的技术支持，才得以让lf解决了一个困扰多时的问题。使得java脚本得到了一次大的升级！\n\n如果开发者想要从java脚本更新到javax脚本，请看官网的升级指南。\n\n\n# 全新的生命周期体系\n\n在2.12.4版本中，lf提供了生命周期体系。开发者可以很方便的实现一些既定的生命周期接口，从而在特定的生命周期织入自定义逻辑。\n\nlf这次提供了5个大的生命周期阶段的接口，扩展lf，让自己的逻辑变得灵活成为了可能。\n\n具体如何使用请参考官网的生命周期全新章节。\n\n\n# 数据库插件支持配置自定义sql\n\n这也是为开发者提供了更加灵活自由的选择，现在开发者可以忽视掉applicationname，enable等字段，自己去定义sql来返回系统所需要加载的规则/脚本。\n\n具体如何使用请参考官网文档中的sql数据库配置源。\n\n\n# 其他的更新\n\n另外这个版本，我们还修复了一直以来困扰开发者的异步循环中的并发问题。\n\n提供了域名版本的dtd文件。\n\n\n# 完整更新列表\n\n特性 #iass9z 新的javax脚本插件，支持java8~java17的所有语法特性\n\nhttps://gitee.com/dromara/liteflow/issues/iass9z\n\n特性 #iajd9h 期望liteflow 有自己的生命周期扩展\n\nhttps://gitee.com/dromara/liteflow/issues/iajd9h\n\n增强 #iasyi0 提供脚本初始化生命周期的扩展点\n\nhttps://gitee.com/dromara/liteflow/issues/iasyi0\n\n增强 #i9h6gy sql脚本在配置上支持用户自定义的过滤条件\n\nhttps://gitee.com/dromara/liteflow/issues/i9h6gy\n\n增强 #iavh8o 把scanner当中的步骤抽象出来，形成一套小的体系，方便的扩展\n\nhttps://gitee.com/dromara/liteflow/issues/iavh8o\n\n增强 #iany4u 组件中提供getcmpdatalist接口\n\nhttps://gitee.com/dromara/liteflow/issues/iany4u\n\n增强 #i5xb03 提供带域名的dtd文件地址，加强xml的提示\n\nhttps://gitee.com/dromara/liteflow/issues/i5xb03\n\n修复 #iasw3i 异步循环迭代组件中迭代对象以及迭代下标存在并发问题\n\nhttps://gitee.com/dromara/liteflow/issues/iasw3i\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.12.2?",frontmatter:{title:"What's New In LiteFlow v2.12.2?",date:"2024-05-31T11:47:13.000Z",permalink:"/pages/8ff019/"},regularPath:"/whats%20new/082.whats%20new%20in%20v2.12.2.html",relativePath:"whats new/082.whats new in v2.12.2.md",key:"v-1c3744ee",path:"/pages/8ff019/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"决策路由支持刷新",slug:"决策路由支持刷新",normalizedTitle:"决策路由支持刷新",charIndex:345},{level:2,title:"SQL插件的轮询逻辑优化",slug:"sql插件的轮询逻辑优化",normalizedTitle:"sql插件的轮询逻辑优化",charIndex:646},{level:2,title:"上下文支持超类获取",slug:"上下文支持超类获取",normalizedTitle:"上下文支持超类获取",charIndex:772},{level:2,title:"EL的构建现在支持retry属性的构建了",slug:"el的构建现在支持retry属性的构建了",normalizedTitle:"el的构建现在支持retry属性的构建了",charIndex:900},{level:2,title:"全部更新列表",slug:"全部更新列表",normalizedTitle:"全部更新列表",charIndex:1046}],headersStr:"前言 决策路由支持刷新 SQL插件的轮询逻辑优化 上下文支持超类获取 EL的构建现在支持retry属性的构建了 全部更新列表",content:'# 前言\n\nLF 2.12.2.1发布啦！\n\n肯定有小伙伴会奇怪，这次怎么最后还有个点1呢。因为2.12.2本来已经发布，但是这期间社区里有个同学用到了声明式的异常事件监听功能，发现有一个bug并立即上报了。我在查清楚原委之后觉得这应该被尽快修复，所以在2.12.2后面又打了个补丁版本。\n\n但是这并代表2.12.2就不能用，如果你没有用到声明式的异常事件监听功能，那么2.12.2和2.12.2.1是完全一致的。\n\n这次的2.12.2.1版本没有带来大的特性，算是常规性迭代，但是也带了很多功能的增强和一些bug的修复。这些issue都来自于社区。\n\n所以更加说明了我们是非常重视社区的。\n\n这次版本带来了13个issue的更新，包括8个增强和5个修复。接下来我会挑一些来介绍。\n\n\n# 决策路由支持刷新\n\n决策路由自从2.12.0推出以来，我们一直在对决策路由做一些优化。比如2.12.1版本支持了数据库中使用决策路由，以及决策路由的命名空间。这次我们对决策路由的调整是：支持了决策路由的刷新。\n\n如果决策路由配置在数据库中，并开启了轮询，那么改变等待轮询即可刷新决策路由。如果没有开启轮询，你现在可以通过调用以下api来完成刷新：\n\nFlowBus.reloadChain("chain1", "THEN(a, b, c)", "AND(r1, r2)");\n\n\n是的，它是一个重载方法，它还有一个两个参数的方法，那是单独刷新规则的，现在它的重载可以连带规则和路由一起刷新了。\n\n\n# SQL插件的轮询逻辑优化\n\n在这之前，一直有社区里的同学反映，在使用数据库存储规则和脚本时，单更新脚本和单更新规则，自动刷新都正常，但是同时更新了规则和脚本，刷新就会一直失效。\n\n我们这次修复了这个问题。现在无论你怎么更新，自动刷新都会生效。\n\n\n# 上下文支持超类获取\n\n这也是社区一位使用者提出的建议，有些上下文的设计是有超类的。在公共组件里希望可以用超类去获取上下文。这样更利于公共组件的定义。\n\n这次我们支持了这一形式的获取。你的上下文既可以用本身的Class获取，也可以用他的超类去获取。\n\n\n# EL的构建现在支持retry属性的构建了\n\n如果经常用动态代码构建规则特性的小伙伴应该知道，LF里有个ELBus对象，是可以很方便的通过代码来构建出规则的。\n\n之前不支持retry属性，这次我们不仅支持了retry。而且我们把ELBus的核心代码部分重构了一遍，更加合理，更加高效。\n\n\n# 全部更新列表\n\n增强 #IAE5PA FlowBus中提供刷新route的api方法\n\nhttps://gitee.com/dromara/liteFlow/issues/IAE5PA\n\n增强 #IACEH9 SQL插件中的轮询逻辑优化\n\nhttps://gitee.com/dromara/liteFlow/issues/IACEH9\n\n增强 #IACEGB 上下文超类判断的获取和转换\n\nhttps://gitee.com/dromara/liteFlow/issues/IACEGB\n\n增强 #IA9QBG el-builder的部分重构\n\nhttps://gitee.com/dromara/liteFlow/issues/IA9QBG\n\n增强 #IA9NOI ELBus中增加对retry构建的api支持\n\nhttps://gitee.com/dromara/liteFlow/issues/IA9NOI\n\n增强 #IA6E3Q redis配置的时候可以指定Redisson的链接数，默认的connections太多了\n\nhttps://gitee.com/dromara/liteFlow/issues/IA6E3Q\n\n增强 #IA8B3T 插件 throw Exception 会丢失堆栈\n\nhttps://gitee.com/dromara/liteFlow/issues/IA8B3T\n\n增强 #IABK5C 校验 EL 表达式，获取校验失败原因\n\nhttps://gitee.com/dromara/liteFlow/issues/IABK5C\n\n修复 #IA5PAK ELBus串行编排不支持对每个节点进行超时配置\n\nhttps://gitee.com/dromara/liteFlow/issues/IA5PAK\n\n修复 #IAD2HH 希望支持执行节点日志与监控日志的分开管理\n\nhttps://gitee.com/dromara/liteFlow/issues/IAD2HH\n\n修复 #IACSQ8 liteflow-solon-plugin 启动报错\n\nhttps://gitee.com/dromara/liteFlow/issues/IACSQ8\n\n修复 #IADIXE 使用迭代循环组件，下游getCurrLoopObj()获取为null\n\nhttps://gitee.com/dromara/liteFlow/issues/IADIXE\n\n修复 #IAFKQV 声明式的onError方法取不到Exception\n\nhttps://gitee.com/dromara/liteFlow/issues/IAFKQV\n\n',normalizedContent:'# 前言\n\nlf 2.12.2.1发布啦！\n\n肯定有小伙伴会奇怪，这次怎么最后还有个点1呢。因为2.12.2本来已经发布，但是这期间社区里有个同学用到了声明式的异常事件监听功能，发现有一个bug并立即上报了。我在查清楚原委之后觉得这应该被尽快修复，所以在2.12.2后面又打了个补丁版本。\n\n但是这并代表2.12.2就不能用，如果你没有用到声明式的异常事件监听功能，那么2.12.2和2.12.2.1是完全一致的。\n\n这次的2.12.2.1版本没有带来大的特性，算是常规性迭代，但是也带了很多功能的增强和一些bug的修复。这些issue都来自于社区。\n\n所以更加说明了我们是非常重视社区的。\n\n这次版本带来了13个issue的更新，包括8个增强和5个修复。接下来我会挑一些来介绍。\n\n\n# 决策路由支持刷新\n\n决策路由自从2.12.0推出以来，我们一直在对决策路由做一些优化。比如2.12.1版本支持了数据库中使用决策路由，以及决策路由的命名空间。这次我们对决策路由的调整是：支持了决策路由的刷新。\n\n如果决策路由配置在数据库中，并开启了轮询，那么改变等待轮询即可刷新决策路由。如果没有开启轮询，你现在可以通过调用以下api来完成刷新：\n\nflowbus.reloadchain("chain1", "then(a, b, c)", "and(r1, r2)");\n\n\n是的，它是一个重载方法，它还有一个两个参数的方法，那是单独刷新规则的，现在它的重载可以连带规则和路由一起刷新了。\n\n\n# sql插件的轮询逻辑优化\n\n在这之前，一直有社区里的同学反映，在使用数据库存储规则和脚本时，单更新脚本和单更新规则，自动刷新都正常，但是同时更新了规则和脚本，刷新就会一直失效。\n\n我们这次修复了这个问题。现在无论你怎么更新，自动刷新都会生效。\n\n\n# 上下文支持超类获取\n\n这也是社区一位使用者提出的建议，有些上下文的设计是有超类的。在公共组件里希望可以用超类去获取上下文。这样更利于公共组件的定义。\n\n这次我们支持了这一形式的获取。你的上下文既可以用本身的class获取，也可以用他的超类去获取。\n\n\n# el的构建现在支持retry属性的构建了\n\n如果经常用动态代码构建规则特性的小伙伴应该知道，lf里有个elbus对象，是可以很方便的通过代码来构建出规则的。\n\n之前不支持retry属性，这次我们不仅支持了retry。而且我们把elbus的核心代码部分重构了一遍，更加合理，更加高效。\n\n\n# 全部更新列表\n\n增强 #iae5pa flowbus中提供刷新route的api方法\n\nhttps://gitee.com/dromara/liteflow/issues/iae5pa\n\n增强 #iaceh9 sql插件中的轮询逻辑优化\n\nhttps://gitee.com/dromara/liteflow/issues/iaceh9\n\n增强 #iacegb 上下文超类判断的获取和转换\n\nhttps://gitee.com/dromara/liteflow/issues/iacegb\n\n增强 #ia9qbg el-builder的部分重构\n\nhttps://gitee.com/dromara/liteflow/issues/ia9qbg\n\n增强 #ia9noi elbus中增加对retry构建的api支持\n\nhttps://gitee.com/dromara/liteflow/issues/ia9noi\n\n增强 #ia6e3q redis配置的时候可以指定redisson的链接数，默认的connections太多了\n\nhttps://gitee.com/dromara/liteflow/issues/ia6e3q\n\n增强 #ia8b3t 插件 throw exception 会丢失堆栈\n\nhttps://gitee.com/dromara/liteflow/issues/ia8b3t\n\n增强 #iabk5c 校验 el 表达式，获取校验失败原因\n\nhttps://gitee.com/dromara/liteflow/issues/iabk5c\n\n修复 #ia5pak elbus串行编排不支持对每个节点进行超时配置\n\nhttps://gitee.com/dromara/liteflow/issues/ia5pak\n\n修复 #iad2hh 希望支持执行节点日志与监控日志的分开管理\n\nhttps://gitee.com/dromara/liteflow/issues/iad2hh\n\n修复 #iacsq8 liteflow-solon-plugin 启动报错\n\nhttps://gitee.com/dromara/liteflow/issues/iacsq8\n\n修复 #iadixe 使用迭代循环组件，下游getcurrloopobj()获取为null\n\nhttps://gitee.com/dromara/liteflow/issues/iadixe\n\n修复 #iafkqv 声明式的onerror方法取不到exception\n\nhttps://gitee.com/dromara/liteflow/issues/iafkqv\n\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.12.3?",frontmatter:{title:"What's New In LiteFlow v2.12.3?",date:"2024-09-05T11:47:13.000Z",permalink:"/pages/8ff020/"},regularPath:"/whats%20new/081.whats%20new%20in%20v2.12.3.html",relativePath:"whats new/081.whats new in v2.12.3.md",key:"v-46e3a4f6",path:"/pages/8ff020/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"嵌套循环获取N层下标/迭代对象",slug:"嵌套循环获取n层下标-迭代对象",normalizedTitle:"嵌套循环获取n层下标/迭代对象",charIndex:143},{level:2,title:"隐式子流程嵌套的问题",slug:"隐式子流程嵌套的问题",normalizedTitle:"隐式子流程嵌套的问题",charIndex:356},{level:2,title:"在Solon体系中支持声明式的组件",slug:"在solon体系中支持声明式的组件",normalizedTitle:"在solon体系中支持声明式的组件",charIndex:448},{level:2,title:"测试用例数提升到2056个",slug:"测试用例数提升到2056个",normalizedTitle:"测试用例数提升到2056个",charIndex:597},{level:2,title:"其他要说的",slug:"其他要说的",normalizedTitle:"其他要说的",charIndex:749},{level:2,title:"2.12.3完整更新列表",slug:"_2-12-3完整更新列表",normalizedTitle:"2.12.3完整更新列表",charIndex:1578}],headersStr:"前言 嵌套循环获取N层下标/迭代对象 隐式子流程嵌套的问题 在Solon体系中支持声明式的组件 测试用例数提升到2056个 其他要说的 2.12.3完整更新列表",content:"# 前言\n\n这一个版本2.12.3做了挺久的。虽然涉及到的issue只有9个，但是其中有些issue涉及到了LF的核心数据结构的变动。为了能让LF的源码设计更加优秀，是做了大量的优化的。\n\n如果你在使用2.12.X系列的版本，可以无缝升级。如果是以下版本，请看官网的升级指南。\n\n\n# 嵌套循环获取N层下标/迭代对象\n\n在之前版本中，这一直是循环体系中不太完美的地方，开发者只能取到当前层的循环下标/迭代对象。而无法取到上层的值。之前版本没提供也是因为涉及到了底层的对象结构的变更，没有很好的思路去入手。\n\n在这个版本中，我们终于提供了这一个特性。不仅能取到上一层的循环下标/迭代对象，还能取到前N层的。\n\n关于这个特性的详细使用方法请参照【常规组件->次数循环组件】以及【常规组件->迭代循环组件】。\n\n\n# 隐式子流程嵌套的问题\n\n其实这个问题和循环嵌套获取N层下标的问题类似，都是属于底层对象结构的不完善导致的。我们这个版本花了很长时间去思考了这个问题，并从底层去解决了本质问题。\n\n\n# 在Solon体系中支持声明式的组件\n\nSolon是一个优秀的纯血国产应用开发框架，LF一直对Solon有支持，但是在之前的版本中，在solon中开发声明式的组件一直存在问题。后来得益于solon作者的帮助，这个问题才得以解决。\n\n现在你可以在solon体系中更好的使用LiteFlow了。\n\n\n# 测试用例数提升到2056个\n\n测试用例数我认为直接反映了一个开源项目的可靠性和稳定性。所以我们在对待测试用例这件事上是有和对待核心代码同样的极致追求。\n\n每一个issue，每一个特性，每一个bug，每一个增强，我们都有相应的测试用例来佐证，并且所有的PR提交都会要求通过所有的测试用例才能合入。\n\n\n# 其他要说的\n\n我们一直积极在回答社区里的各种问题。随着社群人数不断激增，问题也在不断变多。\n\n我们在回答的同时也发现了很多现象，我总结了下主要有以下几类：\n\n1.LF概念性的问题\n\n2.开发中碰到使用LF常见的问题，反复被提问\n\n3.文档有明确的显示提及，但在社区内还是被反复提问\n\n4.某一个功能特性使用有问题\n\n5.同自己公司业务结合设计方面的问题\n\n6.提出建议性LF需要改进的点，新增的特性\n\n7.报LF使用过程中已经明确的Bug\n\n目前LF一共有15个群，每天都会有非常多的社区问题，我们做不到细致的回答每一个人的问题，因为回答问题已经占据了我们很多的时间。而这种模式也并非健康长久的模式。所以我也在思索如何去优化社区答疑这个体验。\n\n对于问题类型一，LF官网可能会在之后增加一栏去专门解释概念，用在哪里，如何选型方面的一些文章。目前的确这方面的解释在官网上有缺失。\n\n对于问题类型二，反复被提问这是我的问题，而非开发者的问题。常见的问题虽然在LF官网有专门栏目，但是没有及时更新和增加，在之后，我会去花时间建立一个比较全面的常见问题知识库供大家查阅。\n\n对于问题类型三，这个只能希望使用者多去看文档，在社区群里也只会给一个指引，而不会过多的去解释。\n\n对于问题类型四，我们建立庞大数量的测试用例一方面是为了保障项目稳定，另一方面也希望使用者在碰到问题时能去源码查询下对应的测试用例，但我遗憾的发现，只有很少的开发者会去查看测试用例，估计能查看源码的人更少了。但是我之后还是会引导社区里的同学去查看对应的测试用例。\n\n对于问题类型五，这个我真没办法回答，尤其是XXX业务可不可以用，要如何设计这类问题，因为我并不精通使用者公司的业务，拿LF如何设计业务这种问题和业务紧密绑定，需要对业务要有很深的理解才可以。\n\n对于问题六，七，其实这两类问题，是对LF本身有很大推动作用的。目前我们都会根据问题去建立相应的issue，并且推动迭代和修复。\n\n\n# 2.12.3完整更新列表\n\n特性 #I9T6PB 嵌套循环获得任意外层的下标或者对象\n\nhttps://gitee.com/dromara/liteFlow/issues/I9T6PB\n\n增强 #IAH00W 增加在LiteflowResponse中超时节点的Id获取方式\n\nhttps://gitee.com/dromara/liteFlow/issues/IAH00W\n\n增强 #IAMBU8 ELBus 增加普通节点构建方法\n\nhttps://gitee.com/dromara/liteFlow/issues/IAMBU8\n\n增强 #IAOW43 在solon体系中支持声明式的组件\n\nhttps://gitee.com/dromara/liteFlow/issues/IAOW43\n\n增强 #IAGJ2F 在使用最新版决策路由功能时发现SPI加载有报错问题\n\nhttps://gitee.com/dromara/liteFlow/issues/IAGJ2F\n\n修复 #IAERN6 隐式子流程嵌套报错\n\nhttps://gitee.com/dromara/liteFlow/issues/IAERN6\n\n修复 #IAIH89 在SQL插件多个数据源都能检测执行通过的情况下，有可能会出现连接泄露\n\nhttps://gitee.com/dromara/liteFlow/issues/IAIH89\n\n修复 #IAJR32 修复在ParallelStrategyExecutor可能出现的NPE问题\n\nhttps://gitee.com/dromara/liteFlow/issues/IAJR32\n\n修复 #IAOICK GraalJavaScriptExecutor 这个类的compile()方法中新开的context没有关闭，可能有隐患\n\nhttps://gitee.com/dromara/liteFlow/issues/IAOICK\n\n",normalizedContent:"# 前言\n\n这一个版本2.12.3做了挺久的。虽然涉及到的issue只有9个，但是其中有些issue涉及到了lf的核心数据结构的变动。为了能让lf的源码设计更加优秀，是做了大量的优化的。\n\n如果你在使用2.12.x系列的版本，可以无缝升级。如果是以下版本，请看官网的升级指南。\n\n\n# 嵌套循环获取n层下标/迭代对象\n\n在之前版本中，这一直是循环体系中不太完美的地方，开发者只能取到当前层的循环下标/迭代对象。而无法取到上层的值。之前版本没提供也是因为涉及到了底层的对象结构的变更，没有很好的思路去入手。\n\n在这个版本中，我们终于提供了这一个特性。不仅能取到上一层的循环下标/迭代对象，还能取到前n层的。\n\n关于这个特性的详细使用方法请参照【常规组件->次数循环组件】以及【常规组件->迭代循环组件】。\n\n\n# 隐式子流程嵌套的问题\n\n其实这个问题和循环嵌套获取n层下标的问题类似，都是属于底层对象结构的不完善导致的。我们这个版本花了很长时间去思考了这个问题，并从底层去解决了本质问题。\n\n\n# 在solon体系中支持声明式的组件\n\nsolon是一个优秀的纯血国产应用开发框架，lf一直对solon有支持，但是在之前的版本中，在solon中开发声明式的组件一直存在问题。后来得益于solon作者的帮助，这个问题才得以解决。\n\n现在你可以在solon体系中更好的使用liteflow了。\n\n\n# 测试用例数提升到2056个\n\n测试用例数我认为直接反映了一个开源项目的可靠性和稳定性。所以我们在对待测试用例这件事上是有和对待核心代码同样的极致追求。\n\n每一个issue，每一个特性，每一个bug，每一个增强，我们都有相应的测试用例来佐证，并且所有的pr提交都会要求通过所有的测试用例才能合入。\n\n\n# 其他要说的\n\n我们一直积极在回答社区里的各种问题。随着社群人数不断激增，问题也在不断变多。\n\n我们在回答的同时也发现了很多现象，我总结了下主要有以下几类：\n\n1.lf概念性的问题\n\n2.开发中碰到使用lf常见的问题，反复被提问\n\n3.文档有明确的显示提及，但在社区内还是被反复提问\n\n4.某一个功能特性使用有问题\n\n5.同自己公司业务结合设计方面的问题\n\n6.提出建议性lf需要改进的点，新增的特性\n\n7.报lf使用过程中已经明确的bug\n\n目前lf一共有15个群，每天都会有非常多的社区问题，我们做不到细致的回答每一个人的问题，因为回答问题已经占据了我们很多的时间。而这种模式也并非健康长久的模式。所以我也在思索如何去优化社区答疑这个体验。\n\n对于问题类型一，lf官网可能会在之后增加一栏去专门解释概念，用在哪里，如何选型方面的一些文章。目前的确这方面的解释在官网上有缺失。\n\n对于问题类型二，反复被提问这是我的问题，而非开发者的问题。常见的问题虽然在lf官网有专门栏目，但是没有及时更新和增加，在之后，我会去花时间建立一个比较全面的常见问题知识库供大家查阅。\n\n对于问题类型三，这个只能希望使用者多去看文档，在社区群里也只会给一个指引，而不会过多的去解释。\n\n对于问题类型四，我们建立庞大数量的测试用例一方面是为了保障项目稳定，另一方面也希望使用者在碰到问题时能去源码查询下对应的测试用例，但我遗憾的发现，只有很少的开发者会去查看测试用例，估计能查看源码的人更少了。但是我之后还是会引导社区里的同学去查看对应的测试用例。\n\n对于问题类型五，这个我真没办法回答，尤其是xxx业务可不可以用，要如何设计这类问题，因为我并不精通使用者公司的业务，拿lf如何设计业务这种问题和业务紧密绑定，需要对业务要有很深的理解才可以。\n\n对于问题六，七，其实这两类问题，是对lf本身有很大推动作用的。目前我们都会根据问题去建立相应的issue，并且推动迭代和修复。\n\n\n# 2.12.3完整更新列表\n\n特性 #i9t6pb 嵌套循环获得任意外层的下标或者对象\n\nhttps://gitee.com/dromara/liteflow/issues/i9t6pb\n\n增强 #iah00w 增加在liteflowresponse中超时节点的id获取方式\n\nhttps://gitee.com/dromara/liteflow/issues/iah00w\n\n增强 #iambu8 elbus 增加普通节点构建方法\n\nhttps://gitee.com/dromara/liteflow/issues/iambu8\n\n增强 #iaow43 在solon体系中支持声明式的组件\n\nhttps://gitee.com/dromara/liteflow/issues/iaow43\n\n增强 #iagj2f 在使用最新版决策路由功能时发现spi加载有报错问题\n\nhttps://gitee.com/dromara/liteflow/issues/iagj2f\n\n修复 #iaern6 隐式子流程嵌套报错\n\nhttps://gitee.com/dromara/liteflow/issues/iaern6\n\n修复 #iaih89 在sql插件多个数据源都能检测执行通过的情况下，有可能会出现连接泄露\n\nhttps://gitee.com/dromara/liteflow/issues/iaih89\n\n修复 #iajr32 修复在parallelstrategyexecutor可能出现的npe问题\n\nhttps://gitee.com/dromara/liteflow/issues/iajr32\n\n修复 #iaoick graaljavascriptexecutor 这个类的compile()方法中新开的context没有关闭，可能有隐患\n\nhttps://gitee.com/dromara/liteflow/issues/iaoick\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.12.0?",frontmatter:{title:"What's New In LiteFlow v2.12.0?",date:"2024-04-15T00:48:57.000Z",permalink:"/pages/8ff017/"},regularPath:"/whats%20new/084.whats%20new%20in%20v2.12.0.html",relativePath:"whats new/084.whats new in v2.12.0.md",key:"v-1c90bd91",path:"/pages/8ff017/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"决策路由",slug:"决策路由",normalizedTitle:"决策路由",charIndex:428},{level:2,title:"布尔组件",slug:"布尔组件",normalizedTitle:"布尔组件",charIndex:870},{level:2,title:"允许启动不检查节点存在性",slug:"允许启动不检查节点存在性",normalizedTitle:"允许启动不检查节点存在性",charIndex:1345},{level:2,title:"重写了python脚本引擎",slug:"重写了python脚本引擎",normalizedTitle:"重写了python脚本引擎",charIndex:1731},{level:2,title:"声明式组件的大一统",slug:"声明式组件的大一统",normalizedTitle:"声明式组件的大一统",charIndex:1914},{level:2,title:"上下文提供别名获取方式",slug:"上下文提供别名获取方式",normalizedTitle:"上下文提供别名获取方式",charIndex:3088},{level:2,title:"EL层面提供retry关键字",slug:"el层面提供retry关键字",normalizedTitle:"el层面提供retry关键字",charIndex:3554},{level:2,title:"新增验证/卸载脚本特性",slug:"新增验证-卸载脚本特性",normalizedTitle:"新增验证/卸载脚本特性",charIndex:3997},{level:2,title:"提供查看一个规则下的所有Node",slug:"提供查看一个规则下的所有node",normalizedTitle:"提供查看一个规则下的所有node",charIndex:4158},{level:2,title:"对某一个规则/脚本进行启停操作",slug:"对某一个规则-脚本进行启停操作",normalizedTitle:"对某一个规则/脚本进行启停操作",charIndex:4276}],headersStr:"前言 决策路由 布尔组件 允许启动不检查节点存在性 重写了python脚本引擎 声明式组件的大一统 上下文提供别名获取方式 EL层面提供retry关键字 新增验证/卸载脚本特性 提供查看一个规则下的所有Node 对某一个规则/脚本进行启停操作",content:'# 前言\n\n距离上次版本已经过去3个月了，这次我们带来了v2.12.0的超大版本更新。这个版本本来准备3月底发布的，中间跳过两次票，一切只为了版本的更加稳定。让各位开发者久等了。\n\n今年能明显感觉使用LF的小伙伴越来越多了，社区的人数也是节节攀升，每天的咨询不断。相信有不少人都在等这个版本，这个版本带来了19个issue的更新，其中包含着非常多的大特性更新，同时也有稳定性的更新和社区反映的一些bug修复。\n\n这三个月中我和LF团队的小伙伴都在为这个版本而努力，新版本官网也做了一些改变。变更了首页的动态效果，现在变得更加简洁了。现在的背景的动图更加贴合LF的组件这个意图，思路来自于七巧板。感谢森阳的倾心设计。\n\n同时v2.12.0更换了slogan，这个版本的slogan为：Make your code amazing。我们希望使用了LF能帮助开发者把他们的代码变得更加灵巧且令人惊叹。\n\n接下来我们来了解下v2.12.0有哪些重头戏吧！\n\n\n# 决策路由\n\n决策路由是v2.12.0的版本特性。LF带来了规则的全新用法，即执行时不指定具体规则ID，通过对决策路由EL的判断，来动态该执行哪些规则，并且匹配以及执行的过程中都是全并行态的。为此LF引入了<route>标签：\n\n<chain name="chain1">\n    <route>\n        AND(r1, r2, r3)\n    </route>\n    <body>\n        THEN(a, b, c);\n    </body>\n</chain>\n\n<chain name="chain2">\n    <route>\n        AND(OR(r4, r5), NOT(r3))\n    </route>\n    <body>\n        SWITCH(x).TO(d, e, f);\n    </body>\n</chain>\n\n\n在决策体中的EL只能用与或非表达式，组件只能用布尔表达式。具体如何使用大家请参考官网文档中的决策路由。\n\n\n# 布尔组件\n\nv2.12.0并不是一个兼容版本，最主要的原因就是新增了布尔组件的概念。\n\n我们在新版本中去除了NodeIfComponent，NodeWhileComponent，NodeBreakComponent 三个组件形态，统一变成了布尔组件NodeBooleanComponent。换句话说，布尔组件能用在IF，WHILE，BREAK三种表达式中。\n\n@LiteflowComponent("x")\npublic class ECmp extends NodeBooleanComponent {\n    @Override\n    public boolean processBoolean() throws Exception {\n        // do your biz\n        return true;\n    }\n}\n\n\n大家如果升级新版本，需要替换以上三种组件为布尔组件，替换下超类就可以了，这个过程不会耽误大家太多时间。为此我们准备了2.12.0升级指南，里面有非常详细的升级指南，这份指南可以在官网找到。\n\n\n# 允许启动不检查节点存在性\n\n社区里有很多小伙伴反映过现在强制性启动检查节点存在性让他们的协作开发受到了一些阻碍。为此LF新版提供了一个全局参数：\n\nparse-mode=PARSE_ONE_ON_FIRST_EXEC\n\n\n这个parse-mode取代了以前的parse-on-start 。这个参数有三种值：\n\n设置值                       含义\nPARSE_ALL_ON_START        启动时解析所有的规则，不配置默认就是这个值\nPARSE_ALL_ON_FIRST_EXEC   启动时不解析规则，但是第一次执行任意规则时，解析所有的\nPARSE_ONE_ON_FIRST_EXEC   启动时不解析规则，但是第一次执行相关规则时，只解析对应的规则\n\n关于这部分的详细解释，请看官网文档中的元数据管理 -> 启动不检查规则。\n\n\n# 重写了python脚本引擎\n\nLF提供了python脚本支持，但是一直以来这个解析引擎就是存在一些问题的，可能是社区里面的人用python引擎的人不多吧，所以这个问题一直没有被暴露出来。既然有人用，既然出现了问题。那么我们就有必要修复这个问题。\n\n为此，我们推翻了之前python解析引擎的实现方式，重新写了一版，解决了python脚本不能正常返回的情况。\n\n\n# 声明式组件的大一统\n\n其实这个特性早在2.11.4中就已经实现了，严格意义上不算新版本的特性。但是由于作了兼容，所以在2.11.X的文档上并没有加以说明。\n\n之前LF分类声明式和方法级别声明式，并且类声明式在声明上比方法级别声明式多了一个@LiteflowCmpDefine 标注，曾经有一个小伙伴表示这个有点多余，而且有点割裂感。\n\n所以LF在新的声明式中可以不要这个标注。基本上类级别声明式和方法级别声明式就统一了，你在一个类中定义一个组件，那就是类级别声明式，定义多个组件就是方法级别声明式。当然以前那种定义方式仍然有效。LF进行了兼容。\n\n这是类级别声明式：\n\n@LiteflowComponent("a")\npublic class ACmp{\n  \n\t@LiteflowMethod(LiteFlowMethodEnum.PROCESS, nodeType = NodeTypeEnum.COMMON)\n\tpublic void processAcmp(NodeComponent bindCmp) {\n\t\tSystem.out.println("ACmp executed!");\n\t}\n}\n\n\n这是方法级别声明式：\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    //普通组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeId = "a", nodeName = "A组件")\n    public void processA(NodeComponent bindCmp) {\n        ...\n    }\n\n    //SWITCH组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_SWITCH, nodeId = "b", nodeName = "B组件", nodeType = NodeTypeEnum.SWITCH)\n    public String processB(NodeComponent bindCmp) {\n        ...\n    }\n    \n    //布尔组件的定义\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS_BOOLEAN, nodeId = "c", nodeName = "C组件", nodeType = NodeTypeEnum.BOOLEAN)\n    public boolean processC(NodeComponent bindCmp) {\n        ...\n    }\n}\n\n\n\n# 上下文提供别名获取方式\n\n上下文的获取，相信大家都知道是通过this.getContextBean或者是this.getFirstContextBean来获取。但是这些获取方式都是通过class来进行获取的，如果传入两个相同class的上下文，就会有问题了。\n\nLF在新版本推出了根据别名获取的方式，想要定义一个上下文的别名，很简单，只需要通过@ContextBean注解进行标注：\n\n@ContextBean("anyName")\npublic class YourContext {\n    ...\n}\n\n\n获取的时候，LF提供了一个新的获取方式：\n\n@Component("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\tTestContext context = this.getContextBean("anyName");\n\t\t...\n\t}\n}\n\n\n这个特性能解决相同类作为上下文的场景。\n\n\n# EL层面提供retry关键字\n\nLF之前提供重试特性，但是重试特性是通过@LiteflowRetry标注来提供的。这个标注在类上，并没有办法在规则EL中得以体现。在新版本中，我们提供了基于EL层面的retry关键字，并且把重试这种特性作用于了任意表达式上，而不再是只作用于组件上。\n\n<chain id="chain1">\n    THEN(a, b.retry(3));\n</chain>\n\n<chain id="chain2">\n    THEN(a, b).retry(3);\n</chain>\n\n<chain id="chain3">\n    FOR(c).DO(a).retry(3);\n</chain>\n\n<chain id="chain4">\n    exp = SWITCH(x).to(m,n,p);\n    IF(f, exp.retry(3), b);\n</chain>\n\n\n关于retry关键字的用法详细请参考官网文档中的高级特性 -> EL中的重试。\n\n\n# 新增验证/卸载脚本特性\n\n在新版本中，我们提供了一个验证脚本和卸载脚本的api。具体用法如下：\n\nboolean isValid = ScriptValidator.validate(script);\n\n\n卸载脚本的用法如下：\n\nFlowBus.unloadScriptNode(String nodeId);\n\n\n\n# 提供查看一个规则下的所有Node\n\n新版中，我们还提供了一个api，用来查看chain下的所有node：\n\nList<Node> nodeList = FlowBus.getNodesByChainId("chain1");\n\n\n\n# 对某一个规则/脚本进行启停操作\n\n在数据中，其实LF早就支持了规则和脚本层面的enable，但是在其他存储插件中，我们之前并未支持。\n\n新版中我们也进行了支持，由于很多存储插件诸如zk，etcd，redis，apollo这种规则/脚本都是KV结构，我们在key的结构上作了一定的修改。\n\n规则key的完整形态为：规则ID[:是否启用]。\n\n脚本key的完整形态为：脚本组件ID:脚本类型[:脚本名称:脚本语言:是否启用]。\n\n其中方括号内的为可选值。\n\n具体这部分的详细解释请参考官方文档中的规则以及配置源这一章。',normalizedContent:'# 前言\n\n距离上次版本已经过去3个月了，这次我们带来了v2.12.0的超大版本更新。这个版本本来准备3月底发布的，中间跳过两次票，一切只为了版本的更加稳定。让各位开发者久等了。\n\n今年能明显感觉使用lf的小伙伴越来越多了，社区的人数也是节节攀升，每天的咨询不断。相信有不少人都在等这个版本，这个版本带来了19个issue的更新，其中包含着非常多的大特性更新，同时也有稳定性的更新和社区反映的一些bug修复。\n\n这三个月中我和lf团队的小伙伴都在为这个版本而努力，新版本官网也做了一些改变。变更了首页的动态效果，现在变得更加简洁了。现在的背景的动图更加贴合lf的组件这个意图，思路来自于七巧板。感谢森阳的倾心设计。\n\n同时v2.12.0更换了slogan，这个版本的slogan为：make your code amazing。我们希望使用了lf能帮助开发者把他们的代码变得更加灵巧且令人惊叹。\n\n接下来我们来了解下v2.12.0有哪些重头戏吧！\n\n\n# 决策路由\n\n决策路由是v2.12.0的版本特性。lf带来了规则的全新用法，即执行时不指定具体规则id，通过对决策路由el的判断，来动态该执行哪些规则，并且匹配以及执行的过程中都是全并行态的。为此lf引入了<route>标签：\n\n<chain name="chain1">\n    <route>\n        and(r1, r2, r3)\n    </route>\n    <body>\n        then(a, b, c);\n    </body>\n</chain>\n\n<chain name="chain2">\n    <route>\n        and(or(r4, r5), not(r3))\n    </route>\n    <body>\n        switch(x).to(d, e, f);\n    </body>\n</chain>\n\n\n在决策体中的el只能用与或非表达式，组件只能用布尔表达式。具体如何使用大家请参考官网文档中的决策路由。\n\n\n# 布尔组件\n\nv2.12.0并不是一个兼容版本，最主要的原因就是新增了布尔组件的概念。\n\n我们在新版本中去除了nodeifcomponent，nodewhilecomponent，nodebreakcomponent 三个组件形态，统一变成了布尔组件nodebooleancomponent。换句话说，布尔组件能用在if，while，break三种表达式中。\n\n@liteflowcomponent("x")\npublic class ecmp extends nodebooleancomponent {\n    @override\n    public boolean processboolean() throws exception {\n        // do your biz\n        return true;\n    }\n}\n\n\n大家如果升级新版本，需要替换以上三种组件为布尔组件，替换下超类就可以了，这个过程不会耽误大家太多时间。为此我们准备了2.12.0升级指南，里面有非常详细的升级指南，这份指南可以在官网找到。\n\n\n# 允许启动不检查节点存在性\n\n社区里有很多小伙伴反映过现在强制性启动检查节点存在性让他们的协作开发受到了一些阻碍。为此lf新版提供了一个全局参数：\n\nparse-mode=parse_one_on_first_exec\n\n\n这个parse-mode取代了以前的parse-on-start 。这个参数有三种值：\n\n设置值                       含义\nparse_all_on_start        启动时解析所有的规则，不配置默认就是这个值\nparse_all_on_first_exec   启动时不解析规则，但是第一次执行任意规则时，解析所有的\nparse_one_on_first_exec   启动时不解析规则，但是第一次执行相关规则时，只解析对应的规则\n\n关于这部分的详细解释，请看官网文档中的元数据管理 -> 启动不检查规则。\n\n\n# 重写了python脚本引擎\n\nlf提供了python脚本支持，但是一直以来这个解析引擎就是存在一些问题的，可能是社区里面的人用python引擎的人不多吧，所以这个问题一直没有被暴露出来。既然有人用，既然出现了问题。那么我们就有必要修复这个问题。\n\n为此，我们推翻了之前python解析引擎的实现方式，重新写了一版，解决了python脚本不能正常返回的情况。\n\n\n# 声明式组件的大一统\n\n其实这个特性早在2.11.4中就已经实现了，严格意义上不算新版本的特性。但是由于作了兼容，所以在2.11.x的文档上并没有加以说明。\n\n之前lf分类声明式和方法级别声明式，并且类声明式在声明上比方法级别声明式多了一个@liteflowcmpdefine 标注，曾经有一个小伙伴表示这个有点多余，而且有点割裂感。\n\n所以lf在新的声明式中可以不要这个标注。基本上类级别声明式和方法级别声明式就统一了，你在一个类中定义一个组件，那就是类级别声明式，定义多个组件就是方法级别声明式。当然以前那种定义方式仍然有效。lf进行了兼容。\n\n这是类级别声明式：\n\n@liteflowcomponent("a")\npublic class acmp{\n  \n\t@liteflowmethod(liteflowmethodenum.process, nodetype = nodetypeenum.common)\n\tpublic void processacmp(nodecomponent bindcmp) {\n\t\tsystem.out.println("acmp executed!");\n\t}\n}\n\n\n这是方法级别声明式：\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    //普通组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process, nodeid = "a", nodename = "a组件")\n    public void processa(nodecomponent bindcmp) {\n        ...\n    }\n\n    //switch组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_switch, nodeid = "b", nodename = "b组件", nodetype = nodetypeenum.switch)\n    public string processb(nodecomponent bindcmp) {\n        ...\n    }\n    \n    //布尔组件的定义\n    @liteflowmethod(value = liteflowmethodenum.process_boolean, nodeid = "c", nodename = "c组件", nodetype = nodetypeenum.boolean)\n    public boolean processc(nodecomponent bindcmp) {\n        ...\n    }\n}\n\n\n\n# 上下文提供别名获取方式\n\n上下文的获取，相信大家都知道是通过this.getcontextbean或者是this.getfirstcontextbean来获取。但是这些获取方式都是通过class来进行获取的，如果传入两个相同class的上下文，就会有问题了。\n\nlf在新版本推出了根据别名获取的方式，想要定义一个上下文的别名，很简单，只需要通过@contextbean注解进行标注：\n\n@contextbean("anyname")\npublic class yourcontext {\n    ...\n}\n\n\n获取的时候，lf提供了一个新的获取方式：\n\n@component("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\ttestcontext context = this.getcontextbean("anyname");\n\t\t...\n\t}\n}\n\n\n这个特性能解决相同类作为上下文的场景。\n\n\n# el层面提供retry关键字\n\nlf之前提供重试特性，但是重试特性是通过@liteflowretry标注来提供的。这个标注在类上，并没有办法在规则el中得以体现。在新版本中，我们提供了基于el层面的retry关键字，并且把重试这种特性作用于了任意表达式上，而不再是只作用于组件上。\n\n<chain id="chain1">\n    then(a, b.retry(3));\n</chain>\n\n<chain id="chain2">\n    then(a, b).retry(3);\n</chain>\n\n<chain id="chain3">\n    for(c).do(a).retry(3);\n</chain>\n\n<chain id="chain4">\n    exp = switch(x).to(m,n,p);\n    if(f, exp.retry(3), b);\n</chain>\n\n\n关于retry关键字的用法详细请参考官网文档中的高级特性 -> el中的重试。\n\n\n# 新增验证/卸载脚本特性\n\n在新版本中，我们提供了一个验证脚本和卸载脚本的api。具体用法如下：\n\nboolean isvalid = scriptvalidator.validate(script);\n\n\n卸载脚本的用法如下：\n\nflowbus.unloadscriptnode(string nodeid);\n\n\n\n# 提供查看一个规则下的所有node\n\n新版中，我们还提供了一个api，用来查看chain下的所有node：\n\nlist<node> nodelist = flowbus.getnodesbychainid("chain1");\n\n\n\n# 对某一个规则/脚本进行启停操作\n\n在数据中，其实lf早就支持了规则和脚本层面的enable，但是在其他存储插件中，我们之前并未支持。\n\n新版中我们也进行了支持，由于很多存储插件诸如zk，etcd，redis，apollo这种规则/脚本都是kv结构，我们在key的结构上作了一定的修改。\n\n规则key的完整形态为：规则id[:是否启用]。\n\n脚本key的完整形态为：脚本组件id:脚本类型[:脚本名称:脚本语言:是否启用]。\n\n其中方括号内的为可选值。\n\n具体这部分的详细解释请参考官方文档中的规则以及配置源这一章。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.12.1?",frontmatter:{title:"What's New In LiteFlow v2.12.1?",date:"2024-05-31T11:47:13.000Z",permalink:"/pages/8ff018/"},regularPath:"/whats%20new/083.whats%20new%20in%20v2.12.1.html",relativePath:"whats new/083.whats new in v2.12.1.md",key:"v-073a8d8d",path:"/pages/8ff018/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"组件注入型参数特性",slug:"组件注入型参数特性",normalizedTitle:"组件注入型参数特性",charIndex:168},{level:2,title:"支持Kotlin脚本语言",slug:"支持kotlin脚本语言",normalizedTitle:"支持kotlin脚本语言",charIndex:803},{level:2,title:"决策路由增加Namespace",slug:"决策路由增加namespace",normalizedTitle:"决策路由增加namespace",charIndex:1385},{level:2,title:"数据库支持决策路由特性",slug:"数据库支持决策路由特性",normalizedTitle:"数据库支持决策路由特性",charIndex:1799}],headersStr:"前言 组件注入型参数特性 支持Kotlin脚本语言 决策路由增加Namespace 数据库支持决策路由特性",content:'# 前言\n\nLF上一次大版本更新是在4月中旬，发布了v2.12.0。推出了版本特性决策路由。\n\n这一次，我们正式发布v2.12.1，推出2个大特性，2个大增强。\n\n希望LF能帮助到更多的开发者，无论你是使用它还是用来学习。我们拥有庞大的社区，近3年多不间断的迭代，已经让LF变成了一款功能完备，生产级别的优秀国产规则引擎框架。\n\n\n# 组件注入型参数特性\n\n现在组件的process方法上也可以接受参数了（这个功能仅限于声明式组件），这些个参数通过@LiteflowFact标注，能够自动注入上下文里的数据。\n\n@LiteflowComponent\npublic class CmpConfig {\n\n    @LiteflowMethod(value = LiteFlowMethodEnum.PROCESS, nodeType = NodeTypeEnum.COMMON, nodeId = "a")\n    public void processA(NodeComponent bindCmp,\n                        @LiteflowFact("user.name") String name,\n                        @LiteflowFact("data1") String data1) {\n        //do biz\n    }\n}\n\n\n这样做的好处是，如果你拥有很多组件，可以省去每个组件每次要去取到上下文然后再去取数据这一套繁琐的过程。\n\n并且@LiteflowFact是支持在上下文里进行自动搜索的，无论你有多少个上下文，利用这一特性，无需关心具体上下文，只需要定义你想获取的数据即可。并且这个特性是支持通过简单的点操作符去获取对象深层次的属性的。\n\n关于这个特性具体请参照官网文档数据上下文->上下文参数注入这一章。\n\n\n# 支持Kotlin脚本语言\n\n其实LF在脚本语言方面支持的种类绝对是规则引擎里最多的，没有之一。\n\n这次我们又支持了Kotlin语言，目前总共支持8种脚本语言，你现在可以利用Kotlin语法定义你的业务了。\n\n<node id="s1" type="script" language="kotlin">\n    import com.yomahub.liteflow.slot.DefaultContext\n\n    fun sum(a: Int, b: Int) = a + b\n    var a = 2\n    var b = 3\n    // 从 bindings 中获取上下文\n    val defaultContext = bindings["defaultContext"] as DefaultContext\n    defaultContext.setData("s1", sum(a, b))\n    println("Hello Kotlin!")\n</node>\n\n\n和其他脚本语言一样，kotlin也可以和java进行互通，甚至于可以引入spring的bean进行rpc调用也是可以的。这本质上是LF的底层机制比较完善，和用什么脚本语言无关的。\n\n关于这个特性具体请参照官网文档脚本组件->脚本语言种类->Kotlin脚本引擎。\n\n\n# 决策路由增加Namespace\n\nLF在v2.12.0中推出了决策路由特性，但是社区里很多使用了这一特性的同学反映决策路由是全局匹配，如果决策路由一多会影响其性能。虽然我实测下来并不会影响太多。但是决策路由是得有组的概念，在新版本中我们给其增加了一个命名空间的概念。可以在执行的时候指定其命名空间。\n\n<chain name="r_chain1" namespace="n1">\n  <route>\n    r1\n  </route>\n  <body>\n    THEN(b,a);\n  </body>\n</chain>\n\n<chain name="r_chain2" namespace="n1">\n  <route>\n    OR(r1,r2)\n  </route>\n  <body>\n    THEN(a,b);\n  </body>\n</chain>\n\n\n关于这个特性具体请参照官网文档决策路由->决策路由用法。\n\n\n# 数据库支持决策路由特性\n\n新版本在数据库插件中支持决策路由特性了。如果你配置相应的字段，并在数据库赋值，即可开启决策路由特性的使用。并且决策路由本身也是可以被热更新的哦。\n\n当然对以前的使用方式也是完全无缝兼容的。',normalizedContent:'# 前言\n\nlf上一次大版本更新是在4月中旬，发布了v2.12.0。推出了版本特性决策路由。\n\n这一次，我们正式发布v2.12.1，推出2个大特性，2个大增强。\n\n希望lf能帮助到更多的开发者，无论你是使用它还是用来学习。我们拥有庞大的社区，近3年多不间断的迭代，已经让lf变成了一款功能完备，生产级别的优秀国产规则引擎框架。\n\n\n# 组件注入型参数特性\n\n现在组件的process方法上也可以接受参数了（这个功能仅限于声明式组件），这些个参数通过@liteflowfact标注，能够自动注入上下文里的数据。\n\n@liteflowcomponent\npublic class cmpconfig {\n\n    @liteflowmethod(value = liteflowmethodenum.process, nodetype = nodetypeenum.common, nodeid = "a")\n    public void processa(nodecomponent bindcmp,\n                        @liteflowfact("user.name") string name,\n                        @liteflowfact("data1") string data1) {\n        //do biz\n    }\n}\n\n\n这样做的好处是，如果你拥有很多组件，可以省去每个组件每次要去取到上下文然后再去取数据这一套繁琐的过程。\n\n并且@liteflowfact是支持在上下文里进行自动搜索的，无论你有多少个上下文，利用这一特性，无需关心具体上下文，只需要定义你想获取的数据即可。并且这个特性是支持通过简单的点操作符去获取对象深层次的属性的。\n\n关于这个特性具体请参照官网文档数据上下文->上下文参数注入这一章。\n\n\n# 支持kotlin脚本语言\n\n其实lf在脚本语言方面支持的种类绝对是规则引擎里最多的，没有之一。\n\n这次我们又支持了kotlin语言，目前总共支持8种脚本语言，你现在可以利用kotlin语法定义你的业务了。\n\n<node id="s1" type="script" language="kotlin">\n    import com.yomahub.liteflow.slot.defaultcontext\n\n    fun sum(a: int, b: int) = a + b\n    var a = 2\n    var b = 3\n    // 从 bindings 中获取上下文\n    val defaultcontext = bindings["defaultcontext"] as defaultcontext\n    defaultcontext.setdata("s1", sum(a, b))\n    println("hello kotlin!")\n</node>\n\n\n和其他脚本语言一样，kotlin也可以和java进行互通，甚至于可以引入spring的bean进行rpc调用也是可以的。这本质上是lf的底层机制比较完善，和用什么脚本语言无关的。\n\n关于这个特性具体请参照官网文档脚本组件->脚本语言种类->kotlin脚本引擎。\n\n\n# 决策路由增加namespace\n\nlf在v2.12.0中推出了决策路由特性，但是社区里很多使用了这一特性的同学反映决策路由是全局匹配，如果决策路由一多会影响其性能。虽然我实测下来并不会影响太多。但是决策路由是得有组的概念，在新版本中我们给其增加了一个命名空间的概念。可以在执行的时候指定其命名空间。\n\n<chain name="r_chain1" namespace="n1">\n  <route>\n    r1\n  </route>\n  <body>\n    then(b,a);\n  </body>\n</chain>\n\n<chain name="r_chain2" namespace="n1">\n  <route>\n    or(r1,r2)\n  </route>\n  <body>\n    then(a,b);\n  </body>\n</chain>\n\n\n关于这个特性具体请参照官网文档决策路由->决策路由用法。\n\n\n# 数据库支持决策路由特性\n\n新版本在数据库插件中支持决策路由特性了。如果你配置相应的字段，并在数据库赋值，即可开启决策路由特性的使用。并且决策路由本身也是可以被热更新的哦。\n\n当然对以前的使用方式也是完全无缝兼容的。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.11.3?",frontmatter:{title:"What's New In LiteFlow v2.11.3?",date:"2023-10-13T23:48:57.000Z",permalink:"/pages/8ff015/"},regularPath:"/whats%20new/086.whats%20new%20in%20v2.11.3.html",relativePath:"whats new/086.whats new in v2.11.3.md",key:"v-99f89dde",path:"/pages/8ff015/",headers:[{level:2,title:"完整更新列表",slug:"完整更新列表",normalizedTitle:"完整更新列表",charIndex:453}],headersStr:"完整更新列表",content:"LiteFlow又发布新版本啦！v2.11.3这个版本主要是修复社区里提出的一些bug的版本。\n\nv2.11.3总计有1个增强，5个修复。\n\n对于SQL插件，可能是大家用的最多的LiteFlow插件，我们在新版本里多增加了一个enable的配置映射。使得你在数据库中可以启用和禁用某些流程和脚本。具体文档可以看SQL插件那章。\n\n同时我们修复了2.11.0，2.11.1两个新版本发布诸多特性中遗留下来的bug。\n\n建议在用2.11.X这个系列版本的都更新到这个版本。更新过程是平滑的。完全兼容。\n\n我们每一个版本都在快速进步，得益于LiteFlow目前拥有一个非常强大的开源团队和一份对开源事业追求的热情。我们认真开发每一个特性，仔细对待每一个测试用例，热心回答社区每一个问题，诚恳听取大家的每一个建议，尽力修复每一个bug。\n\n如果你想加入我们，请联系我。\n\n最近又到了一年一度的双11了，LiteFlow目前运行在上百家公司的核心业务中。希望大家都能双11买买买，服务稳定，顺利度过双11。\n\n\n# 完整更新列表\n\n增强 #I8BPM9 SQL插件增加enable字段的映射\n\nhttps://gitee.com/dromara/liteFlow/issues/I8BPM9\n\n修复 #I8BPMD 修复2.11.2中启动parse两次规则的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I8BPMD\n\n修复 #I8BPHS 修复Redis配置源哨兵模式的地址检查\n\nhttps://gitee.com/dromara/liteFlow/issues/I8BPHS\n\n修复 #I8AWHT LiteFlowChainELBuilder.validate()存在bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AWHT\n\n修复 #I8AR0L 组件定义了重试和回滚，回滚也会被重试\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AR0L\n\n修复 #I8AF1O 修复redis的订阅模式mode解析的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AF1O\n",normalizedContent:"liteflow又发布新版本啦！v2.11.3这个版本主要是修复社区里提出的一些bug的版本。\n\nv2.11.3总计有1个增强，5个修复。\n\n对于sql插件，可能是大家用的最多的liteflow插件，我们在新版本里多增加了一个enable的配置映射。使得你在数据库中可以启用和禁用某些流程和脚本。具体文档可以看sql插件那章。\n\n同时我们修复了2.11.0，2.11.1两个新版本发布诸多特性中遗留下来的bug。\n\n建议在用2.11.x这个系列版本的都更新到这个版本。更新过程是平滑的。完全兼容。\n\n我们每一个版本都在快速进步，得益于liteflow目前拥有一个非常强大的开源团队和一份对开源事业追求的热情。我们认真开发每一个特性，仔细对待每一个测试用例，热心回答社区每一个问题，诚恳听取大家的每一个建议，尽力修复每一个bug。\n\n如果你想加入我们，请联系我。\n\n最近又到了一年一度的双11了，liteflow目前运行在上百家公司的核心业务中。希望大家都能双11买买买，服务稳定，顺利度过双11。\n\n\n# 完整更新列表\n\n增强 #i8bpm9 sql插件增加enable字段的映射\n\nhttps://gitee.com/dromara/liteflow/issues/i8bpm9\n\n修复 #i8bpmd 修复2.11.2中启动parse两次规则的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i8bpmd\n\n修复 #i8bphs 修复redis配置源哨兵模式的地址检查\n\nhttps://gitee.com/dromara/liteflow/issues/i8bphs\n\n修复 #i8awht liteflowchainelbuilder.validate()存在bug\n\nhttps://gitee.com/dromara/liteflow/issues/i8awht\n\n修复 #i8ar0l 组件定义了重试和回滚，回滚也会被重试\n\nhttps://gitee.com/dromara/liteflow/issues/i8ar0l\n\n修复 #i8af1o 修复redis的订阅模式mode解析的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i8af1o\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.11.4?",frontmatter:{title:"What's New In LiteFlow v2.11.4?",date:"2024-01-15T09:48:57.000Z",permalink:"/pages/8ff016/"},regularPath:"/whats%20new/085.whats%20new%20in%20v2.11.4.html",relativePath:"whats new/085.whats new in v2.11.4.md",key:"v-c4a4fde6",path:"/pages/8ff016/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"重写了声明式的部分",slug:"重写了声明式的部分",normalizedTitle:"重写了声明式的部分",charIndex:165},{level:2,title:"解决了并行线程池的性能问题",slug:"解决了并行线程池的性能问题",normalizedTitle:"解决了并行线程池的性能问题",charIndex:449},{level:2,title:"并行线程池隔离BUG的修复",slug:"并行线程池隔离bug的修复",normalizedTitle:"并行线程池隔离bug的修复",charIndex:615},{level:2,title:"增加映射关键字SER和PAR",slug:"增加映射关键字ser和par",normalizedTitle:"增加映射关键字ser和par",charIndex:731},{level:2,title:"CmpStep中加入startTime和endTime",slug:"cmpstep中加入starttime和endtime",normalizedTitle:"cmpstep中加入starttime和endtime",charIndex:919},{level:2,title:"加入了快速解析的参数",slug:"加入了快速解析的参数",normalizedTitle:"加入了快速解析的参数",charIndex:1006},{level:2,title:"Nacos配置模式新增对阿里云MSE的鉴权方式",slug:"nacos配置模式新增对阿里云mse的鉴权方式",normalizedTitle:"nacos配置模式新增对阿里云mse的鉴权方式",charIndex:1520}],headersStr:"介绍 重写了声明式的部分 解决了并行线程池的性能问题 并行线程池隔离BUG的修复 增加映射关键字SER和PAR CmpStep中加入startTime和endTime 加入了快速解析的参数 Nacos配置模式新增对阿里云MSE的鉴权方式",content:'# 介绍\n\n2.11.4经历了BETA1,BETA2,BETA3版本之后，正式版发布!\n\n2.11.4总共有18个issue的更新，绝大多数为增强类issue。在这个版本中，我们优化了底层，着重优化了性能。也提供了一些小特性的升级。\n\n强烈建议还在用2.11.3版本的同学进行升级。\n\n接下来挑几个更新的增强来详细说下。\n\n\n# 重写了声明式的部分\n\n此增强issue困扰我半个多月，一直以来，LiteFlow声明式的底层代码比较混乱。不太好阅读，而且始终会在一些边缘场景莫名其妙的出问题。我一直想对其进行重写，这个版本，我阅读了大量了spring bean构造的底层代码，终于在底层实现了更加优化的改造。改造之后的声明式底层代码更加合理，结构层次也更加清晰，应该会摆脱一些边缘场景的问题。\n\n改造之后的使用方式同之前一致，用户并不会感知到。\n\n只是为了说明下，我们对底层代码是有追求的，并会为了追去极致的代码优雅而去不停努力。\n\n希望你们去使用LiteFlow，因为LF正在变得更强大。\n\n\n# 解决了并行线程池的性能问题\n\n源于社区的小伙伴在落地LF时发现，第一次请求会比后面的请求慢上一些。社区小伙伴也进行排查，发现LF是第一次请求时去初始化并行线程池，并报上了issue。\n\n这里确实是之前的版本没考虑周全，这一次，我们修复了这个问题。之后所有的线程池的初始化全都在启动时进行，包括用户自定义的线程池，也是如此。\n\n\n# 并行线程池隔离BUG的修复\n\n在2.11.1版本中曾经推出了并行线程池的隔离特性，旨在对一些并行分支非常多的进行线程池的隔离，以达到优化性能的目的，没想到这个特性一直存在BUG。这次我们也深度进行了排查，并修复了这个问题。\n\n\n# 增加映射关键字SER和PAR\n\n曾经有一个issue我还记得，说是LF中的THEN和WHEN是表示串行和并行的意思，但是关键字意义却不精准。\n\n虽然我承认THEN和WHEN表示串行和并行的确有些牵强，但是LF用户一直这么用，突然改变最主要的关键字也不太好。\n\n所以这次新推出了SER和PAR关键字，等同于THEN和WHEN。当然继续使用THEN和WHEN也是可以的。\n\n\n# CmpStep中加入startTime和endTime\n\n以前的CmpStep提供了耗时，但是没有组件的执行时间参数，这次提供了startTime和EndTime。\n\n\n# 加入了快速解析的参数\n\n这个增强，也是源于社区内的一位落地的小伙伴，他和我说项目内有几万的流程。启动耗时非常久。\n\n详细分析原因后，发现是LF的CopyOnWriteHashMap比较慢的缘故，当初用这个是为了平滑更新的因素。\n\n所以，2.11.4版本推出了liteflow.fast-load参数，当这个参数为true时。那么启动解析的速度回提升4到5倍。\n\n我也进行了测试，1w条流程(每个流程均有14个组件)耗时3秒，这个解析是线性的。所以在配置了这个参数后，解析速度还是可以接受的。\n\n但是我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。\n\n当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。\n\n\n# Nacos配置模式新增对阿里云MSE的鉴权方式\n\n新版本的LiteFlow在Nacos层面可以支持阿里云的MSE鉴权方式了。\n\n只需要这么配置就行了：\n\nliteflow.rule-source-ext-data={\\\n    "serverAddr":"127.0.0.1:8848",\\\n    "dataId":"demo_rule",\\\n    "group":"DEFAULT_GROUP",\\\n    "namespace":"your namespace id",\\\n    "accessKey":"xxxxxxxxxx",\\\n    "secretKey":"xxxxxxxxxx"\\\n}\n',normalizedContent:'# 介绍\n\n2.11.4经历了beta1,beta2,beta3版本之后，正式版发布!\n\n2.11.4总共有18个issue的更新，绝大多数为增强类issue。在这个版本中，我们优化了底层，着重优化了性能。也提供了一些小特性的升级。\n\n强烈建议还在用2.11.3版本的同学进行升级。\n\n接下来挑几个更新的增强来详细说下。\n\n\n# 重写了声明式的部分\n\n此增强issue困扰我半个多月，一直以来，liteflow声明式的底层代码比较混乱。不太好阅读，而且始终会在一些边缘场景莫名其妙的出问题。我一直想对其进行重写，这个版本，我阅读了大量了spring bean构造的底层代码，终于在底层实现了更加优化的改造。改造之后的声明式底层代码更加合理，结构层次也更加清晰，应该会摆脱一些边缘场景的问题。\n\n改造之后的使用方式同之前一致，用户并不会感知到。\n\n只是为了说明下，我们对底层代码是有追求的，并会为了追去极致的代码优雅而去不停努力。\n\n希望你们去使用liteflow，因为lf正在变得更强大。\n\n\n# 解决了并行线程池的性能问题\n\n源于社区的小伙伴在落地lf时发现，第一次请求会比后面的请求慢上一些。社区小伙伴也进行排查，发现lf是第一次请求时去初始化并行线程池，并报上了issue。\n\n这里确实是之前的版本没考虑周全，这一次，我们修复了这个问题。之后所有的线程池的初始化全都在启动时进行，包括用户自定义的线程池，也是如此。\n\n\n# 并行线程池隔离bug的修复\n\n在2.11.1版本中曾经推出了并行线程池的隔离特性，旨在对一些并行分支非常多的进行线程池的隔离，以达到优化性能的目的，没想到这个特性一直存在bug。这次我们也深度进行了排查，并修复了这个问题。\n\n\n# 增加映射关键字ser和par\n\n曾经有一个issue我还记得，说是lf中的then和when是表示串行和并行的意思，但是关键字意义却不精准。\n\n虽然我承认then和when表示串行和并行的确有些牵强，但是lf用户一直这么用，突然改变最主要的关键字也不太好。\n\n所以这次新推出了ser和par关键字，等同于then和when。当然继续使用then和when也是可以的。\n\n\n# cmpstep中加入starttime和endtime\n\n以前的cmpstep提供了耗时，但是没有组件的执行时间参数，这次提供了starttime和endtime。\n\n\n# 加入了快速解析的参数\n\n这个增强，也是源于社区内的一位落地的小伙伴，他和我说项目内有几万的流程。启动耗时非常久。\n\n详细分析原因后，发现是lf的copyonwritehashmap比较慢的缘故，当初用这个是为了平滑更新的因素。\n\n所以，2.11.4版本推出了liteflow.fast-load参数，当这个参数为true时。那么启动解析的速度回提升4到5倍。\n\n我也进行了测试，1w条流程(每个流程均有14个组件)耗时3秒，这个解析是线性的。所以在配置了这个参数后，解析速度还是可以接受的。\n\n但是我并不推荐所有的人把快速load模式打开，因为快速load模式牺牲了热更新时的平滑性。换句话说就是，在正常模式下，如果当你热更新时正好有正在执行的流程，那么正在执行的流程是会用老的链路的，只有下一次才会用最新的链路。如果你打开了快速load模式，那么在热更新时，正好在执行过程中的流程有可能前半部分是老的流程，而后半部分有可能读到新的流程。这样就造成了不一致了。\n\n当然这种场景是非常极端的场景，在普通的场景中，可能根本也不需要保持热更新时的平滑性。所以fast-load模式是有代价的。鱼和熊掌不可兼得。看项目要求了。\n\n\n# nacos配置模式新增对阿里云mse的鉴权方式\n\n新版本的liteflow在nacos层面可以支持阿里云的mse鉴权方式了。\n\n只需要这么配置就行了：\n\nliteflow.rule-source-ext-data={\\\n    "serveraddr":"127.0.0.1:8848",\\\n    "dataid":"demo_rule",\\\n    "group":"default_group",\\\n    "namespace":"your namespace id",\\\n    "accesskey":"xxxxxxxxxx",\\\n    "secretkey":"xxxxxxxxxx"\\\n}\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.11.2?",frontmatter:{title:"What's New In LiteFlow v2.11.2?",date:"2023-10-13T23:48:57.000Z",permalink:"/pages/8ff014/"},regularPath:"/whats%20new/087.whats%20new%20in%20v2.11.2.html",relativePath:"whats new/087.whats new in v2.11.2.md",key:"v-6f4c3dd6",path:"/pages/8ff014/",headers:[{level:2,title:"v2.11.2介绍",slug:"v2-11-2介绍",normalizedTitle:"v2.11.2介绍",charIndex:2},{level:2,title:"SQL插件支持轮询自动更新模式",slug:"sql插件支持轮询自动更新模式",normalizedTitle:"sql插件支持轮询自动更新模式",charIndex:191},{level:2,title:"WHEN增加must语法",slug:"when增加must语法",normalizedTitle:"when增加must语法",charIndex:555},{level:2,title:"推出EL表达式的动态组装API",slug:"推出el表达式的动态组装api",normalizedTitle:"推出el表达式的动态组装api",charIndex:975},{level:2,title:"链路继承",slug:"链路继承",normalizedTitle:"链路继承",charIndex:1484},{level:2,title:"组件降级",slug:"组件降级",normalizedTitle:"组件降级",charIndex:2033},{level:2,title:"支持绝对路径的模糊匹配",slug:"支持绝对路径的模糊匹配",normalizedTitle:"支持绝对路径的模糊匹配",charIndex:2268},{level:2,title:"WHEN线程池隔离",slug:"when线程池隔离",normalizedTitle:"when线程池隔离",charIndex:2522},{level:2,title:"测试用例增加至1500个",slug:"测试用例增加至1500个",normalizedTitle:"测试用例增加至1500个",charIndex:2738}],headersStr:"v2.11.2介绍 SQL插件支持轮询自动更新模式 WHEN增加must语法 推出EL表达式的动态组装API 链路继承 组件降级 支持绝对路径的模糊匹配 WHEN线程池隔离 测试用例增加至1500个",content:'# v2.11.2介绍\n\n上一个版本是9月1日发布的，经过了一个半月，LiteFlow新的v2.11.2和大家见面了。\n\n这个版本总共带来了7个大特性，3个增强，2个修复。总计12个issue的更新。\n\n其实这已经比上一个大版本已经有过之而无不及了。\n\n这一切归功于LiteFlow的团队小伙伴们，目前团队正式成员一共有11人，他们贡献了这个版本中的诸多的特性，感谢他们。\n\n\n# SQL插件支持轮询自动更新模式\n\nLiteFlow支持把规则和脚本存入任意的关系型数据库，由于关系型数据库不像注册中心会进行推送变更，所以一直以来，规则和脚本在数据库中发生改变，是需要开发者自己手动的去刷新的。并且需要每个应用实例都进行刷新。这对开发者来说，是繁琐了点。\n\n所以我们在v2.11.2中推出了数据库自动轮询更新模式。这一切只需要在你原来的配置中加入：\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    #是否开启SQL数据轮询自动刷新机制 默认不开启\n    pollingEnabled: true\n    ...\n\n\n默认LiteFlow会每1分钟去进行SHA值的对比，由此来判断是否需要更新。\n\n具体使用方式请参考规则文件->SQL数据库配置源。\n\n\n# WHEN增加must语法\n\n之前WHEN推出过any语法，意思是任意一个完成即继续，而忽略其他。但是在社区里有小伙伴碰到真实的场景，需要异步并行中对指定的节点先完成就忽略其他。\n\n为此这次新版本中推出了全新的must语法，提供在并行编排中更多的多样性。\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, c, d).must(b, c),\n        f\n    );\n</chain>\n\n\n也可以指定一个或多个表达式：\n\n<chain name="chain1">\n    THEN(\n        a,\n        WHEN(b, THEN(c, d).id("t1"), e).must(b, "t1"),\n        f\n    );\n</chain>\n\n\n具体使用方式请参考EL规则的写法->并行编排->指定任意节点先执行完则忽略其他。\n\n\n# 推出EL表达式的动态组装API\n\n之前LiteFlow推出过动态构建chain的API，类似于这样：\n\nLiteFlowChainELBuilder.createChain().setChainName("chain1").setEL(\n  "THEN(a, b, WHEN(c, d))"\n).build();\n\n\n但是EL表达式还是需要你自己以字符串的方式填入，这并不能算真正意义上动态。\n\n这次我们推出了全新的EL表达式的动态组装API，对于上面的EL，你可以如下进行动态构建：\n\nThenELWrapper el = ELBus.then(\n\t"a","b",ELBus.when("c", "d")\n);\nLiteFlowChainELBuilder.createChain().setChainName("chain1").setEL(el.toEL()).build();\n\n\n值得一说的是，用java语言构建EL表达式，几乎和EL的写法完全一致。如果你已经熟悉了LiteFlow的规则语法，应该是零成本上手的。\n\n目前API支持了所有的EL语法。具体使用方式请参考用代码构造规则->构造EL。\n\n\n# 链路继承\n\nLiteFlow每一个chain独立，之前的版本不存在继承关系。但在这个新版本中，我们推出了链路继承这个特性。\n\n如同类的继承一样，链路可以继承，那么对于拥有复杂链路的业务系统，可以对链路进行抽象，得到一个非常优雅的表现方式。\n\n我们定义的继承也非常容易看懂：\n\n<chain id="base">\n\tTHEN(a, b, {0}, {1});\n</chain>\n\n<chain id="implA" extends="base">\n\t{0}=IF(c, d, e);\n\t{1}=SWITCH(f).to(j,k);\n</chain>\n\n\n还可以多级继承：\n\n<chain id="base">\n\tTHEN(a, b, {0}, {1});\n</chain>\n\n<chain id="base2" extends="base">\n  {0}=THEN(a,b,{3});\n  {1}=SWITCH(f).to({4},k);\n</chain>\n\n<chain id="implB" extends="base2">\n  {3}=THEN(a,b);\n  {4}=j;\n</chain>\n\n\n如果你有此方面的场景，不妨尝试下继承特性。\n\n具体使用方式请参考高级特性->链路继承。\n\n\n# 组件降级\n\nLiteFlow之前的替补组件全面升级成组件降级特性。\n\n组件降级允许你定义各个类型组件的降级组件。新版本提供了@FallbackCmp注解用于定义。\n\n在EL规则中，如果你用node关键字包裹组件，便开启了降级特性：\n\n<chain id="chain1">\n\tTHEN(node("a"), b, c);\n</chain>\n\n\n当a组件不存在时，便会走到用@FallbackCmp注解定义的降级组件中去。\n\n具体用法请参考高级特定->组件降级。\n\n\n# 支持绝对路径的模糊匹配\n\nLiteFlow对项目内的规则文件的模糊匹配是早就支持的。但是之前的版本一直不支持绝对路径的模糊匹配。\n\n这个版本，我们予以了支持。\n\n你可以使用*或者**来模糊匹配多层级的任意名字的文件：\n\nliteflow.rule-source=/data/lf/**/*Rule.xml\n\n\n如果开启了文件监听功能，还能对模糊路径匹配到的每一个文件进行监听。当文件改变的时候，实现自动刷新功能。是不是很酷。\n\n具体用法请参考规则文件->本地规则文件配置和高级功能->本地文件监听。\n\n\n# WHEN线程池隔离\n\nLiteFlow在v2.11.2版本中新推出了一个配置，在执行WHEN中的并行组件时，每一个when的线程池隔离，在运行复杂的嵌套WHEN链路时，这个特性非常有用。可以有效提高运行速度并且避免死锁问题。\n\n你只需要开启这个配置即可，默认是关闭的。\n\nliteflow.when-thread-pool-isolate=true\n\n\n具体用法请参考EL规则的写法->并行编排->开启WHEN线程池隔离。\n\n\n# 测试用例增加至1500个\n\n我非常注重开源项目的测试用例，这是一个项目质量的保证。这次新版本LiteFlow把测试用例增加到了1500个！\n\n每一个特性的提交，我们都会保证这么多的测试用例全部通过。这也是我们发布LiteFlow每一个版本的底气。\n\n并且，LiteFlow的测试用例覆盖面非常广，行覆盖率达到了90%，我们始终遵循着测试用例大于一切的标准。',normalizedContent:'# v2.11.2介绍\n\n上一个版本是9月1日发布的，经过了一个半月，liteflow新的v2.11.2和大家见面了。\n\n这个版本总共带来了7个大特性，3个增强，2个修复。总计12个issue的更新。\n\n其实这已经比上一个大版本已经有过之而无不及了。\n\n这一切归功于liteflow的团队小伙伴们，目前团队正式成员一共有11人，他们贡献了这个版本中的诸多的特性，感谢他们。\n\n\n# sql插件支持轮询自动更新模式\n\nliteflow支持把规则和脚本存入任意的关系型数据库，由于关系型数据库不像注册中心会进行推送变更，所以一直以来，规则和脚本在数据库中发生改变，是需要开发者自己手动的去刷新的。并且需要每个应用实例都进行刷新。这对开发者来说，是繁琐了点。\n\n所以我们在v2.11.2中推出了数据库自动轮询更新模式。这一切只需要在你原来的配置中加入：\n\nliteflow:\n  rule-source-ext-data-map:\n    ...\n    #是否开启sql数据轮询自动刷新机制 默认不开启\n    pollingenabled: true\n    ...\n\n\n默认liteflow会每1分钟去进行sha值的对比，由此来判断是否需要更新。\n\n具体使用方式请参考规则文件->sql数据库配置源。\n\n\n# when增加must语法\n\n之前when推出过any语法，意思是任意一个完成即继续，而忽略其他。但是在社区里有小伙伴碰到真实的场景，需要异步并行中对指定的节点先完成就忽略其他。\n\n为此这次新版本中推出了全新的must语法，提供在并行编排中更多的多样性。\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, c, d).must(b, c),\n        f\n    );\n</chain>\n\n\n也可以指定一个或多个表达式：\n\n<chain name="chain1">\n    then(\n        a,\n        when(b, then(c, d).id("t1"), e).must(b, "t1"),\n        f\n    );\n</chain>\n\n\n具体使用方式请参考el规则的写法->并行编排->指定任意节点先执行完则忽略其他。\n\n\n# 推出el表达式的动态组装api\n\n之前liteflow推出过动态构建chain的api，类似于这样：\n\nliteflowchainelbuilder.createchain().setchainname("chain1").setel(\n  "then(a, b, when(c, d))"\n).build();\n\n\n但是el表达式还是需要你自己以字符串的方式填入，这并不能算真正意义上动态。\n\n这次我们推出了全新的el表达式的动态组装api，对于上面的el，你可以如下进行动态构建：\n\nthenelwrapper el = elbus.then(\n\t"a","b",elbus.when("c", "d")\n);\nliteflowchainelbuilder.createchain().setchainname("chain1").setel(el.toel()).build();\n\n\n值得一说的是，用java语言构建el表达式，几乎和el的写法完全一致。如果你已经熟悉了liteflow的规则语法，应该是零成本上手的。\n\n目前api支持了所有的el语法。具体使用方式请参考用代码构造规则->构造el。\n\n\n# 链路继承\n\nliteflow每一个chain独立，之前的版本不存在继承关系。但在这个新版本中，我们推出了链路继承这个特性。\n\n如同类的继承一样，链路可以继承，那么对于拥有复杂链路的业务系统，可以对链路进行抽象，得到一个非常优雅的表现方式。\n\n我们定义的继承也非常容易看懂：\n\n<chain id="base">\n\tthen(a, b, {0}, {1});\n</chain>\n\n<chain id="impla" extends="base">\n\t{0}=if(c, d, e);\n\t{1}=switch(f).to(j,k);\n</chain>\n\n\n还可以多级继承：\n\n<chain id="base">\n\tthen(a, b, {0}, {1});\n</chain>\n\n<chain id="base2" extends="base">\n  {0}=then(a,b,{3});\n  {1}=switch(f).to({4},k);\n</chain>\n\n<chain id="implb" extends="base2">\n  {3}=then(a,b);\n  {4}=j;\n</chain>\n\n\n如果你有此方面的场景，不妨尝试下继承特性。\n\n具体使用方式请参考高级特性->链路继承。\n\n\n# 组件降级\n\nliteflow之前的替补组件全面升级成组件降级特性。\n\n组件降级允许你定义各个类型组件的降级组件。新版本提供了@fallbackcmp注解用于定义。\n\n在el规则中，如果你用node关键字包裹组件，便开启了降级特性：\n\n<chain id="chain1">\n\tthen(node("a"), b, c);\n</chain>\n\n\n当a组件不存在时，便会走到用@fallbackcmp注解定义的降级组件中去。\n\n具体用法请参考高级特定->组件降级。\n\n\n# 支持绝对路径的模糊匹配\n\nliteflow对项目内的规则文件的模糊匹配是早就支持的。但是之前的版本一直不支持绝对路径的模糊匹配。\n\n这个版本，我们予以了支持。\n\n你可以使用*或者**来模糊匹配多层级的任意名字的文件：\n\nliteflow.rule-source=/data/lf/**/*rule.xml\n\n\n如果开启了文件监听功能，还能对模糊路径匹配到的每一个文件进行监听。当文件改变的时候，实现自动刷新功能。是不是很酷。\n\n具体用法请参考规则文件->本地规则文件配置和高级功能->本地文件监听。\n\n\n# when线程池隔离\n\nliteflow在v2.11.2版本中新推出了一个配置，在执行when中的并行组件时，每一个when的线程池隔离，在运行复杂的嵌套when链路时，这个特性非常有用。可以有效提高运行速度并且避免死锁问题。\n\n你只需要开启这个配置即可，默认是关闭的。\n\nliteflow.when-thread-pool-isolate=true\n\n\n具体用法请参考el规则的写法->并行编排->开启when线程池隔离。\n\n\n# 测试用例增加至1500个\n\n我非常注重开源项目的测试用例，这是一个项目质量的保证。这次新版本liteflow把测试用例增加到了1500个！\n\n每一个特性的提交，我们都会保证这么多的测试用例全部通过。这也是我们发布liteflow每一个版本的底气。\n\n并且，liteflow的测试用例覆盖面非常广，行覆盖率达到了90%，我们始终遵循着测试用例大于一切的标准。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.11.0?",frontmatter:{title:"What's New In LiteFlow v2.11.0?",date:"2023-08-31T23:48:57.000Z",permalink:"/pages/8ff013/"},regularPath:"/whats%20new/088.whats%20new%20in%20v2.11.0.html",relativePath:"whats new/088.whats new in v2.11.0.md",key:"v-a3bac3ca",path:"/pages/8ff013/",headers:[{level:2,title:"v2.11.0介绍",slug:"v2-11-0介绍",normalizedTitle:"v2.11.0介绍",charIndex:2},{level:2,title:"新的项目LOGO",slug:"新的项目logo",normalizedTitle:"新的项目logo",charIndex:124},{level:2,title:"启用全新域名",slug:"启用全新域名",normalizedTitle:"启用全新域名",charIndex:343},{level:2,title:"新的Slogan",slug:"新的slogan",normalizedTitle:"新的slogan",charIndex:436},{level:2,title:"特性1：能够用Java原生语言来写脚本",slug:"特性1-能够用java原生语言来写脚本",normalizedTitle:"特性1：能够用java原生语言来写脚本",charIndex:645},{level:2,title:"特性2：支持了Redis中存储规则和脚本",slug:"特性2-支持了redis中存储规则和脚本",normalizedTitle:"特性2：支持了redis中存储规则和脚本",charIndex:954},{level:2,title:"特性3：全方位的超时控制",slug:"特性3-全方位的超时控制",normalizedTitle:"特性3：全方位的超时控制",charIndex:1268},{level:2,title:"特性4：异步循环模式",slug:"特性4-异步循环模式",normalizedTitle:"特性4：异步循环模式",charIndex:1804},{level:2,title:"特性5：组件回滚",slug:"特性5-组件回滚",normalizedTitle:"特性5：组件回滚",charIndex:2181},{level:2,title:"测试用例增加到1200个左右",slug:"测试用例增加到1200个左右",normalizedTitle:"测试用例增加到1200个左右",charIndex:2585}],headersStr:"v2.11.0介绍 新的项目LOGO 启用全新域名 新的Slogan 特性1：能够用Java原生语言来写脚本 特性2：支持了Redis中存储规则和脚本 特性3：全方位的超时控制 特性4：异步循环模式 特性5：组件回滚 测试用例增加到1200个左右",content:'# v2.11.0介绍\n\nv2.11.0是一个大版本，LiteFlow提供了5个大的新特性，以及3个加强，2个bug修复。\n\nLiteFlow同时更换了新的项目Logo和启动了新的域名。\n\nLF在这个版本改头换面，以全新的姿态继续向前冲~\n\n\n# 新的项目LOGO\n\n感谢设计师Evan Lou的帮助，为LiteFlow带来了全新的Logo。🤙\n\n新Logo寓意：\n\n1.整体是一片树叶形状，树叶既代表了轻量，也象征着LiteFlow会一直像树叶那样进行光合作用，释放氧气。\n\n2.叶子里的叶脉是一个L和F的交错变体，象征着LiteFlow的缩写。\n\n3.叶脉简单且延展开，象征流程的分叉。\n\n4.整个叶子被叶脉分隔成4部分，象征着编排，4个不同的部分组成了一片完美的叶子。\n\n\n# 启用全新域名\n\nLiteFlow在v2.11.0启用了全新的域名：https://liteflow.cc。简单且好记。\n\n同时老的域名也是可以访问的，会自动重定向到新的域名上。\n\n\n# 新的Slogan\n\nLiteFlow会从2.11.0这个版本开始，为每一个版本都设计一句Slogan。\n\n这个版本的Slogan为：Keep on the light side.。中文寓意为：逐光而行。\n\n这句Slogan一语双关，其中light谐音lite，表示我们会一直坚持LiteFlow的开源迭代。\n\n逐光而行，我希望我自己可以践行，人总要需要一道光来照亮生命，我们疲惫且努力的追逐那道光，远离黑暗。\n\n\n# 特性1：能够用Java原生语言来写脚本\n\n丰富的脚本语言支持是LiteFlow的一大特色，脚本语言轻巧，能否被即时刷新的特点受到了很多开发者的喜爱。\n\nLiteFlow之前支持了挺多的脚本语言，分别是：Groovy，Javascript，Python，QLExpress，Lua，Aviator。\n\n但是不同的语言有不同的语法结构，很多不熟悉的这些语言写法的同学可能还要花点时间去学习该如何写。\n\n这次版本LiteFlow支持了原生Java脚本语言的写法，这意味着你可以无学习成本的直接在脚本里用Java来书写逻辑。\n\n关于Java脚本语言的详细文档请参照官网中脚本组件->脚本语言种类->Java脚本引擎。\n\n\n# 特性2：支持了Redis中存储规则和脚本\n\nLiteFlow支持丰富的存储插件，所有的关系型数据库以及各种注册中心。\n\n这次我们新增了Redis插件，用Redis来存储规则以及脚本。Redis在各大企业中用的比较多。为了保证使用的多样性。我们甚至开发了2种模式：轮询拉取模式和订阅模式，各有特点。\n\n其中轮询拉取模式，我们做了非常多的优化，我们对每一个脚本和规则生成了指纹，只比对指纹，而非拉取整个数据，消耗极小。\n\n订阅模式非常实时，但是需要你用Redission框架来操作Redis，算有一定的使用限制。具体选用哪种模式，交由开发者来决定。\n\n关于redis插件的详细文档请参照官网中规则文件->Redis配置源。\n\n\n# 特性3：全方位的超时控制\n\n在以前的LiteFlow版本中，超时控制只能针对WHEN表达式，且是全局配置。\n\n在新版本中，我们支持了全方位的超时控制体系，一个maxWaitSeconds关键字可对任意的组件、表达式、流程进行超时控制。\n\n对任意表达式的控制：\n\n<chain name="chain1">\n    THEN(a,b).maxWaitSeconds(5);\n</chain>\n<chain name="chain1">\n    FOR(2).DO(a).maxWaitSeconds(3);\n</chain>\n\n\n对组件的超时控制\n\n<chain name="chain1">\n    WHEN(\n        a.maxWaitSeconds(2),\n        b.maxWaitSeconds(3)\n    );\n</chain>\n\n\n对子流程的超时控制\n\n<chain name="testChain">\n    THEN(b)\n</chain>\n<chain name="chain">\n    testChain.maxWaitSeconds(3);\n</chain>\n\n\n关于这块的详细文档请参考官网文档中的高级特性->超时控制\n\n\n# 特性4：异步循环模式\n\n经常群里的小伙伴会反映：LiteFLow的循环体系只支持同步，如果能支持异步就好了。\n\n这个版本我们支持了！对三种循环模式都予以了异步支持。\n\n<chain name="chain1">\n   FOR(2).parallel(true).DO(THEN(a,b,c));\n</chain>\n<chain name="chain2">\n    WHILE(x).parallel(true).DO(THEN(a,b,c));\n</chain>\n<chain name="chain3">\n    ITERATOR(x).parallel(true).DO(THEN(a,b,c));\n</chain>\n\n\n一个parallel关键字搞定。是不是很简单？\n\n关于异步循环的详细文档请参考官网文档中的高级特性->异步循环模式。\n\n\n# 特性5：组件回滚\n\n这也就是所谓的逆操作。LiteFlow从这个版本开始有逆向操作了！LiteFlow会自动帮你记录执行的顺序，当某个组件抛出异常时，会自动按实际执行的顺序进行逆操作。\n\n这一切的前提只需要你在组件中实现rollback方法。\n\n在自动执行完回滚操作后，LiteFlow的日志还会把回滚的步骤都打出来，让你一目了然。\n\n@LiteflowComponent("a")\npublic class ACmp extends NodeComponent {\n\n\t@Override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n\n\t@Override\n\tpublic void rollback() throws Exception {\n\t\t//do your biz\n\t}\n}\n\n\n关于组件回滚的详细文档请参考官网文档中的高级特性->组件回滚。\n\n\n# 测试用例增加到1200个左右\n\n我相信，一个开源框架的上限是看这个框架所解决的问题和这个框架提供的特性和设计。而下限则是这个开源框架的测试用例的完备性。\n\n我们不仅要开疆拓土，提供新特性和新的探索，也要守疆土，确保整体稳定性和质量。\n\n我们这次将测试用例数量提高到近1200个，几乎覆盖到了所有的地方。\n\n大家可以放心用。我们也有完备的社区和组织，社区目前拥有3500人左右。',normalizedContent:'# v2.11.0介绍\n\nv2.11.0是一个大版本，liteflow提供了5个大的新特性，以及3个加强，2个bug修复。\n\nliteflow同时更换了新的项目logo和启动了新的域名。\n\nlf在这个版本改头换面，以全新的姿态继续向前冲~\n\n\n# 新的项目logo\n\n感谢设计师evan lou的帮助，为liteflow带来了全新的logo。🤙\n\n新logo寓意：\n\n1.整体是一片树叶形状，树叶既代表了轻量，也象征着liteflow会一直像树叶那样进行光合作用，释放氧气。\n\n2.叶子里的叶脉是一个l和f的交错变体，象征着liteflow的缩写。\n\n3.叶脉简单且延展开，象征流程的分叉。\n\n4.整个叶子被叶脉分隔成4部分，象征着编排，4个不同的部分组成了一片完美的叶子。\n\n\n# 启用全新域名\n\nliteflow在v2.11.0启用了全新的域名：https://liteflow.cc。简单且好记。\n\n同时老的域名也是可以访问的，会自动重定向到新的域名上。\n\n\n# 新的slogan\n\nliteflow会从2.11.0这个版本开始，为每一个版本都设计一句slogan。\n\n这个版本的slogan为：keep on the light side.。中文寓意为：逐光而行。\n\n这句slogan一语双关，其中light谐音lite，表示我们会一直坚持liteflow的开源迭代。\n\n逐光而行，我希望我自己可以践行，人总要需要一道光来照亮生命，我们疲惫且努力的追逐那道光，远离黑暗。\n\n\n# 特性1：能够用java原生语言来写脚本\n\n丰富的脚本语言支持是liteflow的一大特色，脚本语言轻巧，能否被即时刷新的特点受到了很多开发者的喜爱。\n\nliteflow之前支持了挺多的脚本语言，分别是：groovy，javascript，python，qlexpress，lua，aviator。\n\n但是不同的语言有不同的语法结构，很多不熟悉的这些语言写法的同学可能还要花点时间去学习该如何写。\n\n这次版本liteflow支持了原生java脚本语言的写法，这意味着你可以无学习成本的直接在脚本里用java来书写逻辑。\n\n关于java脚本语言的详细文档请参照官网中脚本组件->脚本语言种类->java脚本引擎。\n\n\n# 特性2：支持了redis中存储规则和脚本\n\nliteflow支持丰富的存储插件，所有的关系型数据库以及各种注册中心。\n\n这次我们新增了redis插件，用redis来存储规则以及脚本。redis在各大企业中用的比较多。为了保证使用的多样性。我们甚至开发了2种模式：轮询拉取模式和订阅模式，各有特点。\n\n其中轮询拉取模式，我们做了非常多的优化，我们对每一个脚本和规则生成了指纹，只比对指纹，而非拉取整个数据，消耗极小。\n\n订阅模式非常实时，但是需要你用redission框架来操作redis，算有一定的使用限制。具体选用哪种模式，交由开发者来决定。\n\n关于redis插件的详细文档请参照官网中规则文件->redis配置源。\n\n\n# 特性3：全方位的超时控制\n\n在以前的liteflow版本中，超时控制只能针对when表达式，且是全局配置。\n\n在新版本中，我们支持了全方位的超时控制体系，一个maxwaitseconds关键字可对任意的组件、表达式、流程进行超时控制。\n\n对任意表达式的控制：\n\n<chain name="chain1">\n    then(a,b).maxwaitseconds(5);\n</chain>\n<chain name="chain1">\n    for(2).do(a).maxwaitseconds(3);\n</chain>\n\n\n对组件的超时控制\n\n<chain name="chain1">\n    when(\n        a.maxwaitseconds(2),\n        b.maxwaitseconds(3)\n    );\n</chain>\n\n\n对子流程的超时控制\n\n<chain name="testchain">\n    then(b)\n</chain>\n<chain name="chain">\n    testchain.maxwaitseconds(3);\n</chain>\n\n\n关于这块的详细文档请参考官网文档中的高级特性->超时控制\n\n\n# 特性4：异步循环模式\n\n经常群里的小伙伴会反映：liteflow的循环体系只支持同步，如果能支持异步就好了。\n\n这个版本我们支持了！对三种循环模式都予以了异步支持。\n\n<chain name="chain1">\n   for(2).parallel(true).do(then(a,b,c));\n</chain>\n<chain name="chain2">\n    while(x).parallel(true).do(then(a,b,c));\n</chain>\n<chain name="chain3">\n    iterator(x).parallel(true).do(then(a,b,c));\n</chain>\n\n\n一个parallel关键字搞定。是不是很简单？\n\n关于异步循环的详细文档请参考官网文档中的高级特性->异步循环模式。\n\n\n# 特性5：组件回滚\n\n这也就是所谓的逆操作。liteflow从这个版本开始有逆向操作了！liteflow会自动帮你记录执行的顺序，当某个组件抛出异常时，会自动按实际执行的顺序进行逆操作。\n\n这一切的前提只需要你在组件中实现rollback方法。\n\n在自动执行完回滚操作后，liteflow的日志还会把回滚的步骤都打出来，让你一目了然。\n\n@liteflowcomponent("a")\npublic class acmp extends nodecomponent {\n\n\t@override\n\tpublic void process() {\n\t\t//do your biz\n\t}\n\n\t@override\n\tpublic void rollback() throws exception {\n\t\t//do your biz\n\t}\n}\n\n\n关于组件回滚的详细文档请参考官网文档中的高级特性->组件回滚。\n\n\n# 测试用例增加到1200个左右\n\n我相信，一个开源框架的上限是看这个框架所解决的问题和这个框架提供的特性和设计。而下限则是这个开源框架的测试用例的完备性。\n\n我们不仅要开疆拓土，提供新特性和新的探索，也要守疆土，确保整体稳定性和质量。\n\n我们这次将测试用例数量提高到近1200个，几乎覆盖到了所有的地方。\n\n大家可以放心用。我们也有完备的社区和组织，社区目前拥有3500人左右。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.10.5?",frontmatter:{title:"What's New In LiteFlow v2.10.5?",date:"2023-03-22T23:48:57.000Z",permalink:"/pages/8ff011/"},regularPath:"/whats%20new/090.whats%20new%20in%20v2.10.5.html",relativePath:"whats new/090.whats new in v2.10.5.md",key:"v-4a5cd6c1",path:"/pages/8ff011/",headers:[{level:2,title:"v2.10.5介绍",slug:"v2-10-5介绍",normalizedTitle:"v2.10.5介绍",charIndex:2},{level:2,title:"日志改造",slug:"日志改造",normalizedTitle:"日志改造",charIndex:80},{level:2,title:"循环场景中的一些bug的修复",slug:"循环场景中的一些bug的修复",normalizedTitle:"循环场景中的一些bug的修复",charIndex:613}],headersStr:"v2.10.5介绍 日志改造 循环场景中的一些bug的修复",content:'# v2.10.5介绍\n\nv2.10.5版本主要就是对日志从底层进行架构改造。增加了支持传入自定义的请求ID。\n\n以及修复了一些循环表达式中的Bug。\n\n\n# 日志改造\n\n我们对日志进行了大幅度的改造，支持了自定义的RequestId传入，这个特性可以很方便的和你自己系统的traceId进行集成。\n\n你可以调用如下方法来传入一个已有的requestId：\n\nLiteflowResponse response = flowExecutor.execute2RespWithRid("chain1", arg, "T001234", YourContext.class);\n\n\n那么，这个链路中所有的框架日志都会带有[T001234]这个传入的ID前缀了。\n\n另外新版本的LiteFlow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求ID前缀。\n\nprivate final LFLog logger = LFLoggerManager.getLogger(FlowExecutor.class);\n\n\n其中LFLog这个类是继承自slf4j的Logger类的，所以它的使用方式和Logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求ID，那么对于定位问题来说，会很方便。推荐大家使用此特性。\n\n\n# 循环场景中的一些bug的修复\n\n看来大家对循环特性使用的还是比较多的。在使用的过程中，社区内也给出了很多反馈意见。\n\n可能是之前对循环定义的测试用例有些少了，所以对于一些场景没覆盖到。这次修复了社区内提供的2个Bug。\n\n同时也补全了测试用例。',normalizedContent:'# v2.10.5介绍\n\nv2.10.5版本主要就是对日志从底层进行架构改造。增加了支持传入自定义的请求id。\n\n以及修复了一些循环表达式中的bug。\n\n\n# 日志改造\n\n我们对日志进行了大幅度的改造，支持了自定义的requestid传入，这个特性可以很方便的和你自己系统的traceid进行集成。\n\n你可以调用如下方法来传入一个已有的requestid：\n\nliteflowresponse response = flowexecutor.execute2respwithrid("chain1", arg, "t001234", yourcontext.class);\n\n\n那么，这个链路中所有的框架日志都会带有[t001234]这个传入的id前缀了。\n\n另外新版本的liteflow还提供了一个日志包装类。只要你在组件中把slf4j的日志声明换成如下形式，那么你在组件中自己打出的日志也会带有请求id前缀。\n\nprivate final lflog logger = lfloggermanager.getlogger(flowexecutor.class);\n\n\n其中lflog这个类是继承自slf4j的logger类的，所以它的使用方式和logger是完全一致的。\n\n你只需要把定义换一下就ok了。\n\n如果在一个链路中相同请求的日志都拥有同一个请求id，那么对于定位问题来说，会很方便。推荐大家使用此特性。\n\n\n# 循环场景中的一些bug的修复\n\n看来大家对循环特性使用的还是比较多的。在使用的过程中，社区内也给出了很多反馈意见。\n\n可能是之前对循环定义的测试用例有些少了，所以对于一些场景没覆盖到。这次修复了社区内提供的2个bug。\n\n同时也补全了测试用例。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.10.6?",frontmatter:{title:"What's New In LiteFlow v2.10.6?",date:"2023-03-22T23:48:57.000Z",permalink:"/pages/8ff012/"},regularPath:"/whats%20new/089.whats%20new%20in%20v2.10.6.html",relativePath:"whats new/089.whats new in v2.10.6.md",key:"v-e34b70da",path:"/pages/8ff012/",headers:[{level:2,title:"v2.10.6介绍",slug:"v2-10-6介绍",normalizedTitle:"v2.10.6介绍",charIndex:2},{level:2,title:"全面支持JDK17",slug:"全面支持jdk17",normalizedTitle:"全面支持jdk17",charIndex:66},{level:2,title:"支持SQL插件使用自己定义的数据源",slug:"支持sql插件使用自己定义的数据源",normalizedTitle:"支持sql插件使用自己定义的数据源",charIndex:371},{level:2,title:"LiteFlow的测试用例全面转向Junit5",slug:"liteflow的测试用例全面转向junit5",normalizedTitle:"liteflow的测试用例全面转向junit5",charIndex:630},{level:2,title:"对脚本和Java的联动进行加强",slug:"对脚本和java的联动进行加强",normalizedTitle:"对脚本和java的联动进行加强",charIndex:853},{level:2,title:"对声明式组件增加了组件名称的设定",slug:"对声明式组件增加了组件名称的设定",normalizedTitle:"对声明式组件增加了组件名称的设定",charIndex:1008},{level:2,title:"错误事件通知的改造",slug:"错误事件通知的改造",normalizedTitle:"错误事件通知的改造",charIndex:1067},{level:2,title:"全局拦截器的改造",slug:"全局拦截器的改造",normalizedTitle:"全局拦截器的改造",charIndex:1250},{level:2,title:"布尔表达式中OR的短路判断",slug:"布尔表达式中or的短路判断",normalizedTitle:"布尔表达式中or的短路判断",charIndex:2169},{level:2,title:"同一个组件复用时Step的记录问题",slug:"同一个组件复用时step的记录问题",normalizedTitle:"同一个组件复用时step的记录问题",charIndex:2308},{level:2,title:"日志方面的增强",slug:"日志方面的增强",normalizedTitle:"日志方面的增强",charIndex:2418}],headersStr:"v2.10.6介绍 全面支持JDK17 支持SQL插件使用自己定义的数据源 LiteFlow的测试用例全面转向Junit5 对脚本和Java的联动进行加强 对声明式组件增加了组件名称的设定 错误事件通知的改造 全局拦截器的改造 布尔表达式中OR的短路判断 同一个组件复用时Step的记录问题 日志方面的增强",content:"# v2.10.6介绍\n\nv2.10.6版本是一个进行诸多增强的版本。总计有11个issue的增强，3个issue的修复。\n\n\n# 全面支持JDK17\n\n其实LiteFlow在2.10.0的时候，已经支持了JDK17。但是项目并未对JDK17进行完整的测试。导致很多小伙伴实际在JDK17环境中跑起来，出现了一些问题。\n\n这是由于LiteFlow的900多个测试用例全部都是针对于JDK8来跑的。并未在JDK17下进行完整的测试。\n\n而2.10.6这个版本，我们系统的针对JDK17进行了完整的测试。通过了全部的测试用例。所以大家可以放心的使用。\n\n当然，LiteFlow也是支持Springboot3的。\n\n有的同学可能会问，JDK20支持不支持？其实连作者自己也不知道是否支持JDK20，因为没有进行系统的测试过。这版本太新了。\n\n\n# 支持SQL插件使用自己定义的数据源\n\nLiteFlow支持将EL表达式，脚本存放在所有的关系型数据库中。但是之前的版本，LiteFlow有自己的一套数据库连接配置，这就导致了往往使用者同一套数据库配置要配置2遍，还有一些使用者在实际的环境中，可能数据源是加密的，或者数据源是从外部获取的。这就没法使用LiteFlow提供的数据源配置了。\n\n所以，这次我们支持了让SQL插件能够使用项目内的数据源来获取数据。更加优雅和方便。\n\n甚至于我们还考虑到了多数据源的场景，让LiteFlow能够智能的挑选正确的数据源。\n\n\n# LiteFlow的测试用例全面转向Junit5\n\n这也许和使用者没啥太大关系。\n\nLiteFlow这个框架功能点非常多，使用人数也非常庞大。所以每一次发版，我都需要补很多测试用例。测试用例是LiteFlow整个框架质量的命脉。甚至于测试用例成为了和核心代码一样重要的存在。所以LiteFlow目前有将近1000个测试用例。\n\n在2.10.6版本的源代码中，所有的测试用例从原先的Junit4全部转向了Junit5。更加稳定。更加有保障。\n\n\n# 对脚本和Java的联动进行加强\n\n主要加强点在@ScriptBean这个注解，这个是脚本和Java联动的关键注解，在社区群里，有同学报出这个注解有时无法正常的工作，导致脚本拿不到Java的对象。对这个问题，我进行了深入研究。在2.10.6版本中，对这个注解进行了很多的优化，应该能彻底解决之前的问题。\n\n\n# 对声明式组件增加了组件名称的设定\n\n在2.10.6版本中，声明式组件支持了声明nodeName 这个属性了。\n\n\n# 错误事件通知的改造\n\n原先错误事件回调通知是这样定义的：\n\npublic void onError() throws Exception;\n\n\n这样定义导致有些同学不知道如何取Exception，为了使api更加友好，这次这个回调方法改成了如下形式：\n\npublic void onError(Exception e) throws Exception;\n\n\n\n# 全局拦截器的改造\n\n原先全局拦截器的定义如下：\n\n@Component\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(String nodeId, Slot slot) {\n        YourContextBean context = slot.getContextBean(YourContextBean.class);\n        //before business\n    }\n\n    @Override\n    public void afterProcess(String nodeId, Slot slot) {\n        YourContextBean context = slot.getContextBean(YourContextBean.class);\n        //after business\n    }\n}\n\n\n这种方式无法直观的拿到很多信息，为了api更加友好，这次我们改造了这个接口的实现参数：\n\n@Component\npublic class CmpAspect implements ICmpAroundAspect {\n    @Override\n    public void beforeProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //before business\n    }\n\n    @Override\n    public void afterProcess(NodeComponent cmp) {\n        YourContextBean context = cmp.getContextBean(YourContextBean.class);\n        //after business\n    }\n}\n\n\n\n# 布尔表达式中OR的短路判断\n\n在社区中有同学反应，如果有以下EL语句：\n\nIF(OR(a,b,c), x);\n\n\n如果a返回true，那其实b和c应该不用执行，而事实情况是LiteFlow把a,b,c都执行了。\n\n所以这次我们也收到了贡献者的PR，把这个问题给优化了。\n\n\n# 同一个组件复用时Step的记录问题\n\nLiteflowResponse的step可以用来回溯整个链路的实际执行情况。但是在相同组件复用的情况下，这个step的记录在之前版本中有些问题。此次我们也修复了这个问题。\n\n\n# 日志方面的增强\n\n在2.10.6版本中，系统默认会以info级别打出所有的节点的耗时信息。\n\n如果觉得日志太多的话，可以通过设置liteflow.print-execution-log=false来进行关闭整个LiteFlow框架的系统日志。",normalizedContent:"# v2.10.6介绍\n\nv2.10.6版本是一个进行诸多增强的版本。总计有11个issue的增强，3个issue的修复。\n\n\n# 全面支持jdk17\n\n其实liteflow在2.10.0的时候，已经支持了jdk17。但是项目并未对jdk17进行完整的测试。导致很多小伙伴实际在jdk17环境中跑起来，出现了一些问题。\n\n这是由于liteflow的900多个测试用例全部都是针对于jdk8来跑的。并未在jdk17下进行完整的测试。\n\n而2.10.6这个版本，我们系统的针对jdk17进行了完整的测试。通过了全部的测试用例。所以大家可以放心的使用。\n\n当然，liteflow也是支持springboot3的。\n\n有的同学可能会问，jdk20支持不支持？其实连作者自己也不知道是否支持jdk20，因为没有进行系统的测试过。这版本太新了。\n\n\n# 支持sql插件使用自己定义的数据源\n\nliteflow支持将el表达式，脚本存放在所有的关系型数据库中。但是之前的版本，liteflow有自己的一套数据库连接配置，这就导致了往往使用者同一套数据库配置要配置2遍，还有一些使用者在实际的环境中，可能数据源是加密的，或者数据源是从外部获取的。这就没法使用liteflow提供的数据源配置了。\n\n所以，这次我们支持了让sql插件能够使用项目内的数据源来获取数据。更加优雅和方便。\n\n甚至于我们还考虑到了多数据源的场景，让liteflow能够智能的挑选正确的数据源。\n\n\n# liteflow的测试用例全面转向junit5\n\n这也许和使用者没啥太大关系。\n\nliteflow这个框架功能点非常多，使用人数也非常庞大。所以每一次发版，我都需要补很多测试用例。测试用例是liteflow整个框架质量的命脉。甚至于测试用例成为了和核心代码一样重要的存在。所以liteflow目前有将近1000个测试用例。\n\n在2.10.6版本的源代码中，所有的测试用例从原先的junit4全部转向了junit5。更加稳定。更加有保障。\n\n\n# 对脚本和java的联动进行加强\n\n主要加强点在@scriptbean这个注解，这个是脚本和java联动的关键注解，在社区群里，有同学报出这个注解有时无法正常的工作，导致脚本拿不到java的对象。对这个问题，我进行了深入研究。在2.10.6版本中，对这个注解进行了很多的优化，应该能彻底解决之前的问题。\n\n\n# 对声明式组件增加了组件名称的设定\n\n在2.10.6版本中，声明式组件支持了声明nodename 这个属性了。\n\n\n# 错误事件通知的改造\n\n原先错误事件回调通知是这样定义的：\n\npublic void onerror() throws exception;\n\n\n这样定义导致有些同学不知道如何取exception，为了使api更加友好，这次这个回调方法改成了如下形式：\n\npublic void onerror(exception e) throws exception;\n\n\n\n# 全局拦截器的改造\n\n原先全局拦截器的定义如下：\n\n@component\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(string nodeid, slot slot) {\n        yourcontextbean context = slot.getcontextbean(yourcontextbean.class);\n        //before business\n    }\n\n    @override\n    public void afterprocess(string nodeid, slot slot) {\n        yourcontextbean context = slot.getcontextbean(yourcontextbean.class);\n        //after business\n    }\n}\n\n\n这种方式无法直观的拿到很多信息，为了api更加友好，这次我们改造了这个接口的实现参数：\n\n@component\npublic class cmpaspect implements icmparoundaspect {\n    @override\n    public void beforeprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //before business\n    }\n\n    @override\n    public void afterprocess(nodecomponent cmp) {\n        yourcontextbean context = cmp.getcontextbean(yourcontextbean.class);\n        //after business\n    }\n}\n\n\n\n# 布尔表达式中or的短路判断\n\n在社区中有同学反应，如果有以下el语句：\n\nif(or(a,b,c), x);\n\n\n如果a返回true，那其实b和c应该不用执行，而事实情况是liteflow把a,b,c都执行了。\n\n所以这次我们也收到了贡献者的pr，把这个问题给优化了。\n\n\n# 同一个组件复用时step的记录问题\n\nliteflowresponse的step可以用来回溯整个链路的实际执行情况。但是在相同组件复用的情况下，这个step的记录在之前版本中有些问题。此次我们也修复了这个问题。\n\n\n# 日志方面的增强\n\n在2.10.6版本中，系统默认会以info级别打出所有的节点的耗时信息。\n\n如果觉得日志太多的话，可以通过设置liteflow.print-execution-log=false来进行关闭整个liteflow框架的系统日志。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.10.2?",frontmatter:{title:"What's New In LiteFlow v2.10.2?",date:"2023-03-22T23:48:57.000Z",permalink:"/pages/8ff010/"},regularPath:"/whats%20new/091.whats%20new%20in%20v2.10.2.html",relativePath:"whats new/091.whats new in v2.10.2.md",key:"v-009820c9",path:"/pages/8ff010/",headers:[{level:2,title:"v2.10.2介绍",slug:"v2-10-2介绍",normalizedTitle:"v2.10.2介绍",charIndex:2},{level:2,title:"与或非表达式",slug:"与或非表达式",normalizedTitle:"与或非表达式",charIndex:56},{level:2,title:"脚本新增了一些元数据",slug:"脚本新增了一些元数据",normalizedTitle:"脚本新增了一些元数据",charIndex:613},{level:2,title:"选择表达式的增强和一些bug的修复",slug:"选择表达式的增强和一些bug的修复",normalizedTitle:"选择表达式的增强和一些bug的修复",charIndex:760}],headersStr:"v2.10.2介绍 与或非表达式 脚本新增了一些元数据 选择表达式的增强和一些bug的修复",content:"# v2.10.2介绍\n\n我们为每个迭代版本都定了一个版本特性。\n\nLiteFlow 2.10.2的版本特性就是与或非表达式。\n\n除此之外，我们还增强了一些内容，修复了社区提出的bug。一共5个issue，作为此次小版本迭代的组成部分。\n\n\n# 与或非表达式\n\n社区里一直有人反应，条件编排能否在EL上写表达式，例如a==5 && b>0这种。\n\n其实编排EL语法一切的操作对象都是组件，所以EL编排语法不能像逻辑代码一样来写很多逻辑过程。\n\n我一直建议逻辑过程，通过java代码或者脚本组件来完成。而脚本组件是可以热更新热替换的。更加灵活。\n\n但是在实际应用中，的确有人需要在条件编排里判断多个条件，而每个条件又是互相独立的组件。那么按照以前的写法，你只能把多个条件的逻辑塞到一个组件里，返回统一的true或者false。\n\n这次我们新增了组件编排层面的与或非表达式，就是AND，OR，NOT表达式。\n\n用法为方法模式：AND(a, b, c)。\n\n可能有些社区里的同学会问，为什么不设计成a && b && c呢，或者是a AND b AND c呢。\n\n我来解释一下，首先这种用法模式和之前的语法呼应，都是方法模式，其次操作符的模式就有点像逻辑了，而这里突出的是编排。再者操作符的模式的几个关键字都被底层占用了。\n\n综上所述，所以延续了之前的EL表述方式。\n\n具体文档在官网EL规则语法大章的与或非表达式小章中。\n\n\n# 脚本新增了一些元数据\n\n脚本中现在也可以拿到循环下标了，在元数据里加入了loopIndex和loopObject2个属性。\n\n可以通过_meta.loopIndex和_meta.loopObject来获取到。\n\n所有的脚本元数据可以参照官网的脚本组件大章中的与Java进行交互小章节。\n\n\n# 选择表达式的增强和一些bug的修复\n\n现在在选择编排语法上，之前tag属性只能添加到组件上，现在对任何的表达式后面都可以添加tag属性了。\n\n在选择节点的返回上，更加灵活了。\n\n具体见官网的常规组件大章中的选择组件小章节。\n\n此次我们还另外修复了2个bug。",normalizedContent:"# v2.10.2介绍\n\n我们为每个迭代版本都定了一个版本特性。\n\nliteflow 2.10.2的版本特性就是与或非表达式。\n\n除此之外，我们还增强了一些内容，修复了社区提出的bug。一共5个issue，作为此次小版本迭代的组成部分。\n\n\n# 与或非表达式\n\n社区里一直有人反应，条件编排能否在el上写表达式，例如a==5 && b>0这种。\n\n其实编排el语法一切的操作对象都是组件，所以el编排语法不能像逻辑代码一样来写很多逻辑过程。\n\n我一直建议逻辑过程，通过java代码或者脚本组件来完成。而脚本组件是可以热更新热替换的。更加灵活。\n\n但是在实际应用中，的确有人需要在条件编排里判断多个条件，而每个条件又是互相独立的组件。那么按照以前的写法，你只能把多个条件的逻辑塞到一个组件里，返回统一的true或者false。\n\n这次我们新增了组件编排层面的与或非表达式，就是and，or，not表达式。\n\n用法为方法模式：and(a, b, c)。\n\n可能有些社区里的同学会问，为什么不设计成a && b && c呢，或者是a and b and c呢。\n\n我来解释一下，首先这种用法模式和之前的语法呼应，都是方法模式，其次操作符的模式就有点像逻辑了，而这里突出的是编排。再者操作符的模式的几个关键字都被底层占用了。\n\n综上所述，所以延续了之前的el表述方式。\n\n具体文档在官网el规则语法大章的与或非表达式小章中。\n\n\n# 脚本新增了一些元数据\n\n脚本中现在也可以拿到循环下标了，在元数据里加入了loopindex和loopobject2个属性。\n\n可以通过_meta.loopindex和_meta.loopobject来获取到。\n\n所有的脚本元数据可以参照官网的脚本组件大章中的与java进行交互小章节。\n\n\n# 选择表达式的增强和一些bug的修复\n\n现在在选择编排语法上，之前tag属性只能添加到组件上，现在对任何的表达式后面都可以添加tag属性了。\n\n在选择节点的返回上，更加灵活了。\n\n具体见官网的常规组件大章中的选择组件小章节。\n\n此次我们还另外修复了2个bug。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.9.7?",frontmatter:{title:"What's New In LiteFlow v2.9.7?",date:"2022-11-30T23:48:57.000Z",permalink:"/pages/8ff007/"},regularPath:"/whats%20new/094.whats%20new%20in%20v2.9.7.html",relativePath:"whats new/094.whats new in v2.9.7.md",key:"v-a3023f2a",path:"/pages/8ff007/",headers:[{level:2,title:"v2.9.7介绍",slug:"v2-9-7介绍",normalizedTitle:"v2.9.7介绍",charIndex:2},{level:2,title:"迭代器组件",slug:"迭代器组件",normalizedTitle:"迭代器组件",charIndex:113},{level:2,title:"对规则异常的报错日志进行优化",slug:"对规则异常的报错日志进行优化",normalizedTitle:"对规则异常的报错日志进行优化",charIndex:327},{level:2,title:"脚本文件的绝对路径支持",slug:"脚本文件的绝对路径支持",normalizedTitle:"脚本文件的绝对路径支持",charIndex:459},{level:2,title:"组件内beforeProcess和afterProcess2个方法的优化",slug:"组件内beforeprocess和afterprocess2个方法的优化",normalizedTitle:"组件内beforeprocess和afterprocess2个方法的优化",charIndex:636},{level:2,title:"支持solon框架",slug:"支持solon框架",normalizedTitle:"支持solon框架",charIndex:759},{level:2,title:"众多细节点的增强和修复",slug:"众多细节点的增强和修复",normalizedTitle:"众多细节点的增强和修复",charIndex:847}],headersStr:"v2.9.7介绍 迭代器组件 对规则异常的报错日志进行优化 脚本文件的绝对路径支持 组件内beforeProcess和afterProcess2个方法的优化 支持solon框架 众多细节点的增强和修复",content:"# v2.9.7介绍\n\n2.9.7是LiteFlow 2023年的第一个版本。很抱歉这个版本来的晚了一点。\n\n2.9.7提供了1个特性，5个增强，4个Bug修复，1个开源集成特性，总计11个issue的更新。\n\n其中版本特性为迭代器组件，弥补了循环组件之前的不足。\n\n\n# 迭代器组件\n\n自从推出了循环组件之后，社区里反应使用体验一直不是很好。其主要因素在于循环组件需要自己去取到当前下标，然后根据下标再去取到对象，这样的过程太过于繁琐。\n\n所以在这个版本，我们增加了一个组件类型：迭代器组件。它也是属于循环组件的一种，结合java的特性，能更快的去循环一个集合。而不用去管下标。\n\n最新的文档已经更新，如果要了解详细用法，可以去相关文档查看。\n\n\n# 对规则异常的报错日志进行优化\n\n在以前的规则异常报错中，社区里的同学一直看不懂报错信息，不知道自己写的规则哪里出了问题。\n\n在新的版本中，我们加强了规则报错的日志丰富性，会用箭头指出具体的语法错误以及报错点。这样能更加方便的帮助使用者进行错误规则的排查。\n\n\n# 脚本文件的绝对路径支持\n\nLiteFlow的脚本通常大家是写在XML里的，但是对于较多篇幅的脚本时，之前LiteFlow提供了文件脚本这一特性，把脚本单独抽出来作为一个文件，一方面更加方便管理，一方面也有编辑器语法的更加丰富的提示管理。但是很遗憾，在之前的版本中，脚本文件只能定义在项目内。无法定义在本地绝对路径中，而这次，我们弥补了这一缺失。\n\n\n# 组件内beforeProcess和afterProcess2个方法的优化\n\n我们在新版本中移除了这2个方法的参数，使这2个方法变成了无参构造。\n\n原因是组件内的任何方法都可以通过this关键字来获得任何参数，原先有参数的确是多此一举了。\n\n\n# 支持solon框架\n\n我们和开源社区里的solon框架进行了集成，现在LiteFlow也支持solon了。如果有小伙伴使用solon的，也可以使用LiteFlow了。\n\n\n# 众多细节点的增强和修复\n\n对于一些不常见的场景，我们的测试用例有的没覆盖到，导致了一些问题，而这些问题在社区进行反应了之后，我们都给予了修复。\n\n我不能保证新的版本是没有BUG的，但是对于大多数主要场景，LiteFlow 2.9.7拥有900多个测试用例，这些测试用例能保证其主要的使用体验和质量。所以，请放心使用。",normalizedContent:"# v2.9.7介绍\n\n2.9.7是liteflow 2023年的第一个版本。很抱歉这个版本来的晚了一点。\n\n2.9.7提供了1个特性，5个增强，4个bug修复，1个开源集成特性，总计11个issue的更新。\n\n其中版本特性为迭代器组件，弥补了循环组件之前的不足。\n\n\n# 迭代器组件\n\n自从推出了循环组件之后，社区里反应使用体验一直不是很好。其主要因素在于循环组件需要自己去取到当前下标，然后根据下标再去取到对象，这样的过程太过于繁琐。\n\n所以在这个版本，我们增加了一个组件类型：迭代器组件。它也是属于循环组件的一种，结合java的特性，能更快的去循环一个集合。而不用去管下标。\n\n最新的文档已经更新，如果要了解详细用法，可以去相关文档查看。\n\n\n# 对规则异常的报错日志进行优化\n\n在以前的规则异常报错中，社区里的同学一直看不懂报错信息，不知道自己写的规则哪里出了问题。\n\n在新的版本中，我们加强了规则报错的日志丰富性，会用箭头指出具体的语法错误以及报错点。这样能更加方便的帮助使用者进行错误规则的排查。\n\n\n# 脚本文件的绝对路径支持\n\nliteflow的脚本通常大家是写在xml里的，但是对于较多篇幅的脚本时，之前liteflow提供了文件脚本这一特性，把脚本单独抽出来作为一个文件，一方面更加方便管理，一方面也有编辑器语法的更加丰富的提示管理。但是很遗憾，在之前的版本中，脚本文件只能定义在项目内。无法定义在本地绝对路径中，而这次，我们弥补了这一缺失。\n\n\n# 组件内beforeprocess和afterprocess2个方法的优化\n\n我们在新版本中移除了这2个方法的参数，使这2个方法变成了无参构造。\n\n原因是组件内的任何方法都可以通过this关键字来获得任何参数，原先有参数的确是多此一举了。\n\n\n# 支持solon框架\n\n我们和开源社区里的solon框架进行了集成，现在liteflow也支持solon了。如果有小伙伴使用solon的，也可以使用liteflow了。\n\n\n# 众多细节点的增强和修复\n\n对于一些不常见的场景，我们的测试用例有的没覆盖到，导致了一些问题，而这些问题在社区进行反应了之后，我们都给予了修复。\n\n我不能保证新的版本是没有bug的，但是对于大多数主要场景，liteflow 2.9.7拥有900多个测试用例，这些测试用例能保证其主要的使用体验和质量。所以，请放心使用。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.10.0?",frontmatter:{title:"What's New In LiteFlow v2.10.0?",date:"2022-11-30T23:48:57.000Z",permalink:"/pages/8ff008/"},regularPath:"/whats%20new/093.whats%20new%20in%20v2.10.0.html",relativePath:"whats new/093.whats new in v2.10.0.md",key:"v-2b4480d1",path:"/pages/8ff008/",headers:[{level:2,title:"v2.10.0介绍",slug:"v2-10-0介绍",normalizedTitle:"v2.10.0介绍",charIndex:2},{level:2,title:"支持springboot3.X",slug:"支持springboot3-x",normalizedTitle:"支持springboot3.x",charIndex:286},{level:2,title:"多种不同语言脚本混合调用的特性",slug:"多种不同语言脚本混合调用的特性",normalizedTitle:"多种不同语言脚本混合调用的特性",charIndex:487},{level:2,title:"增加CATCH表达式",slug:"增加catch表达式",normalizedTitle:"增加catch表达式",charIndex:786},{level:2,title:"文件监听",slug:"文件监听",normalizedTitle:"文件监听",charIndex:956},{level:2,title:"其余要说的",slug:"其余要说的",normalizedTitle:"其余要说的",charIndex:1181}],headersStr:"v2.10.0介绍 支持springboot3.X 多种不同语言脚本混合调用的特性 增加CATCH表达式 文件监听 其余要说的",content:"# v2.10.0介绍\n\n距离上一个版本2.9.7已经有一个月的时间了。这次我们带来了大版本升级：LiteFlow v2.10.0。\n\n这期间其实没一直在忙LiteFlow，中间断断续续的在做。\n\n本来想把这个版本定为2.9.8的，但是从新增的特性来说，的确是进步非常大的一个版本。所以我们索性把这个版本定位成了大版本升级。不过请放心，2.10.0是完全向下兼容2.9.X的。使用者可以放心升级。\n\n这次LiteFlow v2.10.0带来非常多的特性，甚至于为了这个版本，我们把内核部分最重要的一块进行了结构化的整改。使得代码的复用度更加高了，逻辑更加清晰了。\n\n\n# 支持springboot3.X\n\n之前在社区里有很多小伙伴一直在问，为什么LiteFlow在springboot3下启动老是报错，我只能说还不支持。\n\n考虑到springboot3+jdk17确实是未来的方向，这次经过群友贡献，LiteFlow v2.10.0版本终于支持springboot3了！\n\n在支持springboot3的前提下，LiteFlow的依赖方式和使用方式不会有任何改变。\n\n\n# 多种不同语言脚本混合调用的特性\n\nLiteFlow在之前的版本中早已经支持了脚本语言的调用，目前支持了5种脚本语言：groovy，javascript，qlexpress，python，lua。\n\n但是之前的版本同一个项目中只能5选1，你只能使用一种脚本语言。\n\n虽然我一直觉得在同一个项目中使用多种脚本语言是个伪需求，但是的确在社区里有超过5个人和我说了这个事情。我开始意识到也许真有人想做这样的事情，以满足多人分别使用擅长的脚本语言去共同开发一个项目。\n\n所以在新版本中，LiteFlow打破了这个限制。现在你可以定义多种不同语言的脚本，并且可以实现混合编排，参数互通。是不是很棒呢。\n\n\n# 增加CATCH表达式\n\n我原先觉得LiteFlow的EL表达式已经可以满足于大部分的场景了，无需再添加了。直到我做公司的项目的时候用自己的作品时，发现有些特殊的场景的确需要在表达式声明层面进行捕获异常。于是乎我就加了这个表达式。\n\n同时这个表达式也能够起到continue的作用。也弥补了在循环中没有continue关键字的遗漏。\n\n\n# 文件监听\n\nLiteFlow的规则可以存储于任何地方，我们支持了各种数据库以及市面上流行的全部注册中心。大部分的外置存储我们都做到了改变即自动热刷新规则的特点。\n\n但是我们忽略了最常见的存储方式：本地文件。在以前的版本中，本地规则文件改变，无法做到自动刷新。必须手动调用api刷新，或者重启应用。\n\n在新版本中，我们增加了对本地文件的监听特性。真正做到了：改变自动刷新规则。让LiteFlow规则文件的存储方式选择上，又多了一种灵活的方式。\n\n\n# 其余要说的\n\n新版本还增加了对脚本中引用上下文名称的自定义化，修复了社区里提的一部分Bug，重构了底层了一部分代码。\n\n同时，我们测试用例增加到了913个。相应的IDEA插件也进行了更新，这两天应该就能审核好。大家就可以在idea插件市场进行更新了。\n\n前几天有个群友问我，LiteFlow已经一个月没发版了，是不是作者你已经弃坑了。\n\n怎么可能，我迭代维护了2年多，LiteFlow现在正被越来越多的人知道，被越来越多的公司选用作为后端核心框架。而且LiteFlow底层的代码越来越优雅和灵活。\n\n我在憋大招呢。正如官网项目介绍所说：我会长期坚持去完善这个项目，希望可以把LiteFlow带入国内顶尖开源项目的行列。\n\n而现在，我们扬起帆，才刚刚启航，期待着这次荣耀之旅。",normalizedContent:"# v2.10.0介绍\n\n距离上一个版本2.9.7已经有一个月的时间了。这次我们带来了大版本升级：liteflow v2.10.0。\n\n这期间其实没一直在忙liteflow，中间断断续续的在做。\n\n本来想把这个版本定为2.9.8的，但是从新增的特性来说，的确是进步非常大的一个版本。所以我们索性把这个版本定位成了大版本升级。不过请放心，2.10.0是完全向下兼容2.9.x的。使用者可以放心升级。\n\n这次liteflow v2.10.0带来非常多的特性，甚至于为了这个版本，我们把内核部分最重要的一块进行了结构化的整改。使得代码的复用度更加高了，逻辑更加清晰了。\n\n\n# 支持springboot3.x\n\n之前在社区里有很多小伙伴一直在问，为什么liteflow在springboot3下启动老是报错，我只能说还不支持。\n\n考虑到springboot3+jdk17确实是未来的方向，这次经过群友贡献，liteflow v2.10.0版本终于支持springboot3了！\n\n在支持springboot3的前提下，liteflow的依赖方式和使用方式不会有任何改变。\n\n\n# 多种不同语言脚本混合调用的特性\n\nliteflow在之前的版本中早已经支持了脚本语言的调用，目前支持了5种脚本语言：groovy，javascript，qlexpress，python，lua。\n\n但是之前的版本同一个项目中只能5选1，你只能使用一种脚本语言。\n\n虽然我一直觉得在同一个项目中使用多种脚本语言是个伪需求，但是的确在社区里有超过5个人和我说了这个事情。我开始意识到也许真有人想做这样的事情，以满足多人分别使用擅长的脚本语言去共同开发一个项目。\n\n所以在新版本中，liteflow打破了这个限制。现在你可以定义多种不同语言的脚本，并且可以实现混合编排，参数互通。是不是很棒呢。\n\n\n# 增加catch表达式\n\n我原先觉得liteflow的el表达式已经可以满足于大部分的场景了，无需再添加了。直到我做公司的项目的时候用自己的作品时，发现有些特殊的场景的确需要在表达式声明层面进行捕获异常。于是乎我就加了这个表达式。\n\n同时这个表达式也能够起到continue的作用。也弥补了在循环中没有continue关键字的遗漏。\n\n\n# 文件监听\n\nliteflow的规则可以存储于任何地方，我们支持了各种数据库以及市面上流行的全部注册中心。大部分的外置存储我们都做到了改变即自动热刷新规则的特点。\n\n但是我们忽略了最常见的存储方式：本地文件。在以前的版本中，本地规则文件改变，无法做到自动刷新。必须手动调用api刷新，或者重启应用。\n\n在新版本中，我们增加了对本地文件的监听特性。真正做到了：改变自动刷新规则。让liteflow规则文件的存储方式选择上，又多了一种灵活的方式。\n\n\n# 其余要说的\n\n新版本还增加了对脚本中引用上下文名称的自定义化，修复了社区里提的一部分bug，重构了底层了一部分代码。\n\n同时，我们测试用例增加到了913个。相应的idea插件也进行了更新，这两天应该就能审核好。大家就可以在idea插件市场进行更新了。\n\n前几天有个群友问我，liteflow已经一个月没发版了，是不是作者你已经弃坑了。\n\n怎么可能，我迭代维护了2年多，liteflow现在正被越来越多的人知道，被越来越多的公司选用作为后端核心框架。而且liteflow底层的代码越来越优雅和灵活。\n\n我在憋大招呢。正如官网项目介绍所说：我会长期坚持去完善这个项目，希望可以把liteflow带入国内顶尖开源项目的行列。\n\n而现在，我们扬起帆，才刚刚启航，期待着这次荣耀之旅。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.10.1?",frontmatter:{title:"What's New In LiteFlow v2.10.1?",date:"2023-03-22T23:48:57.000Z",permalink:"/pages/8ff009/"},regularPath:"/whats%20new/092.whats%20new%20in%20v2.10.1.html",relativePath:"whats new/092.whats new in v2.10.1.md",key:"v-15ee50cd",path:"/pages/8ff009/",headers:[{level:2,title:"v2.10.1介绍",slug:"v2-10-1介绍",normalizedTitle:"v2.10.1介绍",charIndex:2},{level:2,title:"支持Aviator脚本语言",slug:"支持aviator脚本语言",normalizedTitle:"支持aviator脚本语言",charIndex:161},{level:2,title:"循环表达式嵌套",slug:"循环表达式嵌套",normalizedTitle:"循环表达式嵌套",charIndex:456},{level:2,title:"其余的更新",slug:"其余的更新",normalizedTitle:"其余的更新",charIndex:565}],headersStr:"v2.10.1介绍 支持Aviator脚本语言 循环表达式嵌套 其余的更新",content:"# v2.10.1介绍\n\n前段时间我们刚刚发布了LiteFlow的大版本2.10.0。在这个版本中增加了诸多特性和代码的优化。\n\n我们现在又马不停蹄的推出了小版本升级：2.10.1。\n\n其实2.10.0很稳定，最新的2.10.1版本主要为了增加一个新的脚本语言扩展Aviator和支持了循环表达式的嵌套循环增强。\n\n\n# 支持Aviator脚本语言\n\n首先介绍下Aviator。\n\nAviator是非常优秀的国产表达式引擎开源框架。文档详细，性能优秀，整个解析过程最多扫2次，保证了它的性能超越大部分解释型表达式引擎，整体非常轻量级，整个jar包大小哪怕发展到现在5.3这个版本，也才600k。\n\n在社区中，我听到有人希望支持Aviator这个脚本语言。LiteFlow在脚本的支持度方面一直很全，既然Aviator很多人在用，那LiteFlow索性就一起支持了。\n\n从2.10.1起，社区的小伙伴可以在LiteFlow里使用Aviator脚本了。具体如何依赖和注意事项，请看官方文档中的脚本这一章节。\n\n\n# 循环表达式嵌套\n\nLiteFlow之前的版本推出了循环表达式，循环表达式主要有FOR,WHILE以及迭代表达式ITERATOR，之前是不支持循环嵌套的。\n\n新版本支持了循环表达式的嵌套增强。大家可以去试一试。\n\n\n# 其余的更新\n\n2.10.1版本中我们对所有的代码进行了统一插件格式化处理，修复了多脚本混用在SQL中不起效果的bug。优化了脚本这一块的核心代码。",normalizedContent:"# v2.10.1介绍\n\n前段时间我们刚刚发布了liteflow的大版本2.10.0。在这个版本中增加了诸多特性和代码的优化。\n\n我们现在又马不停蹄的推出了小版本升级：2.10.1。\n\n其实2.10.0很稳定，最新的2.10.1版本主要为了增加一个新的脚本语言扩展aviator和支持了循环表达式的嵌套循环增强。\n\n\n# 支持aviator脚本语言\n\n首先介绍下aviator。\n\naviator是非常优秀的国产表达式引擎开源框架。文档详细，性能优秀，整个解析过程最多扫2次，保证了它的性能超越大部分解释型表达式引擎，整体非常轻量级，整个jar包大小哪怕发展到现在5.3这个版本，也才600k。\n\n在社区中，我听到有人希望支持aviator这个脚本语言。liteflow在脚本的支持度方面一直很全，既然aviator很多人在用，那liteflow索性就一起支持了。\n\n从2.10.1起，社区的小伙伴可以在liteflow里使用aviator脚本了。具体如何依赖和注意事项，请看官方文档中的脚本这一章节。\n\n\n# 循环表达式嵌套\n\nliteflow之前的版本推出了循环表达式，循环表达式主要有for,while以及迭代表达式iterator，之前是不支持循环嵌套的。\n\n新版本支持了循环表达式的嵌套增强。大家可以去试一试。\n\n\n# 其余的更新\n\n2.10.1版本中我们对所有的代码进行了统一插件格式化处理，修复了多脚本混用在sql中不起效果的bug。优化了脚本这一块的核心代码。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.9.6?",frontmatter:{title:"What's New In LiteFlow v2.9.6?",date:"2022-11-30T23:48:57.000Z",permalink:"/pages/8ff006/"},regularPath:"/whats%20new/095.whats%20new%20in%20v2.9.6.html",relativePath:"whats new/095.whats new in v2.9.6.md",key:"v-56ca45aa",path:"/pages/8ff006/",headers:[{level:2,title:"v2.9.6介绍",slug:"v2-9-6介绍",normalizedTitle:"v2.9.6介绍",charIndex:2},{level:2,title:"优化组件底层的实例参数结构",slug:"优化组件底层的实例参数结构",normalizedTitle:"优化组件底层的实例参数结构",charIndex:96},{level:2,title:"对循环组件提供循环下标的特性",slug:"对循环组件提供循环下标的特性",normalizedTitle:"对循环组件提供循环下标的特性",charIndex:392}],headersStr:"v2.9.6介绍 优化组件底层的实例参数结构 对循环组件提供循环下标的特性",content:"# v2.9.6介绍\n\nLiteFlow继续发力，推出了v2.9.6版本。\n\n该版本主要改进了组件底层的实例参数结构，并且对循环组件增加了循环下标的特性。\n\n并且还修复了一些BUG。\n\n\n# 优化组件底层的实例参数结构\n\n这一层优化对于用户是无感知的。但是对于LiteFlow本身的意义是重大的。\n\n随着LiteFlow这个开源项目提供的功能和特性越来越多，我作为作者，也需要考虑今后迭代的成本问题。我希望一个成熟的开源作品，越迭代是代码质量越好的，逻辑是越来越清晰的，结构是越优雅的，这样反过来也能促进迭代速度和成员的参与度。\n\n所以不光要保证特性的实现，还时常需要对项目的架构和模块的实现结构进行复盘，看看哪里需要被优化。\n\n这点目前来说，做的还是相对不错的，所以使用者也大可放心的用。我们在2.9.6中，优化了底层核心部分前期设计的不合理处。使得以后的扩展度会更加高。\n\n\n# 对循环组件提供循环下标的特性\n\n社区里一直有小伙伴在问，对于循环组件如何获取下标的问题。很遗憾，在之前的版本中，LiteFlow一直未能支持。\n\n其实看起来很简单，但是究其底层还是受限于组件底层实例参数的结构问题。也就是前面所提到的。\n\n但是我们这一版本优化了底层的结构，使得这一问题也迎刃而解了。否则可能会通过更为复杂的手段来实现，但是这不是我所希望的，所以这也是这一特性迟迟未动手的原因。\n\n好了，现在支持了。使用很简单，详情请参照次数循环组件以及条件循环组件。",normalizedContent:"# v2.9.6介绍\n\nliteflow继续发力，推出了v2.9.6版本。\n\n该版本主要改进了组件底层的实例参数结构，并且对循环组件增加了循环下标的特性。\n\n并且还修复了一些bug。\n\n\n# 优化组件底层的实例参数结构\n\n这一层优化对于用户是无感知的。但是对于liteflow本身的意义是重大的。\n\n随着liteflow这个开源项目提供的功能和特性越来越多，我作为作者，也需要考虑今后迭代的成本问题。我希望一个成熟的开源作品，越迭代是代码质量越好的，逻辑是越来越清晰的，结构是越优雅的，这样反过来也能促进迭代速度和成员的参与度。\n\n所以不光要保证特性的实现，还时常需要对项目的架构和模块的实现结构进行复盘，看看哪里需要被优化。\n\n这点目前来说，做的还是相对不错的，所以使用者也大可放心的用。我们在2.9.6中，优化了底层核心部分前期设计的不合理处。使得以后的扩展度会更加高。\n\n\n# 对循环组件提供循环下标的特性\n\n社区里一直有小伙伴在问，对于循环组件如何获取下标的问题。很遗憾，在之前的版本中，liteflow一直未能支持。\n\n其实看起来很简单，但是究其底层还是受限于组件底层实例参数的结构问题。也就是前面所提到的。\n\n但是我们这一版本优化了底层的结构，使得这一问题也迎刃而解了。否则可能会通过更为复杂的手段来实现，但是这不是我所希望的，所以这也是这一特性迟迟未动手的原因。\n\n好了，现在支持了。使用很简单，详情请参照次数循环组件以及条件循环组件。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.9.5?",frontmatter:{title:"What's New In LiteFlow v2.9.5?",date:"2022-11-30T23:48:57.000Z",permalink:"/pages/8ff005/"},regularPath:"/whats%20new/096.whats%20new%20in%20v2.9.5.html",relativePath:"whats new/096.whats new in v2.9.5.md",key:"v-0a924c2a",path:"/pages/8ff005/",headers:[{level:2,title:"v2.9.5介绍",slug:"v2-9-5介绍",normalizedTitle:"v2.9.5介绍",charIndex:2},{level:2,title:"支持Apollo",slug:"支持apollo",normalizedTitle:"支持apollo",charIndex:268},{level:2,title:"提供Python和Lua脚本语言的支持",slug:"提供python和lua脚本语言的支持",normalizedTitle:"提供python和lua脚本语言的支持",charIndex:379},{level:2,title:"前置后置节点的增强",slug:"前置后置节点的增强",normalizedTitle:"前置后置节点的增强",charIndex:574},{level:2,title:"选择组件的DEFAULT关键字",slug:"选择组件的default关键字",normalizedTitle:"选择组件的default关键字",charIndex:728}],headersStr:"v2.9.5介绍 支持Apollo 提供Python和Lua脚本语言的支持 前置后置节点的增强 选择组件的DEFAULT关键字",content:"# v2.9.5介绍\n\n新版本我们完成了9个issue，其中包含着3个特性。\n\n2.9.5版本的重点是横向扩展能力。\n\n至此，LiteFlow在存储插件上原生支持了所有的关系型数据库，3种流行注册中心，1个配置中心。总共5个插件，这应该囊括了大部分人的选择了。\n\nLiteFlow在2.9.5版本中，一举在脚本支持度上又新增2种语言，python和lua。至此，已经支持了多达5种脚本语言。\n\n写java框架，何必用Java？\n\nLiteFlow可以让你做到一个Java项目，所有的业务代码都可以是脚本。所有的一切皆可热刷新。\n\n\n# 支持Apollo\n\n感谢社区哈啰团队的贡献者，为LiteFlow提供了Apollo的支持插件。\n\nLiteFlow未来会支持越来越多的其他第三方中间件。\n\n关于Apollo插件的使用方式详见：Apollo配置源。\n\n\n# 提供Python和Lua脚本语言的支持\n\n之前我以为提供了Groovy,Javascript,QLExpress3种脚本语言已经够了，没想到社区里还真有人希望能支持python。\n\n好在LiteFlow在脚本基础层已经有了非常易扩展的机制，我们这次不光提供了python的支持，还提供了lua的支持。不知道有没有喜欢lua这种脚本语言呢，写过redis的脚本的同学一定不会陌生吧。\n\n\n# 前置后置节点的增强\n\n之前前置和后置节点只能在表达式的第一层能执行，这无疑对使用者来是说，会有一定的限制。\n\n我原先觉得这个很难被更改。因为想要更改就必须动一些底层的代码。所以一直没有优化这个特性。\n\n这次在翻看代码的时候发现我原先想的可能有点复杂了，这个问题其实没那么复杂。所以这次终于给修掉了。\n\n\n# 选择组件的DEFAULT关键字\n\n在新版本中，我们对选择组件额外增加了一个关键字DEFAULT，使得能够在无法匹配到任一选项时默认执行一个选项。这在有些场景是非常实用的。\n\n详情请见选择编排。",normalizedContent:"# v2.9.5介绍\n\n新版本我们完成了9个issue，其中包含着3个特性。\n\n2.9.5版本的重点是横向扩展能力。\n\n至此，liteflow在存储插件上原生支持了所有的关系型数据库，3种流行注册中心，1个配置中心。总共5个插件，这应该囊括了大部分人的选择了。\n\nliteflow在2.9.5版本中，一举在脚本支持度上又新增2种语言，python和lua。至此，已经支持了多达5种脚本语言。\n\n写java框架，何必用java？\n\nliteflow可以让你做到一个java项目，所有的业务代码都可以是脚本。所有的一切皆可热刷新。\n\n\n# 支持apollo\n\n感谢社区哈啰团队的贡献者，为liteflow提供了apollo的支持插件。\n\nliteflow未来会支持越来越多的其他第三方中间件。\n\n关于apollo插件的使用方式详见：apollo配置源。\n\n\n# 提供python和lua脚本语言的支持\n\n之前我以为提供了groovy,javascript,qlexpress3种脚本语言已经够了，没想到社区里还真有人希望能支持python。\n\n好在liteflow在脚本基础层已经有了非常易扩展的机制，我们这次不光提供了python的支持，还提供了lua的支持。不知道有没有喜欢lua这种脚本语言呢，写过redis的脚本的同学一定不会陌生吧。\n\n\n# 前置后置节点的增强\n\n之前前置和后置节点只能在表达式的第一层能执行，这无疑对使用者来是说，会有一定的限制。\n\n我原先觉得这个很难被更改。因为想要更改就必须动一些底层的代码。所以一直没有优化这个特性。\n\n这次在翻看代码的时候发现我原先想的可能有点复杂了，这个问题其实没那么复杂。所以这次终于给修掉了。\n\n\n# 选择组件的default关键字\n\n在新版本中，我们对选择组件额外增加了一个关键字default，使得能够在无法匹配到任一选项时默认执行一个选项。这在有些场景是非常实用的。\n\n详情请见选择编排。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.9.4?",frontmatter:{title:"What's New In LiteFlow v2.9.4?",date:"2022-11-30T23:48:57.000Z",permalink:"/pages/8ff004/"},regularPath:"/whats%20new/097.whats%20new%20in%20v2.9.4.html",relativePath:"whats new/097.whats new in v2.9.4.md",key:"v-20d2d6ab",path:"/pages/8ff004/",headers:[{level:2,title:"v2.9.4介绍",slug:"v2-9-4介绍",normalizedTitle:"v2.9.4介绍",charIndex:2},{level:2,title:"新的脚本引擎",slug:"新的脚本引擎",normalizedTitle:"新的脚本引擎",charIndex:94},{level:2,title:"提供规则验证接口",slug:"提供规则验证接口",normalizedTitle:"提供规则验证接口",charIndex:299},{level:2,title:"Zk和Etcd支持局部刷新机制",slug:"zk和etcd支持局部刷新机制",normalizedTitle:"zk和etcd支持局部刷新机制",charIndex:433},{level:2,title:"声明式组件的二次动态代理问题",slug:"声明式组件的二次动态代理问题",normalizedTitle:"声明式组件的二次动态代理问题",charIndex:603},{level:2,title:"其他修复",slug:"其他修复",normalizedTitle:"其他修复",charIndex:742}],headersStr:"v2.9.4介绍 新的脚本引擎 提供规则验证接口 Zk和Etcd支持局部刷新机制 声明式组件的二次动态代理问题 其他修复",content:"# v2.9.4介绍\n\n新版本我们依旧依托于社区，一共完成了14个issue。\n\n其中80%的issue来自于社区使用者。\n\n2.9.4版本完全兼容2.9.3版本，可以无缝升级。\n\n\n# 新的脚本引擎\n\n鉴于之前社区有人反应LiteFlow提供的Javascript脚本引擎是基于jdk的，而JDK的Javascript引擎只支持到ES5规范，且不支持Java 17。\n\n所以这次我们新增了一个Javascript引擎：GraalJs。支持ES6规范，且支持Java 8~17。\n\n当然老的引擎我们还是保留，如果是简单的js语法，你依旧可以用老的引擎。\n\n关于这块详情请参考选择脚本语言。\n\n\n# 提供规则验证接口\n\n虽然LiteFlow在启动时会去编译所有的规则，如果有错也会详细报出，但是在更改脚本前，使用者可能不太确信自己的规则写的有没有问题。所以在社区内，有人提出了希望增加一个验证规则的接口。\n\n那这次我们也提供了相应的接口。详情请参考验证规则。\n\n\n# Zk和Etcd支持局部刷新机制\n\n如果你使用zk或者Etcd，你在zk和etcd里更改了规则，会自动推送到相应的应用进行无感自动刷新。\n\n但是之前的实现模式是全部刷新，即不管你改了哪个规则，所有的规则刷新一遍。虽然LiteFlow刷新速度非常快速，但是这种实现模式还是不够优雅。\n\n这次我们实现了局部刷新，即你改变哪个即刷新哪个。\n\n\n# 声明式组件的二次动态代理问题\n\n在社区内，我们也收到了许多使用声明式组件特性小伙伴们的反馈，在声明式组件上使用类似事务标注等需要动态代理的特性时，LiteFlow的声明式组件会报错。\n\n经过核验，我们发现LiteFlow之前漏考虑了二次动态代理的问题，这次我们修复了。\n\n\n# 其他修复\n\n在新版本中，我们修复其他issue也有很多，包括脚本对元数据取值的bug，@ScriptBean标注所带来的一些小问题，脚本异常处理的优化等等。",normalizedContent:"# v2.9.4介绍\n\n新版本我们依旧依托于社区，一共完成了14个issue。\n\n其中80%的issue来自于社区使用者。\n\n2.9.4版本完全兼容2.9.3版本，可以无缝升级。\n\n\n# 新的脚本引擎\n\n鉴于之前社区有人反应liteflow提供的javascript脚本引擎是基于jdk的，而jdk的javascript引擎只支持到es5规范，且不支持java 17。\n\n所以这次我们新增了一个javascript引擎：graaljs。支持es6规范，且支持java 8~17。\n\n当然老的引擎我们还是保留，如果是简单的js语法，你依旧可以用老的引擎。\n\n关于这块详情请参考选择脚本语言。\n\n\n# 提供规则验证接口\n\n虽然liteflow在启动时会去编译所有的规则，如果有错也会详细报出，但是在更改脚本前，使用者可能不太确信自己的规则写的有没有问题。所以在社区内，有人提出了希望增加一个验证规则的接口。\n\n那这次我们也提供了相应的接口。详情请参考验证规则。\n\n\n# zk和etcd支持局部刷新机制\n\n如果你使用zk或者etcd，你在zk和etcd里更改了规则，会自动推送到相应的应用进行无感自动刷新。\n\n但是之前的实现模式是全部刷新，即不管你改了哪个规则，所有的规则刷新一遍。虽然liteflow刷新速度非常快速，但是这种实现模式还是不够优雅。\n\n这次我们实现了局部刷新，即你改变哪个即刷新哪个。\n\n\n# 声明式组件的二次动态代理问题\n\n在社区内，我们也收到了许多使用声明式组件特性小伙伴们的反馈，在声明式组件上使用类似事务标注等需要动态代理的特性时，liteflow的声明式组件会报错。\n\n经过核验，我们发现liteflow之前漏考虑了二次动态代理的问题，这次我们修复了。\n\n\n# 其他修复\n\n在新版本中，我们修复其他issue也有很多，包括脚本对元数据取值的bug，@scriptbean标注所带来的一些小问题，脚本异常处理的优化等等。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.9.3?",frontmatter:{title:"What's New In LiteFlow v2.9.3?",date:"2022-10-07T12:43:18.000Z",permalink:"/pages/8ff003/"},regularPath:"/whats%20new/098.whats%20new%20in%20v2.9.3.html",relativePath:"whats new/098.whats new in v2.9.3.md",key:"v-46eed36b",path:"/pages/8ff003/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"DB支持脚本的存储",slug:"db支持脚本的存储",normalizedTitle:"db支持脚本的存储",charIndex:176},{level:2,title:"ZK和Etcd结构进行了大幅度改造",slug:"zk和etcd结构进行了大幅度改造",normalizedTitle:"zk和etcd结构进行了大幅度改造",charIndex:271},{level:2,title:"为什么Nacos没进行改造？",slug:"为什么nacos没进行改造",normalizedTitle:"为什么nacos没进行改造？",charIndex:514},{level:2,title:"选择组件的选择功能增强",slug:"选择组件的选择功能增强",normalizedTitle:"选择组件的选择功能增强",charIndex:645},{level:2,title:"修复一些Bug",slug:"修复一些bug",normalizedTitle:"修复一些bug",charIndex:763},{level:2,title:"结语",slug:"结语",normalizedTitle:"结语",charIndex:947}],headersStr:"前言 DB支持脚本的存储 ZK和Etcd结构进行了大幅度改造 为什么Nacos没进行改造？ 选择组件的选择功能增强 修复一些Bug 结语",content:"# 前言\n\n我们一直在努力让LiteFlow这款规则引擎更好用，在2.9.0刚出来的时候，LiteFlow推出了数据库，nacos，etcd，zk这几种原生插件的支持。\n\n但是随后有小伙伴反应，数据库里不支持存储脚本，zk，nacos，etcd里不支持脚本和规则分离，都得写在一起。\n\n今天推出的2.9.3版本我们解决了一大部分这方面的诉求。\n\n\n# DB支持脚本的存储\n\n我们在2.9.3版本中首先解决了数据库不能存储脚本的问题。\n\n用新增的自定义表来解决。你现在可以把脚本也存到数据库中了。\n\n这块的文档详见SQL数据库配置源。\n\n\n# ZK和Etcd结构进行了大幅度改造\n\n之前zk和etcd采用的方式比较傻一点，就单个节点存储所有的xml形式的规则。这样导致的结果是修改起来总得修改一整个规则。\n\n在2.9.3中，我们对zk和etcd的存储结构进行了大刀阔斧的改变。使得zk和etcd也能像关系型数据库那样，规则和脚本能分开进行存储。每个规则和每个脚本都有单独的节点。\n\n并且存储的时候，我们去除了xml的这种格式，只存关键数据。我们插件会给你自动的拼装。\n\n这块文档详见ZK规则文件配置源以及Etcd配置源。\n\n\n# 为什么Nacos没进行改造？\n\n因为我们搞不定，Nacos没法对一个group进行监听，如果拆分了，那就会导致新增规则，删除规则没法被监听到。\n\n而现在这种单个节点的形式，虽然没拆分，但是功能是齐全的。这也是无奈的选择。我们也想拆分的，但是我们搞不定。\n\n\n# 选择组件的选择功能增强\n\n在之前，选择组件只能根据Id来进行选择，2.9.0推出了根据tag来进行选择。但是我们觉得还不够。\n\n2.9.3在这基础上进行了增强，推出了简单的选择表达式。基本上一看即会。\n\n相关文档详见选择组件。\n\n\n# 修复一些Bug\n\n小伙伴们在使用中的时候，会碰到一些已经推出的特性在某些场景下达不到预期的效果。\n\n在这个版本中，我们修复了一些问题，比如脚本的加载存在先后关系，这是不合理的，我们修复了。\n\n比如EL中的字符串格式丢失问题，EL中的data关键字的转型问题，我们也修复了。\n\n同时改正了一些不规范的代码问题，比如chainName和chainId混用的情况。\n\n\n# 结语\n\n大家见证着LiteFlow一步步往前走，同时也希望更多人来帮助这个项目的发展。\n\n同样的，我们也保证2.9.3的质量问题，有任何疑问，欢迎来群里反馈。",normalizedContent:"# 前言\n\n我们一直在努力让liteflow这款规则引擎更好用，在2.9.0刚出来的时候，liteflow推出了数据库，nacos，etcd，zk这几种原生插件的支持。\n\n但是随后有小伙伴反应，数据库里不支持存储脚本，zk，nacos，etcd里不支持脚本和规则分离，都得写在一起。\n\n今天推出的2.9.3版本我们解决了一大部分这方面的诉求。\n\n\n# db支持脚本的存储\n\n我们在2.9.3版本中首先解决了数据库不能存储脚本的问题。\n\n用新增的自定义表来解决。你现在可以把脚本也存到数据库中了。\n\n这块的文档详见sql数据库配置源。\n\n\n# zk和etcd结构进行了大幅度改造\n\n之前zk和etcd采用的方式比较傻一点，就单个节点存储所有的xml形式的规则。这样导致的结果是修改起来总得修改一整个规则。\n\n在2.9.3中，我们对zk和etcd的存储结构进行了大刀阔斧的改变。使得zk和etcd也能像关系型数据库那样，规则和脚本能分开进行存储。每个规则和每个脚本都有单独的节点。\n\n并且存储的时候，我们去除了xml的这种格式，只存关键数据。我们插件会给你自动的拼装。\n\n这块文档详见zk规则文件配置源以及etcd配置源。\n\n\n# 为什么nacos没进行改造？\n\n因为我们搞不定，nacos没法对一个group进行监听，如果拆分了，那就会导致新增规则，删除规则没法被监听到。\n\n而现在这种单个节点的形式，虽然没拆分，但是功能是齐全的。这也是无奈的选择。我们也想拆分的，但是我们搞不定。\n\n\n# 选择组件的选择功能增强\n\n在之前，选择组件只能根据id来进行选择，2.9.0推出了根据tag来进行选择。但是我们觉得还不够。\n\n2.9.3在这基础上进行了增强，推出了简单的选择表达式。基本上一看即会。\n\n相关文档详见选择组件。\n\n\n# 修复一些bug\n\n小伙伴们在使用中的时候，会碰到一些已经推出的特性在某些场景下达不到预期的效果。\n\n在这个版本中，我们修复了一些问题，比如脚本的加载存在先后关系，这是不合理的，我们修复了。\n\n比如el中的字符串格式丢失问题，el中的data关键字的转型问题，我们也修复了。\n\n同时改正了一些不规范的代码问题，比如chainname和chainid混用的情况。\n\n\n# 结语\n\n大家见证着liteflow一步步往前走，同时也希望更多人来帮助这个项目的发展。\n\n同样的，我们也保证2.9.3的质量问题，有任何疑问，欢迎来群里反馈。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.9.1?",frontmatter:{title:"What's New In LiteFlow v2.9.1?",date:"2022-10-07T12:43:18.000Z",permalink:"/pages/8ff002/"},regularPath:"/whats%20new/099.whats%20new%20in%20v2.9.1.html",relativePath:"whats new/099.whats new in v2.9.1.md",key:"v-27cad9cb",path:"/pages/8ff002/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"Javascript脚本语言的支持",slug:"javascript脚本语言的支持",normalizedTitle:"javascript脚本语言的支持",charIndex:134},{level:2,title:"rule-source-ext-data支持在yml文件中的原生配置形式",slug:"rule-source-ext-data支持在yml文件中的原生配置形式",normalizedTitle:"rule-source-ext-data支持在yml文件中的原生配置形式",charIndex:1020},{level:2,title:"外置存储插件的报错无法抛出来",slug:"外置存储插件的报错无法抛出来",normalizedTitle:"外置存储插件的报错无法抛出来",charIndex:1479},{level:2,title:"提升框架的安全性",slug:"提升框架的安全性",normalizedTitle:"提升框架的安全性",charIndex:1620}],headersStr:"前言 Javascript脚本语言的支持 rule-source-ext-data支持在yml文件中的原生配置形式 外置存储插件的报错无法抛出来 提升框架的安全性",content:'# 前言\n\n其实从上一个版本开始，LiteFlow已经对脚本进行了大幅度的加强。目前脚本可以基本上可以代替java的逻辑进行书写。\n\n你甚至可以在脚本中定义定义类，定义方法。官方推荐的脚本语言首选是Groovy。\n\n在这次的2.9.1版本中，LiteFlow更是推出了Javascript脚本语言的支持。\n\n\n# Javascript脚本语言的支持\n\n你可以如下定义你的脚本节点，使用Javascript脚本语言\n\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本1" type="script" language="javascript">\n            <![CDATA[\n                var a=3;\n                var b=2;\n                var c=1;\n                var d=5;\n\n                function addByArray(values) {\n                    var sum = 0;\n                    for (var i = 0; i < values.length; i++) {\n                        sum += values[i];\n                    }\n                    return sum;\n                }\n\n                var result = addByArray([a,b,c,d]);\n\n                defaultContext.setData("s1",parseInt(result));\n            ]]>\n        </node>\n    </nodes>\n</flow>\n\n\n加上language信息是为了方便LiteFlowX做高亮提示。\n\n是的，这次同步发行的LiteFlowX新版本对Groovy和Javascript语法也作了高亮提示支持。让你在写脚本的时候更加得心应手。\n\n并且，在编译脚本的时候，也新增了脚本出错的提示，会在命令行里用箭头标出脚本出错的位置。\n\n详细文档请参考定义脚本组件这一章。\n\n\n# rule-source-ext-data支持在yml文件中的原生配置形式\n\n之前社区很多小伙伴在对springboot的yml形式的存储配置有点疑惑，怎么配置感觉都不对。\n\n其实之前的形式，在yml文件里有要配置成整个json为字符串的形式，这样似乎丧失了yml格式的便捷性。为此，LiteFlow 2.9.1版本支持了yml形式的原生外置存储的配置格式，你可以像如下进行配置：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://127.0.0.1:3306/poseidon\n    driverClassName: com.mysql.cj.jdbc.Driver\n    username: root\n    password: 123456\n    tableName: chain\n    elDataField: el_data\n\n\n详细文档请参考：ZK规则文件配置源，SQL数据库配置源，Nacos配置源，Etcd配置源。\n\n\n# 外置存储插件的报错无法抛出来\n\n之前提供的zk，sqldb，etcd，nacos之类的插件如果初始化或者执行的过程中发生异常，LiteFlow会吃掉其异常。这使得排错过程中大家会有点迷茫。\n\n这次LiteFlow 2.9.1版本中修复了此问题。规则存储插件的报错更加清晰。\n\n\n# 提升框架的安全性\n\nLiteFlow 2.9.1通过了墨菲安全的检测，为0风险框架！更新了可能存在安全漏洞的第三方依赖包。您可放心的使用。\n\n',normalizedContent:'# 前言\n\n其实从上一个版本开始，liteflow已经对脚本进行了大幅度的加强。目前脚本可以基本上可以代替java的逻辑进行书写。\n\n你甚至可以在脚本中定义定义类，定义方法。官方推荐的脚本语言首选是groovy。\n\n在这次的2.9.1版本中，liteflow更是推出了javascript脚本语言的支持。\n\n\n# javascript脚本语言的支持\n\n你可以如下定义你的脚本节点，使用javascript脚本语言\n\n<flow>\n    <nodes>\n        <node id="s1" name="普通脚本1" type="script" language="javascript">\n            <![cdata[\n                var a=3;\n                var b=2;\n                var c=1;\n                var d=5;\n\n                function addbyarray(values) {\n                    var sum = 0;\n                    for (var i = 0; i < values.length; i++) {\n                        sum += values[i];\n                    }\n                    return sum;\n                }\n\n                var result = addbyarray([a,b,c,d]);\n\n                defaultcontext.setdata("s1",parseint(result));\n            ]]>\n        </node>\n    </nodes>\n</flow>\n\n\n加上language信息是为了方便liteflowx做高亮提示。\n\n是的，这次同步发行的liteflowx新版本对groovy和javascript语法也作了高亮提示支持。让你在写脚本的时候更加得心应手。\n\n并且，在编译脚本的时候，也新增了脚本出错的提示，会在命令行里用箭头标出脚本出错的位置。\n\n详细文档请参考定义脚本组件这一章。\n\n\n# rule-source-ext-data支持在yml文件中的原生配置形式\n\n之前社区很多小伙伴在对springboot的yml形式的存储配置有点疑惑，怎么配置感觉都不对。\n\n其实之前的形式，在yml文件里有要配置成整个json为字符串的形式，这样似乎丧失了yml格式的便捷性。为此，liteflow 2.9.1版本支持了yml形式的原生外置存储的配置格式，你可以像如下进行配置：\n\nliteflow:\n  rule-source-ext-data-map:\n    url: jdbc:mysql://127.0.0.1:3306/poseidon\n    driverclassname: com.mysql.cj.jdbc.driver\n    username: root\n    password: 123456\n    tablename: chain\n    eldatafield: el_data\n\n\n详细文档请参考：zk规则文件配置源，sql数据库配置源，nacos配置源，etcd配置源。\n\n\n# 外置存储插件的报错无法抛出来\n\n之前提供的zk，sqldb，etcd，nacos之类的插件如果初始化或者执行的过程中发生异常，liteflow会吃掉其异常。这使得排错过程中大家会有点迷茫。\n\n这次liteflow 2.9.1版本中修复了此问题。规则存储插件的报错更加清晰。\n\n\n# 提升框架的安全性\n\nliteflow 2.9.1通过了墨菲安全的检测，为0风险框架！更新了可能存在安全漏洞的第三方依赖包。您可放心的使用。\n\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"What's New In LiteFlow v2.9.0?",frontmatter:{title:"What's New In LiteFlow v2.9.0?",date:"2022-10-07T12:43:18.000Z",permalink:"/pages/8ff001/"},regularPath:"/whats%20new/100.whats%20new%20in%20v2.9.0.html",relativePath:"whats new/100.whats new in v2.9.0.md",key:"v-1f450a8b",path:"/pages/8ff001/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"循环表达式",slug:"循环表达式",normalizedTitle:"循环表达式",charIndex:222},{level:2,title:"中间件的原生存储支持",slug:"中间件的原生存储支持",normalizedTitle:"中间件的原生存储支持",charIndex:826},{level:2,title:"方法级的声明式组件",slug:"方法级的声明式组件",normalizedTitle:"方法级的声明式组件",charIndex:1175},{level:2,title:"任意Bean均可引入至脚本",slug:"任意bean均可引入至脚本",normalizedTitle:"任意bean均可引入至脚本",charIndex:1442},{level:2,title:"支持单组件的多定义",slug:"支持单组件的多定义",normalizedTitle:"支持单组件的多定义",charIndex:1718},{level:2,title:"组件级别的规则参数设置",slug:"组件级别的规则参数设置",normalizedTitle:"组件级别的规则参数设置",charIndex:1896},{level:2,title:"选择组件支持标签选择",slug:"选择组件支持标签选择",normalizedTitle:"选择组件支持标签选择",charIndex:2279},{level:2,title:"去除了旧表达式的支持",slug:"去除了旧表达式的支持",normalizedTitle:"去除了旧表达式的支持",charIndex:2617}],headersStr:"前言 循环表达式 中间件的原生存储支持 方法级的声明式组件 任意Bean均可引入至脚本 支持单组件的多定义 组件级别的规则参数设置 选择组件支持标签选择 去除了旧表达式的支持",content:'# 前言\n\nLiteFlow v2.9.0版本带来了大量的特性，一共19个issue，还有数不清的优化。是所有发布的版本中特性最多的一次。\n\n我们纵向拓展了LiteFlow的深度，赋予新版本的LiteFlow在编排时拥有更多的能力，适应更多的场景。\n\n我们也同时横向拓展了LiteFlow的广度，推出了规则插件机制，赋予LiteFlow能支持更多的中间件的能力。\n\n让我们一起来看看此次2.9.0版本中我们新增了哪些激动人心的特性吧。\n\n\n# 循环表达式\n\n虽然之前LiteFlow在表达式层面拥有诸多的关键字，可以满足大部分的编排场景。但是在循环层面，并没有原生提供语法来支持。很多小伙伴只能依靠隐式流程自己来完成循环操作。\n\n在2.9.0版本中，我们新增了次数循环表达式和条件循环表达式。\n\n次数循环表达式：\n\n\x3c!-- 直接写数字 --\x3e\n<chain name="chain1">\n    FOR(5).DO(THEN(a, b, c);\n</chain>\n\x3c!-- 在java组件里获取次数 --\x3e\n<chain name="chain1">\n    FOR(x).DO(THEN(a, b, c);\n</chain>\n\n\n条件循环表达式：\n\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b, c);\n</chain>\n\n\n退出循环关键字：\n\n\x3c!-- BREAK可以和FOR...DO连用 --\x3e\n<chain name="chain1">\n    FOR(x).DO(THEN(a, b).BREAK(c);\n</chain>\n\x3c!-- BREAK可以和WHILE...DO连用 --\x3e\n<chain name="chain1">\n    WHILE(w).DO(THEN(a, b).BREAK(c);\n</chain>\n\n\n提示\n\n关于循环表达式的详细说明请查看循环编排章节。\n\n\n# 中间件的原生存储支持\n\n之前LiteFlow只支持本地文件和zk方式存储，如果你想用其他的方式存储规则，LiteFlow提供了扩展接口，需要使用者自己去实现。\n\n这无疑增加了一些使用成本。\n\n在v2.9.0版本中，官方从底层推出了规则存储插件机制，并一口气推出了SQL数据库，Nacos，Etcd的支持，当然之前的ZK支持也独立出了插件。\n\n使用插件，你无需再去自己扩展接口实现。只需引入插件。配置参数即可。大大降低了使用成本。\n\n当然，对于没提供的中间件插件实现，你依旧可以自行扩展去实现。\n\n提示\n\nZK规则插件详细说明：ZK规则文件配置源\n\nSQL数据库规则插件详细说明：SQL数据库配置源\n\nNacos规则插件详细说明：Nacos配置源\n\nEtcd规则插件详细说明：Etcd配置源\n\n\n# 方法级的声明式组件\n\n之前LiteFlow推出了声明式组件，不知道大家都用过没。\n\n声明式组件有一个最大的好处就是无侵入，你仅需通过注解就可以定义出一个组件。提供了自由扩展的可能。\n\n但是类声明组件也是需要一个类对应一个组件。如果你的组件超多，达到上百个，那就需要定义上百个类。造成了类爆炸的现象，不好管理。\n\nv2.9.0推出的方法级的声明式组件正好能解决这个痛点。新版本允许你在一个类里通过方法上的注解完成多个组件的声明。这一切仅仅需要一个注解即可完成。\n\n提示\n\n关于方法级的声明式的详细使用方法请参考：方法级别式声明\n\n\n# 任意Bean均可引入至脚本\n\n早在2.6.X的时候LiteFlow就支持了脚本编写，有些易变且简单的逻辑你可以用脚本来进行编写。\n\n但是之前的版本，脚本里只能引用上下文。\n\n有的小伙伴希望脚本拥有更多的能力，让脚本和java代码之间拥有更多的交互，比如用脚本读个文件？比如用脚本进行一次RPC的调用？\n\n这次v2.9.0带来了新的特性，任意Bean均可引入至脚本，换而言之，就是在脚本里可以调用任意Java Bean的对象。\n\n这一切只需要一个注解即可完成。\n\n提示\n\n关于脚本与Java之间交互的增强的详细使用方法请参考：与Java进行交互\n\n\n# 支持单组件的多定义\n\nLiteFlow之前的版本是不支持单组件多定义的，也就是把一个组件定义成不同的NodeId。如果你这样去定义，那这个组件总是被最后一个NodeId所覆盖。\n\nv2.9.0现在支持了这种定义方式，你可以用动态代码来构建组件，给同一个组件构建不同的nodeId。\n\n提示\n\n关于动态代码构建组件的详细使用方法请参考：如何动态构造\n\n\n# 组件级别的规则参数设置\n\n之前LiteFlow在规则层面是没法给组件设置额外的参数的。\n\n参数只有request层面的参数，由FlowExecutor调用的时候传入。大多数情况，reqeust传入的参数就已经够用了。\n\n但是当相同组件进行编排时，可能要在不同的位置设置不同的组件级参数，就没办法做到了。\n\n这次v2.9.0版本带来了这一特性的支持，新增了data关键词，你可以这样使用：\n\n<chain name="chain1">\n    cmpData = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n\n    THEN(\n        a,\n        b.data(cmpData),\n        c\n    );\n</chain>\n\n\n提示\n\n关于组件参数的使用详细请参考：组件参数\n\n\n# 选择组件支持标签选择\n\nLiteFlow以前的版本对于选择组件返回参数的定义是：只能返回可执行项的id，比如：\n\n<chain name="chain1">\n    SWITCH(s).to(a, b);\n</chain>\n\n\ns组件，要么返回a，要么返回b，要么返回空，除此之外的任何其他返回都会报错提示。\n\nv2.9.0现在支持对tag的选择了，你可以如下定义tag：\n\n<chain name="chain1">\n    SWITCH(s).to(a.tag("cat"), b.tag("dog"));\n</chain>\n\n\n那么要选择到b组件，除了可以返回"b"，还可以写返回："tag:dog"。\n\n提示\n\n关于选择支持标签写法的使用详细请参考：选择组件\n\n\n# 去除了旧表达式的支持\n\nLiteFlow在v2.6.X和v2.7.X阶段是用标签表达式来编排的。\n\n在v2.8.X版本全面转向了EL表达式，但是也是支持标签表达式的。算是一个兼容的版本。所以你会看到EL表达式的规则文件会要求用el.xml这种形式来定义。\n\n但是在v2.9.0中，我们移除了标签表达式的支持。以后将只会支持全新的EL表达式。\n\n所以从v2.9.0开始不再有文件扩展名的约束，你定义成*.xml还是*.el.xml都会支持。\n\n为了兼容大家的文档阅读体验，避免造成理解上的错乱，文档中的示例还是保留了*.el.xml这种形式。这点大家注意下。',normalizedContent:'# 前言\n\nliteflow v2.9.0版本带来了大量的特性，一共19个issue，还有数不清的优化。是所有发布的版本中特性最多的一次。\n\n我们纵向拓展了liteflow的深度，赋予新版本的liteflow在编排时拥有更多的能力，适应更多的场景。\n\n我们也同时横向拓展了liteflow的广度，推出了规则插件机制，赋予liteflow能支持更多的中间件的能力。\n\n让我们一起来看看此次2.9.0版本中我们新增了哪些激动人心的特性吧。\n\n\n# 循环表达式\n\n虽然之前liteflow在表达式层面拥有诸多的关键字，可以满足大部分的编排场景。但是在循环层面，并没有原生提供语法来支持。很多小伙伴只能依靠隐式流程自己来完成循环操作。\n\n在2.9.0版本中，我们新增了次数循环表达式和条件循环表达式。\n\n次数循环表达式：\n\n\x3c!-- 直接写数字 --\x3e\n<chain name="chain1">\n    for(5).do(then(a, b, c);\n</chain>\n\x3c!-- 在java组件里获取次数 --\x3e\n<chain name="chain1">\n    for(x).do(then(a, b, c);\n</chain>\n\n\n条件循环表达式：\n\n<chain name="chain1">\n    while(w).do(then(a, b, c);\n</chain>\n\n\n退出循环关键字：\n\n\x3c!-- break可以和for...do连用 --\x3e\n<chain name="chain1">\n    for(x).do(then(a, b).break(c);\n</chain>\n\x3c!-- break可以和while...do连用 --\x3e\n<chain name="chain1">\n    while(w).do(then(a, b).break(c);\n</chain>\n\n\n提示\n\n关于循环表达式的详细说明请查看循环编排章节。\n\n\n# 中间件的原生存储支持\n\n之前liteflow只支持本地文件和zk方式存储，如果你想用其他的方式存储规则，liteflow提供了扩展接口，需要使用者自己去实现。\n\n这无疑增加了一些使用成本。\n\n在v2.9.0版本中，官方从底层推出了规则存储插件机制，并一口气推出了sql数据库，nacos，etcd的支持，当然之前的zk支持也独立出了插件。\n\n使用插件，你无需再去自己扩展接口实现。只需引入插件。配置参数即可。大大降低了使用成本。\n\n当然，对于没提供的中间件插件实现，你依旧可以自行扩展去实现。\n\n提示\n\nzk规则插件详细说明：zk规则文件配置源\n\nsql数据库规则插件详细说明：sql数据库配置源\n\nnacos规则插件详细说明：nacos配置源\n\netcd规则插件详细说明：etcd配置源\n\n\n# 方法级的声明式组件\n\n之前liteflow推出了声明式组件，不知道大家都用过没。\n\n声明式组件有一个最大的好处就是无侵入，你仅需通过注解就可以定义出一个组件。提供了自由扩展的可能。\n\n但是类声明组件也是需要一个类对应一个组件。如果你的组件超多，达到上百个，那就需要定义上百个类。造成了类爆炸的现象，不好管理。\n\nv2.9.0推出的方法级的声明式组件正好能解决这个痛点。新版本允许你在一个类里通过方法上的注解完成多个组件的声明。这一切仅仅需要一个注解即可完成。\n\n提示\n\n关于方法级的声明式的详细使用方法请参考：方法级别式声明\n\n\n# 任意bean均可引入至脚本\n\n早在2.6.x的时候liteflow就支持了脚本编写，有些易变且简单的逻辑你可以用脚本来进行编写。\n\n但是之前的版本，脚本里只能引用上下文。\n\n有的小伙伴希望脚本拥有更多的能力，让脚本和java代码之间拥有更多的交互，比如用脚本读个文件？比如用脚本进行一次rpc的调用？\n\n这次v2.9.0带来了新的特性，任意bean均可引入至脚本，换而言之，就是在脚本里可以调用任意java bean的对象。\n\n这一切只需要一个注解即可完成。\n\n提示\n\n关于脚本与java之间交互的增强的详细使用方法请参考：与java进行交互\n\n\n# 支持单组件的多定义\n\nliteflow之前的版本是不支持单组件多定义的，也就是把一个组件定义成不同的nodeid。如果你这样去定义，那这个组件总是被最后一个nodeid所覆盖。\n\nv2.9.0现在支持了这种定义方式，你可以用动态代码来构建组件，给同一个组件构建不同的nodeid。\n\n提示\n\n关于动态代码构建组件的详细使用方法请参考：如何动态构造\n\n\n# 组件级别的规则参数设置\n\n之前liteflow在规则层面是没法给组件设置额外的参数的。\n\n参数只有request层面的参数，由flowexecutor调用的时候传入。大多数情况，reqeust传入的参数就已经够用了。\n\n但是当相同组件进行编排时，可能要在不同的位置设置不同的组件级参数，就没办法做到了。\n\n这次v2.9.0版本带来了这一特性的支持，新增了data关键词，你可以这样使用：\n\n<chain name="chain1">\n    cmpdata = \'{"name":"jack","age":27,"birth":"1995-10-01"}\';\n\n    then(\n        a,\n        b.data(cmpdata),\n        c\n    );\n</chain>\n\n\n提示\n\n关于组件参数的使用详细请参考：组件参数\n\n\n# 选择组件支持标签选择\n\nliteflow以前的版本对于选择组件返回参数的定义是：只能返回可执行项的id，比如：\n\n<chain name="chain1">\n    switch(s).to(a, b);\n</chain>\n\n\ns组件，要么返回a，要么返回b，要么返回空，除此之外的任何其他返回都会报错提示。\n\nv2.9.0现在支持对tag的选择了，你可以如下定义tag：\n\n<chain name="chain1">\n    switch(s).to(a.tag("cat"), b.tag("dog"));\n</chain>\n\n\n那么要选择到b组件，除了可以返回"b"，还可以写返回："tag:dog"。\n\n提示\n\n关于选择支持标签写法的使用详细请参考：选择组件\n\n\n# 去除了旧表达式的支持\n\nliteflow在v2.6.x和v2.7.x阶段是用标签表达式来编排的。\n\n在v2.8.x版本全面转向了el表达式，但是也是支持标签表达式的。算是一个兼容的版本。所以你会看到el表达式的规则文件会要求用el.xml这种形式来定义。\n\n但是在v2.9.0中，我们移除了标签表达式的支持。以后将只会支持全新的el表达式。\n\n所以从v2.9.0开始不再有文件扩展名的约束，你定义成*.xml还是*.el.xml都会支持。\n\n为了兼容大家的文档阅读体验，避免造成理解上的错乱，文档中的示例还是保留了*.el.xml这种形式。这点大家注意下。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"LF CLUB社区",frontmatter:{title:"LF CLUB社区",date:"2024-01-15T00:54:47.000Z",permalink:"/pages/8d8888/"},regularPath:"/%E4%BB%98%E8%B4%B9%E7%A4%BE%E5%8C%BA.html",relativePath:"付费社区.md",key:"v-1daaa968",path:"/pages/8d8888/",headersStr:null,content:"LF CLUB是由LiteFlow作者创办的高级付费社区\n\nLF CLUB能帮助到所有LiteFlow框架的使用者，以及想使用LiteFlow的潜在开发者。\n\nLF CLUB提供以下服务：\n\n1.每周发布一篇LF的解析精华系列。从头开始解析LF，只要跟着星球解析系列走，使用者一定能完全掌握LF。\n\n2.提供答疑服务，会员可以无限制提问，当天必定得到详细的回复和指导建议。\n\n3.每个加入的用户每年提供2次远程一对一答疑，远程协助服务。\n\n4.每1到2天会分享LF目前的进度，以及下一个版本的重点。\n\nLF CLUB里能解决你在使用LiteFlow框架时碰到的所有问题，并有系列课程能帮助你深刻理解LiteFlow框架，不同于微信社区，LF CLUB的问题优先级程度是最高的，且答疑非常详细。\n\n独家内容帮助深刻理解，不用在其他平台去搜索问题的答案。作者亲授，相当于随时拥有专家在身边，不用再去求助其他人。\n\n加入LF CLUB，请扫描以下二维码，或者直接点击图片也可以直达：\n\n",normalizedContent:"lf club是由liteflow作者创办的高级付费社区\n\nlf club能帮助到所有liteflow框架的使用者，以及想使用liteflow的潜在开发者。\n\nlf club提供以下服务：\n\n1.每周发布一篇lf的解析精华系列。从头开始解析lf，只要跟着星球解析系列走，使用者一定能完全掌握lf。\n\n2.提供答疑服务，会员可以无限制提问，当天必定得到详细的回复和指导建议。\n\n3.每个加入的用户每年提供2次远程一对一答疑，远程协助服务。\n\n4.每1到2天会分享lf目前的进度，以及下一个版本的重点。\n\nlf club里能解决你在使用liteflow框架时碰到的所有问题，并有系列课程能帮助你深刻理解liteflow框架，不同于微信社区，lf club的问题优先级程度是最高的，且答疑非常详细。\n\n独家内容帮助深刻理解，不用在其他平台去搜索问题的答案。作者亲授，相当于随时拥有专家在身边，不用再去求助其他人。\n\n加入lf club，请扫描以下二维码，或者直接点击图片也可以直达：\n\n",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"如何理解上下文这个概念？",frontmatter:{title:"如何理解上下文这个概念？",date:"2023-03-25T21:55:02.000Z",permalink:"/pages/e1e61f/"},regularPath:"/%E4%B8%93%E9%A2%98%E8%A7%A3%E9%87%8A/01.%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%B8%8A%E4%B8%8B%E6%96%87%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5%EF%BC%9F.html",relativePath:"专题解释/01.如何理解上下文这个概念？.md",key:"v-636d5f18",path:"/pages/e1e61f/",headers:[{level:2,title:"为什么要这么设计呢？",slug:"为什么要这么设计呢",normalizedTitle:"为什么要这么设计呢？",charIndex:146},{level:2,title:"上下文和请求参数有什么区别",slug:"上下文和请求参数有什么区别",normalizedTitle:"上下文和请求参数有什么区别",charIndex:623},{level:2,title:"上下文中的属性如何保证线程安全",slug:"上下文中的属性如何保证线程安全",normalizedTitle:"上下文中的属性如何保证线程安全",charIndex:2049},{level:2,title:"多上下文的使用场景",slug:"多上下文的使用场景",normalizedTitle:"多上下文的使用场景",charIndex:2190}],headersStr:"为什么要这么设计呢？ 上下文和请求参数有什么区别 上下文中的属性如何保证线程安全 多上下文的使用场景",content:'之前在上下文说明这一小章节已经阐述了上下文在LiteFlow框架中是非常重要的概念。\n\n如果有些新手同学对上下文这一概念还不理解，可以看看这小章的说明。\n\n\nLiteFlow所有的组件process方法都是无参无返回构造，组件之间的传递参数以及返回的数据都是通过上下文来进行操作的。\n\n\n# 为什么要这么设计呢？\n\n我们知道在java中调用方法，都是要通过方法名+参数进行调用的，要调用一个方法就必须提供这个方法所需的参数。A方法里调用B方法，等同于A方法强耦合了B方法。\n\n而LiteFlow的核心特性在于编排，如果每个方法名和参数都不一样，就无法做到可替换，可更换顺序。所以必须把组件都设计成一样的模式，消除每个组件的差异性，才能进行编排。\n\nLiteFlow的做法是设计成无参无返回模式，增加了上下文这一概念，业务组件所需要的参数从上下文取，所产出的结果也放到上下文中。\n\n这样设计有两大好处：\n\n * 每一个组件只和上下文发生联系，而无需和其他组件发生联系。这样就消除了组件与组件之间的耦合性。\n * 上下文中的数据是共享给当前请求中所有的组件的，我们平时写代码，如果调用关系是： A->B->C，如果A数据要传递给C，那么要一层层的传下去。而在LiteFlow中，如果A把数据放入上下文，则B和C都可以获取到。\n\n\n每一个请求会产生一个上下文对象，不同请求之间的上下文是隔离开来的。而每个请求结束后，当前的上下文会被销毁回收。\n\n\n# 上下文和请求参数有什么区别\n\n在LiteFlow中调用一个流程，经常会这么调用：\n\nflowExecutor.execute2Resp("chain1", requestArg, CustomContext.class);\n\n\nLiteFlow中请求初始参数和上下文不是一个东西。\n\n初始请求参数代表这个流程开始调用时，从这个流程外部传入的参数，这个初始参数也是贯穿整个流程的，任何一个组件都可以用this.getRequestData()获取到。\n\n上下文是用来存放组件之间产生的数据的，LiteFlow会去初始化这个上下文的class，形成一个全新的实例，在一开始，这个上下文里面是没有任何数据的，组件把执行完的结果数据放入，然后其他组件需要的时候再进行取出，同时链路的最终结果也应该放在上下文中，在组件中用this.getContextBean()获取。最终流程的response也能通过response.getContextBean()获取到。\n\n\n在社区里有一些同学这样写：\n\nCustomContext context = new CustomContext();\ncontext.setName("xxxx");\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", context, CustomContext.class);\n\n\n\n然后他在组件里这样取：\n\nCustomContext context = this.getContextBean(CustomContext.class);\nString name = context.getName();\n\n\n问我为什么name等于null。\n\n\n前面说到，LiteFlow中请求初始参数和上下文不是一个东西。\n\n所以，这些同学这么写，是把一个实例context单独作为了requestData，而this.getContextBean却是另外一个实例。\n\n其实requestData可以是任何对象，只不过这里传的初始参数恰好是CustomContext类型的而已，如果你想取到这个初始参数的CustomContext对象，依然用this.getRequestData() 来获取。\n\n\n然而有的同学就是想把初始参数包裹在上下文里面，怎么办，难道还专门在第一个组件里，把初始参数set进context里面吗？\n\nLiteFlow其实在文档中也有提到，可以传入已经初始化好的Context。\n\n应该这么写：\n\nCustomContext context = new CustomContext();\ncontext.setName("xxxx");\nLiteflowResponse response = flowExecutor.execute2Resp("chain1", null, context);\n\n\n\n其实这就是把初始参数和上下文揉到了一起的体现。\n\n\nLiteFlow的官方建议还是将初始参数和上下文区分开比较好，理由有以下2点：\n\n1.初始参数是不应该被更改的。而上下文里的数据可以随时被更改的。区分开来比较好\n\n2.初始参数可以是任何结构对象，而上下文只是各个组件运行态时所需要的数据对象。如果初始化参数对象被耦合到上下文对象结构里，则从分层理念上来说，是过于耦合了，不利于扩展。\n\n\n\n# 上下文中的属性如何保证线程安全\n\n由于组件编排存在着并发性(WHEN)，那么上下文的某一个对象可能同时会被多个组件访问，那么这时候如何保证线程安全性以及一致性呢。\n\n由于上下文对象是由使用者定义的，所以这个线程安全性需要由使用者来去处理。在问答中也有解释，跳转到相关问答。\n\n\n# 多上下文的使用场景\n\nLiteFlow支持在调用时传入多个上下文对象。很多小伙伴不明白这在什么场景使用。\n\n其实这个特性就是为一些通用组件来准备的。\n\n有的时候通用组件会被复用到很多流程中去。而每个流程的上下文又是不一样的。那么你可以为这个通用组件单独定义一个上下文，然后每次调用，你都传入2个上下文，一个为业务上下文，一个为通用组件上下文。使上下文之间的结构分离，完成通用编排。',normalizedContent:'之前在上下文说明这一小章节已经阐述了上下文在liteflow框架中是非常重要的概念。\n\n如果有些新手同学对上下文这一概念还不理解，可以看看这小章的说明。\n\n\nliteflow所有的组件process方法都是无参无返回构造，组件之间的传递参数以及返回的数据都是通过上下文来进行操作的。\n\n\n# 为什么要这么设计呢？\n\n我们知道在java中调用方法，都是要通过方法名+参数进行调用的，要调用一个方法就必须提供这个方法所需的参数。a方法里调用b方法，等同于a方法强耦合了b方法。\n\n而liteflow的核心特性在于编排，如果每个方法名和参数都不一样，就无法做到可替换，可更换顺序。所以必须把组件都设计成一样的模式，消除每个组件的差异性，才能进行编排。\n\nliteflow的做法是设计成无参无返回模式，增加了上下文这一概念，业务组件所需要的参数从上下文取，所产出的结果也放到上下文中。\n\n这样设计有两大好处：\n\n * 每一个组件只和上下文发生联系，而无需和其他组件发生联系。这样就消除了组件与组件之间的耦合性。\n * 上下文中的数据是共享给当前请求中所有的组件的，我们平时写代码，如果调用关系是： a->b->c，如果a数据要传递给c，那么要一层层的传下去。而在liteflow中，如果a把数据放入上下文，则b和c都可以获取到。\n\n\n每一个请求会产生一个上下文对象，不同请求之间的上下文是隔离开来的。而每个请求结束后，当前的上下文会被销毁回收。\n\n\n# 上下文和请求参数有什么区别\n\n在liteflow中调用一个流程，经常会这么调用：\n\nflowexecutor.execute2resp("chain1", requestarg, customcontext.class);\n\n\nliteflow中请求初始参数和上下文不是一个东西。\n\n初始请求参数代表这个流程开始调用时，从这个流程外部传入的参数，这个初始参数也是贯穿整个流程的，任何一个组件都可以用this.getrequestdata()获取到。\n\n上下文是用来存放组件之间产生的数据的，liteflow会去初始化这个上下文的class，形成一个全新的实例，在一开始，这个上下文里面是没有任何数据的，组件把执行完的结果数据放入，然后其他组件需要的时候再进行取出，同时链路的最终结果也应该放在上下文中，在组件中用this.getcontextbean()获取。最终流程的response也能通过response.getcontextbean()获取到。\n\n\n在社区里有一些同学这样写：\n\ncustomcontext context = new customcontext();\ncontext.setname("xxxx");\nliteflowresponse response = flowexecutor.execute2resp("chain1", context, customcontext.class);\n\n\n\n然后他在组件里这样取：\n\ncustomcontext context = this.getcontextbean(customcontext.class);\nstring name = context.getname();\n\n\n问我为什么name等于null。\n\n\n前面说到，liteflow中请求初始参数和上下文不是一个东西。\n\n所以，这些同学这么写，是把一个实例context单独作为了requestdata，而this.getcontextbean却是另外一个实例。\n\n其实requestdata可以是任何对象，只不过这里传的初始参数恰好是customcontext类型的而已，如果你想取到这个初始参数的customcontext对象，依然用this.getrequestdata() 来获取。\n\n\n然而有的同学就是想把初始参数包裹在上下文里面，怎么办，难道还专门在第一个组件里，把初始参数set进context里面吗？\n\nliteflow其实在文档中也有提到，可以传入已经初始化好的context。\n\n应该这么写：\n\ncustomcontext context = new customcontext();\ncontext.setname("xxxx");\nliteflowresponse response = flowexecutor.execute2resp("chain1", null, context);\n\n\n\n其实这就是把初始参数和上下文揉到了一起的体现。\n\n\nliteflow的官方建议还是将初始参数和上下文区分开比较好，理由有以下2点：\n\n1.初始参数是不应该被更改的。而上下文里的数据可以随时被更改的。区分开来比较好\n\n2.初始参数可以是任何结构对象，而上下文只是各个组件运行态时所需要的数据对象。如果初始化参数对象被耦合到上下文对象结构里，则从分层理念上来说，是过于耦合了，不利于扩展。\n\n\n\n# 上下文中的属性如何保证线程安全\n\n由于组件编排存在着并发性(when)，那么上下文的某一个对象可能同时会被多个组件访问，那么这时候如何保证线程安全性以及一致性呢。\n\n由于上下文对象是由使用者定义的，所以这个线程安全性需要由使用者来去处理。在问答中也有解释，跳转到相关问答。\n\n\n# 多上下文的使用场景\n\nliteflow支持在调用时传入多个上下文对象。很多小伙伴不明白这在什么场景使用。\n\n其实这个特性就是为一些通用组件来准备的。\n\n有的时候通用组件会被复用到很多流程中去。而每个流程的上下文又是不一样的。那么你可以为这个通用组件单独定义一个上下文，然后每次调用，你都传入2个上下文，一个为业务上下文，一个为通用组件上下文。使上下文之间的结构分离，完成通用编排。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"关于项目",frontmatter:{title:"关于项目",date:"2022-06-01T14:36:47.000Z",permalink:"/pages/8d7f1e/"},regularPath:"/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE.html",relativePath:"关于项目.md",key:"v-0b1d72b6",path:"/pages/8d7f1e/",headersStr:null,content:'LiteFlow于2019年诞生，在公司的核心项目上经过了大量生产上的验证后，帮助很多业务项目获得了更好的灵活性和扩展性。\n\nLiteFlow于2020年全面开源，迅速获得了很多人的关注。LiteFlow也获得了2021 年度 OSC 中国开源项目评选「最佳人气项目」 !\n\nLiteFlow于2022年获得了"Gitee最有价值开源项目"的称号！\n\n\nLiteFlow于2024年获得"GitCode G-Star毕业项目"认证！\n\n目前LiteFlow被运用在国内很多知名的公司核心项目上，为很多项目提供了一种解耦和编排式编程的解决方案。\n\nLiteFlow目前社区积极，维护和迭代工作也一直进行着。是一个年轻有生命力的开源项目。\n\n如果你喜欢LiteFlow，可以在Gitee，Github上star和fork。并进入社区群提问和探讨技术。\n\nLiteFlow的Gitee仓库：https://gitee.com/dromara/liteFlow\n\nLiteFlow的Github仓库：https://github.com/dromara/liteflow\n\n你也可以关注作者的公众号，这里会分享实用技术，梳理知识，在技术的道路上和你一起成长进步。\n\n',normalizedContent:'liteflow于2019年诞生，在公司的核心项目上经过了大量生产上的验证后，帮助很多业务项目获得了更好的灵活性和扩展性。\n\nliteflow于2020年全面开源，迅速获得了很多人的关注。liteflow也获得了2021 年度 osc 中国开源项目评选「最佳人气项目」 !\n\nliteflow于2022年获得了"gitee最有价值开源项目"的称号！\n\n\nliteflow于2024年获得"gitcode g-star毕业项目"认证！\n\n目前liteflow被运用在国内很多知名的公司核心项目上，为很多项目提供了一种解耦和编排式编程的解决方案。\n\nliteflow目前社区积极，维护和迭代工作也一直进行着。是一个年轻有生命力的开源项目。\n\n如果你喜欢liteflow，可以在gitee，github上star和fork。并进入社区群提问和探讨技术。\n\nliteflow的gitee仓库：https://gitee.com/dromara/liteflow\n\nliteflow的github仓库：https://github.com/dromara/liteflow\n\n你也可以关注作者的公众号，这里会分享实用技术，梳理知识，在技术的道路上和你一起成长进步。\n\n',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"加入社区讨论",frontmatter:{title:"加入社区讨论",date:"2022-06-01T14:45:45.000Z",permalink:"/pages/73c2c3/"},regularPath:"/%E5%8A%A0%E5%85%A5%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA.html",relativePath:"加入社区讨论.md",key:"v-49473fe3",path:"/pages/73c2c3/",headersStr:null,content:"LiteFlow是轻量，快速，稳定，可编排的组件式流程引擎，自从开源以来，我们收到了很多人的使用反馈，听取这些反馈进行迭代和新特性开发。\n\n如果你在使用中有问题，或者想咨询了解，可以加入群聊，我会细心答复每一个人的疑问。\n\n由于社区群十分庞大，需要邀请入群，你可以关注我的微信公众号，点击个人微信，加好友时备注liteflow，我会拉你入群。\n\n\n\n近期新增分群，可以自由扫码加入：\n\n同时也有QQ群，习惯QQ群的同学可以加群提问和反馈(主要以微信群为主，QQ群回复可能会稍慢)\n\nQQ群：720789088",normalizedContent:"liteflow是轻量，快速，稳定，可编排的组件式流程引擎，自从开源以来，我们收到了很多人的使用反馈，听取这些反馈进行迭代和新特性开发。\n\n如果你在使用中有问题，或者想咨询了解，可以加入群聊，我会细心答复每一个人的疑问。\n\n由于社区群十分庞大，需要邀请入群，你可以关注我的微信公众号，点击个人微信，加好友时备注liteflow，我会拉你入群。\n\n\n\n近期新增分群，可以自由扫码加入：\n\n同时也有qq群，习惯qq群的同学可以加群提问和反馈(主要以微信群为主，qq群回复可能会稍慢)\n\nqq群：720789088",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"升级到2.7.X说明",frontmatter:{title:"升级到2.7.X说明",date:"2022-06-28T23:37:14.000Z",permalink:"/pages/4848b9/"},regularPath:"/%E5%8D%87%E7%BA%A7%E5%88%B02.7.X%E8%AF%B4%E6%98%8E.html",relativePath:"升级到2.7.X说明.md",key:"v-59ace5bb",path:"/pages/4848b9/",headersStr:null,content:"2.7.X较2.6.X最大的不同点有2个：\n\n1.核心包的包路径有些许变化。但是类名都没变。\n\n2.对用户屏蔽了Slot，转而变成了上下文的概念。以前需要你自己自定义slot，现在则是变成了自定义上下文类。你可以把任意的Bean当做上下文传入。\n\n如果你想从2.6.X升级到2.7.X，你需要做以下事情：\n\n * 如果有些类import报红找不到，可以重新import。因为包路径发生了些许改变。\n * 以前你的Slot是extend AbsSlot的。现在你需要去掉继承AbsSlot(这个抽象类已经不存在)，然后最好重命名你的类变成XxxxContext形式。\n * 在组件里，以前你需要先取到Slot对象，然后才能获取数据。现在你需要改成取到上下文对象，this.getContextBean()这个方法就可以方便的取到上下文。\n * 因为Slot概念在2.7.X中对用户隐藏，但是它依旧存在，以前你获取初始参数是在组件内部通过slot.getRequestData()现在最好改成this.getRequestData()方法。\n\n提示\n\n其实很多方法，你依旧可以通过获取Slot对象再去调用获取。但是新版本里已经不推荐了。很多方法现在都可以在组件里通过this关键字去获取了。",normalizedContent:"2.7.x较2.6.x最大的不同点有2个：\n\n1.核心包的包路径有些许变化。但是类名都没变。\n\n2.对用户屏蔽了slot，转而变成了上下文的概念。以前需要你自己自定义slot，现在则是变成了自定义上下文类。你可以把任意的bean当做上下文传入。\n\n如果你想从2.6.x升级到2.7.x，你需要做以下事情：\n\n * 如果有些类import报红找不到，可以重新import。因为包路径发生了些许改变。\n * 以前你的slot是extend absslot的。现在你需要去掉继承absslot(这个抽象类已经不存在)，然后最好重命名你的类变成xxxxcontext形式。\n * 在组件里，以前你需要先取到slot对象，然后才能获取数据。现在你需要改成取到上下文对象，this.getcontextbean()这个方法就可以方便的取到上下文。\n * 因为slot概念在2.7.x中对用户隐藏，但是它依旧存在，以前你获取初始参数是在组件内部通过slot.getrequestdata()现在最好改成this.getrequestdata()方法。\n\n提示\n\n其实很多方法，你依旧可以通过获取slot对象再去调用获取。但是新版本里已经不推荐了。很多方法现在都可以在组件里通过this关键字去获取了。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"Slot是一个什么样的概念，在框架中起到什么样的作用？",frontmatter:{title:"Slot是一个什么样的概念，在框架中起到什么样的作用？",date:"2023-03-25T21:58:48.000Z",permalink:"/pages/ad60b4/"},regularPath:"/%E4%B8%93%E9%A2%98%E8%A7%A3%E9%87%8A/02.Slot%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%9C%A8%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%B5%B7%E5%88%B0%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F.html",relativePath:"专题解释/02.Slot是一个什么样的概念，在框架中起到什么样的作用？.md",key:"v-df9b805c",path:"/pages/ad60b4/",headersStr:null,content:"有使用者肯定发现了，在组件中通过this关键字，可以调用到this.getSlot() 这个方法，返回一个slot。\n\n那这个Slot是什么呢？在框架中起到什么样的作用？\n\n\nSlot对象是上下文的一个包装类。每一个请求，都会申请一个新的Slot对象，同时一个请求结束的时候，也会回收这个slot对象。\n\nLiteFlow框架声称的对于每个请求，上下文之间是隔离的，准确的来说，是Slot之间是隔离的。因为Slot隔离，所以上下文也隔离。上下文是Slot中的一个子项。\n\n\n上下文是用来存放组件中产生的业务数据的，而它的包装类Slot里，则存放着一些框架对于这次请求中的元数据。大多数情况下，用户是不需要关心的。\n\n\n大部分情况下，用户只要直接获得上下文就可以了。\n\n\n值得一提的是，slot的数量可能有些使用者会以为只有1024个，从而认为并发如果超过1024，slot就会分配不过来了。其实不然，LiteFlow框架从很早开始就加入了slot自动扩容的机制，当slot用完的时候，slot就会自动扩容。扩容因子为0.75，也就是说，每次扩容之后的数量为扩容之前的1.75倍。其实使用者是完全不用担心并发大，slot分配不过来的问题。",normalizedContent:"有使用者肯定发现了，在组件中通过this关键字，可以调用到this.getslot() 这个方法，返回一个slot。\n\n那这个slot是什么呢？在框架中起到什么样的作用？\n\n\nslot对象是上下文的一个包装类。每一个请求，都会申请一个新的slot对象，同时一个请求结束的时候，也会回收这个slot对象。\n\nliteflow框架声称的对于每个请求，上下文之间是隔离的，准确的来说，是slot之间是隔离的。因为slot隔离，所以上下文也隔离。上下文是slot中的一个子项。\n\n\n上下文是用来存放组件中产生的业务数据的，而它的包装类slot里，则存放着一些框架对于这次请求中的元数据。大多数情况下，用户是不需要关心的。\n\n\n大部分情况下，用户只要直接获得上下文就可以了。\n\n\n值得一提的是，slot的数量可能有些使用者会以为只有1024个，从而认为并发如果超过1024，slot就会分配不过来了。其实不然，liteflow框架从很早开始就加入了slot自动扩容的机制，当slot用完的时候，slot就会自动扩容。扩容因子为0.75，也就是说，每次扩容之后的数量为扩容之前的1.75倍。其实使用者是完全不用担心并发大，slot分配不过来的问题。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"升级到2.8.X说明",frontmatter:{title:"升级到2.8.X说明",date:"2022-06-01T14:31:18.000Z",permalink:"/pages/88c2e2/"},regularPath:"/%E5%8D%87%E7%BA%A7%E5%88%B02.8.X%E8%AF%B4%E6%98%8E.html",relativePath:"升级到2.8.X说明.md",key:"v-4c31868e",path:"/pages/88c2e2/",headers:[{level:2,title:"🌼2.7.X迁移到2.8.X版本注意事项",slug:"🌼2-7-x迁移到2-8-x版本注意事项",normalizedTitle:"🌼2.7.x迁移到2.8.x版本注意事项",charIndex:157},{level:3,title:"第一部分",slug:"第一部分",normalizedTitle:"第一部分",charIndex:183},{level:3,title:"第二部分",slug:"第二部分",normalizedTitle:"第二部分",charIndex:1150}],headersStr:"🌼2.7.X迁移到2.8.X版本注意事项 第一部分 第二部分",content:"此文档仅适用于从2.7.X升级到2.8.X的指南。\n\n如果你现在使用的版本是2.6.X，那么在升级到2.8.X之前，请先看升级到2.7.X说明。\n\n2.8.X是一个里程碑系列。设计了全新的EL形式的规则表达式。但是也保持了对原有规则的支持，使得以前版本的LiteFlow能够以相对平滑的方式迁移到新版本。\n\n\n# 🌼2.7.X迁移到2.8.X版本注意事项\n\n\n# 第一部分\n\n如果你不打算更换规则表达式的形式，你只需要做以下几点就可以了：\n\n 1. 原先的NodeCondComponent现在更名成为了NodeSwitchComponent，中文表达也从条件组件变更成了选择组件。\n    \n    并且要实现的方法也从processCond变更成了processSwitch。\n\n 2. 对于脚本组件来说，以前的脚本条件组件定义的type是cond_script，现在变成了switch_script，中文表达也从脚本条件组件变更成了脚本选择组件。\n\n 3. 对于声明式组件来说，以前的@LiteflowCondCmpDefine 更名成了@LiteflowSwitchCmpDefine,方法上的定义@LiteflowMethod(LiteFlowMethodEnum.PROCESS_COND)现在变更成了@LiteflowMethod(LiteFlowMethodEnum.PROCESS_SWITCH)。\n\n 4. 原先获取上下文的方式是在组件中调用this.getContextBean()，在2.8.X中需要传入上下文的Class。\n    \n    为什么多传入一个Class呢，因为2.8.X中支持了多上下文的全新特性。你取上下文需要改成以下形式：\n    \n    //推荐以下用法\n    YourContextBean contextBean = this.getContextBean(YourContextBean.class);\n    //2.8.X支持了多上下文的特性，如果你的上下文只有一个的话，用以下语句则和上面等价\n    YourContextBean contextBean = this.getFirstContextBean();\n    \n\n 5. LiteflowResponse对象原先需要定义成泛型的形式，现在不需要泛型了。直接写就可以了。Slot也是，没有泛型了，请在你的代码中去掉泛型。\n\n 6. 如果你的代码实现过LiteFlow的全局组件拦截接口ICmpAroundAspect，也请去掉相关泛型。\n\n 7. 新版本中去除了FlowExecutor直接返回数据上下文的用法，统一用LiteflowResponse类来接收。\n\n\n# 第二部分\n\n如果你想用新的规则表达式，除了第一部分要做以外，还要注意第二部分的变更\n\n 1. 你需要学习EL的表达语法，请参照EL规则的写法。你需要替换所有的规则表达式写法。\n\n 2. 你需要把规则文件名改成xxxx.el.xml的形式（如果不改名，还是会按以前的方式去解析，可能会报错）。\n\n 3. 如果你的规则文件是通过自定义配置源或者zk加载的，原先的写法是：\n    \n     #自定义配置源\n     liteflow.rule-source=xml:com.yomahub.liteflow.test.parsecustom.parser.CustomXmlFlowParser\n     #zk加载\n     liteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    \n    \n    现在需要把xml:变成el_xml，json和yaml也是同理。\n    \n    #自定义配置源\n    liteflow.rule-source=el_xml:com.yomahub.liteflow.test.parsecustom.parser.CustomXmlFlowParser\n    #zk加载\n    liteflow.rule-source=el_xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    \n\n 4. 如果你使用过LiteFlow的被动平滑刷新功能，并且规则已经变更成了EL表达式形式，以前的写法是：\n    \n    FlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_XML, newContent);\n    FlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_JSON, newContent);\n    FlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_YML, newContent);\n    \n    \n    现在需要更换FlowParserTypeEnum的枚举，变成这样：\n    \n    FlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_EL_XML, newContent);\n    FlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_EL_JSON, newContent);\n    FlowBus.refreshFlowMetaData(FlowParserTypeEnum.TYPE_EL_YML, newContent);\n    \n\n 5. 如果你的规则是基于代码动态构建的。现在的动态构建API更加简单，请参照用代码动态构造规则。",normalizedContent:"此文档仅适用于从2.7.x升级到2.8.x的指南。\n\n如果你现在使用的版本是2.6.x，那么在升级到2.8.x之前，请先看升级到2.7.x说明。\n\n2.8.x是一个里程碑系列。设计了全新的el形式的规则表达式。但是也保持了对原有规则的支持，使得以前版本的liteflow能够以相对平滑的方式迁移到新版本。\n\n\n# 🌼2.7.x迁移到2.8.x版本注意事项\n\n\n# 第一部分\n\n如果你不打算更换规则表达式的形式，你只需要做以下几点就可以了：\n\n 1. 原先的nodecondcomponent现在更名成为了nodeswitchcomponent，中文表达也从条件组件变更成了选择组件。\n    \n    并且要实现的方法也从processcond变更成了processswitch。\n\n 2. 对于脚本组件来说，以前的脚本条件组件定义的type是cond_script，现在变成了switch_script，中文表达也从脚本条件组件变更成了脚本选择组件。\n\n 3. 对于声明式组件来说，以前的@liteflowcondcmpdefine 更名成了@liteflowswitchcmpdefine,方法上的定义@liteflowmethod(liteflowmethodenum.process_cond)现在变更成了@liteflowmethod(liteflowmethodenum.process_switch)。\n\n 4. 原先获取上下文的方式是在组件中调用this.getcontextbean()，在2.8.x中需要传入上下文的class。\n    \n    为什么多传入一个class呢，因为2.8.x中支持了多上下文的全新特性。你取上下文需要改成以下形式：\n    \n    //推荐以下用法\n    yourcontextbean contextbean = this.getcontextbean(yourcontextbean.class);\n    //2.8.x支持了多上下文的特性，如果你的上下文只有一个的话，用以下语句则和上面等价\n    yourcontextbean contextbean = this.getfirstcontextbean();\n    \n\n 5. liteflowresponse对象原先需要定义成泛型的形式，现在不需要泛型了。直接写就可以了。slot也是，没有泛型了，请在你的代码中去掉泛型。\n\n 6. 如果你的代码实现过liteflow的全局组件拦截接口icmparoundaspect，也请去掉相关泛型。\n\n 7. 新版本中去除了flowexecutor直接返回数据上下文的用法，统一用liteflowresponse类来接收。\n\n\n# 第二部分\n\n如果你想用新的规则表达式，除了第一部分要做以外，还要注意第二部分的变更\n\n 1. 你需要学习el的表达语法，请参照el规则的写法。你需要替换所有的规则表达式写法。\n\n 2. 你需要把规则文件名改成xxxx.el.xml的形式（如果不改名，还是会按以前的方式去解析，可能会报错）。\n\n 3. 如果你的规则文件是通过自定义配置源或者zk加载的，原先的写法是：\n    \n     #自定义配置源\n     liteflow.rule-source=xml:com.yomahub.liteflow.test.parsecustom.parser.customxmlflowparser\n     #zk加载\n     liteflow.rule-source=xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    \n    \n    现在需要把xml:变成el_xml，json和yaml也是同理。\n    \n    #自定义配置源\n    liteflow.rule-source=el_xml:com.yomahub.liteflow.test.parsecustom.parser.customxmlflowparser\n    #zk加载\n    liteflow.rule-source=el_xml:127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183\n    \n\n 4. 如果你使用过liteflow的被动平滑刷新功能，并且规则已经变更成了el表达式形式，以前的写法是：\n    \n    flowbus.refreshflowmetadata(flowparsertypeenum.type_xml, newcontent);\n    flowbus.refreshflowmetadata(flowparsertypeenum.type_json, newcontent);\n    flowbus.refreshflowmetadata(flowparsertypeenum.type_yml, newcontent);\n    \n    \n    现在需要更换flowparsertypeenum的枚举，变成这样：\n    \n    flowbus.refreshflowmetadata(flowparsertypeenum.type_el_xml, newcontent);\n    flowbus.refreshflowmetadata(flowparsertypeenum.type_el_json, newcontent);\n    flowbus.refreshflowmetadata(flowparsertypeenum.type_el_yml, newcontent);\n    \n\n 5. 如果你的规则是基于代码动态构建的。现在的动态构建api更加简单，请参照用代码动态构造规则。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"升级到2.9.X说明",frontmatter:{title:"升级到2.9.X说明",date:"2022-10-07T12:43:18.000Z",permalink:"/pages/88c2f3/"},regularPath:"/%E5%8D%87%E7%BA%A7%E5%88%B02.9.X%E8%AF%B4%E6%98%8E.html",relativePath:"升级到2.9.X说明.md",key:"v-5a2193b7",path:"/pages/88c2f3/",headers:[{level:2,title:"2.8.X升级到2.9.X的注意事项",slug:"_2-8-x升级到2-9-x的注意事项",normalizedTitle:"2.8.x升级到2.9.x的注意事项",charIndex:119}],headersStr:"2.8.X升级到2.9.X的注意事项",content:"此文档仅适用于从2.8.X升级到2.9.X的指南。如果你处于以前的版本，按照下面提示一级级的升上去。\n\n如果你现在正处在2.6.X阶段，请先看升级到2.7.X说明。\n\n如果你现在正处于2.7.X阶段，请先看升级到2.8.X说明。\n\n\n# 2.8.X升级到2.9.X的注意事项\n\nLiteFlow v2.9.X版本提供了相当多的特性，在核心用法上兼容了2.8.X。\n\n绝大部分人都可以从2.8.X平滑的升级到2.9.X，不需要做任何改动，如果你涉及到以下几点，可能会花个5分钟时间改下：\n\n 1. LiteFlow v2.9.X版本移除了对老的表达式的支持，标签形式的<then><when>这种不再支持，全面转向了EL规则语法。如果你还想用旧的标签语法，那么v2.8.5是最后一个兼容的版本。\n 2. LiteFlow v2.9.X版本不再约束一定要使用*.el.xml/*.el.json/*.el.yml这种类似的扩展名，你可以使用*.xml/*.json/*.yml这样的扩展名。但是在文档示例层面，为了兼容还是使用的是*.el.xml这样的扩展名。文档层面不再做说明了，您继续沿用*.el.xml这样的扩展名也是可以的。\n 3. 如果您之前使用了Zookeeper作为存储介质，那么在2.9.X版本中，您可以能要稍微修改下。因为这次v2.9.0版本对存储介质做了插件化处理，具体请参考ZK规则文件配置。\n 4. 如果您之前使用了声明式组件特性，那么在2.9.X版本中，您可能也要稍微的修改下。2.9.X版本对声明式组件作了重新的设计，不仅支持类声明，也支持方法级别的单类多声明特性了。具体请参考类级别式声明。",normalizedContent:"此文档仅适用于从2.8.x升级到2.9.x的指南。如果你处于以前的版本，按照下面提示一级级的升上去。\n\n如果你现在正处在2.6.x阶段，请先看升级到2.7.x说明。\n\n如果你现在正处于2.7.x阶段，请先看升级到2.8.x说明。\n\n\n# 2.8.x升级到2.9.x的注意事项\n\nliteflow v2.9.x版本提供了相当多的特性，在核心用法上兼容了2.8.x。\n\n绝大部分人都可以从2.8.x平滑的升级到2.9.x，不需要做任何改动，如果你涉及到以下几点，可能会花个5分钟时间改下：\n\n 1. liteflow v2.9.x版本移除了对老的表达式的支持，标签形式的<then><when>这种不再支持，全面转向了el规则语法。如果你还想用旧的标签语法，那么v2.8.5是最后一个兼容的版本。\n 2. liteflow v2.9.x版本不再约束一定要使用*.el.xml/*.el.json/*.el.yml这种类似的扩展名，你可以使用*.xml/*.json/*.yml这样的扩展名。但是在文档示例层面，为了兼容还是使用的是*.el.xml这样的扩展名。文档层面不再做说明了，您继续沿用*.el.xml这样的扩展名也是可以的。\n 3. 如果您之前使用了zookeeper作为存储介质，那么在2.9.x版本中，您可以能要稍微修改下。因为这次v2.9.0版本对存储介质做了插件化处理，具体请参考zk规则文件配置。\n 4. 如果您之前使用了声明式组件特性，那么在2.9.x版本中，您可能也要稍微的修改下。2.9.x版本对声明式组件作了重新的设计，不仅支持类声明，也支持方法级别的单类多声明特性了。具体请参考类级别式声明。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"参与开发",frontmatter:{title:"参与开发",date:"2022-06-01T18:54:08.000Z",permalink:"/pages/ae4dd5/"},regularPath:"/%E5%8F%82%E4%B8%8E%E5%BC%80%E5%8F%91.html",relativePath:"参与开发.md",key:"v-66788692",path:"/pages/ae4dd5/",headers:[{level:2,title:"我要如何做才能成为Committer",slug:"我要如何做才能成为committer",normalizedTitle:"我要如何做才能成为committer",charIndex:42},{level:2,title:"对于长期Committer的要求",slug:"对于长期committer的要求",normalizedTitle:"对于长期committer的要求",charIndex:314},{level:2,title:"提交PR",slug:"提交pr",normalizedTitle:"提交pr",charIndex:444},{level:2,title:"注释以及Comment的要求",slug:"注释以及comment的要求",normalizedTitle:"注释以及comment的要求",charIndex:724},{level:2,title:"写代码时要注意的点",slug:"写代码时要注意的点",normalizedTitle:"写代码时要注意的点",charIndex:1034}],headersStr:"我要如何做才能成为Committer 对于长期Committer的要求 提交PR 注释以及Comment的要求 写代码时要注意的点",content:"我希望对开源有热情的童鞋都来贡献LiteFlow，让这个项目变的越来越好。\n\n\n# 我要如何做才能成为Committer\n\n需要你对开源有热情，技术扎实，有一颗用爱发电的心。\n\n你需要加入LiteFlow的社区群，如何加入请参考加入社区讨论，然后私聊我，表示有意成为开发者。\n\n你需要熟读源码，理解核心代码的逻辑。\n\n然后可以去issue页查看issue列表并进行认领。\n\n或者你有相关建议自己进行创建issue并进行修复也是可以的。\n\n在相关issue下回复“认领”就可以了，然后私聊告诉我。如果已经有相关同学已经认领了，请不要重复认领。\n\n完成3个issue并成功通过审核并合并，我会邀请你成为Committer。\n\n\n# 对于长期Committer的要求\n\n * 需要对开源有热情，技术扎实，有一颗用爱发电的心。\n\n * 理解核心代码逻辑。时刻保持学习的心。\n\n * 需要每个月贡献至少1个PR并成功通过审核并合并。\n\n * 需要参与社区群的建设，积极回答问题和进行宣传。\n\n\n# 提交PR\n\nLiteFlow的PR统一在Gitee平台上进行提交，如果你不知道如何提交PR，可以在Gitee平台里去学习。这里不作说明。\n\n提PR有以下注意点。\n\n * fork后切换到dev分支，请以这个分支为开发基准。\n * 所有的PR提交到dev分支，这个分支为开发分支。\n * 如果你作了功能性的变动，请带上你的测试用例，测试用例规范可以参考之前的测试用例。\n * 所有的PR必须关联至少一个issue，如果没有相关issue，请自行创建一个。\n * 正式提交PR之前，请确保所有的测试用例都通过。\n * 提交信息，均要符合要求，下面有讲述。\n\n\n# 注释以及Comment的要求\n\n在文件头上，一定得有相关头注释信息，请按照规范，如下所示：\n\n/**\n * 这是你对这个类的描述，如比较长，多行也行\n * @author Bryan.Zhang\n * @since 2.6.4\n */\npublic class YourClass{\n\t...\n}\n\n\n相关重要代码，为了保证阅读性，也请加上必要的注释\n\n提交的时候comment也要按照规范来填写：\n\n#bug/feature/enhancement/ #issue号 这是你issue的中文描述\n\n\n举例：\n\nenhancemnet #I595MU 在slot的元数据里增加每个组件执行的耗时和是否成功结果\n\n\n\n# 写代码时要注意的点\n\n开源框架的代码质量的要求会比较高，不仅是实现那么简单，还要考虑到各个环境的兼容性，优雅性和可读性。\n\n所以在写代码时要多想一下。我相信，高标准高要求才能塑造一个优秀的框架。\n\n在代码合并时，我会在PR下面给出修改意见，可能会比较苛刻，吹毛求疵点。请大家谅解，完全是针对代码质量而不是针对谁。",normalizedContent:"我希望对开源有热情的童鞋都来贡献liteflow，让这个项目变的越来越好。\n\n\n# 我要如何做才能成为committer\n\n需要你对开源有热情，技术扎实，有一颗用爱发电的心。\n\n你需要加入liteflow的社区群，如何加入请参考加入社区讨论，然后私聊我，表示有意成为开发者。\n\n你需要熟读源码，理解核心代码的逻辑。\n\n然后可以去issue页查看issue列表并进行认领。\n\n或者你有相关建议自己进行创建issue并进行修复也是可以的。\n\n在相关issue下回复“认领”就可以了，然后私聊告诉我。如果已经有相关同学已经认领了，请不要重复认领。\n\n完成3个issue并成功通过审核并合并，我会邀请你成为committer。\n\n\n# 对于长期committer的要求\n\n * 需要对开源有热情，技术扎实，有一颗用爱发电的心。\n\n * 理解核心代码逻辑。时刻保持学习的心。\n\n * 需要每个月贡献至少1个pr并成功通过审核并合并。\n\n * 需要参与社区群的建设，积极回答问题和进行宣传。\n\n\n# 提交pr\n\nliteflow的pr统一在gitee平台上进行提交，如果你不知道如何提交pr，可以在gitee平台里去学习。这里不作说明。\n\n提pr有以下注意点。\n\n * fork后切换到dev分支，请以这个分支为开发基准。\n * 所有的pr提交到dev分支，这个分支为开发分支。\n * 如果你作了功能性的变动，请带上你的测试用例，测试用例规范可以参考之前的测试用例。\n * 所有的pr必须关联至少一个issue，如果没有相关issue，请自行创建一个。\n * 正式提交pr之前，请确保所有的测试用例都通过。\n * 提交信息，均要符合要求，下面有讲述。\n\n\n# 注释以及comment的要求\n\n在文件头上，一定得有相关头注释信息，请按照规范，如下所示：\n\n/**\n * 这是你对这个类的描述，如比较长，多行也行\n * @author bryan.zhang\n * @since 2.6.4\n */\npublic class yourclass{\n\t...\n}\n\n\n相关重要代码，为了保证阅读性，也请加上必要的注释\n\n提交的时候comment也要按照规范来填写：\n\n#bug/feature/enhancement/ #issue号 这是你issue的中文描述\n\n\n举例：\n\nenhancemnet #i595mu 在slot的元数据里增加每个组件执行的耗时和是否成功结果\n\n\n\n# 写代码时要注意的点\n\n开源框架的代码质量的要求会比较高，不仅是实现那么简单，还要考虑到各个环境的兼容性，优雅性和可读性。\n\n所以在写代码时要多想一下。我相信，高标准高要求才能塑造一个优秀的框架。\n\n在代码合并时，我会在pr下面给出修改意见，可能会比较苛刻，吹毛求疵点。请大家谅解，完全是针对代码质量而不是针对谁。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"支持",frontmatter:{title:"支持",date:"2022-06-01T19:01:33.000Z",permalink:"/pages/fb599d/"},regularPath:"/%E6%94%AF%E6%8C%81/01.%E6%94%AF%E6%8C%81.html",relativePath:"支持/01.支持.md",key:"v-0276baae",path:"/pages/fb599d/",headers:[{level:2,title:"用爱发电",slug:"用爱发电",normalizedTitle:"用爱发电",charIndex:2},{level:2,title:"赞助我们",slug:"赞助我们",normalizedTitle:"赞助我们",charIndex:183},{level:2,title:"赞助商广告",slug:"赞助商广告",normalizedTitle:"赞助商广告",charIndex:300}],headersStr:"用爱发电 赞助我们 赞助商广告",content:"# 用爱发电\n\nLiteFlow在2年前开源，在这2年期间LiteFlow已经逐渐成长为国内规则引擎框架中不可忽视的一款框架。\n\n这背后无疑是大量业余时间成本的付出。\n\n我希望可以借由开源的技术输出来帮助到一些人，无论你使用它来设计系统或者学习它，或是在社群群向我提问。\n\n我会长期坚持去完善这个项目，希望可以把LiteFlow带入国内顶尖开源项目的行列。\n\n\n# 赞助我们\n\n如果LiteFlow实实在在的帮助到了您，您可以打开微信手机端扫描以下微信赞赏码赞助我们的开发。\n\n查看赞助列表。\n\n非常感谢您的支持，正是因为你们，中国开源项目才会越来越蓬勃发展，LiteFlow也能越走越远。\n\n\n# 赞助商广告\n\nLiteFlow是基于Apache-2.0开源的项目，但我们每年都在支付第三方域名，云服务器，CDN流量费，推广开发费用。为了项目能够健康长久的发展下去，我们在LiteFlow官网提供多个赞助商广告位。\n\n如您在LiteFlow官网投放广告，可获得首页以及文档所有页面的展示，目前LiteFlow官网流量大概每月在60w pv以上。\n\n合作方式：\n\n * 合作费用：请加联系方式询问\n * 电子邮箱：weenyc31@163.com\n * 微信：bryan_31（非诚勿扰）\n\n准备材料：\n\n * 首页特别赞助LOGO图：大小控制在100k以内\n * 首页特别赞助描述文字：一段不超过30字的简单介绍\n * 文档页banner图片格式：448px X 120px，支持gif动图，大小控制在500KB以内\n * 链接URL格式：https://xxx.com?from=liteflow",normalizedContent:"# 用爱发电\n\nliteflow在2年前开源，在这2年期间liteflow已经逐渐成长为国内规则引擎框架中不可忽视的一款框架。\n\n这背后无疑是大量业余时间成本的付出。\n\n我希望可以借由开源的技术输出来帮助到一些人，无论你使用它来设计系统或者学习它，或是在社群群向我提问。\n\n我会长期坚持去完善这个项目，希望可以把liteflow带入国内顶尖开源项目的行列。\n\n\n# 赞助我们\n\n如果liteflow实实在在的帮助到了您，您可以打开微信手机端扫描以下微信赞赏码赞助我们的开发。\n\n查看赞助列表。\n\n非常感谢您的支持，正是因为你们，中国开源项目才会越来越蓬勃发展，liteflow也能越走越远。\n\n\n# 赞助商广告\n\nliteflow是基于apache-2.0开源的项目，但我们每年都在支付第三方域名，云服务器，cdn流量费，推广开发费用。为了项目能够健康长久的发展下去，我们在liteflow官网提供多个赞助商广告位。\n\n如您在liteflow官网投放广告，可获得首页以及文档所有页面的展示，目前liteflow官网流量大概每月在60w pv以上。\n\n合作方式：\n\n * 合作费用：请加联系方式询问\n * 电子邮箱：weenyc31@163.com\n * 微信：bryan_31（非诚勿扰）\n\n准备材料：\n\n * 首页特别赞助logo图：大小控制在100k以内\n * 首页特别赞助描述文字：一段不超过30字的简单介绍\n * 文档页banner图片格式：448px x 120px，支持gif动图，大小控制在500kb以内\n * 链接url格式：https://xxx.com?from=liteflow",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"赞助者列表",frontmatter:{title:"赞助者列表",date:"2022-06-02T11:37:17.000Z",permalink:"/pages/b52ac5/"},regularPath:"/%E6%94%AF%E6%8C%81/02.%E8%B5%9E%E5%8A%A9%E8%80%85%E5%88%97%E8%A1%A8.html",relativePath:"支持/02.赞助者列表.md",key:"v-7ddee6a8",path:"/pages/b52ac5/",headersStr:null,content:"赞助人            赞助金额/设备      TA的留言/分享                 赞助时间         投放链接\n一个小目标          ￥6.66        加油加油！！！                  2024-05-09   无\n飘渺             ￥20          很好用的框架，值得学习和钻研           2024-04-22   无\n吕东润            ￥10          无                        2024-04-17   无\n安静             ￥66.66       加油啊！                     2024-04-02   无\n明神月            ￥100         加油                       2024-04-01   无\n冰山             ￥10          开发不易 愿持续精进               2024-03-06   无\n丁明威            ￥10          对于Zookeeper认证的支持可以增强一下   2024-02-28   无\n冯尚居            ￥            无                        2024-01-11   无\n我应在江湖          ￥10          希望编排界面排上日程               2023-12-22   无\n嘻嘻哈哈           ￥6.66        嘻嘻哈哈                     2023-12-15   无\n陈峰             ￥50          非常棒                      2023-12-13   无\n高国栋            ￥20          看了文档都觉得很辛苦，              2023-11-16   无\n                            对比了下drool，你做的很棒👍\n🦀             ￥100         无                        2023-11-02   无\n孟拯             ￥20          加油                       2023-11-02   无\n曹红波            ￥50          无                        2023-10-16   无\n川风页            ￥5           准备使用liteflow啦，先研究研究      2023-10-08   无\nRe0            ￥10          膜拜大神                     2023-10-07   无\n夜未央            ￥10          无                        2023-09-20   无\nRaowl          ￥20          产品很棒，希望越来越好，加油           2023-09-14   无\nWMS熊孝猛         ￥50          请您喝杯酱香拿铁☕️               2023-09-11   无\n可不可以           ￥30          咖啡咖啡                     2023-09-11   无\n🙄             ￥20          无                        2023-09-04   无\n万万             ￥50          buy coffee for you       2023-08-22   无\n小枫             ￥9.9         瑞一下                      2023-08-17   无\nxao            ￥5           优秀                       2023-08-13   无\n江秦             ￥10          大佬喝杯生椰拿铁                 2023-08-09   无\n匿名             ￥5           无                        2023-07-08   无\n李春             ￥20          谢谢，回答！                   2023-07-06   无\n                            一直关注你这个开源项目！\n                            近期考虑再项目中使用！\n乡间小路           ￥5           加油                       2023-07-03   无\n三人行            ￥20          再感谢东哥的2个工程               2023-06-21   无\n琉璃             ￥50          请你喝杯星巴克                  2023-06-16   无\n小黄人            ￥10          加油，期待可视化                 2023-06-14   无\n小韩想放假          ￥18.88       大佬下午喝杯咖啡                 2023-06-04   无\n鄧              ￥100         正在努力的学习使用，加油             2023-05-22   无\n小微有发展          ￥50          为有情怀的人，点个赞！              2023-05-11   无\nOne-fit        ￥100         请东哥喝杯咖啡                  2023-04-21   无\n张凯杰            ￥10          好项目必须赞助一波                2023-04-20   无\n臧学强            ￥50          开源不易，支持                  2023-04-12   无\nMr.Yang        ￥5           无                        2023-04-12   无\n刘航军            ￥50          赞助一杯咖啡                   2023-04-07   无\n水滴             ￥50          开源不易，支持                  2023-03-30   无\n子锋             ￥5           无                        2023-02-01   无\n流云             ￥50          感谢lz的耐心回答了我的疑惑哈          2022-12-29   无\nThott          ￥10          开源不易，坚持更难                2022-12-05   无\n                            liteflow让我学到很多\n🍦             ￥10          请大佬喝杯汽水                  2022-11-23   无\n清澄心            ￥50          感谢你们做出好用的业务流程引擎          2022-11-08   无\n                            而且很热情！\n李              ￥20          感谢大佬无私的开源分享与解答           2022-11-08   无\n                            祝越来越好\n微笑😊           ￥20          微笑😊                     2022-11-07   无\nfaraway        ￥10          群主牛逼，祝你永远梆硬              2022-11-04   无\nMr.陈           ￥10          开源不易                     2022-10-17   无\n[太阳]哈哈敬        ￥20          大佬喝coffee                2022-10-14   无\n李庚谱            ￥200         开源不易，请一起坚持下去。            2022-08-29   无\nDAG            ￥50          很好用的产品👍                 2022-08-22   无\n顾～小诺           ￥18.8        我是支持群主的                  2022-08-17   无\nlls            ￥50          大赞的项目                    2022-08-10   无\nqinkawngdeid   ￥50          开源高尚 祝越来越好               2022-07-26   无\nssssss         ￥50          佬，菜，带                    2022-07-21   无\n-小龙            ￥20          无                        2022-07-18   无\n姜建林            ￥100         PPT真棒，期待可视化前端编排          2022-07-18   无\n小马             ￥50          请大佬喝杯咖啡                  2022-07-15   无\n安.             ￥50          大佬牛逼，期待liteflow的可视化      2022-07-12   无\n辻弌之人           ￥20          支持国产开源                   2022-07-11   无\n李志永            ￥50          支持国产开源软件！                2022-07-06   无\nnoear          ￥200         支持国产开源:-)                2022-07-04   无\n雪落花香           ￥100         投放一个链接                   2022-06-29   ERD-ONLINE\n小马             腾讯云服务器       捐献你一个腾讯云服务器              2022-06-15   无\n               (2C/4G/6M)\n书虫             ￥5           谢谢，你的无私奉献                2022-06-02   无\n姜建林            ￥100         无                        2022-05-16   无\n这是我大哥          ￥50          京东用于组件改造                 2022-04-08   无\n                            感谢提供思路\n🎱             ￥20          送大佬一杯咖啡☕️                2022-03-18   无",normalizedContent:"赞助人            赞助金额/设备      ta的留言/分享                 赞助时间         投放链接\n一个小目标          ￥6.66        加油加油！！！                  2024-05-09   无\n飘渺             ￥20          很好用的框架，值得学习和钻研           2024-04-22   无\n吕东润            ￥10          无                        2024-04-17   无\n安静             ￥66.66       加油啊！                     2024-04-02   无\n明神月            ￥100         加油                       2024-04-01   无\n冰山             ￥10          开发不易 愿持续精进               2024-03-06   无\n丁明威            ￥10          对于zookeeper认证的支持可以增强一下   2024-02-28   无\n冯尚居            ￥            无                        2024-01-11   无\n我应在江湖          ￥10          希望编排界面排上日程               2023-12-22   无\n嘻嘻哈哈           ￥6.66        嘻嘻哈哈                     2023-12-15   无\n陈峰             ￥50          非常棒                      2023-12-13   无\n高国栋            ￥20          看了文档都觉得很辛苦，              2023-11-16   无\n                            对比了下drool，你做的很棒👍\n🦀             ￥100         无                        2023-11-02   无\n孟拯             ￥20          加油                       2023-11-02   无\n曹红波            ￥50          无                        2023-10-16   无\n川风页            ￥5           准备使用liteflow啦，先研究研究      2023-10-08   无\nre0            ￥10          膜拜大神                     2023-10-07   无\n夜未央            ￥10          无                        2023-09-20   无\nraowl          ￥20          产品很棒，希望越来越好，加油           2023-09-14   无\nwms熊孝猛         ￥50          请您喝杯酱香拿铁☕️               2023-09-11   无\n可不可以           ￥30          咖啡咖啡                     2023-09-11   无\n🙄             ￥20          无                        2023-09-04   无\n万万             ￥50          buy coffee for you       2023-08-22   无\n小枫             ￥9.9         瑞一下                      2023-08-17   无\nxao            ￥5           优秀                       2023-08-13   无\n江秦             ￥10          大佬喝杯生椰拿铁                 2023-08-09   无\n匿名             ￥5           无                        2023-07-08   无\n李春             ￥20          谢谢，回答！                   2023-07-06   无\n                            一直关注你这个开源项目！\n                            近期考虑再项目中使用！\n乡间小路           ￥5           加油                       2023-07-03   无\n三人行            ￥20          再感谢东哥的2个工程               2023-06-21   无\n琉璃             ￥50          请你喝杯星巴克                  2023-06-16   无\n小黄人            ￥10          加油，期待可视化                 2023-06-14   无\n小韩想放假          ￥18.88       大佬下午喝杯咖啡                 2023-06-04   无\n鄧              ￥100         正在努力的学习使用，加油             2023-05-22   无\n小微有发展          ￥50          为有情怀的人，点个赞！              2023-05-11   无\none-fit        ￥100         请东哥喝杯咖啡                  2023-04-21   无\n张凯杰            ￥10          好项目必须赞助一波                2023-04-20   无\n臧学强            ￥50          开源不易，支持                  2023-04-12   无\nmr.yang        ￥5           无                        2023-04-12   无\n刘航军            ￥50          赞助一杯咖啡                   2023-04-07   无\n水滴             ￥50          开源不易，支持                  2023-03-30   无\n子锋             ￥5           无                        2023-02-01   无\n流云             ￥50          感谢lz的耐心回答了我的疑惑哈          2022-12-29   无\nthott          ￥10          开源不易，坚持更难                2022-12-05   无\n                            liteflow让我学到很多\n🍦             ￥10          请大佬喝杯汽水                  2022-11-23   无\n清澄心            ￥50          感谢你们做出好用的业务流程引擎          2022-11-08   无\n                            而且很热情！\n李              ￥20          感谢大佬无私的开源分享与解答           2022-11-08   无\n                            祝越来越好\n微笑😊           ￥20          微笑😊                     2022-11-07   无\nfaraway        ￥10          群主牛逼，祝你永远梆硬              2022-11-04   无\nmr.陈           ￥10          开源不易                     2022-10-17   无\n[太阳]哈哈敬        ￥20          大佬喝coffee                2022-10-14   无\n李庚谱            ￥200         开源不易，请一起坚持下去。            2022-08-29   无\ndag            ￥50          很好用的产品👍                 2022-08-22   无\n顾～小诺           ￥18.8        我是支持群主的                  2022-08-17   无\nlls            ￥50          大赞的项目                    2022-08-10   无\nqinkawngdeid   ￥50          开源高尚 祝越来越好               2022-07-26   无\nssssss         ￥50          佬，菜，带                    2022-07-21   无\n-小龙            ￥20          无                        2022-07-18   无\n姜建林            ￥100         ppt真棒，期待可视化前端编排          2022-07-18   无\n小马             ￥50          请大佬喝杯咖啡                  2022-07-15   无\n安.             ￥50          大佬牛逼，期待liteflow的可视化      2022-07-12   无\n辻弌之人           ￥20          支持国产开源                   2022-07-11   无\n李志永            ￥50          支持国产开源软件！                2022-07-06   无\nnoear          ￥200         支持国产开源:-)                2022-07-04   无\n雪落花香           ￥100         投放一个链接                   2022-06-29   erd-online\n小马             腾讯云服务器       捐献你一个腾讯云服务器              2022-06-15   无\n               (2c/4g/6m)\n书虫             ￥5           谢谢，你的无私奉献                2022-06-02   无\n姜建林            ￥100         无                        2022-05-16   无\n这是我大哥          ￥50          京东用于组件改造                 2022-04-08   无\n                            感谢提供思路\n🎱             ￥20          送大佬一杯咖啡☕️                2022-03-18   无",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"升级到2.9.X说明",frontmatter:{title:"升级到2.9.X说明",date:"2022-10-07T12:43:18.000Z",permalink:"/pages/88c2f4/"},regularPath:"/%E5%8D%87%E7%BA%A7%E5%88%B02.9.3%E8%AF%B4%E6%98%8E.html",relativePath:"升级到2.9.3说明.md",key:"v-fe3c68fe",path:"/pages/88c2f4/",headers:[{level:2,title:"2.9.X升级到2.9.3的注意事项",slug:"_2-9-x升级到2-9-3的注意事项",normalizedTitle:"2.9.x升级到2.9.3的注意事项",charIndex:62}],headersStr:"2.9.X升级到2.9.3的注意事项",content:"此文档仅适用于从2.9.0/2.9.1/2.9.2升级到2.9.3的指南。如果你处于以前的版本，请看其他升级文档。\n\n\n# 2.9.X升级到2.9.3的注意事项\n\n核心用法上，完全兼容。\n\n由于2.9.3升级加强了第三方中间件的存储结构。\n\n如果你有用到zk，etcd，数据库来进行存储规则和脚本。那你无法平滑的升级到2.9.3，需要按照以下文档修改你中间件里的结构：\n\nSQL数据库配置源\n\nZK规则文件配置源\n\nEtcd配置源",normalizedContent:"此文档仅适用于从2.9.0/2.9.1/2.9.2升级到2.9.3的指南。如果你处于以前的版本，请看其他升级文档。\n\n\n# 2.9.x升级到2.9.3的注意事项\n\n核心用法上，完全兼容。\n\n由于2.9.3升级加强了第三方中间件的存储结构。\n\n如果你有用到zk，etcd，数据库来进行存储规则和脚本。那你无法平滑的升级到2.9.3，需要按照以下文档修改你中间件里的结构：\n\nsql数据库配置源\n\nzk规则文件配置源\n\netcd配置源",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"更新记录",frontmatter:{title:"更新记录",date:"2022-06-01T14:31:18.000Z",permalink:"/pages/88c2d1/"},regularPath:"/%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95.html",relativePath:"更新记录.md",key:"v-53f8d4bb",path:"/pages/88c2d1/",headers:[{level:2,title:"v2.12.4",slug:"v2-12-4",normalizedTitle:"v2.12.4",charIndex:2},{level:2,title:"v2.12.3",slug:"v2-12-3",normalizedTitle:"v2.12.3",charIndex:714},{level:2,title:"v2.12.2.1",slug:"v2-12-2-1",normalizedTitle:"v2.12.2.1",charIndex:1545},{level:2,title:"v2.12.2",slug:"v2-12-2",normalizedTitle:"v2.12.2",charIndex:1545},{level:2,title:"v2.12.1",slug:"v2-12-1",normalizedTitle:"v2.12.1",charIndex:2702},{level:2,title:"v2.12.0",slug:"v2-12-0",normalizedTitle:"v2.12.0",charIndex:3249},{level:2,title:"v2.11.4",slug:"v2-11-4",normalizedTitle:"v2.11.4",charIndex:4996},{level:2,title:"v2.11.3",slug:"v2-11-3",normalizedTitle:"v2.11.3",charIndex:6587},{level:2,title:"v2.11.2",slug:"v2-11-2",normalizedTitle:"v2.11.2",charIndex:7121},{level:2,title:"v2.11.1",slug:"v2-11-1",normalizedTitle:"v2.11.1",charIndex:7312},{level:2,title:"v2.11.0",slug:"v2-11-0",normalizedTitle:"v2.11.0",charIndex:8266},{level:2,title:"v2.10.7",slug:"v2-10-7",normalizedTitle:"v2.10.7",charIndex:9101},{level:2,title:"v2.10.6",slug:"v2-10-6",normalizedTitle:"v2.10.6",charIndex:9127},{level:2,title:"v2.10.5",slug:"v2-10-5",normalizedTitle:"v2.10.5",charIndex:10390},{level:2,title:"v2.10.4",slug:"v2-10-4",normalizedTitle:"v2.10.4",charIndex:10762},{level:2,title:"v2.10.3",slug:"v2-10-3",normalizedTitle:"v2.10.3",charIndex:11155},{level:2,title:"v2.10.2",slug:"v2-10-2",normalizedTitle:"v2.10.2",charIndex:11584},{level:2,title:"v2.10.1",slug:"v2-10-1",normalizedTitle:"v2.10.1",charIndex:12049},{level:2,title:"v2.10.0",slug:"v2-10-0",normalizedTitle:"v2.10.0",charIndex:12374},{level:2,title:"v2.9.7",slug:"v2-9-7",normalizedTitle:"v2.9.7",charIndex:13172},{level:2,title:"v2.9.6",slug:"v2-9-6",normalizedTitle:"v2.9.6",charIndex:14201},{level:2,title:"v2.9.5",slug:"v2-9-5",normalizedTitle:"v2.9.5",charIndex:14674},{level:2,title:"v2.9.4",slug:"v2-9-4",normalizedTitle:"v2.9.4",charIndex:15452},{level:2,title:"v2.9.3",slug:"v2-9-3",normalizedTitle:"v2.9.3",charIndex:16718},{level:2,title:"v2.9.2",slug:"v2-9-2",normalizedTitle:"v2.9.2",charIndex:17424},{level:2,title:"v2.9.1",slug:"v2-9-1",normalizedTitle:"v2.9.1",charIndex:17467},{level:2,title:"v2.9.0",slug:"v2-9-0",normalizedTitle:"v2.9.0",charIndex:18179},{level:2,title:"v2.8.5",slug:"v2-8-5",normalizedTitle:"v2.8.5",charIndex:19637},{level:2,title:"v2.8.4",slug:"v2-8-4",normalizedTitle:"v2.8.4",charIndex:20086},{level:2,title:"v2.8.3",slug:"v2-8-3",normalizedTitle:"v2.8.3",charIndex:20565},{level:2,title:"v2.8.2",slug:"v2-8-2",normalizedTitle:"v2.8.2",charIndex:20908},{level:2,title:"v2.8.1",slug:"v2-8-1",normalizedTitle:"v2.8.1",charIndex:21513},{level:2,title:"v2.8.0",slug:"v2-8-0",normalizedTitle:"v2.8.0",charIndex:21791},{level:2,title:"v2.7.3",slug:"v2-7-3",normalizedTitle:"v2.7.3",charIndex:23231},{level:2,title:"v2.7.2",slug:"v2-7-2",normalizedTitle:"v2.7.2",charIndex:23427},{level:2,title:"v2.7.1",slug:"v2-7-1",normalizedTitle:"v2.7.1",charIndex:23626},{level:2,title:"v2.7.0",slug:"v2-7-0",normalizedTitle:"v2.7.0",charIndex:23876},{level:2,title:"v2.6.14",slug:"v2-6-14",normalizedTitle:"v2.6.14",charIndex:24919},{level:2,title:"v2.6.13",slug:"v2-6-13",normalizedTitle:"v2.6.13",charIndex:25228},{level:2,title:"v2.6.12",slug:"v2-6-12",normalizedTitle:"v2.6.12",charIndex:25566},{level:2,title:"v2.6.11",slug:"v2-6-11",normalizedTitle:"v2.6.11",charIndex:25762},{level:2,title:"v2.6.10",slug:"v2-6-10",normalizedTitle:"v2.6.10",charIndex:26263},{level:2,title:"v2.6.8",slug:"v2-6-8",normalizedTitle:"v2.6.8",charIndex:26624},{level:2,title:"v2.6.7",slug:"v2-6-7",normalizedTitle:"v2.6.7",charIndex:27663},{level:2,title:"v2.6.6",slug:"v2-6-6",normalizedTitle:"v2.6.6",charIndex:27764},{level:2,title:"v2.6.5",slug:"v2-6-5",normalizedTitle:"v2.6.5",charIndex:28129},{level:2,title:"v2.6.4",slug:"v2-6-4",normalizedTitle:"v2.6.4",charIndex:28327},{level:2,title:"v2.6.3",slug:"v2-6-3",normalizedTitle:"v2.6.3",charIndex:29346},{level:2,title:"v2.6.2",slug:"v2-6-2",normalizedTitle:"v2.6.2",charIndex:29811},{level:2,title:"v2.6.1",slug:"v2-6-1",normalizedTitle:"v2.6.1",charIndex:24919},{level:2,title:"v2.6.0",slug:"v2-6-0",normalizedTitle:"v2.6.0",charIndex:30103},{level:2,title:"v2.6.0-BETA1",slug:"v2-6-0-beta1",normalizedTitle:"v2.6.0-beta1",charIndex:30882},{level:2,title:"v2.5.10",slug:"v2-5-10",normalizedTitle:"v2.5.10",charIndex:31326},{level:2,title:"v2.5.9",slug:"v2-5-9",normalizedTitle:"v2.5.9",charIndex:31539},{level:2,title:"v2.5.8",slug:"v2-5-8",normalizedTitle:"v2.5.8",charIndex:31825},{level:2,title:"v2.5.7",slug:"v2-5-7",normalizedTitle:"v2.5.7",charIndex:31939},{level:2,title:"v2.5.6",slug:"v2-5-6",normalizedTitle:"v2.5.6",charIndex:32049},{level:2,title:"v2.5.5",slug:"v2-5-5",normalizedTitle:"v2.5.5",charIndex:32325},{level:2,title:"v2.5.4",slug:"v2-5-4",normalizedTitle:"v2.5.4",charIndex:32693},{level:2,title:"v2.5.3",slug:"v2-5-3",normalizedTitle:"v2.5.3",charIndex:32789},{level:2,title:"v2.5.2",slug:"v2-5-2",normalizedTitle:"v2.5.2",charIndex:33023},{level:2,title:"v2.5.1",slug:"v2-5-1",normalizedTitle:"v2.5.1",charIndex:31326},{level:2,title:"v2.5.0",slug:"v2-5-0",normalizedTitle:"v2.5.0",charIndex:33322}],headersStr:"v2.12.4 v2.12.3 v2.12.2.1 v2.12.2 v2.12.1 v2.12.0 v2.11.4 v2.11.3 v2.11.2 v2.11.1 v2.11.0 v2.10.7 v2.10.6 v2.10.5 v2.10.4 v2.10.3 v2.10.2 v2.10.1 v2.10.0 v2.9.7 v2.9.6 v2.9.5 v2.9.4 v2.9.3 v2.9.2 v2.9.1 v2.9.0 v2.8.5 v2.8.4 v2.8.3 v2.8.2 v2.8.1 v2.8.0 v2.7.3 v2.7.2 v2.7.1 v2.7.0 v2.6.14 v2.6.13 v2.6.12 v2.6.11 v2.6.10 v2.6.8 v2.6.7 v2.6.6 v2.6.5 v2.6.4 v2.6.3 v2.6.2 v2.6.1 v2.6.0 v2.6.0-BETA1 v2.5.10 v2.5.9 v2.5.8 v2.5.7 v2.5.6 v2.5.5 v2.5.4 v2.5.3 v2.5.2 v2.5.1 v2.5.0",content:'# v2.12.4\n\n更新列表\n\n特性 #IASS9Z 新的JavaX脚本插件，支持java8~java17的所有语法特性\n\nhttps://gitee.com/dromara/liteFlow/issues/IASS9Z\n\n特性 #IAJD9H 期望liteflow 有自己的生命周期扩展\n\nhttps://gitee.com/dromara/liteFlow/issues/IAJD9H\n\n增强 #IASYI0 提供脚本初始化生命周期的扩展点\n\nhttps://gitee.com/dromara/liteFlow/issues/IASYI0\n\n增强 #I9H6GY SQL脚本在配置上支持用户自定义的过滤条件\n\nhttps://gitee.com/dromara/liteFlow/issues/I9H6GY\n\n增强 #IAVH8O 把scanner当中的步骤抽象出来，形成一套小的体系，方便的扩展\n\nhttps://gitee.com/dromara/liteFlow/issues/IAVH8O\n\n增强 #IANY4U 组件中提供getCmpDataList接口\n\nhttps://gitee.com/dromara/liteFlow/issues/IANY4U\n\n增强 #I5XB03 提供带域名的dtd文件地址，加强xml的提示\n\nhttps://gitee.com/dromara/liteFlow/issues/I5XB03\n\n修复 #IASW3I 异步循环迭代组件中迭代对象以及迭代下标存在并发问题\n\nhttps://gitee.com/dromara/liteFlow/issues/IASW3I\n\n\n# v2.12.3\n\n更新列表\n\n特性 #I9T6PB 嵌套循环获得任意外层的下标或者对象\n\nhttps://gitee.com/dromara/liteFlow/issues/I9T6PB\n\n增强 #IAH00W 增加在LiteflowResponse中超时节点的Id获取方式\n\nhttps://gitee.com/dromara/liteFlow/issues/IAH00W\n\n增强 #IAMBU8 ELBus 增加普通节点构建方法\n\nhttps://gitee.com/dromara/liteFlow/issues/IAMBU8\n\n增强 #IAOW43 在solon体系中支持声明式的组件\n\nhttps://gitee.com/dromara/liteFlow/issues/IAOW43\n\n增强 #IAGJ2F 在使用最新版决策路由功能时发现SPI加载有报错问题\n\nhttps://gitee.com/dromara/liteFlow/issues/IAGJ2F\n\n修复 #IAERN6 隐式子流程嵌套报错\n\nhttps://gitee.com/dromara/liteFlow/issues/IAERN6\n\n修复 #IAIH89 在SQL插件多个数据源都能检测执行通过的情况下，有可能会出现连接泄露\n\nhttps://gitee.com/dromara/liteFlow/issues/IAIH89\n\n修复 #IAJR32 修复在ParallelStrategyExecutor可能出现的NPE问题\n\nhttps://gitee.com/dromara/liteFlow/issues/IAJR32\n\n修复 #IAOICK GraalJavaScriptExecutor 这个类的compile()方法中新开的context没有关闭，可能有隐患\n\nhttps://gitee.com/dromara/liteFlow/issues/IAOICK\n\n\n# v2.12.2.1\n\n更新列表\n\n修复 #IAFKQV 声明式的onError方法取不到Exception\n\nhttps://gitee.com/dromara/liteFlow/issues/IAFKQV\n\n\n# v2.12.2\n\n更新列表\n\n增强 #IAE5PA FlowBus中提供刷新route的api方法\n\nhttps://gitee.com/dromara/liteFlow/issues/IAE5PA\n\n增强 #IACEH9 SQL插件中的轮询逻辑优化\n\nhttps://gitee.com/dromara/liteFlow/issues/IACEH9\n\n增强 #IACEGB 上下文超类判断的获取和转换\n\nhttps://gitee.com/dromara/liteFlow/issues/IACEGB\n\n增强 #IA9QBG el-builder的部分重构\n\nhttps://gitee.com/dromara/liteFlow/issues/IA9QBG\n\n增强 #IA9NOI ELBus中增加对retry构建的api支持\n\nhttps://gitee.com/dromara/liteFlow/issues/IA9NOI\n\n增强 #IA6E3Q redis配置的时候可以指定Redisson的链接数，默认的connections太多了\n\nhttps://gitee.com/dromara/liteFlow/issues/IA6E3Q\n\n增强 #IA8B3T 插件 throw Exception 会丢失堆栈\n\nhttps://gitee.com/dromara/liteFlow/issues/IA8B3T\n\n增强 #IABK5C 校验 EL 表达式，获取校验失败原因\n\nhttps://gitee.com/dromara/liteFlow/issues/IABK5C\n\n修复 #IA5PAK ELBus串行编排不支持对每个节点进行超时配置\n\nhttps://gitee.com/dromara/liteFlow/issues/IA5PAK\n\n修复 #IAD2HH 希望支持执行节点日志与监控日志的分开管理\n\nhttps://gitee.com/dromara/liteFlow/issues/IAD2HH\n\n修复 #IACSQ8 liteflow-solon-plugin 启动报错\n\nhttps://gitee.com/dromara/liteFlow/issues/IACSQ8\n\n修复 #IADIXE 使用迭代循环组件，下游getCurrLoopObj()获取为null\n\nhttps://gitee.com/dromara/liteFlow/issues/IADIXE\n\n\n# v2.12.1\n\n更新列表\n\n特性 #I9K14C 为process方法提供注入型参数特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I9K14C\n\n特性 #I9H6GN 支持kotlin脚本语言\n\nhttps://gitee.com/dromara/liteFlow/issues/I9H6GN\n\n特性 #I9PVQ7 决策路由中增加namespace，可以执行指定命名空间的决策路由\n\nhttps://gitee.com/dromara/liteFlow/issues/I9PVQ7\n\n特性 #I9RPBK 数据库插件支持决策路由特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I9RPBK\n\n修复 #I9JDY1 绝对路径模糊匹配，没对windows的路径做支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I9JDY1\n\n修复 #I9N5K8 在自定义组件后，通过getCmpData 获取data的实体对象，data字段与实体类不匹配是会抛异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I9N5K8\n\n\n# v2.12.0\n\n更新列表\n\n特性 #I96A33 为LF增加决策表特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I96A33\n\n特性 #I9DQDU 允许对不存在的组件增加全局参数\n\nhttps://gitee.com/dromara/liteFlow/issues/I9DQDU\n\n特性 #I9050W 为每一个上下文提供一个名字，使用时可以根据名字来获取\n\nhttps://gitee.com/dromara/liteFlow/issues/I9050W\n\n特性 #I8PL2M EL语句里可以设置重试次数，类似于EL中的超时时间\n\nhttps://gitee.com/dromara/liteFlow/issues/I8PL2M\n\n特性 #I61D1N 规则层面增加一个enable的选项，可以禁用规则\n\nhttps://gitee.com/dromara/liteFlow/issues/I61D1N\n\n特性 #I8YNCB 查看某一个chainId下的所有node\n\nhttps://gitee.com/dromara/liteFlow/issues/I8YNCB\n\n特性 #I8HDIA 新增一个验证脚本的方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I8HDIA\n\n增强 #I8SMQB BREAK、IF、WHILE组件统一变成布尔组件\n\nhttps://gitee.com/dromara/liteFlow/issues/I8SMQB\n\n增强 #I8MW6Q 没有脚本（node）加载后没有提供卸载的方法，可能造成脚本一直占用内存\n\nhttps://gitee.com/dromara/liteFlow/issues/I8MW6Q\n\n增强 #I905AD 优化注解的获取速度，优化性能\n\nhttps://gitee.com/dromara/liteFlow/issues/I905AD\n\n增强 #I95XTD python脚本无法写return脚本\n\nhttps://gitee.com/dromara/liteFlow/issues/I95XTD\n\n增强 #I90IRR 设置超时maxWaitSenconds之后，超时的组件仍旧执行会报出NPE的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I90IRR\n\n增强 #I9F2HP 链路继承中的占位符换成双括弧\n\nhttps://gitee.com/dromara/liteFlow/issues/I9F2HP\n\n增强 #I98L0S 现版本需要依赖jackson2.16，缺少toPrettyString方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I98L0S\n\n增强 #I97Y7Y 2.11.4.2版本中ComponentScanner初始化失败，建议重写BeanPostProcessor#postProcessBeforeInitialization\n\nhttps://gitee.com/dromara/liteFlow/issues/I97Y7Y\n\n增强 #I91AUT 对于诸如isContinueOnError或isAccess这样的方法，期望能够提供set形式的调用\n\nhttps://gitee.com/dromara/liteFlow/issues/I91AUT\n\n修复 #I932V4 组件降级，在寻找降级组件时，仍应该去查找下有没有对应的组件\n\nhttps://gitee.com/dromara/liteFlow/issues/I932V4\n\n修复 #I8YDGE 在迭代循环组件中，无法获取子流程传递的请求参数\n\nhttps://gitee.com/dromara/liteFlow/issues/I8YDGE\n\n修复 #I8Y0X4 并行循环中有可能导致的ConditionStack的并发问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I8Y0X4\n\n\n# v2.11.4\n\n更新列表\n\n增强 #I8UQR4 while组件本身加入loopIndex\n\nhttps://gitee.com/dromara/liteFlow/issues/I8UQR4\n\n增强 #I8TZFQ 优化EL的check报错提示，代码优化\n\nhttps://gitee.com/dromara/liteFlow/issues/I8TZFQ\n\n增强 #I8QJE1 增加映射关键字SER和PAR\n\nhttps://gitee.com/dromara/liteFlow/issues/I8QJE1\n\n增强 #I8PWWO CmpStep中加入startTime和endTime\n\nhttps://gitee.com/dromara/liteFlow/issues/I8PWWO\n\n增强 #I8MXIB WHEN线程池可能存在第一次调用的时候初始化\n\nhttps://gitee.com/dromara/liteFlow/issues/I8MXIB\n\n增强 #I8MXHX isAccess在WHEN中会被执行2次的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I8MXHX\n\n增强 #I8J622 动态组件el语句data参数缺少单引号\n\nhttps://gitee.com/dromara/liteFlow/issues/I8J622\n\n增强 #I8IDE5 对声明式代理底层代码进行增强\n\nhttps://gitee.com/dromara/liteFlow/issues/I8IDE5\n\n增强 #I8H1LT 希望提供nacos对于阿里云MSE的鉴权方式\n\nhttps://gitee.com/dromara/liteFlow/issues/I8H1LT\n\n增强 #I8FC4F 超大量规则场景下项目启动时间过长的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I8FC4F\n\n增强 #I8FBBW chain及script新增enable字段后sql打印错误\n\nhttps://gitee.com/dromara/liteFlow/issues/I8FBBW\n\n增强 #I8DW1J LiteFlowChainELBuilder.validate()依然存在bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I8DW1J\n\n增强 #I8AE9G 超时控制增加maxWaitMilliseconds关键字，以增加更精细的时间控制\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AE9G\n\n修复 #I8TZTK EL语句构建的时候，如果出现了脚本节点。会出NPE的异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I8TZTK\n\n修复 #I8S75A 去除循环检测，低版本的jackson可能导致的内存溢出问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I8S75A\n\n修复 #I8RWGZ 开启WHEN线程池隔离线程池创建有问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I8RWGZ\n\n修复 #I8PEZ0 修复sql插件中script表中enable字段不起作用的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I8PEZ0\n\n修复 #I8AF1O 修复redis的订阅模式mode解析的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AF1O\n\n\n# v2.11.3\n\n更新列表\n\n增强 #I8BPM9 SQL插件增加enable字段的映射\n\nhttps://gitee.com/dromara/liteFlow/issues/I8BPM9\n\n修复 #I8BPMD 修复2.11.2中启动parse两次规则的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I8BPMD\n\n修复 #I8BPHS 修复Redis配置源哨兵模式的地址检查\n\nhttps://gitee.com/dromara/liteFlow/issues/I8BPHS\n\n修复 #I8AWHT LiteFlowChainELBuilder.validate()存在bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AWHT\n\n修复 #I8AR0L 组件定义了重试和回滚，回滚也会被重试\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AR0L\n\n修复 #I8AF1O 修复redis的订阅模式mode解析的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I8AF1O\n\n\n# v2.11.2\n\n更新列表\n\n修复 #I88TZW EL组装API当有data方法时，缺少分号的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I88TZW\n\n修复 #I88U0Q SQL插件当eldata字段为空时，启动失败\n\nhttps://gitee.com/dromara/liteFlow/issues/I88U0Q\n\n\n# v2.11.1\n\n更新列表\n\n特性 #I7Y0Y1 SQL插件支持轮询模式\n\nhttps://gitee.com/dromara/liteFlow/issues/I7Y0Y1\n\n特性 #I7XAIB WHEN增加must语法\n\nhttps://gitee.com/dromara/liteFlow/issues/I7XAIB\n\n特性 #I878WV EL表达式动态组装\n\nhttps://gitee.com/dromara/liteFlow/issues/I878WV\n\n特性 #I7SVZF 支持chain的继承关系特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I7SVZF\n\n特性 #I7YYLF 组件降级特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I7YYLF\n\n特性 #I7ZJRH 支持绝对路径的模糊匹配\n\nhttps://gitee.com/dromara/liteFlow/issues/I7ZJRH\n\n特性 #I883LB when线程池隔离支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I883LB\n\n增强 #I821F1 检测链路的循环依赖问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I821F1\n\n增强 #I7G6BB 自定义异步线程池初始化存在并发问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I7G6BB\n\n增强 #I855YM sql 插件重构\n\nhttps://gitee.com/dromara/liteFlow/issues/I855YM\n\n修复 #I82M4G 回滚组件无法获得tag的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I82M4G\n\n修复 #I7ZMVM 普通组件isContinueOnError和isEnd为true时，process直接抛异常会导致isEnd失效\n\nhttps://gitee.com/dromara/liteFlow/issues/I7ZMVM\n\n\n# v2.11.0\n\n更新列表\n\n特性 #I7V6VB 建议增加Janino插件，支持java脚本的书写\n\nhttps://gitee.com/dromara/liteFlow/issues/I7V6VB\n\n特性 #I7T53A 增加Redis存储规则的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I7T53A\n\n特性 #I7I3LL 允许对EL中的每⼀个组件设置超时时间控制\n\nhttps://gitee.com/dromara/liteFlow/issues/I7I3LL\n\n特性 #I7HJFX 循环表达式中支持异步模式\n\nhttps://gitee.com/dromara/liteFlow/issues/I7HJFX\n\n特性 #I590JT 对于回滚流程的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I590JT\n\n增强 #I7QC8V SQL插件格式化加入CDATA\n\nhttps://gitee.com/dromara/liteFlow/issues/I7QC8V\n\n增强 #I7Q8BX 部分代码有NPE风险\n\nhttps://gitee.com/dromara/liteFlow/issues/I7Q8BX\n\n增强 #I7Q4BN 默认主线程池的名称拼写\n\nhttps://gitee.com/dromara/liteFlow/issues/I7Q4BN\n\n修复 #I7WNDA SQLException: 使用druid+oracle会报出关闭的语句错误\n\nhttps://gitee.com/dromara/liteFlow/issues/I7WNDA\n\n修复 #I7TYS3 当组件出现Exception的时候，afterProcess获取不到\n\nhttps://gitee.com/dromara/liteFlow/issues/I7TYS3\n\n\n# v2.10.7\n\n更新列表\n\n修复 #I7PX3O v2.10.6版本中声明式的调用出现问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I7PX3O\n\n\n# v2.10.6\n\n更新列表\n\n增强 #I7KR2F 测试用例全面更新为junit5\n\nhttps://gitee.com/dromara/liteFlow/issues/I7KR2F\n\n增强 #I7J59V java17下进行完整的测试用例测试\n\nhttps://gitee.com/dromara/liteFlow/issues/I7J59V\n\n增强 #I7KZCZ 希望可以使用配置文件中已经配置的数据源\n\nhttps://gitee.com/dromara/liteFlow/issues/I7KZCZ\n\n增强 #I7KY2N 非操作符的短路控制优化\n\nhttps://gitee.com/dromara/liteFlow/issues/I7KY2N\n\n增强 #I7HPAN onError方法增加Exception入参\n\nhttps://gitee.com/dromara/liteFlow/issues/I7HPAN\n\n增强 #I7KOPV 声明组件增加nodeName的定义\n\nhttps://gitee.com/dromara/liteFlow/issues/I7KOPV\n\n增强 #I7KHE5 关于注解声明式使用场景LiteFlowMethodEnum增加getDisplayName\n\nhttps://gitee.com/dromara/liteFlow/issues/I7KHE5\n\n增强 #I7K3T1 自带AOP拦截需要增强获取tag等信息\n\nhttps://gitee.com/dromara/liteFlow/issues/I7K3T1\n\n增强 #I7JZ4D 希望框架有与或非表达式的相关日志\n\nhttps://gitee.com/dromara/liteFlow/issues/I7JZ4D\n\n增强 #I7J1VJ 希望针对节点执行耗时的打印日志支持控制\n\nhttps://gitee.com/dromara/liteFlow/issues/I7J1VJ\n\n增强 #I7LGZR 忘记填写 chainName 的错误提示\n\nhttps://gitee.com/dromara/liteFlow/issues/I7LGZR\n\n修复 #I7L5DX 2.10.5版本中ScriptBean注解注入bean失败\n\nhttps://gitee.com/dromara/liteFlow/issues/I7L5DX\n\n修复 #I7HTR4 同一组件不同tag，取step时候存在问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I7HTR4\n\n修复 #I7GMTS 本地文件监听异常会导致监听线程停止\n\nhttps://gitee.com/dromara/liteFlow/issues/I7GMTS\n\n\n# v2.10.5\n\n更新列表\n\n增强 #I7F567 增加对业务自定义requestId传入的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I7F567\n\n修复 #I7EKS8 在isAccess中进行setIsEnd(true)流程没有结束的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I7EKS8\n\n修复 #I7EKP3 同一个线程里分别调用2个Chain，currObj没有隔离的情况\n\nhttps://gitee.com/dromara/liteFlow/issues/I7EKP3\n\n修复 #I7E8RN 次数循环组件 下标获取问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I7E8RN\n\n\n# v2.10.4\n\n更新列表\n\n增强 #I6XPN4 组件上添加 @RefreshScope 初始化就失败了\n\nhttps://gitee.com/dromara/liteFlow/issues/I6XPN4\n\n修复 #I7C6VR ELIF表达式中目前无法加入AND OR NOT表达式\n\nhttps://gitee.com/dromara/liteFlow/issues/I7C6VR\n\n修复 #I7CCAB 2.10.0中CatchCondition会把ChainEndException也捕获\n\nhttps://gitee.com/dromara/liteFlow/issues/I7CCAB\n\n修复 #I7COX4 SWITCH跳转到设置tag的chain上，存在问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I7COX4\n\n\n# v2.10.3\n\n更新列表\n\n增强 #I6URA5 liteflow异常输出信息优化\n\nhttps://gitee.com/dromara/liteFlow/issues/I6URA5\n\n增强 #I6ZAVN 支持QLExpress的高精度计算\n\nhttps://gitee.com/dromara/liteFlow/issues/I6ZAVN\n\n增强 #I6Q061 WHEN组件最大等待时间希望能支持到毫秒级别\n\nhttps://gitee.com/dromara/liteFlow/issues/I6Q061\n\n修复 #I6Y300 IdGeneratorHolder 存在 NPE 异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I6Y300\n\n修复 #I6WGI3 无法解析oracle url\n\nhttps://gitee.com/dromara/liteFlow/issues/I6WGI3\n\n\n# v2.10.2\n\n更新列表\n\n特性 #I6RF8Y EL表达式里支持并或非操作符\n\nhttps://gitee.com/dromara/liteFlow/issues/I6RF8Y\n\n增强 #I6QOFJ groovy无法支持#循环下标获取获取，希望脚本可以支持获取循环下标\n\nhttps://gitee.com/dromara/liteFlow/issues/I6QOFJ\n\n增强 #I6RFOE LiteFlow能否在流程（表达式）添加类似tag字段的属性，提高选择组件的复用率呢？\n\nhttps://gitee.com/dromara/liteFlow/issues/I6RFOE\n\n修复 #I6TRT2 EL表达式里的//被过滤掉了\n\nhttps://gitee.com/dromara/liteFlow/issues/I6TRT2\n\n修复 #I6URNQ 在CATCH表达中写单独的组件，SLOT中会拿不到异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I6URNQ\n\n\n# v2.10.1\n\n更新列表\n\n特性 #I6O380 支持aviator的脚本语言\n\nhttps://gitee.com/dromara/liteFlow/issues/I6O380\n\n增强 #I6P8F8 支持循环表达式的嵌套循环\n\nhttps://gitee.com/dromara/liteFlow/issues/I6P8F8\n\n增强 #I6O2YE 外置存储支持多脚本混合调用\n\nhttps://gitee.com/dromara/liteFlow/issues/I6O2YE\n\n增强 #I6OBZY 增加代码格式化插件，统一代码风格\n\nhttps://gitee.com/dromara/liteFlow/issues/I6OBZY\n\n\n# v2.10.0\n\n更新列表\n\n特性 #I6NRKH LiteFlow支持springboot 3.0\n\nhttps://gitee.com/dromara/liteFlow/issues/I6NRKH\n\n特性 #I6NGM3 LiteFlow支持多种不同语言脚本混合调用的特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I6NGM3\n\n特性 #I6MPYF 增加CATCH语法表达式\n\nhttps://gitee.com/dromara/liteFlow/issues/I6MPYF\n\n特性 #I6BDLN 是否能绝对路径的目录位置及其所有子目录下规则配置文件的侦听\n\nhttps://gitee.com/dromara/liteFlow/issues/I6BDLN\n\n特性 #I69M1M 对上下文在脚本中的引用，支持自定义名称\n\nhttps://gitee.com/dromara/liteFlow/issues/I69M1M\n\n增强 #I6LWYM 深层次优化Condition维度的代码\n\nhttps://gitee.com/dromara/liteFlow/issues/I6LWYM\n\n修复 #I6G0D5 NodeIfComponent 重写 isAccess 导致空指针报错\n\nhttps://gitee.com/dromara/liteFlow/issues/I6G0D5\n\n修复 #I6JF0K 迭代&循环组件在SWITCH语境中无法获取迭代对象和下标的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I6JF0K\n\n修复 #I6L8YB 对于脚本名称存在<符号在执行脚本时异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I6L8YB\n\n\n# v2.9.7\n\n更新列表\n\n特性 #I6A2GL 增加迭代器表达式特性，用于迭代循环中的集合\n\nhttps://gitee.com/dromara/liteFlow/issues/I6A2GL\n\n增强 #I52TBW 增加与 Solon 框架的适配\n\nhttps://gitee.com/dromara/liteFlow/issues/I52TBW\n\n增强 #I691LD 对beforeProcess和afterProcess两个方法进行参数优化\n\nhttps://gitee.com/dromara/liteFlow/issues/I691LD\n\n增强 #I6BDN3 groovy脚本文件组件希望支持绝对路径\n\nhttps://gitee.com/dromara/liteFlow/issues/I6BDN3\n\n增强 #I679UX 组件参数设入json，支持在脚本组件中点操作符取到\n\nhttps://gitee.com/dromara/liteFlow/issues/I679UX\n\n增强 #I6A2FI 增强Slot元数据的存储，避免在多线程相同组件编排情况下可能造成的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I6A2FI\n\n增强 #I69QOB 动态创建组件时，脚本异常信息完善\n\nhttps://gitee.com/dromara/liteFlow/issues/I69QOB\n\n修复 #I6CJI9 修复循环组件中IF组件获取不了index的情况\n\nhttps://gitee.com/dromara/liteFlow/issues/I6CJI9\n\n修复 #I6ASNG 采用sql数据源形式，FlowExecutor项目初始化时，如果没有配置流程FlowBus.getChainMap()会判空则抛出异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I6ASNG\n\n修复 #I69UVL 如果switch返回为空或者null，无法选取到default组件\n\nhttps://gitee.com/dromara/liteFlow/issues/I69UVL\n\n修复 #I66QPQ 从2.9开始启动报StackOverflowError\n\nhttps://gitee.com/dromara/liteFlow/issues/I66QPQ\n\n\n# v2.9.6\n\n更新列表\n\n增强 #I66KP6 从底层改变NodeComponent和Node之间的实例关联问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I66KP6\n\n增强 #I5VJ85 循环组件支持获取当前循环的下标\n\nhttps://gitee.com/dromara/liteFlow/issues/I5VJ85\n\n修复 #I6624Z 规则data不能传递纯字符串 "xxxx"，在脚本里获得会报错\n\nhttps://gitee.com/dromara/liteFlow/issues/I6624Z\n\n修复 #I668R2 zk，etcd中必须配置chain和script2个节点，只配置其中chain会报错\n\nhttps://gitee.com/dromara/liteFlow/issues/I668R2\n\n修复 #I65TZ2 本地配置文件，目录包含小数点时导致解析错误\n\nhttps://gitee.com/dromara/liteFlow/issues/I65TZ2\n\n\n# v2.9.5\n\n更新列表\n\n特性 #I63WME 希望支持Apollo配置中心配置规则功能\n\nhttps://gitee.com/dromara/liteFlow/issues/I63WME\n\n特性 #I64PDW 增加Python脚本支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I64PDW\n\n特性 #I64T29 增加脚本语言Lua的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I64T29\n\n增强 #I64T00 希望给 SWITCH 增加一个 default 特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I64T00\n\n增强 #I62NEK EL解析方式PRE、FINALLY在嵌套子链中不生效\n\nhttps://gitee.com/dromara/liteFlow/issues/I62NEK\n\n增强 #I64L3Q 期望拓展@ScriptBean注解，能注入指定类的指定方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I64L3Q\n\n增强 #I64HY4 LiteFlowNodeBuilder的添加节点代码优化\n\nhttps://gitee.com/dromara/liteFlow/issues/I64HY4\n\n增强 #I64SY6 期望能完善错误信息的提示\n\nhttps://gitee.com/dromara/liteFlow/issues/I64SY6\n\n修复 #I5XUQS 配置不同格式规则加载时，若EL规则文件不存在，启动会报错。\n\nhttps://gitee.com/dromara/liteFlow/issues/I5XUQS\n\n\n# v2.9.4\n\n更新列表\n\n特性 #I61XYZ 额外提供GraalJs引擎，在js上多一个选择\n\nhttps://gitee.com/dromara/liteFlow/issues/I61XYZ\n\n增强 #I63C31 zk，etcd支持只刷新改变的部分\n\nhttps://gitee.com/dromara/liteFlow/issues/I63C31\n\n增强 #I61EMZ 增加一个验证EL规则的api，供检查之用\n\nhttps://gitee.com/dromara/liteFlow/issues/I61EMZ\n\n增强 #I633VH 建议FlowBus提供批量移除子链方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I633VH\n\n增强 #I61RI0 希望可以开放对 QLExpress 的一些操作！\n\nhttps://gitee.com/dromara/liteFlow/issues/I61RI0\n\n增强 #I622I9 内部代码规范ChainName和ChainId问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I622I9\n\n增强 #I61LYN 规范问题和 不必要的import 常量提取等\n\nhttps://gitee.com/dromara/liteFlow/issues/I61LYN\n\n修复 #I62PV3 声明式组件如果把LiteflowMethod定义在父类中，不执行\n\nhttps://gitee.com/dromara/liteFlow/issues/I62PV3\n\n修复 #I62DT1 如果对上下文标注@ScriptBean，那么脚本和java中拿到的上下文并不是同一个上下文\n\nhttps://gitee.com/dromara/liteFlow/issues/I62DT1\n\n修复 #I61H49 脚本异常希望可以抛出到response\n\nhttps://gitee.com/dromara/liteFlow/issues/I61H49\n\n修复 #I631ZF groovy脚本接入时，自定义异常抛出后被组件失败异常覆盖\n\nhttps://gitee.com/dromara/liteFlow/issues/I631ZF\n\n修复 #I61HIO 方法级的组件声明，然后在方法上打 Spring 的事务注解 @Transactional，会报错\n\nhttps://gitee.com/dromara/liteFlow/issues/I61HIO\n\n修复 #I62CB8 脚本与java交互取元数据的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I62CB8\n\n修复 #I61UZ6 switch选择组件使用标签在同一组件时固定选到最后一个\n\nhttps://gitee.com/dromara/liteFlow/issues/I61UZ6\n\n\n# v2.9.3\n\n更新列表\n\n增强 #I5XWL2 数据库插件支持脚本的存储\n\nhttps://gitee.com/dromara/liteFlow/issues/I5XWL2\n\n增强 #I605FA 支持etcd分离chain以及脚本的存储结构\n\nhttps://gitee.com/dromara/liteFlow/issues/I605FA\n\n增强 #I5ZLH6 支持zk分离chain以及脚本的存储结构\n\nhttps://gitee.com/dromara/liteFlow/issues/I5ZLH6\n\n增强 #I5Y92X 支持选择组件跳转同时指定组件名和标签\n\nhttps://gitee.com/dromara/liteFlow/issues/I5Y92X\n\n增强 #I5ULVA 修正不规范的问题，chain的name和id混用，不太严谨\n\nhttps://gitee.com/dromara/liteFlow/issues/I5ULVA\n\n修复 #I5ZS92 希望能直接获取组件参数的原始字符串，而不是只能获取转换后的 JSON 对象\n\nhttps://gitee.com/dromara/liteFlow/issues/I5ZS92\n\n修复 #I5YEHG 脚本的加载有先后顺序问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5YEHG\n\n修复 #I5ZS8I 修复EL中定义的tag和data中的字符串的空格和换行被过滤掉了的现象\n\nhttps://gitee.com/dromara/liteFlow/issues/I5ZS8I\n\n\n# v2.9.2\n\n更新列表\n\n修复 2.9.1在Nacos场景启动失败的bug\n\n\n# v2.9.1\n\n更新列表\n\n特性 #I5WNMG 脚本组件支持javascript的语法\n\nhttps://gitee.com/dromara/liteFlow/issues/I5WNMG\n\n增强 #I5X7IT rule-source-ext-data支持在springboot yml配置文件中的原生配置\n\nhttps://gitee.com/dromara/liteFlow/issues/I5X7IT\n\n增强 #I5X1O6 提升安全性，更新不安全的第三方依赖\n\nhttps://gitee.com/dromara/liteFlow/issues/I5X1O6\n\n增强 #I5RV3G 规则插件的报错无法抛出来\n\nhttps://gitee.com/dromara/liteFlow/issues/I5RV3G\n\n增强 #I5XB03 增加dtd文件，加强xml的提示\n\nhttps://gitee.com/dromara/liteFlow/issues/I5XB03\n\n增强 #I5P263 脚本执行异常，出现异常的处理\n\nhttps://gitee.com/dromara/liteFlow/issues/I5P263\n\n修复 #I5WSG9 2.9.0版本 tag在 WHEN 下不生效\n\nhttps://gitee.com/dromara/liteFlow/issues/I5WSG9\n\n修复 #I5WLQW 扫描@ScriptBean修饰的类使用的hutool工具类不支持kotlin导致堆栈溢出\n\nhttps://gitee.com/dromara/liteFlow/issues/I5WLQW\n\n\n# v2.9.0\n\n更新列表\n\n特性 #I5RV5D 循环表达式特性的增加\n\nhttps://gitee.com/dromara/liteFlow/issues/I5RV5D\n\n特性 #I5ROOR 增加关系型数据库规则存储插件的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I5ROOR\n\n特性 #I4I5WZ 增加nacos存储规则插件的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I4I5WZ\n\n特性 #I5R005 添加Etcd存储规则插件的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I5R005\n\n特性 #I5QCHL 支持在method级别声明式特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I5QCHL\n\n特性 #I5RV4W 加强脚本和java之间的互动\n\nhttps://gitee.com/dromara/liteFlow/issues/I5RV4W\n\n特性 #I5U3RC 支持组件级别的规则参数配置\n\nhttps://gitee.com/dromara/liteFlow/issues/I5U3RC\n\n特性 #I5RG4H 选择组件支持组件标签选择\n\nhttps://gitee.com/dromara/liteFlow/issues/I5RG4H\n\n增强 #I5SYC8 支持同一组件不同组件ID的定义\n\nhttps://gitee.com/dromara/liteFlow/issues/I5SYC8\n\n增强 #I5QMDZ 把Zk存储的支持拆出来作为插件解耦合\n\nhttps://gitee.com/dromara/liteFlow/issues/I5QMDZ\n\n增强 #I5U1FH 去除老的表达式的支持，精简代码\n\nhttps://gitee.com/dromara/liteFlow/issues/I5U1FH\n\n增强 #I5Q3A7 优化QLExpress的Runner初始化\n\nhttps://gitee.com/dromara/liteFlow/issues/I5Q3A7\n\n增强 #I5U5O6 对声明式类&方法进行了重构，提升了使用友好度\n\nhttps://gitee.com/dromara/liteFlow/issues/I5U5O6\n\n增强 #I5T4LS 优化 FlowParserProvider 类\n\nhttps://gitee.com/dromara/liteFlow/issues/I5T4LS\n\n增强 #I5Q3SS 对于el表达式里的未定义的子表达式和未注册的node进行编译时检查\n\nhttps://gitee.com/dromara/liteFlow/issues/I5Q3SS\n\n增强 #I5OFMU 优化 Operator 代码\n\nhttps://gitee.com/dromara/liteFlow/issues/I5OFMU\n\n修复 #I5PK9Q 隐式流程里的异常会导致主流程里的异常发生\n\nhttps://gitee.com/dromara/liteFlow/issues/I5PK9Q\n\n修复 #I5PFLG 组件统计耗时未统计后置处理\n\nhttps://gitee.com/dromara/liteFlow/issues/I5PFLG\n\n\n# v2.8.5\n\n更新列表\n\n特性 #I5KTST IF三元符语法的添加以及IF ELIF ELSE语法的添加\n\nhttps://gitee.com/dromara/liteFlow/issues/I5KTST\n\n增强 #I5O22X 增加EL解析中的报错详细信息\n\nhttps://gitee.com/dromara/liteFlow/issues/I5O22X\n\n增强 #I5MZJY 解决循环调用同步的隐式流程，参数只能取一次的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5MZJY\n\n修复 #I5NH56 switch组件对于cglib代理过的bean目前处理的不够全面\n\nhttps://gitee.com/dromara/liteFlow/issues/I5NH56\n\n修复 I5NFV3 在zk集群中多个zk地址不生效的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I5NFV3\n\n\n# v2.8.4\n\n更新列表\n\n特性 #I5M34O 支持在流程执行前就传入一个初始化好的context对象的特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I5M34O\n\n增强 #I5LY8B 增强SwitchCondition里面的targetMap无法get到的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5LY8B\n\n增强 #I5KAMF 是否可以增加自定义配置哪些异常类型日志不打印\n\nhttps://gitee.com/dromara/liteFlow/issues/I5KAMF\n\n增强 #I5EU86 把fastjson替换成jackson\n\nhttps://gitee.com/dromara/liteFlow/issues/I5EU86\n\n修复 #I5KJFP Switch组件如果被spring动态代理后，无法取到跳转到的目标节点的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5KJFP\n\n\n# v2.8.3\n\n更新列表\n\n特性 #I5IA5U 提供节点包装语法+替补节点的功能\n\nhttps://gitee.com/dromara/liteFlow/issues/I5IA5U\n\n增强 #I5IOC5 LiteFlowResponse提供errorCode的功能\n\nhttps://gitee.com/dromara/liteFlow/issues/I5IOC5\n\n增强 #I5IJLN 支持脚本里获取requestData\n\nhttps://gitee.com/dromara/liteFlow/issues/I5IJLN\n\n增强 #I5I1QH 重构查找解析器的代码\n\nhttps://gitee.com/dromara/liteFlow/issues/I5I1QH\n\n\n# v2.8.2\n\n更新列表\n\n增强 #I5GBXI 支持EL中任意地方的注释\n\nhttps://gitee.com/dromara/liteFlow/issues/I5GBXI\n\n增强 #I5GD1G 在CmpStep中增加tag的属性\n\nhttps://gitee.com/dromara/liteFlow/issues/I5GD1G\n\n增强 #I5CBYT 框架内多次打印错误日志，希望可以关闭或调整打印次数\n\nhttps://gitee.com/dromara/liteFlow/issues/I5CBYT\n\n增强 #I5GS5F 优化Id生成器的Holder类的逻辑\n\nhttps://gitee.com/dromara/liteFlow/issues/I5GS5F\n\n修复 #I5GYX3 SWITCH不能只路由到1个节点的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5GYX3\n\n修复 #I5F73R 隐式子流程如果是并发的，则初始参数在并发中会被覆盖的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5F73R\n\n修复 #I5HBJC 当有并行子流程的时候，获取当前chainName有bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I5HBJC\n\n\n# v2.8.1\n\n更新列表\n\n增强 #I5FNR4 减少Liteflow核心包对第三方包的依赖\n\nhttps://gitee.com/dromara/liteFlow/issues/I5FNR4\n\n增强 #I5FV48 同样的规则，在用代码加载时不应该每次都被解析一遍\n\nhttps://gitee.com/dromara/liteFlow/issues/I5FV48\n\n修复 #I5G9L0 在相同组件执行完之后，取steps的时候，存在报错现象\n\nhttps://gitee.com/dromara/liteFlow/issues/I5G9L0\n\n\n# v2.8.0\n\n更新列表\n\n特性 #I5CW7I 【版本特性】构造全新的EL规则表达式\n\nhttps://gitee.com/dromara/liteFlow/issues/I5CW7I\n\n特性 #I5CHYH 提供多上下文支持的特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I5CHYH\n\n特性 #I5CJHI 支持requestId的自定义生成器\n\nhttps://gitee.com/dromara/liteFlow/issues/I5CJHI\n\n增强 #I5BR8P 组件打印信息，希望能定制带上别名\n\nhttps://gitee.com/dromara/liteFlow/issues/I5BR8P\n\n增强 #I4TGGV 子流程中的finally节点没有执行\n\nhttps://gitee.com/dromara/liteFlow/issues/I4TGGV\n\n增强 #I5BGGK 引入的dom4j 1.6.1版本报安全性问题，麻烦升级一下\n\nhttps://gitee.com/dromara/liteFlow/issues/I5BGGK\n\n增强 #I5BR5M chain重名的检测\n\nhttps://gitee.com/dromara/liteFlow/issues/I5BR5M\n\n增强 #I5BRFN 提取公共方法减少重复代码，去除魔法值\n\nhttps://gitee.com/dromara/liteFlow/issues/I5BRFN\n\n增强 #I5BVCU 改变核心结构，Condition也成为一个可执行单元\n\nhttps://gitee.com/dromara/liteFlow/issues/I5BVCU\n\n增强 #I5C3OC 增加xml的dtd文件，从而提供格式输入提示和较验\n\nhttps://gitee.com/dromara/liteFlow/issues/I5C3OC\n\n增强 #I5CHYJ 去除FlowExecutor中直接返回上下文的执行方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I5CHYJ\n\n增强 #I5CW1E 调整LiteflowConfig包装类型\n\nhttps://gitee.com/dromara/liteFlow/issues/I5CW1E\n\n增强 #I5D89I 内部新增switchCondition，把选择组件独立出来做，更好的扩展\n\nhttps://gitee.com/dromara/liteFlow/issues/I5D89I\n\n增强 #I5DEGQ 增加Switch的节点类型，以替换cond节点的的定义\n\nhttps://gitee.com/dromara/liteFlow/issues/I5DEGQ\n\n增强 #I5E17C 对parser结构提取公共方法减少重复代码\n\nhttps://gitee.com/dromara/liteFlow/issues/I5E17C\n\n修复 #I58VZD 流程多次使用同一个条件组件问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I58VZD\n\n修复 #I4IOLB when在解析时某些情况下不会合并\n\nhttps://gitee.com/dromara/liteFlow/issues/I4IOLB\n\n\n# v2.7.3\n\n更新列表\n\n修复 #I5CB1Y 声明式组件无法进入beforeProcess和afterProcess方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I5CB1Y\n\n修复 #I5C7LM 声明式组件的方法名自定义会出问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5C7LM\n\n\n# v2.7.2\n\n更新列表\n\n修复 #I5BZW7 隐式流程的requestData获取不到的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5BZW7\n\n修复 #I5C23U 子流程用getChainName取不到当前ChainName的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I5C23U\n\n\n# v2.7.1\n\n更新列表\n\n特性 #I5AYM5 组件事件回调特性支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I5AYM5\n\n修复 #I5AVD2 新版本2.7.0中，全局切面中拿不到组件的别名了\n\nhttps://gitee.com/dromara/liteFlow/issues/I5AVD2\n\n修复 #I5AYI1 修复默认值提醒有误差\n\nhttps://gitee.com/dromara/liteFlow/issues/I5AYI1\n\n\n# v2.7.0\n\n更新列表\n\n特性 #I588BO 对Slot模型的重构，在用户使用中去除Slot模型的概念，引入上下文的概念\n\nhttps://gitee.com/dromara/liteFlow/issues/I588BO\n\n特性 #I4U5S3 liteFlow日志级别打印开关设置\n\nhttps://gitee.com/dromara/liteFlow/issues/I4U5S3\n\n增强 #I58VVV 对core的package结构进行整理\n\nhttps://gitee.com/dromara/liteFlow/issues/I58VVV\n\n增强 #I595MU 在slot的元数据里增加每个组件执行的耗时和是否成功结果\n\nhttps://gitee.com/dromara/liteFlow/issues/I595MU\n\n增强 #I56ZQ3 打印步骤与执行时间\n\nhttps://gitee.com/dromara/liteFlow/issues/I56ZQ3\n\n增强 #I5A55K 在NodeComponent里重新加上beforeProcess和afterProcess方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I5A55K\n\n增强 #I5851Y 对启动初始化的报错进行区分下，现在报错粒度太粗\n\nhttps://gitee.com/dromara/liteFlow/issues/I5851Y\n\n增强 #I5851R 对自定义组件名进行trim，防止开发者手误有空格\n\nhttps://gitee.com/dromara/liteFlow/issues/I5851R\n\n修复 #I4XRBA 关于when和then混合使用时(有any和isAccess的情况下)，then的节点先执行的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4XRBA\n\n修复 #I4TJB0 自定义的Slot类必须有无惨构建\n\nhttps://gitee.com/dromara/liteFlow/issues/I4TJB0\n\n修复 #I4I730 this.setIsEnd(true)主动终止,2.6.4中抛出的异常ChainEndException还是打印error日志\n\nhttps://gitee.com/dromara/liteFlow/issues/I4I730\n\n\n# v2.6.14\n\n更新列表\n\n特性 #I54VBS 从设计上改善NodeComponent，支持声明式组件\n\nhttps://gitee.com/dromara/liteFlow/issues/I54VBS\n\n增强 #I57IEJ requestId更换算法，看上去更加整洁\n\nhttps://gitee.com/dromara/liteFlow/issues/I57IEJ\n\n修复 #I576ZY 修复processor异常后 ICmpAroundAspect里面的aferProcess不能正常执行的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I576ZY\n\n\n# v2.6.13\n\n更新列表\n\n特性 #I4ZVCL 执行器增加future的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I4ZVCL\n\n特性 #I51OBD 支持流程的销毁\n\nhttps://gitee.com/dromara/liteFlow/issues/I51OBD\n\n增强 #I4ZPNQ 隐式调用流程建议增加返回reponse的接口\n\nhttps://gitee.com/dromara/liteFlow/issues/I4ZPNQ\n\n修复 #I510LM 使用windows的绝对路径下的配置文件存在bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I510LM\n\n\n# v2.6.12\n\n更新列表\n\n增强 #I4YRVI 添加可执行实体对象作为构建流程的中间载体\n\nhttps://gitee.com/dromara/liteFlow/issues/I4YRVI\n\n修复 #I4YNN6 在某些高版本的springboot中，bean的重复注册会有问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4YNN6\n\n\n# v2.6.11\n\n更新列表\n\n特性 #I4UPWG 模块架构调整，支持非Spring的项目使用\n\nhttps://gitee.com/dromara/liteFlow/issues/I4UPWG\n\n增强 #I4VTWB 代码动态构建规则,setClazz方法使用全限定名不太友好\n\nhttps://gitee.com/dromara/liteFlow/issues/I4VTWB\n\n增强 #I4TIWM whenExecutors目前不用注入到spring上下文中了\n\nhttps://gitee.com/dromara/liteFlow/issues/I4TIWM\n\n修复 #I4VEV2 用spring扫描组件，但是流程用动态代码创建，会出现slot无法分配的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I4VEV2\n\n修复 #I4VGCN 在非spring环境下，LiteflowConfigGetter无法获取到原始的config实例\n\nhttps://gitee.com/dromara/liteFlow/issues/I4VGCN\n\n\n# v2.6.10\n\n更新列表\n\n特性 #I4R7AN 支持自定义组件执行器的扩展\n\nhttps://gitee.com/dromara/liteFlow/issues/I4R7AN\n\n增强 #I4T3NQ 适配spring的懒加载模式\n\nhttps://gitee.com/dromara/liteFlow/issues/I4T3NQ\n\n增强 #I4T3MQ 去除this.setIsEnd(true)打出的堆栈信息\n\nhttps://gitee.com/dromara/liteFlow/issues/I4T3MQ\n\n修复 #I4TBDT 修复因为ChianEndException导致的用slot接受抛错的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4TBDT\n\n\n# v2.6.8\n\n更新列表\n\n特性 #I4GS07 代码动态组件装配的特性\n\nhttps://gitee.com/dromara/liteFlow/issues/I4GS07\n\n特性 #I4QWH7 支持循环依赖\n\nhttps://gitee.com/dromara/liteFlow/issues/I4QWH7\n\n增强 #I4OQIX 组件执行轨迹日志级别调整\n\nhttps://gitee.com/dromara/liteFlow/issues/I4OQIX\n\n增强 #I4OTK4 希望finally组件可以获取到then组件的异常对象\n\nhttps://gitee.com/dromara/liteFlow/issues/I4OTK4\n\n增强 #I4PJKP when标签中默认的errorResume改为false\n\nhttps://gitee.com/dromara/liteFlow/issues/I4PJKP\n\n增强 #I4PTY4 修复CopyOnWriteHashMap可能存在的Bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I4PTY4\n\n增强 #I4QV69 QLExpressScriptExecutor加载缓存脚本有线程安全问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4QV69\n\n增强 #I4QWJK 重构parser逻辑，解决的代码冗余问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4QWJK\n\n增强 #I4R5UI 升级LiteFlow的相关第三方依赖jar包的版本\n\nhttps://gitee.com/dromara/liteFlow/issues/I4R5UI\n\n修复 #I4RF0A 解决有些场景里启动时SpringAware后加载的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4RF0A\n\n修复 #I4QOP6 when超时时抛出的错是NPT\n\nhttps://gitee.com/dromara/liteFlow/issues/I4QOP6\n\n修复 #I4PA2A 在NodeComponent的isAccess中获取tag失败\n\nhttps://gitee.com/dromara/liteFlow/issues/I4PA2A\n\n\n# v2.6.7\n\n更新列表\n\n修复 #I4MINM 加载脚本节点时，节点里面的实例对象被改动了\n\nhttps://gitee.com/dromara/liteFlow/issues/I4MINM\n\n\n# v2.6.6\n\n更新列表\n\n特性 #I4E5NX 异步线程池自定义\n\nhttps://gitee.com/dromara/liteFlow/issues/I4E5NX\n\n增强 #I4M3Q4 ruleSource支持配置绝对路径的配置文件\n\nhttps://gitee.com/dromara/liteFlow/issues/I4M3Q4\n\n修复 #I4LV63 在2.6.5版本中多线程tag取值中，xml没有问题，而json形式有问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4LV63\n\n修复 #I4LUQ5 默认的slot的dataMap无法放入值为null的对象\n\nhttps://gitee.com/dromara/liteFlow/issues/I4LUQ5\n\n\n# v2.6.5\n\n更新列表\n\n增强 #I4IDB0 hutool依赖版本冲突，升级了hutool版本\n\nhttps://gitee.com/dromara/liteFlow/issues/I4IDB0\n\n修复 #I4HZYN 使用When操作同一个Node时，会造成Tag标签的线程不安全\n\nhttps://gitee.com/dromara/liteFlow/issues/I4HZYN\n\n\n# v2.6.4\n\n更新列表\n\n特性 #I4GYV2 script节点支持从文件中获取脚本\n\nhttps://gitee.com/dromara/liteFlow/issues/I4GYV2\n\n特性 #I4HGOW 支持链路的前置和后置节点\n\nhttps://gitee.com/dromara/liteFlow/issues/I4HGOW\n\n特性 #I4FSHW 优雅平滑刷新的支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I4FSHW\n\n特性 #I4GS03 并行节点中支持任意节点结束即继续的流程设计\n\nhttps://gitee.com/dromara/liteFlow/issues/I4GS03\n\n增强 #I4HKZG 借鉴asyncTool对异步线程底层进行了彻底重构\n\nhttps://gitee.com/dromara/liteFlow/issues/I4HKZG\n\n增强 #I4HD8L 支持异步节点返回自定义的错误\n\nhttps://gitee.com/dromara/liteFlow/issues/I4HD8L\n\n增强 #I4GZ1Q 增强异步线程超时的情况下打印出具体超时节点的信息\n\nhttps://gitee.com/dromara/liteFlow/issues/I4GZ1Q\n\n增强 #I4EXCP 新增 自定义 关闭/启动 Banner\n\nhttps://gitee.com/dromara/liteFlow/issues/I4EXCP\n\n修复 #I4GY9L 在启动后马上刷新流程后会有offerSlot的报错\n\nhttps://gitee.com/dromara/liteFlow/issues/I4GY9L\n\n修复 #I4FYKA jsonparser好像缺少脚本条件组件的解析\n\nhttps://gitee.com/dromara/liteFlow/issues/I4FYKA\n\n修复 #I4HQAA setIsEnd目前受isContinue的判断影响，还是会继续\n\nhttps://gitee.com/dromara/liteFlow/issues/I4HQAA\n\n修复 #I4HTY6 异步线程池不受配置控制的bug，一直是默认的数量\n\nhttps://gitee.com/dromara/liteFlow/issues/I4HTY6\n\n\n# v2.6.3\n\n更新列表\n\n增强 #I4E0V9 支持在NodeComponent里自定义beforeProcess和afterProcess,没有覆盖方式时，默认读取aspect里的方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I4E0V9\n\n增强 #I4DGEU 可以实现把ZK客户端curator依赖改成optional吗\n\nhttps://gitee.com/dromara/liteFlow/issues/I4DGEU\n\n修复 #I4E11G xml里定义条件组件有空格无法识别，如：b( testChan3 | testChan2 )。增加节点trim处理\n\nhttps://gitee.com/dromara/liteFlow/issues/I4E11G\n\n修复 #I4E2V4 修复异步线程池没有被TTL修饰有可能引起的无法拿到ThreadLocal值的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I4E2V4\n\n\n# v2.6.2\n\n更新列表\n\n特性 #I4CRSY 在一个流程中的同名组件无法传递不同的参数，为组件增加标签属性\n\nhttps://gitee.com/dromara/liteFlow/issues/I4CRSY\n\n\n# v2.6.1\n\n更新列表\n\n修复 #I4CGL8 QLExpress脚本引擎在refresh脚本节点的时候会失败\n\nhttps://gitee.com/dromara/liteFlow/issues/I4CGL8\n\n增强 #I455ZS 规则重复嵌套校验\n\nhttps://gitee.com/dromara/liteFlow/issues/I455ZS\n\n\n# v2.6.0\n\n更新列表\n\n特性 #I4892Y 提供私有投递特性，slot这种结构体系，对于多个子线程进入同一个组件的情况下，不容易区分不同的传值。无法做到重用组件\n\nhttps://gitee.com/dromara/liteFlow/issues/I4892Y\n\n特性 #I49FDK 中断重试目前是全局的，希望增加针对个别组件和特定exception\n\nhttps://gitee.com/dromara/liteFlow/issues/I49FDK\n\n增强 #I49JP1 DataBus中SlotSize的大小不支持动态扩展，无法应对高并发下的流量突增\n\nhttps://gitee.com/dromara/liteFlow/issues/I49JP1\n\n增强 #I45QAJ 支持自定义的zkNodePath\n\nhttps://gitee.com/dromara/liteFlow/issues/I45QAJ\n\n修复 #I49EHH setIsEnd设计的不合理性\n\nhttps://gitee.com/dromara/liteFlow/issues/I49EHH\n\n修复 #I4BAJC setIsEnd结束的流程不需要进行重试\n\nhttps://gitee.com/dromara/liteFlow/issues/I4BAJC\n\n修复 #I49L1S 初始化DataBus的数据槽索引QUEUE大小的时候容量设置有问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I49L1S\n\n修复 #I46U6Y 自定义JsonParse,调用flowExecutor的reloadRule,抛出异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I46U6Y\n\n\n# v2.6.0-BETA1\n\n更新列表\n\n特性 #I44FT8 支持脚本语言的组件，并支持动态刷新脚本(版本特性)\n\nhttps://gitee.com/dromara/liteFlow/issues/I44FT8\n\n特性 #I3ZVEA 流程组件支持重试\n\nhttps://gitee.com/dromara/liteFlow/issues/I3ZVEA\n\n增强 #I40DWO 流程配置文件中增加业务描述，打印步骤中带入业务描述\n\nhttps://gitee.com/dromara/liteFlow/issues/I40DWO\n\n修复 #I3VZMZ when类型condition场景下记录节点执行路径的方法会造成数据丢失\n\nhttps://gitee.com/dromara/liteFlow/issues/I3VZMZ\n\n修复 #I3UOJG 流程终止Slot内无数据\n\nhttps://gitee.com/dromara/liteFlow/issues/I3UOJG\n\n\n# v2.5.10\n\n更新列表\n\n增强 #I426YS 支持多个不同类型的配置方式同时解析\n\nhttps://gitee.com/dromara/liteFlow/issues/I426YS\n\n修复 #I40VPB 关于LiteflowExecutorAutoConfiguration中的shutdown bean名称\n\nhttps://gitee.com/dromara/liteFlow/issues/I40VPB\n\n\n# v2.5.9\n\n更新列表\n\n修复：#I413PU 增加liteflow.enable参数，来标记是否自动装配liteflow\n\nhttps://gitee.com/dromara/liteFlow/issues/I413PU\n\n修复：#I40YVK 当主流程与子流程在不同的配置文件中时，会报错\n\nhttps://gitee.com/dromara/liteFlow/issues/I40YVK\n\n修复：#I41S18 在开启监控的情况下，偶尔会报出空指针的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I41S18\n\n\n# v2.5.8\n\n更新列表\n\n修复：#I3YX3Z 当抛出异常时，LiteflowResponse中的Slot为null\n\nhttps://gitee.com/dromara/liteFlow/issues/I3YX3Z\n\n\n# v2.5.7\n\n更新列表\n\n修复：#I3W8FH 自定义配置源类无法依赖spring上下文中的bean的bug\n\nhttps://gitee.com/dromara/liteFlow/issues/I3W8FH\n\n\n# v2.5.6\n\n更新列表\n\n修复: #I3SFOO:2.5.X解析多个flow.xml文件时条件节点的条件节点list会被清空\n\nhttps://gitee.com/dromara/liteFlow/issues/I3SFOO\n\n增强: #I3S5G8:动态平滑刷新机制\n\nhttps://gitee.com/dromara/liteFlow/issues/I3S5G8\n\n增强: #I3S0QA:DataBus 性能优化 Lock Free\n\nhttps://gitee.com/dromara/liteFlow/issues/I3S0QA\n\n\n# v2.5.5\n\n更新列表\n\n增强: #I3QRW9 希望增加对SpringBoot 1.5.x版本的兼容适配\n\nhttps://gitee.com/dromara/liteFlow/issues/I3QRW9\n\n增强：#I3N144 是否能支持rule的通配符\n\nhttps://gitee.com/dromara/liteFlow/issues/I3N144\n\n增强：#I3IPXG 流程加载的时候 可以把流程加载的来源 也打印到日志中\n\nhttps://gitee.com/dromara/liteFlow/issues/I3IPXG\n\n修复：#I3ND7T 目前springboot下的缺省rule-source不起作用\n\nhttps://gitee.com/dromara/liteFlow/issues/I3ND7T\n\n\n# v2.5.4\n\n更新列表\n\n修复: #I3NSF8 空的flow文件会导致无法启动\n\nhttps://gitee.com/dromara/liteFlow/issues/I3NSF8\n\n\n# v2.5.3\n\n更新列表\n\n特性：#I3N2E2 支持编程时式的注册组件的方式\n\nhttps://gitee.com/dromara/liteFlow/issues/I3N2E2\n\n增强：#I3MMBL 添加additional-spring-configuration-metadata.json 到 liteflow-springboot-starter\n\nhttps://gitee.com/dromara/liteFlow/issues/I3MMBL\n\n\n# v2.5.2\n\n更新列表\n\n修复：#I3IG1K SpringBoot的fat jar模式下，流程文件会找不到的问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I3IG1K\n\n增强：#I3IGEB 重命名FlowExecutor中流程调用方法名称\n\nhttps://gitee.com/dromara/liteFlow/issues/I3IGEB\n\n\n# v2.5.1\n\n更新列表\n\n增强：#I3I1TW 优化FlowExecutor中调用方法\n\nhttps://gitee.com/dromara/liteFlow/issues/I3I1TW\n\n\n# v2.5.0\n\n更新列表\n\n特性：#I3CTY2 规则支持json和yml\n\nhttps://gitee.com/dromara/liteFlow/issues/I3CTY2\n\n特性：#I37QVR 提供异步组件执行时候的线程池支持\n\nhttps://gitee.com/dromara/liteFlow/issues/I37QVR\n\n增强：#I3CT11 能对任意包的下的组件进行切面\n\nhttps://gitee.com/dromara/liteFlow/issues/I3CT11\n\n修复：#I3CT9A 监控打印的耗时不准确问题\n\nhttps://gitee.com/dromara/liteFlow/issues/I3CT9A\n\n增强：#I3C5Y9 对于底层配置结构作了优化更改\n\nhttps://gitee.com/dromara/liteFlow/issues/I3C5Y9\n\n增强：#I3CTMQ 抛弃org.apache.common的包，依赖hutool\n\nhttps://gitee.com/dromara/liteFlow/issues/I3CTMQ\n\n增强：#I3CTUK 每个组件的对slot index的存储，换成阿里的TTL\n\nhttps://gitee.com/dromara/liteFlow/issues/I3CTUK\n\n修复：#I3CT49 连续的when标签，之间并不是完全并行的\n\nhttps://gitee.com/dromara/liteFlow/issues/I3CT49\n\n修复：#I3DM7Y 2.4.0-RC1版本会出现基础同步组件失败的情形\n\nhttps://gitee.com/dromara/liteFlow/issues/I3DM7Y\n\n修复：#I3DMX4 目前FlowExecutor会吃掉业务异常\n\nhttps://gitee.com/dromara/liteFlow/issues/I3DMX4\n\n支持：#I3CT01 LiteFlow增加单元测试\n\nhttps://gitee.com/dromara/liteFlow/issues/I3CT01',normalizedContent:'# v2.12.4\n\n更新列表\n\n特性 #iass9z 新的javax脚本插件，支持java8~java17的所有语法特性\n\nhttps://gitee.com/dromara/liteflow/issues/iass9z\n\n特性 #iajd9h 期望liteflow 有自己的生命周期扩展\n\nhttps://gitee.com/dromara/liteflow/issues/iajd9h\n\n增强 #iasyi0 提供脚本初始化生命周期的扩展点\n\nhttps://gitee.com/dromara/liteflow/issues/iasyi0\n\n增强 #i9h6gy sql脚本在配置上支持用户自定义的过滤条件\n\nhttps://gitee.com/dromara/liteflow/issues/i9h6gy\n\n增强 #iavh8o 把scanner当中的步骤抽象出来，形成一套小的体系，方便的扩展\n\nhttps://gitee.com/dromara/liteflow/issues/iavh8o\n\n增强 #iany4u 组件中提供getcmpdatalist接口\n\nhttps://gitee.com/dromara/liteflow/issues/iany4u\n\n增强 #i5xb03 提供带域名的dtd文件地址，加强xml的提示\n\nhttps://gitee.com/dromara/liteflow/issues/i5xb03\n\n修复 #iasw3i 异步循环迭代组件中迭代对象以及迭代下标存在并发问题\n\nhttps://gitee.com/dromara/liteflow/issues/iasw3i\n\n\n# v2.12.3\n\n更新列表\n\n特性 #i9t6pb 嵌套循环获得任意外层的下标或者对象\n\nhttps://gitee.com/dromara/liteflow/issues/i9t6pb\n\n增强 #iah00w 增加在liteflowresponse中超时节点的id获取方式\n\nhttps://gitee.com/dromara/liteflow/issues/iah00w\n\n增强 #iambu8 elbus 增加普通节点构建方法\n\nhttps://gitee.com/dromara/liteflow/issues/iambu8\n\n增强 #iaow43 在solon体系中支持声明式的组件\n\nhttps://gitee.com/dromara/liteflow/issues/iaow43\n\n增强 #iagj2f 在使用最新版决策路由功能时发现spi加载有报错问题\n\nhttps://gitee.com/dromara/liteflow/issues/iagj2f\n\n修复 #iaern6 隐式子流程嵌套报错\n\nhttps://gitee.com/dromara/liteflow/issues/iaern6\n\n修复 #iaih89 在sql插件多个数据源都能检测执行通过的情况下，有可能会出现连接泄露\n\nhttps://gitee.com/dromara/liteflow/issues/iaih89\n\n修复 #iajr32 修复在parallelstrategyexecutor可能出现的npe问题\n\nhttps://gitee.com/dromara/liteflow/issues/iajr32\n\n修复 #iaoick graaljavascriptexecutor 这个类的compile()方法中新开的context没有关闭，可能有隐患\n\nhttps://gitee.com/dromara/liteflow/issues/iaoick\n\n\n# v2.12.2.1\n\n更新列表\n\n修复 #iafkqv 声明式的onerror方法取不到exception\n\nhttps://gitee.com/dromara/liteflow/issues/iafkqv\n\n\n# v2.12.2\n\n更新列表\n\n增强 #iae5pa flowbus中提供刷新route的api方法\n\nhttps://gitee.com/dromara/liteflow/issues/iae5pa\n\n增强 #iaceh9 sql插件中的轮询逻辑优化\n\nhttps://gitee.com/dromara/liteflow/issues/iaceh9\n\n增强 #iacegb 上下文超类判断的获取和转换\n\nhttps://gitee.com/dromara/liteflow/issues/iacegb\n\n增强 #ia9qbg el-builder的部分重构\n\nhttps://gitee.com/dromara/liteflow/issues/ia9qbg\n\n增强 #ia9noi elbus中增加对retry构建的api支持\n\nhttps://gitee.com/dromara/liteflow/issues/ia9noi\n\n增强 #ia6e3q redis配置的时候可以指定redisson的链接数，默认的connections太多了\n\nhttps://gitee.com/dromara/liteflow/issues/ia6e3q\n\n增强 #ia8b3t 插件 throw exception 会丢失堆栈\n\nhttps://gitee.com/dromara/liteflow/issues/ia8b3t\n\n增强 #iabk5c 校验 el 表达式，获取校验失败原因\n\nhttps://gitee.com/dromara/liteflow/issues/iabk5c\n\n修复 #ia5pak elbus串行编排不支持对每个节点进行超时配置\n\nhttps://gitee.com/dromara/liteflow/issues/ia5pak\n\n修复 #iad2hh 希望支持执行节点日志与监控日志的分开管理\n\nhttps://gitee.com/dromara/liteflow/issues/iad2hh\n\n修复 #iacsq8 liteflow-solon-plugin 启动报错\n\nhttps://gitee.com/dromara/liteflow/issues/iacsq8\n\n修复 #iadixe 使用迭代循环组件，下游getcurrloopobj()获取为null\n\nhttps://gitee.com/dromara/liteflow/issues/iadixe\n\n\n# v2.12.1\n\n更新列表\n\n特性 #i9k14c 为process方法提供注入型参数特性\n\nhttps://gitee.com/dromara/liteflow/issues/i9k14c\n\n特性 #i9h6gn 支持kotlin脚本语言\n\nhttps://gitee.com/dromara/liteflow/issues/i9h6gn\n\n特性 #i9pvq7 决策路由中增加namespace，可以执行指定命名空间的决策路由\n\nhttps://gitee.com/dromara/liteflow/issues/i9pvq7\n\n特性 #i9rpbk 数据库插件支持决策路由特性\n\nhttps://gitee.com/dromara/liteflow/issues/i9rpbk\n\n修复 #i9jdy1 绝对路径模糊匹配，没对windows的路径做支持\n\nhttps://gitee.com/dromara/liteflow/issues/i9jdy1\n\n修复 #i9n5k8 在自定义组件后，通过getcmpdata 获取data的实体对象，data字段与实体类不匹配是会抛异常\n\nhttps://gitee.com/dromara/liteflow/issues/i9n5k8\n\n\n# v2.12.0\n\n更新列表\n\n特性 #i96a33 为lf增加决策表特性\n\nhttps://gitee.com/dromara/liteflow/issues/i96a33\n\n特性 #i9dqdu 允许对不存在的组件增加全局参数\n\nhttps://gitee.com/dromara/liteflow/issues/i9dqdu\n\n特性 #i9050w 为每一个上下文提供一个名字，使用时可以根据名字来获取\n\nhttps://gitee.com/dromara/liteflow/issues/i9050w\n\n特性 #i8pl2m el语句里可以设置重试次数，类似于el中的超时时间\n\nhttps://gitee.com/dromara/liteflow/issues/i8pl2m\n\n特性 #i61d1n 规则层面增加一个enable的选项，可以禁用规则\n\nhttps://gitee.com/dromara/liteflow/issues/i61d1n\n\n特性 #i8yncb 查看某一个chainid下的所有node\n\nhttps://gitee.com/dromara/liteflow/issues/i8yncb\n\n特性 #i8hdia 新增一个验证脚本的方法\n\nhttps://gitee.com/dromara/liteflow/issues/i8hdia\n\n增强 #i8smqb break、if、while组件统一变成布尔组件\n\nhttps://gitee.com/dromara/liteflow/issues/i8smqb\n\n增强 #i8mw6q 没有脚本（node）加载后没有提供卸载的方法，可能造成脚本一直占用内存\n\nhttps://gitee.com/dromara/liteflow/issues/i8mw6q\n\n增强 #i905ad 优化注解的获取速度，优化性能\n\nhttps://gitee.com/dromara/liteflow/issues/i905ad\n\n增强 #i95xtd python脚本无法写return脚本\n\nhttps://gitee.com/dromara/liteflow/issues/i95xtd\n\n增强 #i90irr 设置超时maxwaitsenconds之后，超时的组件仍旧执行会报出npe的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i90irr\n\n增强 #i9f2hp 链路继承中的占位符换成双括弧\n\nhttps://gitee.com/dromara/liteflow/issues/i9f2hp\n\n增强 #i98l0s 现版本需要依赖jackson2.16，缺少toprettystring方法\n\nhttps://gitee.com/dromara/liteflow/issues/i98l0s\n\n增强 #i97y7y 2.11.4.2版本中componentscanner初始化失败，建议重写beanpostprocessor#postprocessbeforeinitialization\n\nhttps://gitee.com/dromara/liteflow/issues/i97y7y\n\n增强 #i91aut 对于诸如iscontinueonerror或isaccess这样的方法，期望能够提供set形式的调用\n\nhttps://gitee.com/dromara/liteflow/issues/i91aut\n\n修复 #i932v4 组件降级，在寻找降级组件时，仍应该去查找下有没有对应的组件\n\nhttps://gitee.com/dromara/liteflow/issues/i932v4\n\n修复 #i8ydge 在迭代循环组件中，无法获取子流程传递的请求参数\n\nhttps://gitee.com/dromara/liteflow/issues/i8ydge\n\n修复 #i8y0x4 并行循环中有可能导致的conditionstack的并发问题\n\nhttps://gitee.com/dromara/liteflow/issues/i8y0x4\n\n\n# v2.11.4\n\n更新列表\n\n增强 #i8uqr4 while组件本身加入loopindex\n\nhttps://gitee.com/dromara/liteflow/issues/i8uqr4\n\n增强 #i8tzfq 优化el的check报错提示，代码优化\n\nhttps://gitee.com/dromara/liteflow/issues/i8tzfq\n\n增强 #i8qje1 增加映射关键字ser和par\n\nhttps://gitee.com/dromara/liteflow/issues/i8qje1\n\n增强 #i8pwwo cmpstep中加入starttime和endtime\n\nhttps://gitee.com/dromara/liteflow/issues/i8pwwo\n\n增强 #i8mxib when线程池可能存在第一次调用的时候初始化\n\nhttps://gitee.com/dromara/liteflow/issues/i8mxib\n\n增强 #i8mxhx isaccess在when中会被执行2次的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i8mxhx\n\n增强 #i8j622 动态组件el语句data参数缺少单引号\n\nhttps://gitee.com/dromara/liteflow/issues/i8j622\n\n增强 #i8ide5 对声明式代理底层代码进行增强\n\nhttps://gitee.com/dromara/liteflow/issues/i8ide5\n\n增强 #i8h1lt 希望提供nacos对于阿里云mse的鉴权方式\n\nhttps://gitee.com/dromara/liteflow/issues/i8h1lt\n\n增强 #i8fc4f 超大量规则场景下项目启动时间过长的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i8fc4f\n\n增强 #i8fbbw chain及script新增enable字段后sql打印错误\n\nhttps://gitee.com/dromara/liteflow/issues/i8fbbw\n\n增强 #i8dw1j liteflowchainelbuilder.validate()依然存在bug\n\nhttps://gitee.com/dromara/liteflow/issues/i8dw1j\n\n增强 #i8ae9g 超时控制增加maxwaitmilliseconds关键字，以增加更精细的时间控制\n\nhttps://gitee.com/dromara/liteflow/issues/i8ae9g\n\n修复 #i8tztk el语句构建的时候，如果出现了脚本节点。会出npe的异常\n\nhttps://gitee.com/dromara/liteflow/issues/i8tztk\n\n修复 #i8s75a 去除循环检测，低版本的jackson可能导致的内存溢出问题\n\nhttps://gitee.com/dromara/liteflow/issues/i8s75a\n\n修复 #i8rwgz 开启when线程池隔离线程池创建有问题\n\nhttps://gitee.com/dromara/liteflow/issues/i8rwgz\n\n修复 #i8pez0 修复sql插件中script表中enable字段不起作用的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i8pez0\n\n修复 #i8af1o 修复redis的订阅模式mode解析的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i8af1o\n\n\n# v2.11.3\n\n更新列表\n\n增强 #i8bpm9 sql插件增加enable字段的映射\n\nhttps://gitee.com/dromara/liteflow/issues/i8bpm9\n\n修复 #i8bpmd 修复2.11.2中启动parse两次规则的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i8bpmd\n\n修复 #i8bphs 修复redis配置源哨兵模式的地址检查\n\nhttps://gitee.com/dromara/liteflow/issues/i8bphs\n\n修复 #i8awht liteflowchainelbuilder.validate()存在bug\n\nhttps://gitee.com/dromara/liteflow/issues/i8awht\n\n修复 #i8ar0l 组件定义了重试和回滚，回滚也会被重试\n\nhttps://gitee.com/dromara/liteflow/issues/i8ar0l\n\n修复 #i8af1o 修复redis的订阅模式mode解析的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i8af1o\n\n\n# v2.11.2\n\n更新列表\n\n修复 #i88tzw el组装api当有data方法时，缺少分号的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i88tzw\n\n修复 #i88u0q sql插件当eldata字段为空时，启动失败\n\nhttps://gitee.com/dromara/liteflow/issues/i88u0q\n\n\n# v2.11.1\n\n更新列表\n\n特性 #i7y0y1 sql插件支持轮询模式\n\nhttps://gitee.com/dromara/liteflow/issues/i7y0y1\n\n特性 #i7xaib when增加must语法\n\nhttps://gitee.com/dromara/liteflow/issues/i7xaib\n\n特性 #i878wv el表达式动态组装\n\nhttps://gitee.com/dromara/liteflow/issues/i878wv\n\n特性 #i7svzf 支持chain的继承关系特性\n\nhttps://gitee.com/dromara/liteflow/issues/i7svzf\n\n特性 #i7yylf 组件降级特性\n\nhttps://gitee.com/dromara/liteflow/issues/i7yylf\n\n特性 #i7zjrh 支持绝对路径的模糊匹配\n\nhttps://gitee.com/dromara/liteflow/issues/i7zjrh\n\n特性 #i883lb when线程池隔离支持\n\nhttps://gitee.com/dromara/liteflow/issues/i883lb\n\n增强 #i821f1 检测链路的循环依赖问题\n\nhttps://gitee.com/dromara/liteflow/issues/i821f1\n\n增强 #i7g6bb 自定义异步线程池初始化存在并发问题\n\nhttps://gitee.com/dromara/liteflow/issues/i7g6bb\n\n增强 #i855ym sql 插件重构\n\nhttps://gitee.com/dromara/liteflow/issues/i855ym\n\n修复 #i82m4g 回滚组件无法获得tag的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i82m4g\n\n修复 #i7zmvm 普通组件iscontinueonerror和isend为true时，process直接抛异常会导致isend失效\n\nhttps://gitee.com/dromara/liteflow/issues/i7zmvm\n\n\n# v2.11.0\n\n更新列表\n\n特性 #i7v6vb 建议增加janino插件，支持java脚本的书写\n\nhttps://gitee.com/dromara/liteflow/issues/i7v6vb\n\n特性 #i7t53a 增加redis存储规则的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i7t53a\n\n特性 #i7i3ll 允许对el中的每⼀个组件设置超时时间控制\n\nhttps://gitee.com/dromara/liteflow/issues/i7i3ll\n\n特性 #i7hjfx 循环表达式中支持异步模式\n\nhttps://gitee.com/dromara/liteflow/issues/i7hjfx\n\n特性 #i590jt 对于回滚流程的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i590jt\n\n增强 #i7qc8v sql插件格式化加入cdata\n\nhttps://gitee.com/dromara/liteflow/issues/i7qc8v\n\n增强 #i7q8bx 部分代码有npe风险\n\nhttps://gitee.com/dromara/liteflow/issues/i7q8bx\n\n增强 #i7q4bn 默认主线程池的名称拼写\n\nhttps://gitee.com/dromara/liteflow/issues/i7q4bn\n\n修复 #i7wnda sqlexception: 使用druid+oracle会报出关闭的语句错误\n\nhttps://gitee.com/dromara/liteflow/issues/i7wnda\n\n修复 #i7tys3 当组件出现exception的时候，afterprocess获取不到\n\nhttps://gitee.com/dromara/liteflow/issues/i7tys3\n\n\n# v2.10.7\n\n更新列表\n\n修复 #i7px3o v2.10.6版本中声明式的调用出现问题\n\nhttps://gitee.com/dromara/liteflow/issues/i7px3o\n\n\n# v2.10.6\n\n更新列表\n\n增强 #i7kr2f 测试用例全面更新为junit5\n\nhttps://gitee.com/dromara/liteflow/issues/i7kr2f\n\n增强 #i7j59v java17下进行完整的测试用例测试\n\nhttps://gitee.com/dromara/liteflow/issues/i7j59v\n\n增强 #i7kzcz 希望可以使用配置文件中已经配置的数据源\n\nhttps://gitee.com/dromara/liteflow/issues/i7kzcz\n\n增强 #i7ky2n 非操作符的短路控制优化\n\nhttps://gitee.com/dromara/liteflow/issues/i7ky2n\n\n增强 #i7hpan onerror方法增加exception入参\n\nhttps://gitee.com/dromara/liteflow/issues/i7hpan\n\n增强 #i7kopv 声明组件增加nodename的定义\n\nhttps://gitee.com/dromara/liteflow/issues/i7kopv\n\n增强 #i7khe5 关于注解声明式使用场景liteflowmethodenum增加getdisplayname\n\nhttps://gitee.com/dromara/liteflow/issues/i7khe5\n\n增强 #i7k3t1 自带aop拦截需要增强获取tag等信息\n\nhttps://gitee.com/dromara/liteflow/issues/i7k3t1\n\n增强 #i7jz4d 希望框架有与或非表达式的相关日志\n\nhttps://gitee.com/dromara/liteflow/issues/i7jz4d\n\n增强 #i7j1vj 希望针对节点执行耗时的打印日志支持控制\n\nhttps://gitee.com/dromara/liteflow/issues/i7j1vj\n\n增强 #i7lgzr 忘记填写 chainname 的错误提示\n\nhttps://gitee.com/dromara/liteflow/issues/i7lgzr\n\n修复 #i7l5dx 2.10.5版本中scriptbean注解注入bean失败\n\nhttps://gitee.com/dromara/liteflow/issues/i7l5dx\n\n修复 #i7htr4 同一组件不同tag，取step时候存在问题\n\nhttps://gitee.com/dromara/liteflow/issues/i7htr4\n\n修复 #i7gmts 本地文件监听异常会导致监听线程停止\n\nhttps://gitee.com/dromara/liteflow/issues/i7gmts\n\n\n# v2.10.5\n\n更新列表\n\n增强 #i7f567 增加对业务自定义requestid传入的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i7f567\n\n修复 #i7eks8 在isaccess中进行setisend(true)流程没有结束的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i7eks8\n\n修复 #i7ekp3 同一个线程里分别调用2个chain，currobj没有隔离的情况\n\nhttps://gitee.com/dromara/liteflow/issues/i7ekp3\n\n修复 #i7e8rn 次数循环组件 下标获取问题\n\nhttps://gitee.com/dromara/liteflow/issues/i7e8rn\n\n\n# v2.10.4\n\n更新列表\n\n增强 #i6xpn4 组件上添加 @refreshscope 初始化就失败了\n\nhttps://gitee.com/dromara/liteflow/issues/i6xpn4\n\n修复 #i7c6vr elif表达式中目前无法加入and or not表达式\n\nhttps://gitee.com/dromara/liteflow/issues/i7c6vr\n\n修复 #i7ccab 2.10.0中catchcondition会把chainendexception也捕获\n\nhttps://gitee.com/dromara/liteflow/issues/i7ccab\n\n修复 #i7cox4 switch跳转到设置tag的chain上，存在问题\n\nhttps://gitee.com/dromara/liteflow/issues/i7cox4\n\n\n# v2.10.3\n\n更新列表\n\n增强 #i6ura5 liteflow异常输出信息优化\n\nhttps://gitee.com/dromara/liteflow/issues/i6ura5\n\n增强 #i6zavn 支持qlexpress的高精度计算\n\nhttps://gitee.com/dromara/liteflow/issues/i6zavn\n\n增强 #i6q061 when组件最大等待时间希望能支持到毫秒级别\n\nhttps://gitee.com/dromara/liteflow/issues/i6q061\n\n修复 #i6y300 idgeneratorholder 存在 npe 异常\n\nhttps://gitee.com/dromara/liteflow/issues/i6y300\n\n修复 #i6wgi3 无法解析oracle url\n\nhttps://gitee.com/dromara/liteflow/issues/i6wgi3\n\n\n# v2.10.2\n\n更新列表\n\n特性 #i6rf8y el表达式里支持并或非操作符\n\nhttps://gitee.com/dromara/liteflow/issues/i6rf8y\n\n增强 #i6qofj groovy无法支持#循环下标获取获取，希望脚本可以支持获取循环下标\n\nhttps://gitee.com/dromara/liteflow/issues/i6qofj\n\n增强 #i6rfoe liteflow能否在流程（表达式）添加类似tag字段的属性，提高选择组件的复用率呢？\n\nhttps://gitee.com/dromara/liteflow/issues/i6rfoe\n\n修复 #i6trt2 el表达式里的//被过滤掉了\n\nhttps://gitee.com/dromara/liteflow/issues/i6trt2\n\n修复 #i6urnq 在catch表达中写单独的组件，slot中会拿不到异常\n\nhttps://gitee.com/dromara/liteflow/issues/i6urnq\n\n\n# v2.10.1\n\n更新列表\n\n特性 #i6o380 支持aviator的脚本语言\n\nhttps://gitee.com/dromara/liteflow/issues/i6o380\n\n增强 #i6p8f8 支持循环表达式的嵌套循环\n\nhttps://gitee.com/dromara/liteflow/issues/i6p8f8\n\n增强 #i6o2ye 外置存储支持多脚本混合调用\n\nhttps://gitee.com/dromara/liteflow/issues/i6o2ye\n\n增强 #i6obzy 增加代码格式化插件，统一代码风格\n\nhttps://gitee.com/dromara/liteflow/issues/i6obzy\n\n\n# v2.10.0\n\n更新列表\n\n特性 #i6nrkh liteflow支持springboot 3.0\n\nhttps://gitee.com/dromara/liteflow/issues/i6nrkh\n\n特性 #i6ngm3 liteflow支持多种不同语言脚本混合调用的特性\n\nhttps://gitee.com/dromara/liteflow/issues/i6ngm3\n\n特性 #i6mpyf 增加catch语法表达式\n\nhttps://gitee.com/dromara/liteflow/issues/i6mpyf\n\n特性 #i6bdln 是否能绝对路径的目录位置及其所有子目录下规则配置文件的侦听\n\nhttps://gitee.com/dromara/liteflow/issues/i6bdln\n\n特性 #i69m1m 对上下文在脚本中的引用，支持自定义名称\n\nhttps://gitee.com/dromara/liteflow/issues/i69m1m\n\n增强 #i6lwym 深层次优化condition维度的代码\n\nhttps://gitee.com/dromara/liteflow/issues/i6lwym\n\n修复 #i6g0d5 nodeifcomponent 重写 isaccess 导致空指针报错\n\nhttps://gitee.com/dromara/liteflow/issues/i6g0d5\n\n修复 #i6jf0k 迭代&循环组件在switch语境中无法获取迭代对象和下标的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i6jf0k\n\n修复 #i6l8yb 对于脚本名称存在<符号在执行脚本时异常\n\nhttps://gitee.com/dromara/liteflow/issues/i6l8yb\n\n\n# v2.9.7\n\n更新列表\n\n特性 #i6a2gl 增加迭代器表达式特性，用于迭代循环中的集合\n\nhttps://gitee.com/dromara/liteflow/issues/i6a2gl\n\n增强 #i52tbw 增加与 solon 框架的适配\n\nhttps://gitee.com/dromara/liteflow/issues/i52tbw\n\n增强 #i691ld 对beforeprocess和afterprocess两个方法进行参数优化\n\nhttps://gitee.com/dromara/liteflow/issues/i691ld\n\n增强 #i6bdn3 groovy脚本文件组件希望支持绝对路径\n\nhttps://gitee.com/dromara/liteflow/issues/i6bdn3\n\n增强 #i679ux 组件参数设入json，支持在脚本组件中点操作符取到\n\nhttps://gitee.com/dromara/liteflow/issues/i679ux\n\n增强 #i6a2fi 增强slot元数据的存储，避免在多线程相同组件编排情况下可能造成的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i6a2fi\n\n增强 #i69qob 动态创建组件时，脚本异常信息完善\n\nhttps://gitee.com/dromara/liteflow/issues/i69qob\n\n修复 #i6cji9 修复循环组件中if组件获取不了index的情况\n\nhttps://gitee.com/dromara/liteflow/issues/i6cji9\n\n修复 #i6asng 采用sql数据源形式，flowexecutor项目初始化时，如果没有配置流程flowbus.getchainmap()会判空则抛出异常\n\nhttps://gitee.com/dromara/liteflow/issues/i6asng\n\n修复 #i69uvl 如果switch返回为空或者null，无法选取到default组件\n\nhttps://gitee.com/dromara/liteflow/issues/i69uvl\n\n修复 #i66qpq 从2.9开始启动报stackoverflowerror\n\nhttps://gitee.com/dromara/liteflow/issues/i66qpq\n\n\n# v2.9.6\n\n更新列表\n\n增强 #i66kp6 从底层改变nodecomponent和node之间的实例关联问题\n\nhttps://gitee.com/dromara/liteflow/issues/i66kp6\n\n增强 #i5vj85 循环组件支持获取当前循环的下标\n\nhttps://gitee.com/dromara/liteflow/issues/i5vj85\n\n修复 #i6624z 规则data不能传递纯字符串 "xxxx"，在脚本里获得会报错\n\nhttps://gitee.com/dromara/liteflow/issues/i6624z\n\n修复 #i668r2 zk，etcd中必须配置chain和script2个节点，只配置其中chain会报错\n\nhttps://gitee.com/dromara/liteflow/issues/i668r2\n\n修复 #i65tz2 本地配置文件，目录包含小数点时导致解析错误\n\nhttps://gitee.com/dromara/liteflow/issues/i65tz2\n\n\n# v2.9.5\n\n更新列表\n\n特性 #i63wme 希望支持apollo配置中心配置规则功能\n\nhttps://gitee.com/dromara/liteflow/issues/i63wme\n\n特性 #i64pdw 增加python脚本支持\n\nhttps://gitee.com/dromara/liteflow/issues/i64pdw\n\n特性 #i64t29 增加脚本语言lua的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i64t29\n\n增强 #i64t00 希望给 switch 增加一个 default 特性\n\nhttps://gitee.com/dromara/liteflow/issues/i64t00\n\n增强 #i62nek el解析方式pre、finally在嵌套子链中不生效\n\nhttps://gitee.com/dromara/liteflow/issues/i62nek\n\n增强 #i64l3q 期望拓展@scriptbean注解，能注入指定类的指定方法\n\nhttps://gitee.com/dromara/liteflow/issues/i64l3q\n\n增强 #i64hy4 liteflownodebuilder的添加节点代码优化\n\nhttps://gitee.com/dromara/liteflow/issues/i64hy4\n\n增强 #i64sy6 期望能完善错误信息的提示\n\nhttps://gitee.com/dromara/liteflow/issues/i64sy6\n\n修复 #i5xuqs 配置不同格式规则加载时，若el规则文件不存在，启动会报错。\n\nhttps://gitee.com/dromara/liteflow/issues/i5xuqs\n\n\n# v2.9.4\n\n更新列表\n\n特性 #i61xyz 额外提供graaljs引擎，在js上多一个选择\n\nhttps://gitee.com/dromara/liteflow/issues/i61xyz\n\n增强 #i63c31 zk，etcd支持只刷新改变的部分\n\nhttps://gitee.com/dromara/liteflow/issues/i63c31\n\n增强 #i61emz 增加一个验证el规则的api，供检查之用\n\nhttps://gitee.com/dromara/liteflow/issues/i61emz\n\n增强 #i633vh 建议flowbus提供批量移除子链方法\n\nhttps://gitee.com/dromara/liteflow/issues/i633vh\n\n增强 #i61ri0 希望可以开放对 qlexpress 的一些操作！\n\nhttps://gitee.com/dromara/liteflow/issues/i61ri0\n\n增强 #i622i9 内部代码规范chainname和chainid问题\n\nhttps://gitee.com/dromara/liteflow/issues/i622i9\n\n增强 #i61lyn 规范问题和 不必要的import 常量提取等\n\nhttps://gitee.com/dromara/liteflow/issues/i61lyn\n\n修复 #i62pv3 声明式组件如果把liteflowmethod定义在父类中，不执行\n\nhttps://gitee.com/dromara/liteflow/issues/i62pv3\n\n修复 #i62dt1 如果对上下文标注@scriptbean，那么脚本和java中拿到的上下文并不是同一个上下文\n\nhttps://gitee.com/dromara/liteflow/issues/i62dt1\n\n修复 #i61h49 脚本异常希望可以抛出到response\n\nhttps://gitee.com/dromara/liteflow/issues/i61h49\n\n修复 #i631zf groovy脚本接入时，自定义异常抛出后被组件失败异常覆盖\n\nhttps://gitee.com/dromara/liteflow/issues/i631zf\n\n修复 #i61hio 方法级的组件声明，然后在方法上打 spring 的事务注解 @transactional，会报错\n\nhttps://gitee.com/dromara/liteflow/issues/i61hio\n\n修复 #i62cb8 脚本与java交互取元数据的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i62cb8\n\n修复 #i61uz6 switch选择组件使用标签在同一组件时固定选到最后一个\n\nhttps://gitee.com/dromara/liteflow/issues/i61uz6\n\n\n# v2.9.3\n\n更新列表\n\n增强 #i5xwl2 数据库插件支持脚本的存储\n\nhttps://gitee.com/dromara/liteflow/issues/i5xwl2\n\n增强 #i605fa 支持etcd分离chain以及脚本的存储结构\n\nhttps://gitee.com/dromara/liteflow/issues/i605fa\n\n增强 #i5zlh6 支持zk分离chain以及脚本的存储结构\n\nhttps://gitee.com/dromara/liteflow/issues/i5zlh6\n\n增强 #i5y92x 支持选择组件跳转同时指定组件名和标签\n\nhttps://gitee.com/dromara/liteflow/issues/i5y92x\n\n增强 #i5ulva 修正不规范的问题，chain的name和id混用，不太严谨\n\nhttps://gitee.com/dromara/liteflow/issues/i5ulva\n\n修复 #i5zs92 希望能直接获取组件参数的原始字符串，而不是只能获取转换后的 json 对象\n\nhttps://gitee.com/dromara/liteflow/issues/i5zs92\n\n修复 #i5yehg 脚本的加载有先后顺序问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5yehg\n\n修复 #i5zs8i 修复el中定义的tag和data中的字符串的空格和换行被过滤掉了的现象\n\nhttps://gitee.com/dromara/liteflow/issues/i5zs8i\n\n\n# v2.9.2\n\n更新列表\n\n修复 2.9.1在nacos场景启动失败的bug\n\n\n# v2.9.1\n\n更新列表\n\n特性 #i5wnmg 脚本组件支持javascript的语法\n\nhttps://gitee.com/dromara/liteflow/issues/i5wnmg\n\n增强 #i5x7it rule-source-ext-data支持在springboot yml配置文件中的原生配置\n\nhttps://gitee.com/dromara/liteflow/issues/i5x7it\n\n增强 #i5x1o6 提升安全性，更新不安全的第三方依赖\n\nhttps://gitee.com/dromara/liteflow/issues/i5x1o6\n\n增强 #i5rv3g 规则插件的报错无法抛出来\n\nhttps://gitee.com/dromara/liteflow/issues/i5rv3g\n\n增强 #i5xb03 增加dtd文件，加强xml的提示\n\nhttps://gitee.com/dromara/liteflow/issues/i5xb03\n\n增强 #i5p263 脚本执行异常，出现异常的处理\n\nhttps://gitee.com/dromara/liteflow/issues/i5p263\n\n修复 #i5wsg9 2.9.0版本 tag在 when 下不生效\n\nhttps://gitee.com/dromara/liteflow/issues/i5wsg9\n\n修复 #i5wlqw 扫描@scriptbean修饰的类使用的hutool工具类不支持kotlin导致堆栈溢出\n\nhttps://gitee.com/dromara/liteflow/issues/i5wlqw\n\n\n# v2.9.0\n\n更新列表\n\n特性 #i5rv5d 循环表达式特性的增加\n\nhttps://gitee.com/dromara/liteflow/issues/i5rv5d\n\n特性 #i5roor 增加关系型数据库规则存储插件的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i5roor\n\n特性 #i4i5wz 增加nacos存储规则插件的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i4i5wz\n\n特性 #i5r005 添加etcd存储规则插件的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i5r005\n\n特性 #i5qchl 支持在method级别声明式特性\n\nhttps://gitee.com/dromara/liteflow/issues/i5qchl\n\n特性 #i5rv4w 加强脚本和java之间的互动\n\nhttps://gitee.com/dromara/liteflow/issues/i5rv4w\n\n特性 #i5u3rc 支持组件级别的规则参数配置\n\nhttps://gitee.com/dromara/liteflow/issues/i5u3rc\n\n特性 #i5rg4h 选择组件支持组件标签选择\n\nhttps://gitee.com/dromara/liteflow/issues/i5rg4h\n\n增强 #i5syc8 支持同一组件不同组件id的定义\n\nhttps://gitee.com/dromara/liteflow/issues/i5syc8\n\n增强 #i5qmdz 把zk存储的支持拆出来作为插件解耦合\n\nhttps://gitee.com/dromara/liteflow/issues/i5qmdz\n\n增强 #i5u1fh 去除老的表达式的支持，精简代码\n\nhttps://gitee.com/dromara/liteflow/issues/i5u1fh\n\n增强 #i5q3a7 优化qlexpress的runner初始化\n\nhttps://gitee.com/dromara/liteflow/issues/i5q3a7\n\n增强 #i5u5o6 对声明式类&方法进行了重构，提升了使用友好度\n\nhttps://gitee.com/dromara/liteflow/issues/i5u5o6\n\n增强 #i5t4ls 优化 flowparserprovider 类\n\nhttps://gitee.com/dromara/liteflow/issues/i5t4ls\n\n增强 #i5q3ss 对于el表达式里的未定义的子表达式和未注册的node进行编译时检查\n\nhttps://gitee.com/dromara/liteflow/issues/i5q3ss\n\n增强 #i5ofmu 优化 operator 代码\n\nhttps://gitee.com/dromara/liteflow/issues/i5ofmu\n\n修复 #i5pk9q 隐式流程里的异常会导致主流程里的异常发生\n\nhttps://gitee.com/dromara/liteflow/issues/i5pk9q\n\n修复 #i5pflg 组件统计耗时未统计后置处理\n\nhttps://gitee.com/dromara/liteflow/issues/i5pflg\n\n\n# v2.8.5\n\n更新列表\n\n特性 #i5ktst if三元符语法的添加以及if elif else语法的添加\n\nhttps://gitee.com/dromara/liteflow/issues/i5ktst\n\n增强 #i5o22x 增加el解析中的报错详细信息\n\nhttps://gitee.com/dromara/liteflow/issues/i5o22x\n\n增强 #i5mzjy 解决循环调用同步的隐式流程，参数只能取一次的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5mzjy\n\n修复 #i5nh56 switch组件对于cglib代理过的bean目前处理的不够全面\n\nhttps://gitee.com/dromara/liteflow/issues/i5nh56\n\n修复 i5nfv3 在zk集群中多个zk地址不生效的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i5nfv3\n\n\n# v2.8.4\n\n更新列表\n\n特性 #i5m34o 支持在流程执行前就传入一个初始化好的context对象的特性\n\nhttps://gitee.com/dromara/liteflow/issues/i5m34o\n\n增强 #i5ly8b 增强switchcondition里面的targetmap无法get到的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5ly8b\n\n增强 #i5kamf 是否可以增加自定义配置哪些异常类型日志不打印\n\nhttps://gitee.com/dromara/liteflow/issues/i5kamf\n\n增强 #i5eu86 把fastjson替换成jackson\n\nhttps://gitee.com/dromara/liteflow/issues/i5eu86\n\n修复 #i5kjfp switch组件如果被spring动态代理后，无法取到跳转到的目标节点的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5kjfp\n\n\n# v2.8.3\n\n更新列表\n\n特性 #i5ia5u 提供节点包装语法+替补节点的功能\n\nhttps://gitee.com/dromara/liteflow/issues/i5ia5u\n\n增强 #i5ioc5 liteflowresponse提供errorcode的功能\n\nhttps://gitee.com/dromara/liteflow/issues/i5ioc5\n\n增强 #i5ijln 支持脚本里获取requestdata\n\nhttps://gitee.com/dromara/liteflow/issues/i5ijln\n\n增强 #i5i1qh 重构查找解析器的代码\n\nhttps://gitee.com/dromara/liteflow/issues/i5i1qh\n\n\n# v2.8.2\n\n更新列表\n\n增强 #i5gbxi 支持el中任意地方的注释\n\nhttps://gitee.com/dromara/liteflow/issues/i5gbxi\n\n增强 #i5gd1g 在cmpstep中增加tag的属性\n\nhttps://gitee.com/dromara/liteflow/issues/i5gd1g\n\n增强 #i5cbyt 框架内多次打印错误日志，希望可以关闭或调整打印次数\n\nhttps://gitee.com/dromara/liteflow/issues/i5cbyt\n\n增强 #i5gs5f 优化id生成器的holder类的逻辑\n\nhttps://gitee.com/dromara/liteflow/issues/i5gs5f\n\n修复 #i5gyx3 switch不能只路由到1个节点的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5gyx3\n\n修复 #i5f73r 隐式子流程如果是并发的，则初始参数在并发中会被覆盖的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5f73r\n\n修复 #i5hbjc 当有并行子流程的时候，获取当前chainname有bug\n\nhttps://gitee.com/dromara/liteflow/issues/i5hbjc\n\n\n# v2.8.1\n\n更新列表\n\n增强 #i5fnr4 减少liteflow核心包对第三方包的依赖\n\nhttps://gitee.com/dromara/liteflow/issues/i5fnr4\n\n增强 #i5fv48 同样的规则，在用代码加载时不应该每次都被解析一遍\n\nhttps://gitee.com/dromara/liteflow/issues/i5fv48\n\n修复 #i5g9l0 在相同组件执行完之后，取steps的时候，存在报错现象\n\nhttps://gitee.com/dromara/liteflow/issues/i5g9l0\n\n\n# v2.8.0\n\n更新列表\n\n特性 #i5cw7i 【版本特性】构造全新的el规则表达式\n\nhttps://gitee.com/dromara/liteflow/issues/i5cw7i\n\n特性 #i5chyh 提供多上下文支持的特性\n\nhttps://gitee.com/dromara/liteflow/issues/i5chyh\n\n特性 #i5cjhi 支持requestid的自定义生成器\n\nhttps://gitee.com/dromara/liteflow/issues/i5cjhi\n\n增强 #i5br8p 组件打印信息，希望能定制带上别名\n\nhttps://gitee.com/dromara/liteflow/issues/i5br8p\n\n增强 #i4tggv 子流程中的finally节点没有执行\n\nhttps://gitee.com/dromara/liteflow/issues/i4tggv\n\n增强 #i5bggk 引入的dom4j 1.6.1版本报安全性问题，麻烦升级一下\n\nhttps://gitee.com/dromara/liteflow/issues/i5bggk\n\n增强 #i5br5m chain重名的检测\n\nhttps://gitee.com/dromara/liteflow/issues/i5br5m\n\n增强 #i5brfn 提取公共方法减少重复代码，去除魔法值\n\nhttps://gitee.com/dromara/liteflow/issues/i5brfn\n\n增强 #i5bvcu 改变核心结构，condition也成为一个可执行单元\n\nhttps://gitee.com/dromara/liteflow/issues/i5bvcu\n\n增强 #i5c3oc 增加xml的dtd文件，从而提供格式输入提示和较验\n\nhttps://gitee.com/dromara/liteflow/issues/i5c3oc\n\n增强 #i5chyj 去除flowexecutor中直接返回上下文的执行方法\n\nhttps://gitee.com/dromara/liteflow/issues/i5chyj\n\n增强 #i5cw1e 调整liteflowconfig包装类型\n\nhttps://gitee.com/dromara/liteflow/issues/i5cw1e\n\n增强 #i5d89i 内部新增switchcondition，把选择组件独立出来做，更好的扩展\n\nhttps://gitee.com/dromara/liteflow/issues/i5d89i\n\n增强 #i5degq 增加switch的节点类型，以替换cond节点的的定义\n\nhttps://gitee.com/dromara/liteflow/issues/i5degq\n\n增强 #i5e17c 对parser结构提取公共方法减少重复代码\n\nhttps://gitee.com/dromara/liteflow/issues/i5e17c\n\n修复 #i58vzd 流程多次使用同一个条件组件问题\n\nhttps://gitee.com/dromara/liteflow/issues/i58vzd\n\n修复 #i4iolb when在解析时某些情况下不会合并\n\nhttps://gitee.com/dromara/liteflow/issues/i4iolb\n\n\n# v2.7.3\n\n更新列表\n\n修复 #i5cb1y 声明式组件无法进入beforeprocess和afterprocess方法\n\nhttps://gitee.com/dromara/liteflow/issues/i5cb1y\n\n修复 #i5c7lm 声明式组件的方法名自定义会出问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5c7lm\n\n\n# v2.7.2\n\n更新列表\n\n修复 #i5bzw7 隐式流程的requestdata获取不到的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5bzw7\n\n修复 #i5c23u 子流程用getchainname取不到当前chainname的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i5c23u\n\n\n# v2.7.1\n\n更新列表\n\n特性 #i5aym5 组件事件回调特性支持\n\nhttps://gitee.com/dromara/liteflow/issues/i5aym5\n\n修复 #i5avd2 新版本2.7.0中，全局切面中拿不到组件的别名了\n\nhttps://gitee.com/dromara/liteflow/issues/i5avd2\n\n修复 #i5ayi1 修复默认值提醒有误差\n\nhttps://gitee.com/dromara/liteflow/issues/i5ayi1\n\n\n# v2.7.0\n\n更新列表\n\n特性 #i588bo 对slot模型的重构，在用户使用中去除slot模型的概念，引入上下文的概念\n\nhttps://gitee.com/dromara/liteflow/issues/i588bo\n\n特性 #i4u5s3 liteflow日志级别打印开关设置\n\nhttps://gitee.com/dromara/liteflow/issues/i4u5s3\n\n增强 #i58vvv 对core的package结构进行整理\n\nhttps://gitee.com/dromara/liteflow/issues/i58vvv\n\n增强 #i595mu 在slot的元数据里增加每个组件执行的耗时和是否成功结果\n\nhttps://gitee.com/dromara/liteflow/issues/i595mu\n\n增强 #i56zq3 打印步骤与执行时间\n\nhttps://gitee.com/dromara/liteflow/issues/i56zq3\n\n增强 #i5a55k 在nodecomponent里重新加上beforeprocess和afterprocess方法\n\nhttps://gitee.com/dromara/liteflow/issues/i5a55k\n\n增强 #i5851y 对启动初始化的报错进行区分下，现在报错粒度太粗\n\nhttps://gitee.com/dromara/liteflow/issues/i5851y\n\n增强 #i5851r 对自定义组件名进行trim，防止开发者手误有空格\n\nhttps://gitee.com/dromara/liteflow/issues/i5851r\n\n修复 #i4xrba 关于when和then混合使用时(有any和isaccess的情况下)，then的节点先执行的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4xrba\n\n修复 #i4tjb0 自定义的slot类必须有无惨构建\n\nhttps://gitee.com/dromara/liteflow/issues/i4tjb0\n\n修复 #i4i730 this.setisend(true)主动终止,2.6.4中抛出的异常chainendexception还是打印error日志\n\nhttps://gitee.com/dromara/liteflow/issues/i4i730\n\n\n# v2.6.14\n\n更新列表\n\n特性 #i54vbs 从设计上改善nodecomponent，支持声明式组件\n\nhttps://gitee.com/dromara/liteflow/issues/i54vbs\n\n增强 #i57iej requestid更换算法，看上去更加整洁\n\nhttps://gitee.com/dromara/liteflow/issues/i57iej\n\n修复 #i576zy 修复processor异常后 icmparoundaspect里面的aferprocess不能正常执行的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i576zy\n\n\n# v2.6.13\n\n更新列表\n\n特性 #i4zvcl 执行器增加future的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i4zvcl\n\n特性 #i51obd 支持流程的销毁\n\nhttps://gitee.com/dromara/liteflow/issues/i51obd\n\n增强 #i4zpnq 隐式调用流程建议增加返回reponse的接口\n\nhttps://gitee.com/dromara/liteflow/issues/i4zpnq\n\n修复 #i510lm 使用windows的绝对路径下的配置文件存在bug\n\nhttps://gitee.com/dromara/liteflow/issues/i510lm\n\n\n# v2.6.12\n\n更新列表\n\n增强 #i4yrvi 添加可执行实体对象作为构建流程的中间载体\n\nhttps://gitee.com/dromara/liteflow/issues/i4yrvi\n\n修复 #i4ynn6 在某些高版本的springboot中，bean的重复注册会有问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4ynn6\n\n\n# v2.6.11\n\n更新列表\n\n特性 #i4upwg 模块架构调整，支持非spring的项目使用\n\nhttps://gitee.com/dromara/liteflow/issues/i4upwg\n\n增强 #i4vtwb 代码动态构建规则,setclazz方法使用全限定名不太友好\n\nhttps://gitee.com/dromara/liteflow/issues/i4vtwb\n\n增强 #i4tiwm whenexecutors目前不用注入到spring上下文中了\n\nhttps://gitee.com/dromara/liteflow/issues/i4tiwm\n\n修复 #i4vev2 用spring扫描组件，但是流程用动态代码创建，会出现slot无法分配的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i4vev2\n\n修复 #i4vgcn 在非spring环境下，liteflowconfiggetter无法获取到原始的config实例\n\nhttps://gitee.com/dromara/liteflow/issues/i4vgcn\n\n\n# v2.6.10\n\n更新列表\n\n特性 #i4r7an 支持自定义组件执行器的扩展\n\nhttps://gitee.com/dromara/liteflow/issues/i4r7an\n\n增强 #i4t3nq 适配spring的懒加载模式\n\nhttps://gitee.com/dromara/liteflow/issues/i4t3nq\n\n增强 #i4t3mq 去除this.setisend(true)打出的堆栈信息\n\nhttps://gitee.com/dromara/liteflow/issues/i4t3mq\n\n修复 #i4tbdt 修复因为chianendexception导致的用slot接受抛错的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4tbdt\n\n\n# v2.6.8\n\n更新列表\n\n特性 #i4gs07 代码动态组件装配的特性\n\nhttps://gitee.com/dromara/liteflow/issues/i4gs07\n\n特性 #i4qwh7 支持循环依赖\n\nhttps://gitee.com/dromara/liteflow/issues/i4qwh7\n\n增强 #i4oqix 组件执行轨迹日志级别调整\n\nhttps://gitee.com/dromara/liteflow/issues/i4oqix\n\n增强 #i4otk4 希望finally组件可以获取到then组件的异常对象\n\nhttps://gitee.com/dromara/liteflow/issues/i4otk4\n\n增强 #i4pjkp when标签中默认的errorresume改为false\n\nhttps://gitee.com/dromara/liteflow/issues/i4pjkp\n\n增强 #i4pty4 修复copyonwritehashmap可能存在的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i4pty4\n\n增强 #i4qv69 qlexpressscriptexecutor加载缓存脚本有线程安全问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4qv69\n\n增强 #i4qwjk 重构parser逻辑，解决的代码冗余问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4qwjk\n\n增强 #i4r5ui 升级liteflow的相关第三方依赖jar包的版本\n\nhttps://gitee.com/dromara/liteflow/issues/i4r5ui\n\n修复 #i4rf0a 解决有些场景里启动时springaware后加载的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4rf0a\n\n修复 #i4qop6 when超时时抛出的错是npt\n\nhttps://gitee.com/dromara/liteflow/issues/i4qop6\n\n修复 #i4pa2a 在nodecomponent的isaccess中获取tag失败\n\nhttps://gitee.com/dromara/liteflow/issues/i4pa2a\n\n\n# v2.6.7\n\n更新列表\n\n修复 #i4minm 加载脚本节点时，节点里面的实例对象被改动了\n\nhttps://gitee.com/dromara/liteflow/issues/i4minm\n\n\n# v2.6.6\n\n更新列表\n\n特性 #i4e5nx 异步线程池自定义\n\nhttps://gitee.com/dromara/liteflow/issues/i4e5nx\n\n增强 #i4m3q4 rulesource支持配置绝对路径的配置文件\n\nhttps://gitee.com/dromara/liteflow/issues/i4m3q4\n\n修复 #i4lv63 在2.6.5版本中多线程tag取值中，xml没有问题，而json形式有问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4lv63\n\n修复 #i4luq5 默认的slot的datamap无法放入值为null的对象\n\nhttps://gitee.com/dromara/liteflow/issues/i4luq5\n\n\n# v2.6.5\n\n更新列表\n\n增强 #i4idb0 hutool依赖版本冲突，升级了hutool版本\n\nhttps://gitee.com/dromara/liteflow/issues/i4idb0\n\n修复 #i4hzyn 使用when操作同一个node时，会造成tag标签的线程不安全\n\nhttps://gitee.com/dromara/liteflow/issues/i4hzyn\n\n\n# v2.6.4\n\n更新列表\n\n特性 #i4gyv2 script节点支持从文件中获取脚本\n\nhttps://gitee.com/dromara/liteflow/issues/i4gyv2\n\n特性 #i4hgow 支持链路的前置和后置节点\n\nhttps://gitee.com/dromara/liteflow/issues/i4hgow\n\n特性 #i4fshw 优雅平滑刷新的支持\n\nhttps://gitee.com/dromara/liteflow/issues/i4fshw\n\n特性 #i4gs03 并行节点中支持任意节点结束即继续的流程设计\n\nhttps://gitee.com/dromara/liteflow/issues/i4gs03\n\n增强 #i4hkzg 借鉴asynctool对异步线程底层进行了彻底重构\n\nhttps://gitee.com/dromara/liteflow/issues/i4hkzg\n\n增强 #i4hd8l 支持异步节点返回自定义的错误\n\nhttps://gitee.com/dromara/liteflow/issues/i4hd8l\n\n增强 #i4gz1q 增强异步线程超时的情况下打印出具体超时节点的信息\n\nhttps://gitee.com/dromara/liteflow/issues/i4gz1q\n\n增强 #i4excp 新增 自定义 关闭/启动 banner\n\nhttps://gitee.com/dromara/liteflow/issues/i4excp\n\n修复 #i4gy9l 在启动后马上刷新流程后会有offerslot的报错\n\nhttps://gitee.com/dromara/liteflow/issues/i4gy9l\n\n修复 #i4fyka jsonparser好像缺少脚本条件组件的解析\n\nhttps://gitee.com/dromara/liteflow/issues/i4fyka\n\n修复 #i4hqaa setisend目前受iscontinue的判断影响，还是会继续\n\nhttps://gitee.com/dromara/liteflow/issues/i4hqaa\n\n修复 #i4hty6 异步线程池不受配置控制的bug，一直是默认的数量\n\nhttps://gitee.com/dromara/liteflow/issues/i4hty6\n\n\n# v2.6.3\n\n更新列表\n\n增强 #i4e0v9 支持在nodecomponent里自定义beforeprocess和afterprocess,没有覆盖方式时，默认读取aspect里的方法\n\nhttps://gitee.com/dromara/liteflow/issues/i4e0v9\n\n增强 #i4dgeu 可以实现把zk客户端curator依赖改成optional吗\n\nhttps://gitee.com/dromara/liteflow/issues/i4dgeu\n\n修复 #i4e11g xml里定义条件组件有空格无法识别，如：b( testchan3 | testchan2 )。增加节点trim处理\n\nhttps://gitee.com/dromara/liteflow/issues/i4e11g\n\n修复 #i4e2v4 修复异步线程池没有被ttl修饰有可能引起的无法拿到threadlocal值的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i4e2v4\n\n\n# v2.6.2\n\n更新列表\n\n特性 #i4crsy 在一个流程中的同名组件无法传递不同的参数，为组件增加标签属性\n\nhttps://gitee.com/dromara/liteflow/issues/i4crsy\n\n\n# v2.6.1\n\n更新列表\n\n修复 #i4cgl8 qlexpress脚本引擎在refresh脚本节点的时候会失败\n\nhttps://gitee.com/dromara/liteflow/issues/i4cgl8\n\n增强 #i455zs 规则重复嵌套校验\n\nhttps://gitee.com/dromara/liteflow/issues/i455zs\n\n\n# v2.6.0\n\n更新列表\n\n特性 #i4892y 提供私有投递特性，slot这种结构体系，对于多个子线程进入同一个组件的情况下，不容易区分不同的传值。无法做到重用组件\n\nhttps://gitee.com/dromara/liteflow/issues/i4892y\n\n特性 #i49fdk 中断重试目前是全局的，希望增加针对个别组件和特定exception\n\nhttps://gitee.com/dromara/liteflow/issues/i49fdk\n\n增强 #i49jp1 databus中slotsize的大小不支持动态扩展，无法应对高并发下的流量突增\n\nhttps://gitee.com/dromara/liteflow/issues/i49jp1\n\n增强 #i45qaj 支持自定义的zknodepath\n\nhttps://gitee.com/dromara/liteflow/issues/i45qaj\n\n修复 #i49ehh setisend设计的不合理性\n\nhttps://gitee.com/dromara/liteflow/issues/i49ehh\n\n修复 #i4bajc setisend结束的流程不需要进行重试\n\nhttps://gitee.com/dromara/liteflow/issues/i4bajc\n\n修复 #i49l1s 初始化databus的数据槽索引queue大小的时候容量设置有问题\n\nhttps://gitee.com/dromara/liteflow/issues/i49l1s\n\n修复 #i46u6y 自定义jsonparse,调用flowexecutor的reloadrule,抛出异常\n\nhttps://gitee.com/dromara/liteflow/issues/i46u6y\n\n\n# v2.6.0-beta1\n\n更新列表\n\n特性 #i44ft8 支持脚本语言的组件，并支持动态刷新脚本(版本特性)\n\nhttps://gitee.com/dromara/liteflow/issues/i44ft8\n\n特性 #i3zvea 流程组件支持重试\n\nhttps://gitee.com/dromara/liteflow/issues/i3zvea\n\n增强 #i40dwo 流程配置文件中增加业务描述，打印步骤中带入业务描述\n\nhttps://gitee.com/dromara/liteflow/issues/i40dwo\n\n修复 #i3vzmz when类型condition场景下记录节点执行路径的方法会造成数据丢失\n\nhttps://gitee.com/dromara/liteflow/issues/i3vzmz\n\n修复 #i3uojg 流程终止slot内无数据\n\nhttps://gitee.com/dromara/liteflow/issues/i3uojg\n\n\n# v2.5.10\n\n更新列表\n\n增强 #i426ys 支持多个不同类型的配置方式同时解析\n\nhttps://gitee.com/dromara/liteflow/issues/i426ys\n\n修复 #i40vpb 关于liteflowexecutorautoconfiguration中的shutdown bean名称\n\nhttps://gitee.com/dromara/liteflow/issues/i40vpb\n\n\n# v2.5.9\n\n更新列表\n\n修复：#i413pu 增加liteflow.enable参数，来标记是否自动装配liteflow\n\nhttps://gitee.com/dromara/liteflow/issues/i413pu\n\n修复：#i40yvk 当主流程与子流程在不同的配置文件中时，会报错\n\nhttps://gitee.com/dromara/liteflow/issues/i40yvk\n\n修复：#i41s18 在开启监控的情况下，偶尔会报出空指针的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i41s18\n\n\n# v2.5.8\n\n更新列表\n\n修复：#i3yx3z 当抛出异常时，liteflowresponse中的slot为null\n\nhttps://gitee.com/dromara/liteflow/issues/i3yx3z\n\n\n# v2.5.7\n\n更新列表\n\n修复：#i3w8fh 自定义配置源类无法依赖spring上下文中的bean的bug\n\nhttps://gitee.com/dromara/liteflow/issues/i3w8fh\n\n\n# v2.5.6\n\n更新列表\n\n修复: #i3sfoo:2.5.x解析多个flow.xml文件时条件节点的条件节点list会被清空\n\nhttps://gitee.com/dromara/liteflow/issues/i3sfoo\n\n增强: #i3s5g8:动态平滑刷新机制\n\nhttps://gitee.com/dromara/liteflow/issues/i3s5g8\n\n增强: #i3s0qa:databus 性能优化 lock free\n\nhttps://gitee.com/dromara/liteflow/issues/i3s0qa\n\n\n# v2.5.5\n\n更新列表\n\n增强: #i3qrw9 希望增加对springboot 1.5.x版本的兼容适配\n\nhttps://gitee.com/dromara/liteflow/issues/i3qrw9\n\n增强：#i3n144 是否能支持rule的通配符\n\nhttps://gitee.com/dromara/liteflow/issues/i3n144\n\n增强：#i3ipxg 流程加载的时候 可以把流程加载的来源 也打印到日志中\n\nhttps://gitee.com/dromara/liteflow/issues/i3ipxg\n\n修复：#i3nd7t 目前springboot下的缺省rule-source不起作用\n\nhttps://gitee.com/dromara/liteflow/issues/i3nd7t\n\n\n# v2.5.4\n\n更新列表\n\n修复: #i3nsf8 空的flow文件会导致无法启动\n\nhttps://gitee.com/dromara/liteflow/issues/i3nsf8\n\n\n# v2.5.3\n\n更新列表\n\n特性：#i3n2e2 支持编程时式的注册组件的方式\n\nhttps://gitee.com/dromara/liteflow/issues/i3n2e2\n\n增强：#i3mmbl 添加additional-spring-configuration-metadata.json 到 liteflow-springboot-starter\n\nhttps://gitee.com/dromara/liteflow/issues/i3mmbl\n\n\n# v2.5.2\n\n更新列表\n\n修复：#i3ig1k springboot的fat jar模式下，流程文件会找不到的问题\n\nhttps://gitee.com/dromara/liteflow/issues/i3ig1k\n\n增强：#i3igeb 重命名flowexecutor中流程调用方法名称\n\nhttps://gitee.com/dromara/liteflow/issues/i3igeb\n\n\n# v2.5.1\n\n更新列表\n\n增强：#i3i1tw 优化flowexecutor中调用方法\n\nhttps://gitee.com/dromara/liteflow/issues/i3i1tw\n\n\n# v2.5.0\n\n更新列表\n\n特性：#i3cty2 规则支持json和yml\n\nhttps://gitee.com/dromara/liteflow/issues/i3cty2\n\n特性：#i37qvr 提供异步组件执行时候的线程池支持\n\nhttps://gitee.com/dromara/liteflow/issues/i37qvr\n\n增强：#i3ct11 能对任意包的下的组件进行切面\n\nhttps://gitee.com/dromara/liteflow/issues/i3ct11\n\n修复：#i3ct9a 监控打印的耗时不准确问题\n\nhttps://gitee.com/dromara/liteflow/issues/i3ct9a\n\n增强：#i3c5y9 对于底层配置结构作了优化更改\n\nhttps://gitee.com/dromara/liteflow/issues/i3c5y9\n\n增强：#i3ctmq 抛弃org.apache.common的包，依赖hutool\n\nhttps://gitee.com/dromara/liteflow/issues/i3ctmq\n\n增强：#i3ctuk 每个组件的对slot index的存储，换成阿里的ttl\n\nhttps://gitee.com/dromara/liteflow/issues/i3ctuk\n\n修复：#i3ct49 连续的when标签，之间并不是完全并行的\n\nhttps://gitee.com/dromara/liteflow/issues/i3ct49\n\n修复：#i3dm7y 2.4.0-rc1版本会出现基础同步组件失败的情形\n\nhttps://gitee.com/dromara/liteflow/issues/i3dm7y\n\n修复：#i3dmx4 目前flowexecutor会吃掉业务异常\n\nhttps://gitee.com/dromara/liteflow/issues/i3dmx4\n\n支持：#i3ct01 liteflow增加单元测试\n\nhttps://gitee.com/dromara/liteflow/issues/i3ct01',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"谁在使用",frontmatter:{title:"谁在使用",date:"2022-06-01T14:47:35.000Z",permalink:"/pages/9b9f41/"},regularPath:"/%E7%94%A8%E6%88%B7.html",relativePath:"用户.md",key:"v-b83e32ac",path:"/pages/9b9f41/",headersStr:null,content:"用户列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n为了更好地为您提供服务,请在此登记。",normalizedContent:"用户列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n为了更好地为您提供服务,请在此登记。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"问答",frontmatter:{title:"问答",date:"2022-06-03T22:39:35.000Z",permalink:"/pages/845dff/",sidebar:!1,article:!1},regularPath:"/%E9%97%AE%E7%AD%94.html",relativePath:"问答.md",key:"v-2619eb8a",path:"/pages/845dff/",headers:[{level:2,title:"Q：LiteFlow支持事务么？",slug:"q-liteflow支持事务么",normalizedTitle:"q：liteflow支持事务么？",charIndex:3},{level:2,title:"Q：LiteFlow适用于什么场景？",slug:"q-liteflow适用于什么场景",normalizedTitle:"q：liteflow适用于什么场景？",charIndex:23},{level:2,title:"Q：是否可以做审批流或者角色轮转的流程？",slug:"q-是否可以做审批流或者角色轮转的流程",normalizedTitle:"q：是否可以做审批流或者角色轮转的流程？",charIndex:45},{level:2,title:"Q：是否可以运行到一半手动停止，然后下次继续运行链路？",slug:"q-是否可以运行到一半手动停止-然后下次继续运行链路",normalizedTitle:"q：是否可以运行到一半手动停止，然后下次继续运行链路？",charIndex:69},{level:2,title:"Q：为什么规则存储Nacos不支持拆分规则和脚本，而是需要保存整个XML？",slug:"q-为什么规则存储nacos不支持拆分规则和脚本-而是需要保存整个xml",normalizedTitle:"q：为什么规则存储nacos不支持拆分规则和脚本，而是需要保存整个xml？",charIndex:100},{level:2,title:"Q：对于通用组件进行复用编排，上下文类型该如何设置？",slug:"q-对于通用组件进行复用编排-上下文类型该如何设置",normalizedTitle:"q：对于通用组件进行复用编排，上下文类型该如何设置？",charIndex:141},{level:2,title:"Q：上下文里的数据是线程安全的吗？",slug:"q-上下文里的数据是线程安全的吗",normalizedTitle:"q：上下文里的数据是线程安全的吗？",charIndex:171},{level:2,title:"Q：LiteFlow性能如何？",slug:"q-liteflow性能如何",normalizedTitle:"q：liteflow性能如何？",charIndex:192},{level:2,title:"Q：是否支持逆向执行，来实现回滚等操作？",slug:"q-是否支持逆向执行-来实现回滚等操作",normalizedTitle:"q：是否支持逆向执行，来实现回滚等操作？",charIndex:211},{level:2,title:"Q：是否支持界面编排？",slug:"q-是否支持界面编排",normalizedTitle:"q：是否支持界面编排？",charIndex:235},{level:2,title:"Q：如何做跨服务的分布式编排？",slug:"q-如何做跨服务的分布式编排",normalizedTitle:"q：如何做跨服务的分布式编排？",charIndex:250},{level:2,title:"Q：flowExecutor.execute2Resp调用了，为什么取不到上下文中的参数",slug:"q-flowexecutor-execute2resp调用了-为什么取不到上下文中的参数",normalizedTitle:"q：flowexecutor.execute2resp调用了，为什么取不到上下文中的参数",charIndex:269},{level:2,title:"Q：流程中是否如果有回调该如何处理",slug:"q-流程中是否如果有回调该如何处理",normalizedTitle:"q：流程中是否如果有回调该如何处理",charIndex:317},{level:2,title:"Q：如果出现栈溢出怎么办",slug:"q-如果出现栈溢出怎么办",normalizedTitle:"q：如果出现栈溢出怎么办",charIndex:338},{level:2,title:"Q：启动时出现NoSuchMethodError的错误是什么原因",slug:"q-启动时出现nosuchmethoderror的错误是什么原因",normalizedTitle:"q：启动时出现nosuchmethoderror的错误是什么原因",charIndex:354}],headersStr:"Q：LiteFlow支持事务么？ Q：LiteFlow适用于什么场景？ Q：是否可以做审批流或者角色轮转的流程？ Q：是否可以运行到一半手动停止，然后下次继续运行链路？ Q：为什么规则存储Nacos不支持拆分规则和脚本，而是需要保存整个XML？ Q：对于通用组件进行复用编排，上下文类型该如何设置？ Q：上下文里的数据是线程安全的吗？ Q：LiteFlow性能如何？ Q：是否支持逆向执行，来实现回滚等操作？ Q：是否支持界面编排？ Q：如何做跨服务的分布式编排？ Q：flowExecutor.execute2Resp调用了，为什么取不到上下文中的参数 Q：流程中是否如果有回调该如何处理 Q：如果出现栈溢出怎么办 Q：启动时出现NoSuchMethodError的错误是什么原因",content:' * Q：LiteFlow支持事务么？\n * Q：LiteFlow适用于什么场景？\n * Q：是否可以做审批流或者角色轮转的流程？\n * Q：是否可以运行到一半手动停止，然后下次继续运行链路？\n * Q：为什么规则存储Nacos不支持拆分规则和脚本，而是需要保存整个XML？\n * Q：对于通用组件进行复用编排，上下文类型该如何设置？\n * Q：上下文里的数据是线程安全的吗？\n * Q：LiteFlow性能如何？\n * Q：是否支持逆向执行，来实现回滚等操作？\n * Q：是否支持界面编排？\n * Q：如何做跨服务的分布式编排？\n * Q：flowExecutor.execute2Resp调用了，为什么取不到上下文中的参数\n * Q：流程中是否如果有回调该如何处理\n * Q：如果出现栈溢出怎么办\n * Q：启动时出现NoSuchMethodError的错误是什么原因\n\n\n\n\n# Q：LiteFlow支持事务么？\n\nA：不能说支持或者说不支持，因为LiteFlow和事务没有本质上的关系。LiteFlow只不过在本地帮你把代码进行组件化和可编排化，事务还是按照原先的方式去做。例如，你完全可以加@Transactional来开启spring事务：\n\n@Transactional\npublic void testIsAccess() {\n  LiteflowResponse response = flowExecutor.execute2Resp("chain1", 101);\n  if (!response.isSuccess()){\n    throw response.getCause();\n  }\n}\n\n\n那么，这个链路中的所有组件，只要有一个组件发生异常，那么执行过的本地事务就会回滚，同理，你可以在任意地点加编程式事务。\n\n同理，如果涉及到分布式事务，你也可以采用任意一种分布式事务的解决方案来做，这本质上已经脱离了LiteFlow的讨论范畴。\n\n\n# Q：LiteFlow适用于什么场景？\n\nA：LiteFlow适用于具有复杂逻辑，逻辑复用性比较强的业务系统，可以利用LiteFlow框架对业务进行解耦，编排，复用，动态更新，使代码更加优雅。\n\nLiteFlow使用场景不限业务，只要你的业务系统可以根据业务边界来划分出来一个个独立的组件逻辑。既可以使用LiteFlow框架来优化你的代码。\n\n\n# Q：是否可以做审批流或者角色轮转的流程？\n\nA：其实在开篇LiteFLow简介已经有提到过，LiteFlow不做基于角色流转的流程，只做逻辑流程。并且LiteFlow在以后，也不会做基于角色流转的流程，因为LiteFlow要保持轻量和易用性，是一个无状态的流程编排工具。如果你的业务是基于角色流转的，推荐使用Flowable。\n\n\n# Q：是否可以运行到一半手动停止，然后下次继续运行链路？\n\nA：不可以。LiteFlow是一个无状态的规则引擎。不对中间状态进行存储。LiteFlow更希望业务一次性运行完，并且自己保证其幂等性。如果你确实有业务场景，需要运行到一半手动停止。那么建议你去使用Flowable等一些有状态的流程引擎框架。\n\n\n# Q：为什么规则存储Nacos不支持拆分规则和脚本，而是需要保存整个XML？\n\n因为Nacos没法对一个group进行监听，如果拆分了，那就会导致新增规则，删除规则没法被监听到。\n\n而现在这种单个节点的形式，虽然没拆分，但是功能是齐全的。这也是无奈的选择。我们也想拆分的，但是我们搞不定。\n\nNacos官方也有类似的issue，官方表示考虑在3.0的时候加入对group的监听特性。\n\n\n# Q：对于通用组件进行复用编排，上下文类型该如何设置？\n\n如果你有一个通用组件，要定义在不同的链路中。那你就给这个组件一个单独的上下文，LiteFlow是支持多上下文传入的，你调用链路的时候，代入这个上下文。那这个通用组件就可以在不同的链路中使用了。\n\n还有种方法，就是你自己定义一个弱类型的上下文类型，比如Map。但是使用的时候需要你自己去强转类型。\n\n\n# Q：上下文里的数据是线程安全的吗？\n\nA：LiteFlow虽然提供了默认的上下文实现，但是更建议用户自己去实现自己的上下文。Slot本质上是一个普通的值对象，虽然LiteFlow能保证上下文本身的线程安全（指在多线程情况下，多个请求上下文不会串），但是上下文内数据的线程安全性是无法保障的，这需要用户自己去定义其线程安全的属性。比如你在上下文里定义了一个int的变量，多个异步节点对其进行增加，那当然会有线程安全的问题。你需要在你自己定义的上下文内部去声明一个AtomicInteger对象，从而保证线程安全。\n\n\n# Q：LiteFlow性能如何？\n\nA：LiteFlow本身性能优秀，几乎没有什么额外的损耗，在压测过程中，基于复杂的价格逻辑引擎的业务系统，三十多个组件，在实测中可以跑到单机1500多的TPS。当然，这是基于良好的组件实现逻辑的前提下。如果你的组件里有一个bad sql，或者大量的IO操作，RPC调用操作，那么任何框架也无法提升你业务的TPS。这里只能说LiteFlow框架本身对系统几乎无额外损耗，如果你的系统使用了LiteFlow但是TPS/QPS很低的话，那么请从你的组件实现逻辑入手排查。\n\n\n# Q：是否支持逆向执行，来实现回滚等操作？\n\nA：不支持，如果要实现本地回滚，请用事务来控制，如果涉及分布式事务的回滚，也有分布式事务的解决方案可以用。\n\n但是之后的版本可能会出一个特性，在执行的过程中，如果遇到某个Exception去执行额外的链路，如果真的想逆向执行，可以把回滚组件放到这个里面。\n\n\n# Q：是否支持界面编排？\n\nA：已经有无数人说的界面编排特性，我想说几句：\n\n界面编排已经不算作特性了，应该算作LiteFlow这个开源框架的一个形态升级，形态延伸。\n\n这个形态升级我一定会做。不仅会做，还会出一整套集编排，管理，监控，追踪于一体的后端界面。\n\n这也是LiteFlow这个框架的愿景：做最轻量，最好用的，能快速赋予生产力的国产优秀的规则编排框架。\n\nLiteFlow才刚刚起步，核心的很多地方还在快速迭代中。后面不做好，无法马上开始做前端编排。加上作者也有本职工作，也是打工人。只能日常挤出时间来做。所以这点望大家理解。目前LiteFlow的迭代还是很频繁的。我打算之后每个月出2个迭代更新版本。\n\n相信这天的到来，不会太久。请支持LiteFlow框架的小伙伴继续关注它。\n\n\n# Q：如何做跨服务的分布式编排？\n\nA：LiteFlow是轻量级的单服务编排，你可以把它理解为一个工具包。和高可用，分布式没有关系。\n\n你一个业务系统里面有50个组件，liteflow可以编排，复杂一点的也可以。但是你多个业务系统，想要用一个链路，去编排不同服务里的组件。先去调用A服务的组件a，再去调用B服务的组件b，再去调用C服务的组件c，这种LiteFlow并不支持。\n\n变相的实现，只有你独立出来一个服务X，然后服务X写3个组件(x1,x2,x3)分别用rpc去调用a,b,c，然后把x1,x2,x3编排成一个链路。\n\n但是对LiteFlow来说，它运行的组件也只是X服务中的3个组件，至于组件里面是rpc调用还是其他网络IO操作，这和LiteFlow本身没有关系，因为已经涉及到业务实现层了。\n\n\n# Q：flowExecutor.execute2Resp调用了，为什么取不到上下文中的参数\n\n如下调用\n\nUserContext context = new UserContext();\ncontext.setName("jack");\nLiteflowResponse response = flowExecutor.extcute2Resp("chain1", context, UserContext.class);\n\n\n为什么我在组件或者脚本中取到的name参数为null？\n\nA：在执行器一章里已经有明确的提示了：\n\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文class\npublic LiteflowResponse execute2Resp(String chainId, Object param, Class<?>... contextBeanClazzArray)\n//第一个参数为流程ID，第二个参数为流程入参，后面可以传入多个上下文的Bean\npublic LiteflowResponse execute2Resp(String chainId, Object param, Object... contextBeanArray)\n\n\n其中第二个参数为流程入参，流程入参其实和上下文没什么关系，在组件中通过this.getRequestData()来获得。在脚本中通过requestData变量获得。\n\n第三个参数为上下文，如果你传入了class，那么liteflow会帮你初始化一个空的对象。当然也支持传入已经初始化好的bean。在组件里通过this.getContextBean来获得，在脚本里直接通过xxxContext来引用。\n\n回到上述问题，如果把初始化好的bean作为流程入参传入，而上下文传入UserContext.class，那么其实this.getRequestData出来的是这个bean，而this.getContextBean出来是一个空的UserContext对象，所以你拿到的name为null。\n\n这里正确的做法是：\n\nUserContext context = new UserContext();\ncontext.setName("jack");\nLiteflowResponse response = flowExecutor.extcute2Resp("chain1", null, context);\n\n\n在很多情况下，流程入参是可以包装到上下文里去的。所以流程入参这里给个null即可。所以上下文和流程入参是2个完全不相干的概念，这点别弄混淆。\n\n\n# Q：流程中是否如果有回调该如何处理\n\n例如以下流程包含4个组件\n\nTHEN(a, b, c, d)\n\n其中c发送结果到第三方，d要等待第三方回调才可以处理，这种要如何做？\n\nA：LiteFlow是无状态的规则引擎，即时不用LiteFlow，这种模式也应该考虑如何更优雅的设计\n\n一般都是分成2段式，第一段发出去后，保存其中间状态，然后回调回来再进行第二段。\n\n\n# Q：如果出现栈溢出怎么办\n\nA：确保LF的版本在2.11.4+以上，如果版本没问题，还出现栈溢出，大概率就是jvm参数Xss配置太少了。\n\n解析EL本质上是一个递归调用，如果你层数很多很深，用到的栈空间就会增加。如果Xss太少就会报栈溢出的错误。\n\n\n# Q：启动时出现NoSuchMethodError的错误是什么原因\n\n在LiteFlow中启动时出现这个错，大概率都可能是以下3个依赖包的冲突而导致。\n\ntransmittable-thread-local 要求版本 2.12.3+\n\nbyte-buddy 要求版本 1.14.10+\n\nhutool 要求版本 5.8.26+\n\n所谓依赖冲突就是你本地的其他jar包传递依赖的包覆盖了LiteFlow传递依赖的版本。如果你的这个错是以上jar包的某一个，只需要重新定义其版本号即可。',normalizedContent:' * q：liteflow支持事务么？\n * q：liteflow适用于什么场景？\n * q：是否可以做审批流或者角色轮转的流程？\n * q：是否可以运行到一半手动停止，然后下次继续运行链路？\n * q：为什么规则存储nacos不支持拆分规则和脚本，而是需要保存整个xml？\n * q：对于通用组件进行复用编排，上下文类型该如何设置？\n * q：上下文里的数据是线程安全的吗？\n * q：liteflow性能如何？\n * q：是否支持逆向执行，来实现回滚等操作？\n * q：是否支持界面编排？\n * q：如何做跨服务的分布式编排？\n * q：flowexecutor.execute2resp调用了，为什么取不到上下文中的参数\n * q：流程中是否如果有回调该如何处理\n * q：如果出现栈溢出怎么办\n * q：启动时出现nosuchmethoderror的错误是什么原因\n\n\n\n\n# q：liteflow支持事务么？\n\na：不能说支持或者说不支持，因为liteflow和事务没有本质上的关系。liteflow只不过在本地帮你把代码进行组件化和可编排化，事务还是按照原先的方式去做。例如，你完全可以加@transactional来开启spring事务：\n\n@transactional\npublic void testisaccess() {\n  liteflowresponse response = flowexecutor.execute2resp("chain1", 101);\n  if (!response.issuccess()){\n    throw response.getcause();\n  }\n}\n\n\n那么，这个链路中的所有组件，只要有一个组件发生异常，那么执行过的本地事务就会回滚，同理，你可以在任意地点加编程式事务。\n\n同理，如果涉及到分布式事务，你也可以采用任意一种分布式事务的解决方案来做，这本质上已经脱离了liteflow的讨论范畴。\n\n\n# q：liteflow适用于什么场景？\n\na：liteflow适用于具有复杂逻辑，逻辑复用性比较强的业务系统，可以利用liteflow框架对业务进行解耦，编排，复用，动态更新，使代码更加优雅。\n\nliteflow使用场景不限业务，只要你的业务系统可以根据业务边界来划分出来一个个独立的组件逻辑。既可以使用liteflow框架来优化你的代码。\n\n\n# q：是否可以做审批流或者角色轮转的流程？\n\na：其实在开篇liteflow简介已经有提到过，liteflow不做基于角色流转的流程，只做逻辑流程。并且liteflow在以后，也不会做基于角色流转的流程，因为liteflow要保持轻量和易用性，是一个无状态的流程编排工具。如果你的业务是基于角色流转的，推荐使用flowable。\n\n\n# q：是否可以运行到一半手动停止，然后下次继续运行链路？\n\na：不可以。liteflow是一个无状态的规则引擎。不对中间状态进行存储。liteflow更希望业务一次性运行完，并且自己保证其幂等性。如果你确实有业务场景，需要运行到一半手动停止。那么建议你去使用flowable等一些有状态的流程引擎框架。\n\n\n# q：为什么规则存储nacos不支持拆分规则和脚本，而是需要保存整个xml？\n\n因为nacos没法对一个group进行监听，如果拆分了，那就会导致新增规则，删除规则没法被监听到。\n\n而现在这种单个节点的形式，虽然没拆分，但是功能是齐全的。这也是无奈的选择。我们也想拆分的，但是我们搞不定。\n\nnacos官方也有类似的issue，官方表示考虑在3.0的时候加入对group的监听特性。\n\n\n# q：对于通用组件进行复用编排，上下文类型该如何设置？\n\n如果你有一个通用组件，要定义在不同的链路中。那你就给这个组件一个单独的上下文，liteflow是支持多上下文传入的，你调用链路的时候，代入这个上下文。那这个通用组件就可以在不同的链路中使用了。\n\n还有种方法，就是你自己定义一个弱类型的上下文类型，比如map。但是使用的时候需要你自己去强转类型。\n\n\n# q：上下文里的数据是线程安全的吗？\n\na：liteflow虽然提供了默认的上下文实现，但是更建议用户自己去实现自己的上下文。slot本质上是一个普通的值对象，虽然liteflow能保证上下文本身的线程安全（指在多线程情况下，多个请求上下文不会串），但是上下文内数据的线程安全性是无法保障的，这需要用户自己去定义其线程安全的属性。比如你在上下文里定义了一个int的变量，多个异步节点对其进行增加，那当然会有线程安全的问题。你需要在你自己定义的上下文内部去声明一个atomicinteger对象，从而保证线程安全。\n\n\n# q：liteflow性能如何？\n\na：liteflow本身性能优秀，几乎没有什么额外的损耗，在压测过程中，基于复杂的价格逻辑引擎的业务系统，三十多个组件，在实测中可以跑到单机1500多的tps。当然，这是基于良好的组件实现逻辑的前提下。如果你的组件里有一个bad sql，或者大量的io操作，rpc调用操作，那么任何框架也无法提升你业务的tps。这里只能说liteflow框架本身对系统几乎无额外损耗，如果你的系统使用了liteflow但是tps/qps很低的话，那么请从你的组件实现逻辑入手排查。\n\n\n# q：是否支持逆向执行，来实现回滚等操作？\n\na：不支持，如果要实现本地回滚，请用事务来控制，如果涉及分布式事务的回滚，也有分布式事务的解决方案可以用。\n\n但是之后的版本可能会出一个特性，在执行的过程中，如果遇到某个exception去执行额外的链路，如果真的想逆向执行，可以把回滚组件放到这个里面。\n\n\n# q：是否支持界面编排？\n\na：已经有无数人说的界面编排特性，我想说几句：\n\n界面编排已经不算作特性了，应该算作liteflow这个开源框架的一个形态升级，形态延伸。\n\n这个形态升级我一定会做。不仅会做，还会出一整套集编排，管理，监控，追踪于一体的后端界面。\n\n这也是liteflow这个框架的愿景：做最轻量，最好用的，能快速赋予生产力的国产优秀的规则编排框架。\n\nliteflow才刚刚起步，核心的很多地方还在快速迭代中。后面不做好，无法马上开始做前端编排。加上作者也有本职工作，也是打工人。只能日常挤出时间来做。所以这点望大家理解。目前liteflow的迭代还是很频繁的。我打算之后每个月出2个迭代更新版本。\n\n相信这天的到来，不会太久。请支持liteflow框架的小伙伴继续关注它。\n\n\n# q：如何做跨服务的分布式编排？\n\na：liteflow是轻量级的单服务编排，你可以把它理解为一个工具包。和高可用，分布式没有关系。\n\n你一个业务系统里面有50个组件，liteflow可以编排，复杂一点的也可以。但是你多个业务系统，想要用一个链路，去编排不同服务里的组件。先去调用a服务的组件a，再去调用b服务的组件b，再去调用c服务的组件c，这种liteflow并不支持。\n\n变相的实现，只有你独立出来一个服务x，然后服务x写3个组件(x1,x2,x3)分别用rpc去调用a,b,c，然后把x1,x2,x3编排成一个链路。\n\n但是对liteflow来说，它运行的组件也只是x服务中的3个组件，至于组件里面是rpc调用还是其他网络io操作，这和liteflow本身没有关系，因为已经涉及到业务实现层了。\n\n\n# q：flowexecutor.execute2resp调用了，为什么取不到上下文中的参数\n\n如下调用\n\nusercontext context = new usercontext();\ncontext.setname("jack");\nliteflowresponse response = flowexecutor.extcute2resp("chain1", context, usercontext.class);\n\n\n为什么我在组件或者脚本中取到的name参数为null？\n\na：在执行器一章里已经有明确的提示了：\n\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文class\npublic liteflowresponse execute2resp(string chainid, object param, class<?>... contextbeanclazzarray)\n//第一个参数为流程id，第二个参数为流程入参，后面可以传入多个上下文的bean\npublic liteflowresponse execute2resp(string chainid, object param, object... contextbeanarray)\n\n\n其中第二个参数为流程入参，流程入参其实和上下文没什么关系，在组件中通过this.getrequestdata()来获得。在脚本中通过requestdata变量获得。\n\n第三个参数为上下文，如果你传入了class，那么liteflow会帮你初始化一个空的对象。当然也支持传入已经初始化好的bean。在组件里通过this.getcontextbean来获得，在脚本里直接通过xxxcontext来引用。\n\n回到上述问题，如果把初始化好的bean作为流程入参传入，而上下文传入usercontext.class，那么其实this.getrequestdata出来的是这个bean，而this.getcontextbean出来是一个空的usercontext对象，所以你拿到的name为null。\n\n这里正确的做法是：\n\nusercontext context = new usercontext();\ncontext.setname("jack");\nliteflowresponse response = flowexecutor.extcute2resp("chain1", null, context);\n\n\n在很多情况下，流程入参是可以包装到上下文里去的。所以流程入参这里给个null即可。所以上下文和流程入参是2个完全不相干的概念，这点别弄混淆。\n\n\n# q：流程中是否如果有回调该如何处理\n\n例如以下流程包含4个组件\n\nthen(a, b, c, d)\n\n其中c发送结果到第三方，d要等待第三方回调才可以处理，这种要如何做？\n\na：liteflow是无状态的规则引擎，即时不用liteflow，这种模式也应该考虑如何更优雅的设计\n\n一般都是分成2段式，第一段发出去后，保存其中间状态，然后回调回来再进行第二段。\n\n\n# q：如果出现栈溢出怎么办\n\na：确保lf的版本在2.11.4+以上，如果版本没问题，还出现栈溢出，大概率就是jvm参数xss配置太少了。\n\n解析el本质上是一个递归调用，如果你层数很多很深，用到的栈空间就会增加。如果xss太少就会报栈溢出的错误。\n\n\n# q：启动时出现nosuchmethoderror的错误是什么原因\n\n在liteflow中启动时出现这个错，大概率都可能是以下3个依赖包的冲突而导致。\n\ntransmittable-thread-local 要求版本 2.12.3+\n\nbyte-buddy 要求版本 1.14.10+\n\nhutool 要求版本 5.8.26+\n\n所谓依赖冲突就是你本地的其他jar包传递依赖的包覆盖了liteflow传递依赖的版本。如果你的这个错是以上jar包的某一个，只需要重新定义其版本号即可。',charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3},{title:"项目成员",frontmatter:{title:"项目成员",date:"2022-10-08T23:55:08.000Z",permalink:"/pages/ae4d66/"},regularPath:"/%E9%A1%B9%E7%9B%AE%E6%88%90%E5%91%98.html",relativePath:"项目成员.md",key:"v-a9f0e71a",path:"/pages/ae4d66/",headersStr:null,content:"个人介绍\n\n铂赛东\n\nLiteFlow作者\n\n- name: 铂赛东\n  desc: LiteFlow作者\n  avatar: /img/members/author.png\n  link: https://gitee.com/bryan31\n  bgColor: '#d7d7d7'\n  textColor: '#000000'\n\n\n开源项目LiteFlow作者，开源项目TLog作者，拥有2个GVP荣誉，[元人部落]公众号博主。基础中间件架构师，深耕架构相关工作十多年。\n\n一个永远勇敢坚定追逐光的即将不惑之年的开发者。立志把LiteFlow带入中国顶尖开源软件的行列。\n\n\n个人介绍\n\n小易\n\nLiteFlowX插件作者\n\n- name: 小易\n  desc: LiteFlowX插件作者\n  avatar: /img/members/m1.jpg\n  link: https://gitee.com/liupeiqiang\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n24岁年轻小伙，大家都叫我小易，不喜欢浪费时间做对自己毫无提升的事，热爱编程、热爱天文、热爱物理，LiteFlowX插件开发作者，目前位于广东某集团担任java后端开发工程师，但个人而言并不仅局限于java后端。\n\n为什么加入：当时为治理公司业务逻辑的解耦问题迫在眉睫，在某种机缘巧合的作用下遇到LiteFlow框架，我对LiteFlow的第一个好印象就是文档内容令人眼前一亮，十分友好且易上手，但规则表达式写起来容易出错，原因是开发过程中缺少检查，组件跳转、组件统计、表达式高亮等问题，于是乎在铂赛东共同探讨下开始对LiteFlowX插件进行评估以及制作，将其作为LiteFlow框架的“辅助”，专为提高使用LiteFlow时的开发效率而设计。\n\n个人愿景：在浩荡的开源社区里，向各位大佬们看齐，成为架构师是我当前的目标之一，相比于这堆框架好不好用，我更感兴趣的是这堆框架的实现原理是什么。感觉自己还算年轻，该学习的东西还有很多，初来乍到请多多指教。\n\n\n个人介绍\n\n农鲜哥\n\nLiteFlow开源成员\n\n- name: 农鲜哥\n  desc: LiteFlow开源成员\n  avatar: /img/members/m2.png\n  link: https://gitee.com/zendwang\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\nzendwang， 目前就职于一家高速发展的互联网保险公司，做crud boy多年，深刻感受到面对各种复杂的业务流程，如果代码只能应付眼下的业务需求，后面维护成本不可估量，如何解决这个问题，带着这个困惑，有幸接触到LiteFlow，并尝试参与社区开发，做了一些单元测试和代码优化的工作。目前已经把LiteFlow应用到公司部分核心业务场景，用LiteFlow的组件、流程来做业务解耦真的很方便，开发、维护都so easy 。\n\n愿景：多多参与社区开发和社区群问题解答，帮助和引导社区的开发同学都早日用上LiteFlow、参与LiteFlow。\n\n\n个人介绍\n\n与或非\n\nLiteFlow开源成员\n\n- name: 与或非\n  desc: LiteFlow开源成员\n  avatar: /img/members/m3.png\n  link: https://gitee.com/tangkc123\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n我是与或非，从事 java 开发4年，非常荣幸受邀成为 LiteFlow 的 Committer。第一次给 LiteFlow 提 pr 是修改测试用例的文件路径，和作者沟通很愉快，感受到作者对开源事业的热情。正是这份热情吸引我持续给项目提交 pr。在后续的 pr 中我也得到了作者及其他小伙伴的帮助，和LiteFlow一起成长。作为java 行业的初学者，希望能从LiteFlow开始为开源事业做一些自己的贡献，在成为一名合格程序员的路上越走越远。\n\n\n个人介绍\n\n小马\n\nLiteFlow开源成员\n\n- name: 小马\n  desc: LiteFlow开源成员\n  avatar: /img/members/m4.png\n  link: https://gitee.com/nmnl\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n个人简介: IT行业10年耕作(职业路线码农>组长>经理>CTO>码农); 热爱各种技术; 做事的原则对事情有种极度刻薄的观念并且去实现它，有时却退而求其次完成它。就是这样矛盾的一个人。\n\n为什么加入: 给自己一个机会，参与开源回报开源。\n\n个人愿景: 学会LiteFlow并且使用它再回报它，码农其实挺好的。\n\n\n个人介绍\n\nRainie\n\nLiteFlow开源成员\n\n- name: Rainie\n  desc: LiteFlow开源成员\n  avatar: /img/members/m5.png\n  link: https://gitee.com/h-xinyu\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n目前就读于中国科学院大学电子信息专业22级。\n\n在开源之夏活动中参与了LiteFlow的课题研究，并成为了LiteFlow开源成员。\n\n在开发过程中，导师不仅在总体方案上会给出清晰思路，每次提交代码还会认真逐行review，提出很细致的代码优化建议，也让我对开源多了一份敬意，开源的代码更需要精益求精，对代码高质量要求才能让项目走得更远。\n\n参与开源虽然时间不长但收获了很多。希望在以后的开源之路上能够增强自己的方案设计和代码能力，写出更优雅的代码，为项目做出更多有用的贡献~~\n\n个人介绍\n\nDaleLee\n\nLiteFlow开源成员\n\n- name: DaleLee\n  desc: LiteFlow开源成员\n  avatar: /img/members/m6.png\n  link: https://gitee.com/dalelee\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n目前就读于福州大学研三。\n\n做开源最开心的一刻，莫过于自己的 PR 被合并的那一刻，那时候有一种巨大的自豪感和满足感。开源代来给我最大的收获，在于让我意识到了设计和测试的重要性，这也是我之前写代码经常忽略的地方。良好的设计是成功的开始，完善的测试才能保障代码的正确性。\n\n导师在课题的完成过程中给与了我非常大的帮助。在每一版方案中，导师都会认真地给出改进建议；对于我提出的每一个问题，导师也是知无不言，耐心解答；对于代码质量，导师也会严格把控。导师是一个有情怀的人，真正践行了开源精神，也是我开源道路上的榜样和引路人。\n\n非常荣幸成为 LiteFlow 项目的 Committer。课题的完成不是结束，而是新的开始。希望今后能够更加深入地参与 LiteFolw 的开发，为社区做出更多贡献，结识更多志同道合的小伙伴。\n\n个人介绍\n\n小张\n\nLiteFlow开源成员\n\n- name: 小张\n  desc: LiteFlow开源成员\n  avatar: /img/members/m7.png\n  link: https://gitee.com/zhhhhy\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n目前就读于中国农业大学的计算机科学与技术专业，目前是华南理工大学软件工程专业的一名研究生，研究内容在大方向上属于云计算。\n\n我最初是通过开源之夏中LiteFlow的Redis课题了解到LiteFlow的。那时候通过邮件与导师联系沟通方案，导师针对每封邮件的方案都提出了自己的建议。虽然最后没能选上，但是在跟导师交流的过 程中，我也受益颇多。在后续异步循环课题的开发过程中，导师对于问题的回复也非常及时和耐心，并且对于pr的质量也有自己的把控。此外导师的技术也没得说，是在领域深耕多年的前辈，而且对于LiteFlow的维护也非常上心，每天都能看到导师在群里孜孜不倦的回复问题。\n\nLiteFlow源码的注释非常详细，整体的阅读体验非常好；其导师非常热心，对于同学提出的问题都能够及时的回复；最后，我在做课题的过程中也学到了很多东西，比如在阅读源码和实现功能的过程中，我学到了很多关于Java并发编程的知识，这些知识之前我只在八股文里边了解过，而通过做课题，我将有机会将这些知识运用到实际项目中。\n\n参与开源，主要是希望能把自己学到的东西用到实际项目中去，提高自己的技术水平。也希望LiteFlow能够越来越好，能够有更多的人参与到其中来。\n\n个人介绍\n\nRain\n\nLiteFlow开源成员\n\n- name: Rain\n  desc: LiteFlow开源成员\n  avatar: /img/members/m8.png\n  link: https://gitee.com/RainZs\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n目前就读于北京邮电大学。\n\n在开源项目的实践中，我受益匪浅。首先，参与到开源项目是一个极好的学习机会，每一次遇到困难时需要自己查阅资料并且思考解决方案，这不仅能够加深自己对之前已经学过知识的了解，更能让自己去了解到更多新的知识。\n\n此外，参与开源项目是一个能让自己时刻获得成就感并激励自己进步的过程。有时候想通了一个知识点、解决了一个卡住自己一段时间的问题，亦或是理解了某一段代码的逻辑，都会让自己充满成就感，从而更有信心地进行下一个阶段的研究。在开发的过程中，遇到的困难主要是将思路转化为代码实现的过程，可能某一条思路的代码实现方案有很多，但是如何选出一条最优并且最符合开发习惯的代码方案是一项艰难的任务。\n\n希望LiteFlow项目能够被更多的人了解与使用，也希望自己能够为社区做出更多的贡献。\n\n个人介绍\n\n落一\n\nLiteFlow开源成员\n\n- name: 落一\n  desc: LiteFlow开源成员\n  avatar: /img/members/m9.png\n  link: https://gitee.com/luoyi-yu\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n我是落一，热爱技术，热衷开源。参与到 LiteFlow 开源项目中也是为了能够贡献自己的一份力量，也希望能有更多志同道合的朋友一起参与进来，共同学习、贡献。\n\n社区比较活跃，项目发展也是相对迅速。从去年开始接触 LiteFlow 项目时，就被项目的设计给吸引到了，虽然说离顶级项目仍有很大距离，但这也是不断努力的方向；也希望项目能够发展成像 Drools 那样。\n\n目前处理的 PR 中，思路上存在的问题较多，考虑情况时不够全面，需要的应该是更加简洁的逻辑去实现复杂的逻辑。在与作者大佬交流过程中，就能感受到他比较独到的处理思想，这也是需要多加学习的地方。\n\n参与开源项目，一方面是提升自我，另一方面为回馈开源社区；同时也呼吁更多人参与开源，共建更大的开源社区。\n\n个人介绍\n\n葛足澳\n\nLiteFlow开源成员\n\n- name: 葛足澳\n  desc: LiteFlow开源成员\n  avatar: /img/members/m10.png\n  link: https://gitee.com/gezuao\n  bgColor: '#ffe3d8'\n  textColor: '#444452'\n\n\n我是葛足澳，目前在南京大学软件学院读研究生，热爱程序设计竞赛。\n\n我首次了解到LiteFlow项目是通过参与开源之夏项目，后续进行EL表达式动态组装课题的开发。在课题开发过程中，我发现如何设计简洁易用的API是一个相当困扰我的问题。然而，我很庆幸有一位优秀的导师给予了我很多帮助。作为一位经验丰富的前辈，导师及时而耐心地回答了我的问题。我非常感谢导师在开发过程中给予我的指导和支持。\n\n开源项目通常对代码质量有比较高的要求，对我来说是很好的学以致用的机会。在参与LiteFlow课题的过程中，我也发现了许多优秀的开发者。我希望能向这些开源贡献者学习，并提升自己的设计和开发能力。我期待与大家共同努力，为LiteFlow项目的发展贡献一份力量。",normalizedContent:"个人介绍\n\n铂赛东\n\nliteflow作者\n\n- name: 铂赛东\n  desc: liteflow作者\n  avatar: /img/members/author.png\n  link: https://gitee.com/bryan31\n  bgcolor: '#d7d7d7'\n  textcolor: '#000000'\n\n\n开源项目liteflow作者，开源项目tlog作者，拥有2个gvp荣誉，[元人部落]公众号博主。基础中间件架构师，深耕架构相关工作十多年。\n\n一个永远勇敢坚定追逐光的即将不惑之年的开发者。立志把liteflow带入中国顶尖开源软件的行列。\n\n\n个人介绍\n\n小易\n\nliteflowx插件作者\n\n- name: 小易\n  desc: liteflowx插件作者\n  avatar: /img/members/m1.jpg\n  link: https://gitee.com/liupeiqiang\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n24岁年轻小伙，大家都叫我小易，不喜欢浪费时间做对自己毫无提升的事，热爱编程、热爱天文、热爱物理，liteflowx插件开发作者，目前位于广东某集团担任java后端开发工程师，但个人而言并不仅局限于java后端。\n\n为什么加入：当时为治理公司业务逻辑的解耦问题迫在眉睫，在某种机缘巧合的作用下遇到liteflow框架，我对liteflow的第一个好印象就是文档内容令人眼前一亮，十分友好且易上手，但规则表达式写起来容易出错，原因是开发过程中缺少检查，组件跳转、组件统计、表达式高亮等问题，于是乎在铂赛东共同探讨下开始对liteflowx插件进行评估以及制作，将其作为liteflow框架的“辅助”，专为提高使用liteflow时的开发效率而设计。\n\n个人愿景：在浩荡的开源社区里，向各位大佬们看齐，成为架构师是我当前的目标之一，相比于这堆框架好不好用，我更感兴趣的是这堆框架的实现原理是什么。感觉自己还算年轻，该学习的东西还有很多，初来乍到请多多指教。\n\n\n个人介绍\n\n农鲜哥\n\nliteflow开源成员\n\n- name: 农鲜哥\n  desc: liteflow开源成员\n  avatar: /img/members/m2.png\n  link: https://gitee.com/zendwang\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\nzendwang， 目前就职于一家高速发展的互联网保险公司，做crud boy多年，深刻感受到面对各种复杂的业务流程，如果代码只能应付眼下的业务需求，后面维护成本不可估量，如何解决这个问题，带着这个困惑，有幸接触到liteflow，并尝试参与社区开发，做了一些单元测试和代码优化的工作。目前已经把liteflow应用到公司部分核心业务场景，用liteflow的组件、流程来做业务解耦真的很方便，开发、维护都so easy 。\n\n愿景：多多参与社区开发和社区群问题解答，帮助和引导社区的开发同学都早日用上liteflow、参与liteflow。\n\n\n个人介绍\n\n与或非\n\nliteflow开源成员\n\n- name: 与或非\n  desc: liteflow开源成员\n  avatar: /img/members/m3.png\n  link: https://gitee.com/tangkc123\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n我是与或非，从事 java 开发4年，非常荣幸受邀成为 liteflow 的 committer。第一次给 liteflow 提 pr 是修改测试用例的文件路径，和作者沟通很愉快，感受到作者对开源事业的热情。正是这份热情吸引我持续给项目提交 pr。在后续的 pr 中我也得到了作者及其他小伙伴的帮助，和liteflow一起成长。作为java 行业的初学者，希望能从liteflow开始为开源事业做一些自己的贡献，在成为一名合格程序员的路上越走越远。\n\n\n个人介绍\n\n小马\n\nliteflow开源成员\n\n- name: 小马\n  desc: liteflow开源成员\n  avatar: /img/members/m4.png\n  link: https://gitee.com/nmnl\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n个人简介: it行业10年耕作(职业路线码农>组长>经理>cto>码农); 热爱各种技术; 做事的原则对事情有种极度刻薄的观念并且去实现它，有时却退而求其次完成它。就是这样矛盾的一个人。\n\n为什么加入: 给自己一个机会，参与开源回报开源。\n\n个人愿景: 学会liteflow并且使用它再回报它，码农其实挺好的。\n\n\n个人介绍\n\nrainie\n\nliteflow开源成员\n\n- name: rainie\n  desc: liteflow开源成员\n  avatar: /img/members/m5.png\n  link: https://gitee.com/h-xinyu\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n目前就读于中国科学院大学电子信息专业22级。\n\n在开源之夏活动中参与了liteflow的课题研究，并成为了liteflow开源成员。\n\n在开发过程中，导师不仅在总体方案上会给出清晰思路，每次提交代码还会认真逐行review，提出很细致的代码优化建议，也让我对开源多了一份敬意，开源的代码更需要精益求精，对代码高质量要求才能让项目走得更远。\n\n参与开源虽然时间不长但收获了很多。希望在以后的开源之路上能够增强自己的方案设计和代码能力，写出更优雅的代码，为项目做出更多有用的贡献~~\n\n个人介绍\n\ndalelee\n\nliteflow开源成员\n\n- name: dalelee\n  desc: liteflow开源成员\n  avatar: /img/members/m6.png\n  link: https://gitee.com/dalelee\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n目前就读于福州大学研三。\n\n做开源最开心的一刻，莫过于自己的 pr 被合并的那一刻，那时候有一种巨大的自豪感和满足感。开源代来给我最大的收获，在于让我意识到了设计和测试的重要性，这也是我之前写代码经常忽略的地方。良好的设计是成功的开始，完善的测试才能保障代码的正确性。\n\n导师在课题的完成过程中给与了我非常大的帮助。在每一版方案中，导师都会认真地给出改进建议；对于我提出的每一个问题，导师也是知无不言，耐心解答；对于代码质量，导师也会严格把控。导师是一个有情怀的人，真正践行了开源精神，也是我开源道路上的榜样和引路人。\n\n非常荣幸成为 liteflow 项目的 committer。课题的完成不是结束，而是新的开始。希望今后能够更加深入地参与 litefolw 的开发，为社区做出更多贡献，结识更多志同道合的小伙伴。\n\n个人介绍\n\n小张\n\nliteflow开源成员\n\n- name: 小张\n  desc: liteflow开源成员\n  avatar: /img/members/m7.png\n  link: https://gitee.com/zhhhhy\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n目前就读于中国农业大学的计算机科学与技术专业，目前是华南理工大学软件工程专业的一名研究生，研究内容在大方向上属于云计算。\n\n我最初是通过开源之夏中liteflow的redis课题了解到liteflow的。那时候通过邮件与导师联系沟通方案，导师针对每封邮件的方案都提出了自己的建议。虽然最后没能选上，但是在跟导师交流的过 程中，我也受益颇多。在后续异步循环课题的开发过程中，导师对于问题的回复也非常及时和耐心，并且对于pr的质量也有自己的把控。此外导师的技术也没得说，是在领域深耕多年的前辈，而且对于liteflow的维护也非常上心，每天都能看到导师在群里孜孜不倦的回复问题。\n\nliteflow源码的注释非常详细，整体的阅读体验非常好；其导师非常热心，对于同学提出的问题都能够及时的回复；最后，我在做课题的过程中也学到了很多东西，比如在阅读源码和实现功能的过程中，我学到了很多关于java并发编程的知识，这些知识之前我只在八股文里边了解过，而通过做课题，我将有机会将这些知识运用到实际项目中。\n\n参与开源，主要是希望能把自己学到的东西用到实际项目中去，提高自己的技术水平。也希望liteflow能够越来越好，能够有更多的人参与到其中来。\n\n个人介绍\n\nrain\n\nliteflow开源成员\n\n- name: rain\n  desc: liteflow开源成员\n  avatar: /img/members/m8.png\n  link: https://gitee.com/rainzs\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n目前就读于北京邮电大学。\n\n在开源项目的实践中，我受益匪浅。首先，参与到开源项目是一个极好的学习机会，每一次遇到困难时需要自己查阅资料并且思考解决方案，这不仅能够加深自己对之前已经学过知识的了解，更能让自己去了解到更多新的知识。\n\n此外，参与开源项目是一个能让自己时刻获得成就感并激励自己进步的过程。有时候想通了一个知识点、解决了一个卡住自己一段时间的问题，亦或是理解了某一段代码的逻辑，都会让自己充满成就感，从而更有信心地进行下一个阶段的研究。在开发的过程中，遇到的困难主要是将思路转化为代码实现的过程，可能某一条思路的代码实现方案有很多，但是如何选出一条最优并且最符合开发习惯的代码方案是一项艰难的任务。\n\n希望liteflow项目能够被更多的人了解与使用，也希望自己能够为社区做出更多的贡献。\n\n个人介绍\n\n落一\n\nliteflow开源成员\n\n- name: 落一\n  desc: liteflow开源成员\n  avatar: /img/members/m9.png\n  link: https://gitee.com/luoyi-yu\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n我是落一，热爱技术，热衷开源。参与到 liteflow 开源项目中也是为了能够贡献自己的一份力量，也希望能有更多志同道合的朋友一起参与进来，共同学习、贡献。\n\n社区比较活跃，项目发展也是相对迅速。从去年开始接触 liteflow 项目时，就被项目的设计给吸引到了，虽然说离顶级项目仍有很大距离，但这也是不断努力的方向；也希望项目能够发展成像 drools 那样。\n\n目前处理的 pr 中，思路上存在的问题较多，考虑情况时不够全面，需要的应该是更加简洁的逻辑去实现复杂的逻辑。在与作者大佬交流过程中，就能感受到他比较独到的处理思想，这也是需要多加学习的地方。\n\n参与开源项目，一方面是提升自我，另一方面为回馈开源社区；同时也呼吁更多人参与开源，共建更大的开源社区。\n\n个人介绍\n\n葛足澳\n\nliteflow开源成员\n\n- name: 葛足澳\n  desc: liteflow开源成员\n  avatar: /img/members/m10.png\n  link: https://gitee.com/gezuao\n  bgcolor: '#ffe3d8'\n  textcolor: '#444452'\n\n\n我是葛足澳，目前在南京大学软件学院读研究生，热爱程序设计竞赛。\n\n我首次了解到liteflow项目是通过参与开源之夏项目，后续进行el表达式动态组装课题的开发。在课题开发过程中，我发现如何设计简洁易用的api是一个相当困扰我的问题。然而，我很庆幸有一位优秀的导师给予了我很多帮助。作为一位经验丰富的前辈，导师及时而耐心地回答了我的问题。我非常感谢导师在开发过程中给予我的指导和支持。\n\n开源项目通常对代码质量有比较高的要求，对我来说是很好的学以致用的机会。在参与liteflow课题的过程中，我也发现了许多优秀的开发者。我希望能向这些开源贡献者学习，并提升自己的设计和开发能力。我期待与大家共同努力，为liteflow项目的发展贡献一份力量。",charsets:{cjk:!0},lastUpdated:"2025/02/16, 14:38:49",lastUpdatedTimestamp:1739716729e3}],themeConfig:{nav:[{text:"💒首页",link:"/"},{text:"📚文档",link:"/pages/5816c5/",items:[{text:"v2.12.4(当前版本)",link:"/pages/5816c5/"},{text:"What's New",items:[{text:"What' s New In LiteFlow v2.12.4?",link:"/pages/8ff021/"}]},{text:"历史版本",items:[{text:"v2.11.X",link:"/pages/v2.11.X/5816c5/"},{text:"v2.10.X",link:"/pages/v2.10.X/5816c5/"},{text:"v2.9.X",link:"/pages/v2.9.X/5816c5/"},{text:"v2.8.X",link:"/pages/v2.8.X/5816c5/"}]},{text:"升级指南",items:[{text:"2.12.4升级指南",link:"/pages/88c2f1/"},{text:"2.12.0升级指南",link:"/pages/88c2f2/"},{text:"升级到2.9.3说明",link:"/pages/88c2f4/"},{text:"升级到2.9.X说明",link:"/pages/88c2f3/"},{text:"升级到2.8.X说明",link:"/pages/88c2e2/"},{text:"升级到2.7.X说明",link:"/pages/4848b9/"}]}]},{text:"👑LF CLUB社区",link:"/pages/8d8888/"},{text:"❓问答",items:[{text:"常见问题",link:"/pages/845dff/"},{text:"专题解释",items:[{text:"如何理解上下文这个概念？",link:"/pages/e1e61f/"},{text:"Slot是一个什么样的概念，在框架中起到什么样的作用？",link:"/pages/ad60b4/"}]}]},{text:"💖赞助",link:"/pages/fb599d/"},{text:"🧩插件",link:"/pages/liteflowx/"},{text:"🔥PPT",link:"/pages/8d6666/"},{text:"🐶关于项目",items:[{text:"项目介绍",link:"/pages/8d7f1e/"},{text:"项目成员",link:"/pages/ae4d66/"},{text:"更新记录",link:"/pages/88c2d1/"},{text:"参与开发",link:"/pages/ae4dd5/"}]},{text:"👥加入群聊",link:"/pages/73c2c3/"},{text:"🧤谁在使用",link:"/pages/9b9f41/"},{text:"🛖仓库托管",items:[{text:"Gitee",link:"https://gitee.com/dromara/liteFlow"},{text:"Github",link:"https://github.com/dromara/liteflow"},{text:"推荐",items:[{text:"TLog-轻量级的分布式日志追踪神器",link:"https://tlog.yomahub.com/"},{text:"Forest-更轻量、更简单实用的HTTP客户端框架",link:"https://forest.dtflyx.com/"},{text:"Jpom-一款原生 ops 软件",link:"https://jpom.top/"}]}]}],sidebarDepth:2,logo:"/img/logo.png",searchMaxSuggestions:10,lastUpdated:"上次更新",docsRepo:"bryan31/liteflow-homepage",docsDir:"docs",editLinks:!0,editLinkText:"帮助我们改善此文档",sidebar:{"/00.en/":[{title:"v2.11.X Document",collapsable:!1,children:[["08.v2.11.X Document/010.Introduction.md","🍤 Introduction","/pages/5816c5/"]]}],catalogue:{},"/07.v2.12.X文档/":[["010.LiteFlow简介.md","🍤LiteFlow简介","/pages/5816c5/"],["020.项目特性.md","🍓项目特性","/pages/724bc3/"],{title:"🧁环境支持",collapsable:!1,children:[["021.🧁环境支持/005.环境支持说明.md","🗣环境支持说明","/pages/c1a488/"],["021.🧁环境支持/010.JDK支持度.md","☕️JDK支持度","/pages/7cf080/"],["021.🧁环境支持/020.Springboot支持度.md","🌿Springboot支持度","/pages/891e0f/"],["021.🧁环境支持/030.Spring的支持度.md","🌱Spring的支持度","/pages/2d12db/"]]},{title:"🍟快速开始(Hello world)",collapsable:!1,children:[["030.🍟快速开始(Hello world)/005.说明.md","🍄说明","/pages/631fa1/"],{title:"🌿Springboot场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md","🧬依赖","/pages/df6982/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md","⚙️配置","/pages/82ef41/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md","🛫执行","/pages/9f4489/"]]},{title:"🌱Spring场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md","🧬依赖","/pages/0a4573/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md","⚙️配置","/pages/495f21/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md","🛫执行","/pages/0e0fb5/"]]},{title:"🌵其他场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md","🍄说明","/pages/522432/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md","🧬依赖","/pages/8760c4/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md","⚙️配置","/pages/249d17/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md","🛫执行","/pages/151524/"]]}]},{title:"🍢配置项",collapsable:!1,children:[["040.🍢配置项/010.说明.md","🍄说明","/pages/b70ec8/"],["040.🍢配置项/020.Springboot下的配置项.md","🌿Springboot下的配置项","/pages/4594ec/"],["040.🍢配置项/030.Spring下的配置项.md","🌱Spring下的配置项","/pages/33833a/"],["040.🍢配置项/040.其他场景代码设置配置项.md","🌵其他场景代码设置配置项","/pages/b5065a/"]]},{title:"🗂规则以及配置源",collapsable:!1,children:[["050.🗂规则以及配置源/010.规则文件格式.md","📔规则文件格式","/pages/6fa87e/"],["050.🗂规则以及配置源/020.本地规则文件配置.md","📕本地规则文件配置","/pages/51ddd5/"],["050.🗂规则以及配置源/030.ZK规则文件配置源.md","📗ZK规则文件配置源","/pages/ffc345/"],["050.🗂规则以及配置源/040.SQL数据库配置源.md","📘SQL数据库配置源","/pages/236b4f/"],["050.🗂规则以及配置源/050.Nacos配置源.md","📋Nacos配置源","/pages/09b776/"],["050.🗂规则以及配置源/060.Etcd配置源.md","🗄Etcd配置源","/pages/4bfac2/"],["050.🗂规则以及配置源/065.Apollo配置源.md","📜Apollo配置源","/pages/bea809/"],{title:"📑Redis配置源",collapsable:!1,children:[["050.🗂规则以及配置源/066.📑Redis配置源/010.配置说明.md","配置说明","/pages/38dcf8/"],["050.🗂规则以及配置源/066.📑Redis配置源/020.轮询模式配置.md","轮询模式配置","/pages/186747/"],["050.🗂规则以及配置源/066.📑Redis配置源/030.订阅模式配置.md","订阅模式配置","/pages/3f553f/"]]},["050.🗂规则以及配置源/070.自定义配置源.md","📙自定义配置源","/pages/25f2c0/"]]},{title:"🔗常规组件",collapsable:!1,children:[["055.🔗常规组件/010.普通组件.md","📎普通组件","/pages/8486fb/"],["055.🔗常规组件/020.选择组件.md","✂️选择组件","/pages/c0f5d7/"],["055.🔗常规组件/030.布尔组件.md","⛓布尔组件","/pages/cb0b59/"],["055.🔗常规组件/040.次数循环组件.md","🧬次数循环组件","/pages/5f971f/"],["055.🔗常规组件/055.迭代循环组件.md","⌛️迭代循环组件","/pages/64262b/"]]},{title:"🧩EL规则的写法",collapsable:!1,children:[["060.🧩EL规则的写法/010.说明.md","🍄说明","/pages/16eca9/"],["060.🧩EL规则的写法/020.串行编排.md","🌴串行编排","/pages/a590ee/"],["060.🧩EL规则的写法/030.并行编排.md","🎋并行编排","/pages/b3446a/"],["060.🧩EL规则的写法/040.选择编排.md","🌾选择编排","/pages/d90483/"],["060.🧩EL规则的写法/045.条件编排.md","🌵条件编排","/pages/e76999/"],["060.🧩EL规则的写法/046.循环编排.md","🌳循环编排","/pages/fbf715/"],["060.🧩EL规则的写法/047.捕获异常表达式.md","🎃捕获异常表达式","/pages/f53b51/"],["060.🧩EL规则的写法/048.与或非表达式.md","🍄与或非表达式","/pages/a8b344/"],["060.🧩EL规则的写法/050.使用子流程.md","🍁使用子流程","/pages/dc5df7/"],["060.🧩EL规则的写法/060.使用子变量.md","🍂使用子变量","/pages/71ff49/"],["060.🧩EL规则的写法/070.复杂编排例子.md","💐复杂编排例子","/pages/5156b3/"],["060.🧩EL规则的写法/080.关于分号.md","🌻关于分号","/pages/af44a6/"],["060.🧩EL规则的写法/090.关于注释.md","🌰关于注释","/pages/f3dc09/"],["060.🧩EL规则的写法/100.组件名包装.md","🐚组件名包装","/pages/2df3d9/"],["060.🧩EL规则的写法/110.验证规则.md","🔆验证规则","/pages/395fd0/"]]},{title:"🌮数据上下文",collapsable:!1,children:[["070.🌮数据上下文/010.说明.md","🍄说明","/pages/74b4bf/"],["070.🌮数据上下文/020.数据上下文的定义和使用.md","🌯数据上下文的定义和使用","/pages/501abf/"],["070.🌮数据上下文/030.用初始化好的上下文传入.md","🪶用初始化好的上下文传入","/pages/f05ed6/"],["070.🌮数据上下文/040.给上下文设置别名.md","🥨给上下文设置别名","/pages/e71ced/"],["070.🌮数据上下文/050.上下文参数注入.md","🥙上下文参数注入","/pages/8777f8/"]]},{title:"🛩执行器",collapsable:!1,children:[["080.🛩执行器/010.说明.md","🍄说明","/pages/90b2a5/"],["080.🛩执行器/020.执行方法.md","🎡执行方法","/pages/20072e/"],["080.🛩执行器/030.流程入参.md","🎢流程入参","/pages/563b67/"],["080.🛩执行器/040.LiteflowResponse对象.md","🎈LiteflowResponse对象","/pages/9f653d/"]]},{title:"🍋脚本组件",collapsable:!1,children:[["085.🍋脚本组件/005.脚本语言介绍.md","🌭脚本语言介绍","/pages/38c781/"],{title:"🍫脚本语言种类",collapsable:!1,children:[["085.🍋脚本组件/010.🍫脚本语言种类/010.Groovy脚本引擎.md","🥏Groovy脚本引擎","/pages/36877b/"],["085.🍋脚本组件/010.🍫脚本语言种类/020.Javascript脚本引擎.md","🧀Javascript脚本引擎","/pages/07f433/"],["085.🍋脚本组件/010.🍫脚本语言种类/030.Java脚本引擎.md","☕️Java脚本引擎","/pages/2b8afb/"],["085.🍋脚本组件/010.🍫脚本语言种类/040.QLExpress脚本引擎.md","🥞QLExpress脚本引擎","/pages/19db6d/"],["085.🍋脚本组件/010.🍫脚本语言种类/050.Python脚本引擎.md","🍧Python脚本引擎","/pages/114982/"],["085.🍋脚本组件/010.🍫脚本语言种类/060.Lua脚本引擎.md","🍝Lua脚本引擎","/pages/5f0cc7/"],["085.🍋脚本组件/010.🍫脚本语言种类/070.Aviator脚本引擎.md","🥐Aviator脚本引擎","/pages/bad4b0/"],["085.🍋脚本组件/010.🍫脚本语言种类/080.Kotlin脚本引擎.md","🥠Kotlin脚本引擎","/pages/7c44ca/"]]},["085.🍋脚本组件/015.脚本与Java进行交互.md","🍣脚本与Java进行交互","/pages/d861c8/"],["085.🍋脚本组件/020.多脚本语言混合共存.md","🍱多脚本语言混合共存","/pages/acba2c/"],["085.🍋脚本组件/030.文件脚本的定义.md","🌯文件脚本的定义","/pages/f7acfd/"],["085.🍋脚本组件/050.动态刷新脚本.md","🍘动态刷新脚本","/pages/cbcb14/"],["085.🍋脚本组件/060.验证脚本.md","🍦验证脚本","/pages/a5f7d9/"],["085.🍋脚本组件/070.卸载脚本.md","🗑卸载脚本","/pages/28ad17/"]]},{title:"🍇声明式组件",collapsable:!1,children:[["086.🍇声明式组件/010.什么叫声明式组件.md","🥭什么叫声明式组件","/pages/46f0fa/"],["086.🍇声明式组件/020.类级别式声明.md","🧅类级别式声明","/pages/18f548/"],["086.🍇声明式组件/030.方法级别式声明.md","🥥方法级别式声明","/pages/797830/"]]},{title:"🎲用代码动态构造规则",collapsable:!1,children:[["090.🎲用代码动态构造规则/010.说明.md","🍄说明","/pages/9aa85a/"],["090.🎲用代码动态构造规则/020.构造Node.md","🥜构造Node","/pages/5bbee3/"],["090.🎲用代码动态构造规则/030.构造EL.md","🌰构造EL","/pages/a3cb4b/"],["090.🎲用代码动态构造规则/040.构造Chain.md","🍞构造Chain","/pages/cd0445/"]]},{title:"🍼元数据管理",collapsable:!1,children:[["095.🍼元数据管理/010.概念以及介绍.md","⛰概念以及介绍","/pages/7cb165/"],["095.🍼元数据管理/020.平滑热刷新.md","🍖平滑热刷新","/pages/204d71/"],["095.🍼元数据管理/030.启动不检查规则.md","🍮启动不检查规则","/pages/891f36/"],["095.🍼元数据管理/040.查看指定规则下的所有组件.md","🫔查看指定规则下的所有组件","/pages/b0bb54/"]]},{title:"🧮决策路由",collapsable:!1,children:[["097.🧮决策路由/010.概念以及介绍.md","🏖概念以及介绍","/pages/ec1ac4/"],["097.🧮决策路由/020.决策路由用法.md","🍽决策路由用法","/pages/b7ed78/"]]},{title:"😸生命周期",collapsable:!1,children:[["098.😸生命周期/010.启动时生命周期.md","🐮启动时生命周期","/pages/ef098d/"],["098.😸生命周期/020.执行时生命周期.md","🐳执行时生命周期","/pages/f6ae9e/"]]},{title:"🎨高级特性",collapsable:!1,children:[["100.🎨高级特性/030.前置和后置组件.md","🍒前置和后置组件","/pages/9f93be/"],["100.🎨高级特性/031.本地规则文件监听.md","🍌本地规则文件监听","/pages/f8aa79/"],["100.🎨高级特性/035.组件降级.md","🥠组件降级","/pages/79289a/"],["100.🎨高级特性/036.组件参数.md","🍉组件参数","/pages/6e4d15/"],["100.🎨高级特性/040.组件别名.md","🍑组件别名","/pages/92ef89/"],["100.🎨高级特性/050.组件标签.md","🍍组件标签","/pages/0f788f/"],["100.🎨高级特性/060.组件事件回调.md","🥝组件事件回调","/pages/3ee755/"],["100.🎨高级特性/061.组件回滚.md","🐋组件回滚","/pages/y172l7/"],["100.🎨高级特性/070.隐式子流程.md","🥑隐式子流程","/pages/80e873/"],["100.🎨高级特性/080.私有投递.md","🍕私有投递","/pages/fbb938/"],["100.🎨高级特性/090.组件重试.md","🍣组件重试","/pages/7e9da1/"],["100.🎨高级特性/091.EL中的重试.md","🫐EL中的重试","/pages/b44233/"],["100.🎨高级特性/095.异步循环模式.md","🥦异步循环模式","/pages/35cc4a/"],["100.🎨高级特性/097.超时控制.md","⏱️超时控制","/pages/fd5984/"],["100.🎨高级特性/105.链路继承.md","🥯链路继承","/pages/524c43/","🧪 Beta"],["100.🎨高级特性/110.组件切面.md","🍪组件切面","/pages/2373f5/"],["100.🎨高级特性/120.步骤信息.md","🍡步骤信息","/pages/e5ed0d/"],["100.🎨高级特性/125.异常.md","🧊异常","/pages/dc9bfe/"],["100.🎨高级特性/130.打印信息详解.md","🧇打印信息详解","/pages/4d614c/"],["100.🎨高级特性/140.自定义请求Id.md","🧁自定义请求Id","/pages/47e8f5/"],["100.🎨高级特性/145.快速解析模式.md","🫕快速解析模式","/pages/5fe959/"],["100.🎨高级特性/150.不同格式规则加载.md","🌭不同格式规则加载","/pages/a7e02e/"],["100.🎨高级特性/160.异步线程池自定义.md","🥗异步线程池自定义","/pages/7280ea/"],["100.🎨高级特性/170.自定义组件执行器.md","🍿自定义组件执行器","/pages/46bbed/"],["100.🎨高级特性/180.简单监控.md","🍥简单监控","/pages/e59f3a/"],["100.🎨高级特性/190.XML的DTD.md","🧉XML的DTD","/pages/0066ae/"]]},{title:"⛱测试用例以及示例",collapsable:!1,children:[["110.⛱测试用例以及示例/010.测试用例.md","🪁测试用例","/pages/81cdce/"],["110.⛱测试用例以及示例/020.DEMO案例.md","🪀DEMO案例","/pages/0a8188/"]]},["120.性能表现.md","🪂性能表现","/pages/9bf839/"]],"/08.v2.11.X文档/":[["010.LiteFlow简介.md","🍤LiteFlow简介","/pages/v2.11.X/5816c5/"],["020.项目特性.md","🍓项目特性","/pages/v2.11.X/724bc3/"],{title:"🧁环境支持",collapsable:!1,children:[["021.🧁环境支持/010.JDK支持度.md","☕️JDK支持度","/pages/v2.11.X/7cf080/"],["021.🧁环境支持/020.Springboot支持度.md","🌿Springboot支持度","/pages/v2.11.X/891e0f/"],["021.🧁环境支持/030.Spring的支持度.md","🌱Spring的支持度","/pages/v2.11.X/2d12db/"]]},{title:"🍟快速开始(Hello world)",collapsable:!1,children:[["030.🍟快速开始(Hello world)/005.说明.md","🍄说明","/pages/v2.11.X/631fa1/"],{title:"🌿Springboot场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md","🧬依赖","/pages/v2.11.X/df6982/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md","⚙️配置","/pages/v2.11.X/82ef41/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md","🛫执行","/pages/v2.11.X/9f4489/"]]},{title:"🌱Spring场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md","🧬依赖","/pages/v2.11.X/0a4573/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md","⚙️配置","/pages/v2.11.X/495f21/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md","🛫执行","/pages/v2.11.X/0e0fb5/"]]},{title:"🌵其他场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md","🍄说明","/pages/v2.11.X/522432/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md","🧬依赖","/pages/v2.11.X/8760c4/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md","⚙️配置","/pages/v2.11.X/249d17/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md","🛫执行","/pages/v2.11.X/151524/"]]}]},{title:"🍢配置项",collapsable:!1,children:[["040.🍢配置项/010.说明.md","🍄说明","/pages/v2.11.X/b70ec8/"],["040.🍢配置项/020.Springboot下的配置项.md","🌿Springboot下的配置项","/pages/v2.11.X/4594ec/"],["040.🍢配置项/030.Spring下的配置项.md","🌱Spring下的配置项","/pages/v2.11.X/33833a/"],["040.🍢配置项/040.其他场景代码设置配置项.md","🌵其他场景代码设置配置项","/pages/v2.11.X/b5065a/"]]},{title:"🗂规则文件",collapsable:!1,children:[["050.🗂规则文件/010.规则文件格式.md","📔规则文件格式","/pages/v2.11.X/6fa87e/"],["050.🗂规则文件/020.本地规则文件配置.md","📕本地规则文件配置","/pages/v2.11.X/51ddd5/"],["050.🗂规则文件/030.ZK规则文件配置源.md","📗ZK规则文件配置源","/pages/v2.11.X/ffc345/"],["050.🗂规则文件/040.SQL数据库配置源.md","📘SQL数据库配置源","/pages/v2.11.X/236b4f/"],["050.🗂规则文件/050.Nacos配置源.md","📋Nacos配置源","/pages/v2.11.X/09b776/"],["050.🗂规则文件/060.Etcd配置源.md","🗄Etcd配置源","/pages/v2.11.X/4bfac2/"],["050.🗂规则文件/065.Apollo配置源.md","📜Apollo配置源","/pages/v2.11.X/bea809/"],{title:"📑Redis配置源",collapsable:!1,children:[["050.🗂规则文件/066.📑Redis配置源/010.配置说明.md","配置说明","/pages/v2.11.X/38dcf8/"],["050.🗂规则文件/066.📑Redis配置源/020.轮询模式配置.md","轮询模式配置","/pages/v2.11.X/186747/"],["050.🗂规则文件/066.📑Redis配置源/030.订阅模式配置.md","订阅模式配置","/pages/v2.11.X/3f553f/"]]},["050.🗂规则文件/070.自定义配置源.md","📙自定义配置源","/pages/v2.11.X/25f2c0/"]]},{title:"🔗常规组件",collapsable:!1,children:[["055.🔗常规组件/010.普通组件.md","📎普通组件","/pages/v2.11.X/8486fb/"],["055.🔗常规组件/020.选择组件.md","✂️选择组件","/pages/v2.11.X/c0f5d7/"],["055.🔗常规组件/030.条件组件.md","📌条件组件","/pages/v2.11.X/cb0b59/"],["055.🔗常规组件/040.次数循环组件.md","🧬次数循环组件","/pages/v2.11.X/5f971f/"],["055.🔗常规组件/050.条件循环组件.md","⛓条件循环组件","/pages/v2.11.X/e6995e/"],["055.🔗常规组件/055.迭代循环组件.md","⌛️迭代循环组件","/pages/v2.11.X/64262b/"],["055.🔗常规组件/060.退出循环组件.md","🧿退出循环组件","/pages/v2.11.X/c078cd/"]]},{title:"🧩EL规则的写法",collapsable:!1,children:[["060.🧩EL规则的写法/010.说明.md","🍄说明","/pages/v2.11.X/16eca9/"],["060.🧩EL规则的写法/020.串行编排.md","🌴串行编排","/pages/v2.11.X/a590ee/"],["060.🧩EL规则的写法/030.并行编排.md","🎋并行编排","/pages/v2.11.X/b3446a/"],["060.🧩EL规则的写法/040.选择编排.md","🌾选择编排","/pages/v2.11.X/d90483/"],["060.🧩EL规则的写法/045.条件编排.md","🌵条件编排","/pages/v2.11.X/e76999/"],["060.🧩EL规则的写法/046.循环编排.md","🌳循环编排","/pages/v2.11.X/fbf715/"],["060.🧩EL规则的写法/047.捕获异常表达式.md","🎃捕获异常表达式","/pages/v2.11.X/f53b51/"],["060.🧩EL规则的写法/048.与或非表达式.md","🍄与或非表达式","/pages/v2.11.X/a8b344/"],["060.🧩EL规则的写法/050.使用子流程.md","🍁使用子流程","/pages/v2.11.X/dc5df7/"],["060.🧩EL规则的写法/060.使用子变量.md","🍂使用子变量","/pages/v2.11.X/71ff49/"],["060.🧩EL规则的写法/070.复杂编排例子.md","💐复杂编排例子","/pages/v2.11.X/5156b3/"],["060.🧩EL规则的写法/080.关于分号.md","🌻关于分号","/pages/v2.11.X/af44a6/"],["060.🧩EL规则的写法/090.关于注释.md","🌰关于注释","/pages/v2.11.X/f3dc09/"],["060.🧩EL规则的写法/100.组件名包装.md","🐚组件名包装","/pages/v2.11.X/2df3d9/"],["060.🧩EL规则的写法/110.验证规则.md","🔆验证规则","/pages/v2.11.X/395fd0/"]]},{title:"🌮数据上下文",collapsable:!1,children:[["070.🌮数据上下文/010.说明.md","🍄说明","/pages/v2.11.X/74b4bf/"],["070.🌮数据上下文/020.数据上下文的定义和使用.md","🌯数据上下文的定义和使用","/pages/v2.11.X/501abf/"],["070.🌮数据上下文/030.用初始化好的上下文传入.md","🪶用初始化好的上下文传入","/pages/v2.11.X/f05ed6/"]]},{title:"🛩执行器",collapsable:!1,children:[["080.🛩执行器/010.说明.md","🍄说明","/pages/v2.11.X/90b2a5/"],["080.🛩执行器/020.执行方法.md","🎡执行方法","/pages/v2.11.X/20072e/"],["080.🛩执行器/030.流程入参.md","🎢流程入参","/pages/v2.11.X/563b67/"],["080.🛩执行器/040.LiteflowResponse对象.md","🎈LiteflowResponse对象","/pages/v2.11.X/9f653d/"]]},{title:"🍋脚本组件",collapsable:!1,children:[["085.🍋脚本组件/005.脚本语言介绍.md","🌭脚本语言介绍","/pages/v2.11.X/38c781/"],{title:"🍫脚本语言种类",collapsable:!1,children:[["085.🍋脚本组件/010.🍫脚本语言种类/010.Groovy脚本引擎.md","🥏Groovy脚本引擎","/pages/v2.11.X/36877b/"],["085.🍋脚本组件/010.🍫脚本语言种类/020.Javascript脚本引擎.md","🧀Javascript脚本引擎","/pages/v2.11.X/07f433/"],["085.🍋脚本组件/010.🍫脚本语言种类/030.Java脚本引擎.md","☕️Java脚本引擎","/pages/v2.11.X/2b8afb/"],["085.🍋脚本组件/010.🍫脚本语言种类/040.QLExpress脚本引擎.md","🥞QLExpress脚本引擎","/pages/v2.11.X/19db6d/"],["085.🍋脚本组件/010.🍫脚本语言种类/050.Python脚本引擎.md","🍧Python脚本引擎","/pages/v2.11.X/114982/"],["085.🍋脚本组件/010.🍫脚本语言种类/060.Lua脚本引擎.md","🍝Lua脚本引擎","/pages/v2.11.X/5f0cc7/"],["085.🍋脚本组件/010.🍫脚本语言种类/070.Aviator脚本引擎.md","🥐Aviator脚本引擎","/pages/v2.11.X/bad4b0/"]]},["085.🍋脚本组件/015.脚本与Java进行交互.md","🍣脚本与Java进行交互","/pages/v2.11.X/d861c8/"],["085.🍋脚本组件/020.多脚本语言混合共存.md","🍱多脚本语言混合共存","/pages/v2.11.X/acba2c/"],["085.🍋脚本组件/030.文件脚本的定义.md","🌯文件脚本的定义","/pages/v2.11.X/f7acfd/"],["085.🍋脚本组件/050.动态刷新脚本.md","🍘动态刷新脚本","/pages/v2.11.X/cbcb14/"]]},{title:"🍇声明式组件",collapsable:!1,children:[["086.🍇声明式组件/010.什么叫声明式组件.md","🥭什么叫声明式组件","/pages/v2.11.X/46f0fa/"],["086.🍇声明式组件/020.类级别式声明.md","🧅类级别式声明","/pages/v2.11.X/18f548/"],["086.🍇声明式组件/030.方法级别式声明.md","🥥方法级别式声明","/pages/v2.11.X/797830/"]]},{title:"🎲用代码动态构造规则",collapsable:!1,children:[["090.🎲用代码动态构造规则/010.说明.md","🍄说明","/pages/v2.11.X/9aa85a/"],["090.🎲用代码动态构造规则/020.构造Node.md","🥜构造Node","/pages/v2.11.X/5bbee3/"],["090.🎲用代码动态构造规则/030.构造EL.md","🌰构造EL","/pages/v2.11.X/a3cb4b/"],["090.🎲用代码动态构造规则/040.构造Chain.md","🍞构造Chain","/pages/v2.11.X/cd0445/"]]},{title:"🎨高级特性",collapsable:!1,children:[["100.🎨高级特性/030.前置和后置组件.md","🍒前置和后置组件","/pages/v2.11.X/9f93be/"],["100.🎨高级特性/031.本地规则文件监听.md","🍌本地规则文件监听","/pages/v2.11.X/f8aa79/"],["100.🎨高级特性/035.组件降级.md","🥠组件降级","/pages/v2.11.X/79289a/"],["100.🎨高级特性/036.组件参数.md","🍉组件参数","/pages/v2.11.X/6e4d15/"],["100.🎨高级特性/040.组件别名.md","🍑组件别名","/pages/v2.11.X/92ef89/"],["100.🎨高级特性/050.组件标签.md","🍍组件标签","/pages/v2.11.X/0f788f/"],["100.🎨高级特性/060.组件事件回调.md","🥝组件事件回调","/pages/v2.11.X/3ee755/"],["100.🎨高级特性/061.组件回滚.md","🐋组件回滚","/pages/v2.11.X/y172l7/"],["100.🎨高级特性/070.隐式子流程.md","🥑隐式子流程","/pages/v2.11.X/80e873/"],["100.🎨高级特性/080.私有投递.md","🍕私有投递","/pages/v2.11.X/fbb938/"],["100.🎨高级特性/090.组件重试.md","🍣组件重试","/pages/v2.11.X/7e9da1/"],["100.🎨高级特性/091.异步循环模式.md","🥦异步循环模式","/pages/v2.11.X/35cc4a/"],["100.🎨高级特性/092.超时控制.md","⏱️超时控制","/pages/v2.11.X/fd5984/"],["100.🎨高级特性/100.平滑热刷新.md","🍖平滑热刷新","/pages/v2.11.X/204d71/"],["100.🎨高级特性/105.链路继承.md","🥯链路继承","/pages/v2.11.X/524c43/","🧪 Beta"],["100.🎨高级特性/110.组件切面.md","🍪组件切面","/pages/v2.11.X/2373f5/"],["100.🎨高级特性/120.步骤信息.md","🍡步骤信息","/pages/v2.11.X/e5ed0d/"],["100.🎨高级特性/125.异常.md","🧊异常","/pages/v2.11.X/dc9bfe/"],["100.🎨高级特性/130.打印信息详解.md","🧇打印信息详解","/pages/v2.11.X/4d614c/"],["100.🎨高级特性/140.自定义请求Id.md","🧁自定义请求Id","/pages/v2.11.X/47e8f5/"],["100.🎨高级特性/145.快速解析模式.md","🫕快速解析模式","/pages/v2.11.X/5fe959/"],["100.🎨高级特性/150.不同格式规则加载.md","🌭不同格式规则加载","/pages/v2.11.X/a7e02e/"],["100.🎨高级特性/160.异步线程池自定义.md","🥗异步线程池自定义","/pages/v2.11.X/7280ea/"],["100.🎨高级特性/170.自定义组件执行器.md","🍿自定义组件执行器","/pages/v2.11.X/46bbed/"],["100.🎨高级特性/180.简单监控.md","🍥简单监控","/pages/v2.11.X/e59f3a/"],["100.🎨高级特性/190.XML的DTD.md","🧉XML的DTD","/pages/v2.11.X/0066ae/"]]},{title:"⛱测试用例以及示例",collapsable:!1,children:[["110.⛱测试用例以及示例/010.测试用例.md","🪁测试用例","/pages/v2.11.X/81cdce/"],["110.⛱测试用例以及示例/020.DEMO案例.md","🪀DEMO案例","/pages/v2.11.X/0a8188/"]]},["120.性能表现.md","🪂性能表现","/pages/v2.11.X/9bf839/"]],"/09.v2.10.X文档/":[["010.LiteFlow简介.md","🍤LiteFlow简介","/pages/v2.10.X/5816c5/"],["020.项目特性.md","🍓项目特性","/pages/v2.10.X/724bc3/"],{title:"🧁环境支持",collapsable:!1,children:[["021.🧁环境支持/010.JDK支持度.md","☕️JDK支持度","/pages/v2.10.X/7cf080/"],["021.🧁环境支持/020.Springboot支持度.md","🌿Springboot支持度","/pages/v2.10.X/891e0f/"],["021.🧁环境支持/030.Spring的支持度.md","🌱Spring的支持度","/pages/v2.10.X/2d12db/"]]},{title:"🍟快速开始(Hello world)",collapsable:!1,children:[["030.🍟快速开始(Hello world)/005.说明.md","🍄说明","/pages/v2.10.X/631fa1/"],{title:"🌿Springboot场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md","🧬依赖","/pages/v2.10.X/df6982/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md","⚙️配置","/pages/v2.10.X/82ef41/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md","🛫执行","/pages/v2.10.X/9f4489/"]]},{title:"🌱Spring场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md","🧬依赖","/pages/v2.10.X/0a4573/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md","⚙️配置","/pages/v2.10.X/495f21/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md","🛫执行","/pages/v2.10.X/0e0fb5/"]]},{title:"🌵其他场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md","🍄说明","/pages/v2.10.X/522432/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md","🧬依赖","/pages/v2.10.X/8760c4/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md","⚙️配置","/pages/v2.10.X/249d17/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md","🛫执行","/pages/v2.10.X/151524/"]]}]},{title:"🍢配置项",collapsable:!1,children:[["040.🍢配置项/010.说明.md","🍄说明","/pages/v2.10.X/b70ec8/"],["040.🍢配置项/020.Springboot下的配置项.md","🌿Springboot下的配置项","/pages/v2.10.X/4594ec/"],["040.🍢配置项/030.Spring下的配置项.md","🌱Spring下的配置项","/pages/v2.10.X/33833a/"],["040.🍢配置项/040.其他场景代码设置配置项.md","🌵其他场景代码设置配置项","/pages/v2.10.X/b5065a/"]]},{title:"🗂规则文件",collapsable:!1,children:[["050.🗂规则文件/010.规则文件格式.md","📔规则文件格式","/pages/v2.10.X/6fa87e/"],["050.🗂规则文件/020.本地规则文件配置.md","📕本地规则文件配置","/pages/v2.10.X/51ddd5/"],["050.🗂规则文件/030.ZK规则文件配置源.md","📗ZK规则文件配置源","/pages/v2.10.X/ffc345/"],["050.🗂规则文件/040.SQL数据库配置源.md","📘SQL数据库配置源","/pages/v2.10.X/236b4f/"],["050.🗂规则文件/050.Nacos配置源.md","📋Nacos配置源","/pages/v2.10.X/09b776/"],["050.🗂规则文件/060.Etcd配置源.md","🗄Etcd配置源","/pages/v2.10.X/4bfac2/"],["050.🗂规则文件/065.Apollo配置源.md","📜Apollo配置源","/pages/v2.10.X/bea809/"],["050.🗂规则文件/070.自定义配置源.md","📙自定义配置源","/pages/v2.10.X/25f2c0/"]]},{title:"🔗常规组件",collapsable:!1,children:[["055.🔗常规组件/010.普通组件.md","📎普通组件","/pages/v2.10.X/8486fb/"],["055.🔗常规组件/020.选择组件.md","✂️选择组件","/pages/v2.10.X/c0f5d7/"],["055.🔗常规组件/030.条件组件.md","📌条件组件","/pages/v2.10.X/cb0b59/"],["055.🔗常规组件/040.次数循环组件.md","🧬次数循环组件","/pages/v2.10.X/5f971f/"],["055.🔗常规组件/050.条件循环组件.md","⛓条件循环组件","/pages/v2.10.X/e6995e/"],["055.🔗常规组件/055.迭代循环组件.md","⌛️迭代循环组件","/pages/v2.10.X/64262b/"],["055.🔗常规组件/060.退出循环组件.md","🧿退出循环组件","/pages/v2.10.X/c078cd/"]]},{title:"🧩EL规则的写法",collapsable:!1,children:[["060.🧩EL规则的写法/010.说明.md","🍄说明","/pages/v2.10.X/16eca9/"],["060.🧩EL规则的写法/020.串行编排.md","🌴串行编排","/pages/v2.10.X/a590ee/"],["060.🧩EL规则的写法/030.并行编排.md","🎋并行编排","/pages/v2.10.X/b3446a/"],["060.🧩EL规则的写法/040.选择编排.md","🌾选择编排","/pages/v2.10.X/d90483/"],["060.🧩EL规则的写法/045.条件编排.md","🌵条件编排","/pages/v2.10.X/e76999/"],["060.🧩EL规则的写法/046.循环编排.md","🌳循环编排","/pages/v2.10.X/fbf715/"],["060.🧩EL规则的写法/047.捕获异常表达式.md","🎃捕获异常表达式","/pages/v2.10.X/f53b51/"],["060.🧩EL规则的写法/048.与或非表达式.md","🍄与或非表达式","/pages/v2.10.X/a8b344/"],["060.🧩EL规则的写法/050.使用子流程.md","🍁使用子流程","/pages/v2.10.X/dc5df7/"],["060.🧩EL规则的写法/060.使用子变量.md","🍂使用子变量","/pages/v2.10.X/71ff49/"],["060.🧩EL规则的写法/070.复杂编排例子.md","💐复杂编排例子","/pages/v2.10.X/5156b3/"],["060.🧩EL规则的写法/080.关于分号.md","🌻关于分号","/pages/v2.10.X/af44a6/"],["060.🧩EL规则的写法/090.关于注释.md","🌰关于注释","/pages/v2.10.X/f3dc09/"],["060.🧩EL规则的写法/100.组件名包装.md","🐚组件名包装","/pages/v2.10.X/2df3d9/"],["060.🧩EL规则的写法/110.验证规则.md","🔆验证规则","/pages/v2.10.X/395fd0/"]]},{title:"🌮数据上下文",collapsable:!1,children:[["070.🌮数据上下文/010.说明.md","🍄说明","/pages/v2.10.X/74b4bf/"],["070.🌮数据上下文/020.数据上下文的定义和使用.md","🌯数据上下文的定义和使用","/pages/v2.10.X/501abf/"],["070.🌮数据上下文/030.用初始化好的上下文传入.md","🪶用初始化好的上下文传入","/pages/v2.10.X/f05ed6/"]]},{title:"🛩执行器",collapsable:!1,children:[["080.🛩执行器/010.说明.md","🍄说明","/pages/v2.10.X/90b2a5/"],["080.🛩执行器/020.执行方法.md","🎡执行方法","/pages/v2.10.X/20072e/"],["080.🛩执行器/030.流程入参.md","🎢流程入参","/pages/v2.10.X/563b67/"],["080.🛩执行器/040.LiteflowResponse对象.md","🎈LiteflowResponse对象","/pages/v2.10.X/9f653d/"]]},{title:"🍋脚本组件",collapsable:!1,children:[["085.🍋脚本组件/010.选择脚本语言.md","🍫选择脚本语言","/pages/v2.10.X/bd70f7/"],["085.🍋脚本组件/020.定义脚本组件.md","🍕定义脚本组件","/pages/v2.10.X/81d53c/"],["085.🍋脚本组件/025.多脚本语言混合共存.md","🍱多脚本语言混合共存","/pages/v2.10.X/acba2c/"],["085.🍋脚本组件/030.文件脚本的定义.md","🌯文件脚本的定义","/pages/v2.10.X/f7acfd/"],["085.🍋脚本组件/040.脚本与Java进行交互.md","🍣脚本与Java进行交互","/pages/v2.10.X/d861c8/"],["085.🍋脚本组件/050.动态刷新脚本.md","🍘动态刷新脚本","/pages/v2.10.X/cbcb14/"]]},{title:"🍇声明式组件",collapsable:!1,children:[["086.🍇声明式组件/010.什么叫声明式组件.md","🥭什么叫声明式组件","/pages/v2.10.X/46f0fa/"],["086.🍇声明式组件/020.类级别式声明.md","🧅类级别式声明","/pages/v2.10.X/18f548/"],["086.🍇声明式组件/030.方法级别式声明.md","🥥方法级别式声明","/pages/v2.10.X/797830/"]]},{title:"🎲用代码动态构造规则",collapsable:!1,children:[["090.🎲用代码动态构造规则/010.说明.md","🍄说明","/pages/v2.10.X/9aa85a/"],["090.🎲用代码动态构造规则/020.如何构造.md","🎯如何构造","/pages/v2.10.X/6bc8fe/"]]},{title:"🎨高级特性",collapsable:!1,children:[["100.🎨高级特性/030.前置和后置组件.md","🍒前置和后置组件","/pages/v2.10.X/9f93be/"],["100.🎨高级特性/031.本地规则文件监听.md","🍌本地规则文件监听","/pages/v2.10.X/f8aa79/"],["100.🎨高级特性/035.替补组件.md","🥠替补组件","/pages/v2.10.X/79289a/"],["100.🎨高级特性/036.组件参数.md","🍉组件参数","/pages/v2.10.X/6e4d15/"],["100.🎨高级特性/040.组件别名.md","🍑组件别名","/pages/v2.10.X/92ef89/"],["100.🎨高级特性/050.组件标签.md","🍍组件标签","/pages/v2.10.X/0f788f/"],["100.🎨高级特性/060.组件事件回调.md","🥝组件事件回调","/pages/v2.10.X/3ee755/"],["100.🎨高级特性/070.隐式子流程.md","🥑隐式子流程","/pages/v2.10.X/80e873/"],["100.🎨高级特性/080.私有投递.md","🍕私有投递","/pages/v2.10.X/fbb938/"],["100.🎨高级特性/090.组件重试.md","🍣组件重试","/pages/v2.10.X/7e9da1/"],["100.🎨高级特性/100.平滑热刷新.md","🍖平滑热刷新","/pages/v2.10.X/204d71/"],["100.🎨高级特性/110.组件切面.md","🍪组件切面","/pages/v2.10.X/2373f5/"],["100.🎨高级特性/120.步骤信息.md","🍡步骤信息","/pages/v2.10.X/e5ed0d/"],["100.🎨高级特性/125.异常.md","🧊异常","/pages/v2.10.X/dc9bfe/"],["100.🎨高级特性/130.打印信息详解.md","🧇打印信息详解","/pages/v2.10.X/4d614c/"],["100.🎨高级特性/140.自定义请求Id.md","🧁自定义请求Id","/pages/v2.10.X/47e8f5/"],["100.🎨高级特性/150.不同格式规则加载.md","🌭不同格式规则加载","/pages/v2.10.X/a7e02e/"],["100.🎨高级特性/160.异步线程池自定义.md","🥗异步线程池自定义","/pages/v2.10.X/7280ea/"],["100.🎨高级特性/170.自定义组件执行器.md","🍿自定义组件执行器","/pages/v2.10.X/46bbed/"],["100.🎨高级特性/180.简单监控.md","🍥简单监控","/pages/v2.10.X/e59f3a/"],["100.🎨高级特性/190.XML的DTD.md","🧉XML的DTD","/pages/v2.10.X/0066ae/"]]},{title:"⛱测试用例以及示例",collapsable:!1,children:[["110.⛱测试用例以及示例/010.测试用例.md","🪁测试用例","/pages/v2.10.X/81cdce/"],["110.⛱测试用例以及示例/020.DEMO案例.md","🪀DEMO案例","/pages/v2.10.X/0a8188/"]]},["120.性能表现.md","🪂性能表现","/pages/v2.10.X/9bf839/"]],"/10.v2.9.X文档/":[["010.LiteFlow简介.md","🍤LiteFlow简介","/pages/v2.9.X/5816c5/"],["020.项目特性.md","🍓项目特性","/pages/v2.9.X/724bc3/"],{title:"🍟快速开始(Hello world)",collapsable:!1,children:[["030.🍟快速开始(Hello world)/005.说明.md","🍄说明","/pages/v2.9.X/631fa1/"],{title:"🌿Springboot场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md","🧬依赖","/pages/v2.9.X/df6982/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md","⚙️配置","/pages/v2.9.X/82ef41/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md","🛫执行","/pages/v2.9.X/9f4489/"]]},{title:"🌱Spring场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md","🧬依赖","/pages/v2.9.X/0a4573/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md","⚙️配置","/pages/v2.9.X/495f21/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md","🛫执行","/pages/v2.9.X/0e0fb5/"]]},{title:"🌵其他场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md","🍄说明","/pages/v2.9.X/522432/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md","🧬依赖","/pages/v2.9.X/8760c4/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md","⚙️配置","/pages/v2.9.X/249d17/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md","🛫执行","/pages/v2.9.X/151524/"]]}]},{title:"🍢配置项",collapsable:!1,children:[["040.🍢配置项/010.说明.md","🍄说明","/pages/v2.9.X/b70ec8/"],["040.🍢配置项/020.Springboot下的配置项.md","🌿Springboot下的配置项","/pages/v2.9.X/4594ec/"],["040.🍢配置项/030.Spring下的配置项.md","🌱Spring下的配置项","/pages/v2.9.X/33833a/"],["040.🍢配置项/040.其他场景代码设置配置项.md","🌵其他场景代码设置配置项","/pages/v2.9.X/b5065a/"]]},{title:"🗂规则文件",collapsable:!1,children:[["050.🗂规则文件/010.规则文件格式.md","📔规则文件格式","/pages/v2.9.X/6fa87e/"],["050.🗂规则文件/020.本地规则文件配置.md","📕本地规则文件配置","/pages/v2.9.X/51ddd5/"],["050.🗂规则文件/030.ZK规则文件配置源.md","📗ZK规则文件配置源","/pages/v2.9.X/ffc345/"],["050.🗂规则文件/040.SQL数据库配置源.md","📘SQL数据库配置源","/pages/v2.9.X/236b4f/"],["050.🗂规则文件/050.Nacos配置源.md","📋Nacos配置源","/pages/v2.9.X/09b776/"],["050.🗂规则文件/060.Etcd配置源.md","🗄Etcd配置源","/pages/v2.9.X/4bfac2/"],["050.🗂规则文件/065.Apollo配置源.md","📜Apollo配置源","/pages/v2.9.X/bea809/"],["050.🗂规则文件/070.自定义配置源.md","📙自定义配置源","/pages/v2.9.X/25f2c0/"]]},{title:"🔗常规组件",collapsable:!1,children:[["055.🔗常规组件/010.普通组件.md","📎普通组件","/pages/v2.9.X/8486fb/"],["055.🔗常规组件/020.选择组件.md","✂️选择组件","/pages/v2.9.X/c0f5d7/"],["055.🔗常规组件/030.条件组件.md","📌条件组件","/pages/v2.9.X/cb0b59/"],["055.🔗常规组件/040.次数循环组件.md","🧬次数循环组件","/pages/v2.9.X/5f971f/"],["055.🔗常规组件/050.条件循环组件.md","⛓条件循环组件","/pages/v2.9.X/e6995e/"],["055.🔗常规组件/055.迭代循环组件.md","⌛️迭代循环组件","/pages/v2.9.X/64262b/"],["055.🔗常规组件/060.退出循环组件.md","🧿退出循环组件","/pages/v2.9.X/c078cd/"]]},{title:"🧩EL规则的写法",collapsable:!1,children:[["060.🧩EL规则的写法/010.说明.md","🍄说明","/pages/v2.9.X/16eca9/"],["060.🧩EL规则的写法/020.串行编排.md","🌴串行编排","/pages/v2.9.X/a590ee/"],["060.🧩EL规则的写法/030.并行编排.md","🎋并行编排","/pages/v2.9.X/b3446a/"],["060.🧩EL规则的写法/040.选择编排.md","🌾选择编排","/pages/v2.9.X/d90483/"],["060.🧩EL规则的写法/045.条件编排.md","🌵条件编排","/pages/v2.9.X/e76999/"],["060.🧩EL规则的写法/046.循环编排.md","🌳循环编排","/pages/v2.9.X/fbf715/"],["060.🧩EL规则的写法/050.使用子流程.md","🍁使用子流程","/pages/v2.9.X/dc5df7/"],["060.🧩EL规则的写法/060.使用子变量.md","🍂使用子变量","/pages/v2.9.X/71ff49/"],["060.🧩EL规则的写法/070.复杂编排例子.md","💐复杂编排例子","/pages/v2.9.X/5156b3/"],["060.🧩EL规则的写法/080.关于分号.md","🌻关于分号","/pages/v2.9.X/af44a6/"],["060.🧩EL规则的写法/090.关于注释.md","🌰关于注释","/pages/v2.9.X/f3dc09/"],["060.🧩EL规则的写法/100.组件名包装.md","🐚组件名包装","/pages/v2.9.X/2df3d9/"],["060.🧩EL规则的写法/110.验证规则.md","🔆验证规则","/pages/v2.9.X/395fd0/"]]},{title:"🌮数据上下文",collapsable:!1,children:[["070.🌮数据上下文/010.说明.md","🍄说明","/pages/v2.9.X/74b4bf/"],["070.🌮数据上下文/020.数据上下文的定义和使用.md","🌯数据上下文的定义和使用","/pages/v2.9.X/501abf/"],["070.🌮数据上下文/030.用初始化好的上下文传入.md","🪶用初始化好的上下文传入","/pages/v2.9.X/f05ed6/"]]},{title:"🛩执行器",collapsable:!1,children:[["080.🛩执行器/010.说明.md","🍄说明","/pages/v2.9.X/90b2a5/"],["080.🛩执行器/020.执行方法.md","🎡执行方法","/pages/v2.9.X/20072e/"],["080.🛩执行器/030.流程入参.md","🎢流程入参","/pages/v2.9.X/563b67/"],["080.🛩执行器/040.LiteflowResponse对象.md","🎈LiteflowResponse对象","/pages/v2.9.X/9f653d/"]]},{title:"🍋脚本组件",collapsable:!1,children:[["085.🍋脚本组件/010.选择脚本语言.md","🍫选择脚本语言","/pages/v2.9.X/bd70f7/"],["085.🍋脚本组件/020.定义脚本组件.md","🍕定义脚本组件","/pages/v2.9.X/81d53c/"],["085.🍋脚本组件/030.文件脚本的定义.md","🌯文件脚本的定义","/pages/v2.9.X/f7acfd/"],["085.🍋脚本组件/040.与Java进行交互.md","🍣与Java进行交互","/pages/v2.9.X/d861c8/"],["085.🍋脚本组件/050.动态刷新脚本.md","🍘动态刷新脚本","/pages/v2.9.X/cbcb14/"]]},{title:"🍇声明式组件",collapsable:!1,children:[["086.🍇声明式组件/010.什么叫声明式组件.md","🥭什么叫声明式组件","/pages/v2.9.X/46f0fa/"],["086.🍇声明式组件/020.类级别式声明.md","🧅类级别式声明","/pages/v2.9.X/18f548/"],["086.🍇声明式组件/030.方法级别式声明.md","🥥方法级别式声明","/pages/v2.9.X/797830/"]]},{title:"🎲用代码动态构造规则",collapsable:!1,children:[["090.🎲用代码动态构造规则/010.说明.md","🍄说明","/pages/v2.9.X/9aa85a/"],["090.🎲用代码动态构造规则/020.如何构造.md","🎯如何构造","/pages/v2.9.X/6bc8fe/"]]},{title:"🎨高级特性",collapsable:!1,children:[["100.🎨高级特性/030.前置和后置组件.md","🍒前置和后置组件","/pages/v2.9.X/9f93be/"],["100.🎨高级特性/035.替补组件.md","🥠替补组件","/pages/v2.9.X/79289a/"],["100.🎨高级特性/036.组件参数.md","🍉组件参数","/pages/v2.9.X/6e4d15/"],["100.🎨高级特性/040.组件别名.md","🍑组件别名","/pages/v2.9.X/92ef89/"],["100.🎨高级特性/050.组件标签.md","🍍组件标签","/pages/v2.9.X/0f788f/"],["100.🎨高级特性/060.组件事件回调.md","🥝组件事件回调","/pages/v2.9.X/3ee755/"],["100.🎨高级特性/070.隐式子流程.md","🥑隐式子流程","/pages/v2.9.X/80e873/"],["100.🎨高级特性/080.私有投递.md","🍕私有投递","/pages/v2.9.X/fbb938/"],["100.🎨高级特性/090.组件重试.md","🍣组件重试","/pages/v2.9.X/7e9da1/"],["100.🎨高级特性/100.平滑热刷新.md","🍖平滑热刷新","/pages/v2.9.X/204d71/"],["100.🎨高级特性/110.组件切面.md","🍪组件切面","/pages/v2.9.X/2373f5/"],["100.🎨高级特性/120.步骤信息.md","🍡步骤信息","/pages/v2.9.X/e5ed0d/"],["100.🎨高级特性/125.异常.md","🧊异常","/pages/v2.9.X/dc9bfe/"],["100.🎨高级特性/130.打印信息详解.md","🧇打印信息详解","/pages/v2.9.X/4d614c/"],["100.🎨高级特性/140.自定义请求Id.md","🧁自定义请求Id","/pages/v2.9.X/47e8f5/"],["100.🎨高级特性/150.不同格式规则加载.md","🌭不同格式规则加载","/pages/v2.9.X/a7e02e/"],["100.🎨高级特性/160.异步线程池自定义.md","🥗异步线程池自定义","/pages/v2.9.X/7280ea/"],["100.🎨高级特性/170.自定义组件执行器.md","🍿自定义组件执行器","/pages/v2.9.X/46bbed/"],["100.🎨高级特性/180.简单监控.md","🍥简单监控","/pages/v2.9.X/e59f3a/"],["100.🎨高级特性/190.XML的DTD.md","🧉XML的DTD","/pages/v2.9.X/0066ae/"]]},{title:"⛱测试用例以及示例",collapsable:!1,children:[["110.⛱测试用例以及示例/010.测试用例.md","🪁测试用例","/pages/v2.9.X/81cdce/"],["110.⛱测试用例以及示例/020.DEMO案例.md","🪀DEMO案例","/pages/v2.9.X/0a8188/"]]},["120.性能表现.md","🪂性能表现","/pages/v2.9.X/9bf839/"]],"/15.v2.8.X文档/":[["010.LiteFlow简介.md","🍤LiteFlow简介","/pages/v2.8.X/5816c5/"],["020.项目特性.md","🍓项目特性","/pages/v2.8.X/724bc3/"],{title:"🍟快速开始(Hello world)",collapsable:!1,children:[["030.🍟快速开始(Hello world)/005.说明.md","🍄说明","/pages/v2.8.X/631fa1/"],{title:"🌿Springboot场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/010.依赖.md","🧬依赖","/pages/v2.8.X/df6982/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/020.配置.md","⚙️配置","/pages/v2.8.X/82ef41/"],["030.🍟快速开始(Hello world)/010.🌿Springboot场景安装运行/030.执行.md","🛫执行","/pages/v2.8.X/9f4489/"]]},{title:"🌱Spring场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/010.依赖.md","🧬依赖","/pages/v2.8.X/0a4573/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/020.配置.md","⚙️配置","/pages/v2.8.X/495f21/"],["030.🍟快速开始(Hello world)/020.🌱Spring场景安装运行/030.执行.md","🛫执行","/pages/v2.8.X/0e0fb5/"]]},{title:"🌵其他场景安装运行",collapsable:!1,children:[["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/010.说明.md","🍄说明","/pages/v2.8.X/522432/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/020.依赖.md","🧬依赖","/pages/v2.8.X/8760c4/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/030.配置.md","⚙️配置","/pages/v2.8.X/249d17/"],["030.🍟快速开始(Hello world)/030.🌵其他场景安装运行/040.执行.md","🛫执行","/pages/v2.8.X/151524/"]]}]},{title:"🍢配置项",collapsable:!1,children:[["040.🍢配置项/010.说明.md","🍄说明","/pages/v2.8.X/b70ec8/"],["040.🍢配置项/020.Springboot下的配置项.md","🌿Springboot下的配置项","/pages/v2.8.X/4594ec/"],["040.🍢配置项/030.Spring下的配置项.md","🌱Spring下的配置项","/pages/v2.8.X/33833a/"],["040.🍢配置项/040.其他场景代码设置配置项.md","🌵其他场景代码设置配置项","/pages/v2.8.X/b5065a/"]]},{title:"🗂规则文件",collapsable:!1,children:[["050.🗂规则文件/010.规则文件格式.md","📔规则文件格式","/pages/v2.8.X/6fa87e/"],["050.🗂规则文件/020.本地规则文件配置.md","📕本地规则文件配置","/pages/v2.8.X/51ddd5/"],["050.🗂规则文件/030.ZK规则文件配置.md","📗ZK规则文件配置","/pages/v2.8.X/ffc345/"],["050.🗂规则文件/040.自定义配置源.md","📙自定义配置源","/pages/v2.8.X/25f2c0/"]]},{title:"🔗常规组件",collapsable:!1,children:[["055.🔗常规组件/010.普通组件.md","📎普通组件","/pages/v2.8.X/8486fb/"],["055.🔗常规组件/020.选择组件.md","✂️选择组件","/pages/v2.8.X/c0f5d7/"],["055.🔗常规组件/030.条件组件.md","📌条件组件","/pages/v2.8.X/cb0b59/"]]},{title:"🧩EL规则的写法",collapsable:!1,children:[["060.🧩EL规则的写法/010.说明.md","🍄说明","/pages/v2.8.X/16eca9/"],["060.🧩EL规则的写法/020.串行编排.md","🌴串行编排","/pages/v2.8.X/a590ee/"],["060.🧩EL规则的写法/030.并行编排.md","🎋并行编排","/pages/v2.8.X/b3446a/"],["060.🧩EL规则的写法/040.选择编排.md","🌾选择编排","/pages/v2.8.X/d90483/"],["060.🧩EL规则的写法/045.条件编排.md","🌵条件编排","/pages/v2.8.X/e76999/"],["060.🧩EL规则的写法/050.使用子流程.md","🍁使用子流程","/pages/v2.8.X/dc5df7/"],["060.🧩EL规则的写法/060.使用子变量.md","🍂使用子变量","/pages/v2.8.X/71ff49/"],["060.🧩EL规则的写法/070.复杂编排例子.md","💐复杂编排例子","/pages/v2.8.X/5156b3/"],["060.🧩EL规则的写法/080.关于分号.md","🌻关于分号","/pages/v2.8.X/af44a6/"],["060.🧩EL规则的写法/090.关于注释.md","🌰关于注释","/pages/v2.8.X/f3dc09/"],["060.🧩EL规则的写法/100.组件名包装.md","🐚组件名包装","/pages/v2.8.X/2df3d9/"]]},{title:"🌮数据上下文",collapsable:!1,children:[["070.🌮数据上下文/010.说明.md","🍄说明","/pages/v2.8.X/74b4bf/"],["070.🌮数据上下文/020.数据上下文的定义和使用.md","🌯数据上下文的定义和使用","/pages/v2.8.X/501abf/"],["070.🌮数据上下文/030.用初始化好的上下文传入.md","🪶用初始化好的上下文传入","/pages/v2.8.X/f05ed6/"]]},{title:"🛩执行器",collapsable:!1,children:[["080.🛩执行器/010.说明.md","🍄说明","/pages/v2.8.X/90b2a5/"],["080.🛩执行器/020.执行方法.md","🎡执行方法","/pages/v2.8.X/20072e/"],["080.🛩执行器/030.流程入参.md","🎢流程入参","/pages/v2.8.X/563b67/"],["080.🛩执行器/040.LiteflowResponse对象.md","🎈LiteflowResponse对象","/pages/v2.8.X/9f653d/"]]},{title:"🎲用代码动态构造规则",collapsable:!1,children:[["090.🎲用代码动态构造规则/010.说明.md","🍄说明","/pages/v2.8.X/9aa85a/"],["090.🎲用代码动态构造规则/020.如何构造.md","🎯如何构造","/pages/v2.8.X/6bc8fe/"]]},{title:"🎨高级特性",collapsable:!1,children:[["100.🎨高级特性/010.脚本组件.md","🍋脚本组件","/pages/v2.8.X/40b16f/"],["100.🎨高级特性/020.声明式组件.md","🍇声明式组件","/pages/v2.8.X/f33919/"],["100.🎨高级特性/030.前置和后置组件.md","🍒前置和后置组件","/pages/v2.8.X/9f93be/"],["100.🎨高级特性/035.替补组件.md","🥠替补组件","/pages/v2.8.X/79289a/"],["100.🎨高级特性/040.组件别名.md","🍑组件别名","/pages/v2.8.X/92ef89/"],["100.🎨高级特性/050.组件标签.md","🍍组件标签","/pages/v2.8.X/0f788f/"],["100.🎨高级特性/060.组件事件回调.md","🥝组件事件回调","/pages/v2.8.X/3ee755/"],["100.🎨高级特性/070.隐式子流程.md","🥑隐式子流程","/pages/v2.8.X/80e873/"],["100.🎨高级特性/080.私有投递.md","🍕私有投递","/pages/v2.8.X/fbb938/"],["100.🎨高级特性/090.组件重试.md","🍣组件重试","/pages/v2.8.X/7e9da1/"],["100.🎨高级特性/100.平滑热刷新.md","🍖平滑热刷新","/pages/v2.8.X/204d71/"],["100.🎨高级特性/110.组件切面.md","🍪组件切面","/pages/v2.8.X/2373f5/"],["100.🎨高级特性/120.步骤信息.md","🍡步骤信息","/pages/v2.8.X/e5ed0d/"],["100.🎨高级特性/125.异常.md","🧊异常","/pages/v2.8.X/dc9bfe/"],["100.🎨高级特性/130.打印信息详解.md","🧇打印信息详解","/pages/v2.8.X/4d614c/"],["100.🎨高级特性/140.自定义请求Id.md","🧁自定义请求Id","/pages/v2.8.X/47e8f5/"],["100.🎨高级特性/150.不同格式规则加载.md","🌭不同格式规则加载","/pages/v2.8.X/a7e02e/"],["100.🎨高级特性/160.异步线程池自定义.md","🥗异步线程池自定义","/pages/v2.8.X/7280ea/"],["100.🎨高级特性/170.自定义组件执行器.md","🍿自定义组件执行器","/pages/v2.8.X/46bbed/"],["100.🎨高级特性/180.简单监控.md","🍥简单监控","/pages/v2.8.X/e59f3a/"]]},{title:"⛱测试用例以及示例",collapsable:!1,children:[["110.⛱测试用例以及示例/010.测试用例.md","🪁测试用例","/pages/v2.8.X/81cdce/"],["110.⛱测试用例以及示例/020.DEMO案例.md","🪀DEMO案例","/pages/v2.8.X/0a8188/"]]},["120.性能表现.md","🪂性能表现","/pages/v2.8.X/9bf839/"]],"/20.v2.7.X文档/":[["010.LiteFlow简介.md","LiteFlow简介","/pages/v2.7.X/967466/"],["020.项目特性.md","项目特性","/pages/v2.7.X/e0508d/"],{title:"快速开始(Hello world)",collapsable:!1,children:[{title:"Springboot场景安装运行",collapsable:!1,children:[["030.快速开始(Hello world)/010.Springboot场景安装运行/010.依赖.md","依赖","/pages/v2.7.X/fe8369/"],["030.快速开始(Hello world)/010.Springboot场景安装运行/020.配置.md","配置","/pages/v2.7.X/36c961/"],["030.快速开始(Hello world)/010.Springboot场景安装运行/030.执行.md","执行","/pages/v2.7.X/ad3883/"]]},{title:"Spring场景安装运行",collapsable:!1,children:[["030.快速开始(Hello world)/020.Spring场景安装运行/010.依赖.md","依赖","/pages/v2.7.X/314fee/"],["030.快速开始(Hello world)/020.Spring场景安装运行/020.配置.md","配置","/pages/v2.7.X/ecc62a/"],["030.快速开始(Hello world)/020.Spring场景安装运行/030.执行.md","执行","/pages/v2.7.X/646cb4/"]]},{title:"其他场景安装运行",collapsable:!1,children:[["030.快速开始(Hello world)/030.其他场景安装运行/010.说明.md","说明","/pages/v2.7.X/c5d947/"],["030.快速开始(Hello world)/030.其他场景安装运行/020.依赖.md","依赖","/pages/v2.7.X/83cb46/"],["030.快速开始(Hello world)/030.其他场景安装运行/030.配置.md","配置","/pages/v2.7.X/2c4a45/"],["030.快速开始(Hello world)/030.其他场景安装运行/040.执行.md","执行","/pages/v2.7.X/ac3dc2/"]]}]},{title:"配置项",collapsable:!1,children:[["035.配置项/010.说明.md","说明","/pages/v2.7.X/82459b/"],["035.配置项/020.Springboot下的配置项.md","Springboot下的配置项","/pages/v2.7.X/3bc025/"],["035.配置项/030.Spring下的配置项.md","Spring下的配置项","/pages/v2.7.X/dc0673/"],["035.配置项/040.其他场景代码设置配置项.md","其他场景代码设置配置项","/pages/v2.7.X/e9ec4f/"]]},{title:"规则文件",collapsable:!1,children:[["040.规则文件/010.规则文件格式.md","规则文件格式","/pages/v2.7.X/7e3166/"],["040.规则文件/020.本地规则文件配置.md","本地规则文件配置","/pages/v2.7.X/a6fd84/"],["040.规则文件/030.ZK规则文件配置.md","ZK规则文件配置","/pages/v2.7.X/b527e6/"],["040.规则文件/040.自定义配置源.md","自定义配置源","/pages/v2.7.X/3dd60b/"]]},{title:"用代码动态构造规则",collapsable:!1,children:[["050.用代码动态构造规则/010.说明.md","说明","/pages/v2.7.X/182a88/"],["050.用代码动态构造规则/020.如何构造.md","如何构造","/pages/v2.7.X/e0eebf/"]]},{title:"使用详细指南",collapsable:!1,children:[["060.使用详细指南/010.开启和关闭.md","开启和关闭","/pages/v2.7.X/202997/"],["060.使用详细指南/015.规则文件路径.md","规则文件路径","/pages/v2.7.X/9c7367/"],["060.使用详细指南/020.同步异步编排.md","同步异步编排","/pages/v2.7.X/e8e603/"],["060.使用详细指南/030.执行器.md","执行器","/pages/v2.7.X/375299/"],["060.使用详细指南/040.数据上下文.md","数据上下文","/pages/v2.7.X/16f927/"],["060.使用详细指南/045.Response对象.md","Response对象","/pages/v2.7.X/db0fab/"],["060.使用详细指南/050.普通组件.md","普通组件","/pages/v2.7.X/aab3f7/"],["060.使用详细指南/060.条件组件.md","条件组件","/pages/v2.7.X/c284f7/"],["060.使用详细指南/070.脚本组件.md","脚本组件","/pages/v2.7.X/504b45/"],["060.使用详细指南/080.声明式组件.md","声明式组件","/pages/v2.7.X/9a30d2/"],["060.使用详细指南/090.前置后置组件.md","前置后置组件","/pages/v2.7.X/bedc2a/"],["060.使用详细指南/095.组件别名.md","组件别名","/pages/v2.7.X/4c74f0/"],["060.使用详细指南/100.组件标签.md","组件标签","/pages/v2.7.X/c7d5f3/"],["060.使用详细指南/105.组件事件回调.md","组件事件回调","/pages/v2.7.X/d22f8f/"],["060.使用详细指南/110.子流程.md","子流程","/pages/v2.7.X/5821d4/"],["060.使用详细指南/120.隐式子流程.md","隐式子流程","/pages/v2.7.X/d36e61/"],["060.使用详细指南/130.私有投递.md","私有投递","/pages/v2.7.X/7aa497/"],["060.使用详细指南/140.组件重试.md","组件重试","/pages/v2.7.X/3f6ca1/"],["060.使用详细指南/150.平滑热刷新.md","平滑热刷新","/pages/v2.7.X/19c886/"],["060.使用详细指南/160.组件切面.md","组件切面","/pages/v2.7.X/feb764/"],["060.使用详细指南/170.步骤信息.md","步骤信息","/pages/v2.7.X/a5728b/"],["060.使用详细指南/180.打印信息详解.md","打印信息详解","/pages/v2.7.X/85ae47/"],["060.使用详细指南/190.不同格式规则加载.md","不同格式规则加载","/pages/v2.7.X/decf9a/"],["060.使用详细指南/200.When异步线程池.md","When异步线程池","/pages/v2.7.X/2b3b21/"],["060.使用详细指南/210.自定义组件执行器.md","自定义组件执行器","/pages/v2.7.X/1a7d84/"],["060.使用详细指南/220.简单监控.md","简单监控","/pages/v2.7.X/9ec64b/"]]},{title:"示例工程",collapsable:!1,children:[["070.示例工程/010.测试用例.md","测试用例","/pages/v2.7.X/beadb0/"],["070.示例工程/020.DEMO案例.md","DEMO案例","/pages/v2.7.X/73272c/"]]},["080.性能表现.md","性能表现","/pages/v2.7.X/cdfa53/"]],"/30.v2.6.X文档/":[["010.LiteFlow介绍.md","LiteFlow介绍","/pages/v2.6.X/dfd970/"],["020.项目特性.md","项目特性","/pages/v2.6.X/8c0b63/"],{title:"安装和集成",collapsable:!1,children:[{title:"Springboot场景安装运行",collapsable:!1,children:[["030.安装和集成/010.Springboot场景安装运行/010.依赖.md","依赖","/pages/v2.6.X/2d57d5/"],["030.安装和集成/010.Springboot场景安装运行/020.配置.md","配置","/pages/v2.6.X/f50478/"],["030.安装和集成/010.Springboot场景安装运行/030.执行.md","执行","/pages/v2.6.X/73a9e7/"]]},{title:"Spring场景安装运行",collapsable:!1,children:[["030.安装和集成/020.Spring场景安装运行/010.依赖.md","依赖","/pages/v2.6.X/165d6f/"],["030.安装和集成/020.Spring场景安装运行/020.配置.md","配置","/pages/v2.6.X/4e34ba/"],["030.安装和集成/020.Spring场景安装运行/030.执行.md","执行","/pages/v2.6.X/47ef69/"]]},{title:"其他场景安装运行",collapsable:!1,children:[["030.安装和集成/030.其他场景安装运行/010.说明.md","说明","/pages/v2.6.X/d53ad2/"],["030.安装和集成/030.其他场景安装运行/020.依赖.md","依赖","/pages/v2.6.X/9191fb/"],["030.安装和集成/030.其他场景安装运行/030.配置.md","配置","/pages/v2.6.X/80afec/"],["030.安装和集成/030.其他场景安装运行/040.执行.md","执行","/pages/v2.6.X/81d136/"]]}]},{title:"规则文件",collapsable:!1,children:[["040.规则文件/010.规则文件格式.md","规则文件格式","/pages/v2.6.X/c10d7e/"],["040.规则文件/020.本地规则文件配置.md","本地规则文件配置","/pages/v2.6.X/23d0c3/"],["040.规则文件/030.ZK规则文件配置.md","ZK规则文件配置","/pages/v2.6.X/2adc0f/"],["040.规则文件/040.自定义配置源.md","自定义配置源","/pages/v2.6.X/240fe8/"]]},{title:"用代码动态构造规则",collapsable:!1,children:[["050.用代码动态构造规则/010.说明.md","说明","/pages/v2.6.X/b2143d/"],["050.用代码动态构造规则/020.如何构造.md","如何构造","/pages/v2.6.X/933342/"]]},{title:"使用详细指南",collapsable:!1,children:[["060.使用详细指南/010.开启和关闭.md","开启和关闭","/pages/v2.6.X/1f47ae/"],["060.使用详细指南/020.同步异步编排.md","同步异步编排","/pages/v2.6.X/25d803/"],["060.使用详细指南/030.执行器.md","执行器","/pages/v2.6.X/07dc9a/"],["060.使用详细指南/040.数据槽.md","数据槽","/pages/v2.6.X/eb758e/"],["060.使用详细指南/050.普通组件.md","普通组件","/pages/v2.6.X/43f09b/"],["060.使用详细指南/060.条件组件.md","条件组件","/pages/v2.6.X/381ed2/"],["060.使用详细指南/070.脚本组件.md","脚本组件","/pages/v2.6.X/8f6247/"],["060.使用详细指南/080.声明式组件.md","声明式组件","/pages/v2.6.X/6f8b42/"],["060.使用详细指南/090.前置后置组件.md","前置后置组件","/pages/v2.6.X/1e7143/"],["060.使用详细指南/100.组件标签.md","组件标签","/pages/v2.6.X/87e386/"],["060.使用详细指南/110.子流程.md","子流程","/pages/v2.6.X/2be4e2/"],["060.使用详细指南/120.隐式子流程.md","隐式子流程","/pages/v2.6.X/2777ec/"],["060.使用详细指南/130.私有投递.md","私有投递","/pages/v2.6.X/5466e5/"],["060.使用详细指南/140.组件重试.md","组件重试","/pages/v2.6.X/e441ee/"],["060.使用详细指南/150.平滑热刷新.md","平滑热刷新","/pages/v2.6.X/d0e86d/"],["060.使用详细指南/160.组件切面.md","组件切面","/pages/v2.6.X/21d500/"],["060.使用详细指南/170.异常处理机制.md","异常处理机制","/pages/v2.6.X/d61011/"],["060.使用详细指南/180.步骤打印.md","步骤打印","/pages/v2.6.X/ce6352/"],["060.使用详细指南/190.不同格式规则加载.md","不同格式规则加载","/pages/v2.6.X/f67d92/"],["060.使用详细指南/200.When异步线程池.md","When异步线程池","/pages/v2.6.X/8c4aba/"],["060.使用详细指南/210.自定义组件执行器.md","自定义组件执行器","/pages/v2.6.X/48258b/"],["060.使用详细指南/220.简单监控.md","简单监控","/pages/v2.6.X/4b18be/"]]},{title:"示例工程",collapsable:!1,children:[["070.示例工程/010.测试用例.md","测试用例","/pages/v2.6.X/45096f/"],["070.示例工程/020.DEMO案例.md","DEMO案例","/pages/v2.6.X/3ae932/"]]},["080.性能表现.md","性能表现","/pages/v2.6.X/dfd1af/"]],"/whats new/":[["080.whats new in v2.12.4.md","What's New In LiteFlow v2.12.4?","/pages/8ff021/"],["081.whats new in v2.12.3.md","What's New In LiteFlow v2.12.3?","/pages/8ff020/"],["082.whats new in v2.12.2.md","What's New In LiteFlow v2.12.2?","/pages/8ff019/"],["083.whats new in v2.12.1.md","What's New In LiteFlow v2.12.1?","/pages/8ff018/"],["084.whats new in v2.12.0.md","What's New In LiteFlow v2.12.0?","/pages/8ff017/"],["085.whats new in v2.11.4.md","What's New In LiteFlow v2.11.4?","/pages/8ff016/"],["086.whats new in v2.11.3.md","What's New In LiteFlow v2.11.3?","/pages/8ff015/"],["087.whats new in v2.11.2.md","What's New In LiteFlow v2.11.2?","/pages/8ff014/"],["088.whats new in v2.11.0.md","What's New In LiteFlow v2.11.0?","/pages/8ff013/"],["089.whats new in v2.10.6.md","What's New In LiteFlow v2.10.6?","/pages/8ff012/"],["090.whats new in v2.10.5.md","What's New In LiteFlow v2.10.5?","/pages/8ff011/"],["091.whats new in v2.10.2.md","What's New In LiteFlow v2.10.2?","/pages/8ff010/"],["092.whats new in v2.10.1.md","What's New In LiteFlow v2.10.1?","/pages/8ff009/"],["093.whats new in v2.10.0.md","What's New In LiteFlow v2.10.0?","/pages/8ff008/"],["094.whats new in v2.9.7.md","What's New In LiteFlow v2.9.7?","/pages/8ff007/"],["095.whats new in v2.9.6.md","What's New In LiteFlow v2.9.6?","/pages/8ff006/"],["096.whats new in v2.9.5.md","What's New In LiteFlow v2.9.5?","/pages/8ff005/"],["097.whats new in v2.9.4.md","What's New In LiteFlow v2.9.4?","/pages/8ff004/"],["098.whats new in v2.9.3.md","What's New In LiteFlow v2.9.3?","/pages/8ff003/"],["099.whats new in v2.9.1.md","What's New In LiteFlow v2.9.1?","/pages/8ff002/"],["100.whats new in v2.9.0.md","What's New In LiteFlow v2.9.0?","/pages/8ff001/"]],"/专题解释/":[["01.如何理解上下文这个概念？.md","如何理解上下文这个概念？","/pages/e1e61f/"],["02.Slot是一个什么样的概念，在框架中起到什么样的作用？.md","Slot是一个什么样的概念，在框架中起到什么样的作用？","/pages/ad60b4/"]],"/支持/":[["01.支持.md","支持","/pages/fb599d/"],["02.赞助者列表.md","赞助者列表","/pages/b52ac5/"]]},updateBar:{showToArticle:!1},titleBadge:!1,category:!1,tag:!1,author:{name:"铂赛东",href:"https://gitee.com/bryan31"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:weenyc31@163.com"},{iconClass:"icon-gitee",title:"Gitee",link:"https://gitee.com/dromara/liteFlow"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dromara/liteflow"}]},footer:{createYear:2020,copyrightInfo:'铂赛东 | MIT License <br> <a href="https://beian.miit.gov.cn/">沪ICP备18012955号-2</a>'},htmlModules:{sidebarT:'<div style="width:230px;margin:0 auto;display:flex;flex-direction: column;"> \n                <a name="adv" class="none" href="https://xiaonuo.vip" target="_blank">\n      <img class="no-zoom" style="width:100%;" src="/img/donate/snowy-banner.jpg">\n    </a><a name="adv" class="none" href="http://www.yunchengxc.com/" target="_blank">\n      <img class="no-zoom" style="width:100%;" src="/img/donate/yuncheng-banner.png">\n    </a><a name="adv" class="none" href="https://ccbpm.cn/?frm=liteFlow" target="_blank">\n      <img class="no-zoom" style="width:100%;" src="/img/donate/chicheng-banner.png">\n    </a><a name="adv" class="none" href="https://www.learun.cn?fuid=03" target="_blank">\n        <img class="no-zoom" style="width:100%;" src="/img/donate/liruan-banner.jpg">\n    </a><a name="adv" class="none" href="https://www.misboot.com/?from=LiteFlow" target="_blank">\n        <img class="no-zoom" style="width:100%;" src="/img/donate/misboot-banner.png">\n    </a><a name="adv" class="none" href="https://www.jnpfsoft.com/index.html?from=liteflow" target="_blank">\n        <img class="no-zoom" style="width:100%;" src="/img/donate/yinmai-banner.png">\n    </a><a name="adv" class="none" href="https://www.mingdao.com?s=utm_49=utm_source=liteflow&utm_medium=banner&utm_campaign=%E5%93%81%E7%89%8C%E6%8E%A8%E5%B9%BF&utm_content=IT%E8%B5%8B%E8%83%BD%E4%B8%9A%E5%8A%A1" target="_blank">\n        <img class="no-zoom" style="width:100%;" src="/img/donate/mdy-banner.png">\n    </a><a name="adv" class="none" href="https://www.suconnect.com" target="_blank">\n        <img class="no-zoom" style="width:100%;" src="/img/donate/suzhong-banner-1.png">\n    </a>\n                <div style="order: 9999;">\n                  <br/> \n                  <span style=\'color: gray;font-size: smaller;\'>广告采用随机轮播方式显示</span>\n                  <span style=\'color: #E01E5A;font-size: smaller;font-weight: bolder;float: right\'>❤️<a href=\'/pages/fb599d/\'>成为赞助商</a></span>\n                  <br/>\n                </div>\n                <div style="order: 100000;background-color:var(--borderColor);width:100%;height:1px;margin: 30px 0px 0px 0px;position:relative;">\n                  <button style=\'border-radius: 100%;padding: 0;text-align: center;border: none;background-color: #ff3861;cursor: pointer;position: absolute;left: calc(50% - 15px);top: -15px;height: 30px;width: 30px;color: #fff;\' onclick=\'document.getElementById("sidebar-slot-top").style.display="none"\'>收</button>\n                </div>\n              </div>\n              ',pageT:'\n  <div class="wwads-cn wwads-horizontal page-wwads" data-id="129"></div>\n  <div class="pin-adv">\n    <a href="https://t.zsxq.com/16imSPf5C"><img style="width:90.5%;border-radius: 3px;" src="/img/donate/lfClub-banner.png"></a>\n  </div>\n  <div class="pin-adv">\n    <a href="https://fastbee.cn/"><img style="width:45%;border-radius: 3px;" src="/img/donate/fb-banner.png"></a>\n    <a href="https://www.suconnect.com"><img style="width:45%;border-radius: 3px;" src="/img/donate/suzhong-banner-2.png"></a>\n  </div>\n  <style>\n      .pin-adv{\n        width:100%!important;\n        min-height: 0;\n        margin: 0;\n        margin-top: 5px;\n        border-radius: 3px;\n      }\n      .page-wwads{\n        width:100%!important;\n        min-height: 0;\n        margin: 0;\n      }\n      .page-wwads .wwads-img img{\n        width:80px!important;\n      }\n      .page-wwads .wwads-poweredby{\n        width: 40px;\n        position: absolute;\n        right: 25px;\n        bottom: 3px;\n      }\n      .wwads-content .wwads-text, .page-wwads .wwads-text{\n        height: 100%;\n        padding-top: 5px;\n        display: block;\n      }\n  </style>\n  '}},locales:{"/":{lang:"zh-CN",title:"LiteFlow",description:"一个轻量，快速，稳定可编排的组件式规则引擎",path:"/"}}};var Ct=t(95),Bt=t(96),Ft=t(12);var Lt={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(Ft.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(Ft.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Ft.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,o=n.length;a<o;a++){const{frontmatter:{categories:o,tags:i}}=n[a];"array"===Object(Ft.n)(o)&&o.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(Ft.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};a.default.component(Ct.default),a.default.component(Bt.default);function Xt(n){return n.toString().padStart(2,"0")}t(242);a.default.component("Notice",()=>Promise.all([t.e(0),t.e(2),t.e(5)]).then(t.bind(null,470))),a.default.component("Badge",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,1080))),a.default.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,95))),a.default.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,96)));t(243);var Tt=[({Vue:n,options:e,router:t,siteData:a,isServer:o})=>{o||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>万维</span><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout((function(){function n(n){return Math.floor(Math.random()*n)+1}const e=document.getElementsByName("adv"),t=document.getElementsByName("adv_must");if(!(e.length<=0&&t.length<=0)){for(let t=0;t<e.length;t++)e[t].style.order=n(9998);for(let e=0;e<t.length;e++)t[e].style.order=n(9998);if(5>=e.length)for(let n=0;n<e.length;n++)e[n].classList.remove("none");else e.forEach(n=>{n.className="none"}),function(n,e){for(var t=[],a=0;a<n;a++)t.push(a);return t.sort(()=>Math.random()-.5).slice(0,e)}(e.length,5).forEach(n=>{e[n].classList.remove("none")})}}),250),setTimeout(()=>{const n=document.querySelector(".page-ad");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Xt(n.getUTCMonth()+1)}-${Xt(n.getUTCDate())} ${Xt(n.getUTCHours())}:${Xt(n.getUTCMinutes())}:${Xt(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(Lt)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?3404a5635d185ca6dda4ccbaaeaf73d3";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],It=[];class St extends class{constructor(){this.store=new a.default({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){a.default.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(St.prototype,{getPageAsyncComponent:ce,getLayoutAsyncComponent:de,getAsyncComponent:pe,getVueComponent:me});var kt={install(n){const e=new St;n.$vuepress=e,n.prototype.$vuepress=e}};function Nt(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var zt={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return he("pageKey",e),a.default.component(e)||a.default.component(e,ce(e)),a.default.component(e)?n(e):n("")}},jt={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Dt={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Pt=(t(244),t(245),Object(Et.a)(Dt,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),_t={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};a.default.config.productionTip=!1,a.default.use(Jn),a.default.use(kt),a.default.mixin(function(n,e,t=a.default){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const o=new(n(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),l={};return Object.keys(i).reduce((n,e)=>(e.startsWith("$")&&(n[e]=i[e].get),n),l),{computed:l}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},At)),a.default.component("Content",zt),a.default.component("ContentSlotsDistributor",jt),a.default.component("OutboundLink",Pt),a.default.component("ClientOnly",_t),a.default.component("Layout",de("Layout")),a.default.component("NotFound",de("NotFound")),a.default.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"db4099b"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:At.routerBase||At.base,t=new Jn({base:e,mode:"history",fallback:!1,routes:yt,scrollBehavior:(n,e,t)=>t||(n.hash?!a.default.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Nt(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Nt(n,t)?a(t):a()}else a();else{const t=e.path+"/",o=e.path+".html";Nt(n,o)?a(o):Nt(n,t)?a(t):a()}})}(t);const o={};try{await Promise.all(Tt.filter(n=>"function"==typeof n).map(e=>e({Vue:a.default,options:o,router:t,siteData:At,isServer:n})))}catch(n){console.error(n)}return{app:new a.default(Object.assign(o,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},It.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);