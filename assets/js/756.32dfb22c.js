(window.webpackJsonp=window.webpackJsonp||[]).push([[756],{1218:function(t,s,v){"use strict";v.r(s);var l=v(8),o=Object(l.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("LiteFlow从"),s("code",[t._v("2.6.8")]),t._v("版本开始支持基于方法链的代码构造链路的特性。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("通过代码构造模式，你可以不用写xml/json/yaml的规则文件。用代码来构建规则。")]),t._v(" "),s("p",[t._v("事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("意义")]),t._v(" "),s("p",[t._v("提供动态代码构造的API意义在于以下两点：")]),t._v(" "),s("ul",[s("li",[t._v("有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。")]),t._v(" "),s("li",[t._v("如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造API去构造链路。")])])]),t._v(" "),s("p",[t._v("LiteFlow在"),s("code",[t._v("2.6.8")]),t._v("中设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。")]),t._v(" "),s("p",[t._v("并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考"),s("RouterLink",{attrs:{to:"/pages/v2.7.X/19c886/"}},[t._v("平滑热刷新")]),t._v("。")],1)])}),[],!1,null,null,null);s.default=o.exports}}]);