(window.webpackJsonp=window.webpackJsonp||[]).push([[432],{894:function(t,l,s){"use strict";s.r(l);var o=s(8),v=Object(o.a)({},(function(){var t=this,l=t._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("p",[t._v("之前的章节讲述的是通过规则文件去构造流程。")]),t._v(" "),l("p",[t._v("LiteFlow也支持用代码去构造流程，你可以不用写xml/json/yaml的规则文件，ruleSource不用去定义。完全用代码去构建。")]),t._v(" "),l("p",[t._v("事实上，LiteFlow的规则无论是什么格式的，最终底层也是由构造链去构造的。")]),t._v(" "),l("div",{staticClass:"custom-block tip"},[l("p",{staticClass:"custom-block-title"},[t._v("意义")]),t._v(" "),l("p",[t._v("提供动态代码构造的API意义在于以下两点：")]),t._v(" "),l("ul",[l("li",[t._v("有些规则并不是在项目启动时就确定的。你可以通过构造模式，以代码形式的方式去动态构造一条链路，也可以去替换一条链路。")]),t._v(" "),l("li",[t._v("如果你想把规则的细节点存数据库(而不是存整段规则文件)，那么动态代码构造是个不错的选择。只不过，你需要在应用启动时自己写逻辑去读库，然后用动态代码构造API去构造链路。")])])]),t._v(" "),l("p",[t._v("LiteFlow设计了非常简单的构造方法链式API，让你可以很轻松的构造一条链路。")]),t._v(" "),l("p",[t._v("并且，这一切同规则文件一样，都是支持平滑热刷新的，你完全不必担心在高并发时更换流程会造成链路错乱的问题。关于平滑热刷新，可以参考"),l("RouterLink",{attrs:{to:"/pages/v2.10.X/204d71/"}},[t._v("平滑热刷新")]),t._v("。")],1)])}),[],!1,null,null,null);l.default=v.exports}}]);