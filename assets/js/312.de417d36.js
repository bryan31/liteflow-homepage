(window.webpackJsonp=window.webpackJsonp||[]).push([[312],{771:function(t,s,o){"use strict";o.r(s);var l=o(8),e=Object(l.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("概念")]),t._v(" "),s("p",[t._v("在执行器执行流程时会分配数据上下文实例给这个请求。不同请求的数据上下文实例是完全隔离的。里面存放着此请求所有的用户数据。不同的组件之间是不传递参数的，所有的数据交互都是通过这个数据上下文来实现的。")])]),t._v(" "),s("p",[t._v("数据上下文这个概念在LiteFlow框架中非常重要，你所有的业务数据都是放在数据上下文中。")]),t._v(" "),s("p",[t._v("要做到可编排，一定是消除每个组件差异性的。如果每个组件出参入参都不一致，那就没法编排了。")]),t._v(" "),s("p",[t._v("LiteFlow对此有独特的设计理念，平时我们写瀑布流的程序时，A调用B，那A一定要把B所需要的参数传递给B，而在LiteFlow框架体系中，每个组件的定义中是不需要接受参数的，也无任何返回的。")]),t._v(" "),s("p",[t._v("每个组件只需要从数据上下文中获取自己关心的数据即可，而不用关心此数据是由谁提供的，同样的，每个组件也只要把自己执行所产生的结果数据放到数据上下文中即可，也不用关心此数据到底是提供给谁用的。这样一来，就从数据层面一定程度的解耦了。从而达到可编排的目的。关于这个理念，也在"),s("RouterLink",{attrs:{to:"/pages/v2.11.X/5816c5/"}},[t._v("LiteFlow简介")]),t._v("中的设计原则有提到过，给了一个形象的例子，大家可以再去看看。")],1),t._v(" "),s("p",[t._v("一旦在数据上下文中放入数据，整个链路中的任一节点都是可以取到的。")])])}),[],!1,null,null,null);s.default=e.exports}}]);